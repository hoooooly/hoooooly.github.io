

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" href="/img/icon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Holy Chan">
  <meta name="keywords" content="">
  
  <title>Beego的MVC架构 - Holy的个人站点</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":78,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"e0b23de316904d07fb7110bd99d69a80","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"5nl8DQfwVmV1EVq02TMrVpLl-gzGzoHsz","app_key":"RbsmRlFYbVuACVohRTd4N6Cr","server_url":"https://5nl8dqfw.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Holy</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                文章
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    归档
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Beego的MVC架构">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-29 16:44" pubdate>
        2021年8月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      123
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Beego的MVC架构</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年8月30日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="beego-的-MVC-架构介绍"><a href="#beego-的-MVC-架构介绍" class="headerlink" title="beego 的 MVC 架构介绍"></a>beego 的 MVC 架构介绍</h1><p>beego 是一个典型的 MVC 框架，它的整个执行逻辑如下图所示：</p>
<p><img src="detail.png" srcset="/img/loading.gif" lazyload></p>
<p>通过文字来描述如下：</p>
<ol>
<li>在监听的端口接收数据，默认监听在 8080 端口。</li>
<li>用户请求到达 8080 端口之后进入 beego 的处理逻辑。</li>
<li>初始化 Context 对象，根据请求判断是否为 WebSocket 请求，如果是的话设置 Input，同时判断请求的方法是否在标准请求方法中（GET、POST、PUT、DELETE、PATCH、OPTIONS、HEAD），防止用户的恶意伪造请求攻击造成不必要的影响。</li>
<li>执行 BeforeRouter 过滤器，当然在 beego 里面有开关设置。如果用户设置了过滤器，那么该开关打开，这样可以提高在没有开启过滤器的情况下提高执行效率。如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。</li>
<li>开始执行静态文件的处理，查看用户的请求 URL 是否和注册在静态文件处理 StaticDir 中的 prefix 是否匹配。如果匹配的话，采用 <code>http</code> 包中默认的 ServeFile 来处理静态文件。</li>
<li>如果不是静态文件开始初始化 session 模块(如果开启 session 的话)，这个里面大家需要注意，如果你的 BeforeRouter 过滤器用到了 session 就会报错，你应该把它加入到 AfterStatic 过滤器中。</li>
<li>开始执行 AfterStatic 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。</li>
<li>执行过过滤器之后，开始从固定的路由规则中查找和请求 URL 相匹配的对象。这个匹配是全匹配规则，即如果用户请求的 URL 是 <code>/hello/world</code>，那么固定规则中 <code>/hello</code> 是不会匹配的，只有完全匹配才算匹配。如果匹配的话就进入逻辑执行，如果不匹配进入下一环节的正则匹配。</li>
<li>正则匹配是进行正则的全匹配，这个正则是按照用户添加 beego 路由顺序来进行匹配的，也就是说，如果你在添加路由的时候你的顺序影响你的匹配。和固定匹配一样，如果匹配的话就进行逻辑执行，如果不匹配进入 Auto 匹配。</li>
<li>如果用户注册了 AutoRouter，那么会通过 <code>controller/method</code> 这样的方式去查找对应的 Controller 和他内置的方法，如果找到就开始执行逻辑，如果找不到就跳转到监控判断。</li>
<li>如果找到 Controller 的话，那么就开始执行逻辑，首先执行 BeforeExec 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。</li>
<li>Controller 开始执行 Init 函数，初始化基本的一些信息，这个函数一般都是 beego.Controller 的初始化，不建议用户继承的时候修改该函数。</li>
<li>是否开启了 XSRF，开启的话就调用 Controller 的 XsrfToken，然后如果是 POST 请求就调用 CheckXsrfCookie 方法。</li>
<li>继续执行 Controller 的 Prepare 函数，这个函数一般是预留给用户的，用来做 Controller 里面的一些参数初始化之类的工作。如果在初始化中 responseWriter 有输出，那么就直接进入 Finish 函数逻辑。</li>
<li>如果没有输出的话，那么根据用户注册的方法执行相应的逻辑，如果用户没有注册，那么就调用 http.Method 对应的方法（Get/Post 等）。执行相应的逻辑，例如数据读取，数据赋值，模板显示之类的，或者直接输出 JSON 或者 XML。</li>
<li>如果 responseWriter 没有输出，那么就调用 Render 函数进行模板输出。</li>
<li>执行 Controller 的 Finish 函数，这个函数是预留给用户用来重写的，用于释放一些资源。释放在 Init 中初始化的信息数据。</li>
<li>执行 AfterExec 过滤器，如果有输出的话就跳转到监控判断逻辑。</li>
<li>执行 Controller 的 Destructor，用于释放 Init 中初始化的一些数据。</li>
<li>如果这一路执行下来都没有找到路由，那么会调用 404 显示找不到该页面。</li>
<li>最后所有的逻辑都汇聚到了监控判断，如果用户开启了监控模块（默认是开启一个 8088 端口用于进程内监控），这样就会把访问的请求链接扔给监控程序去记录当前访问的 QPS，对应的链接访问的执行时间，请求链接等。</li>
</ol>
<h1 id="controller-设计"><a href="#controller-设计" class="headerlink" title="controller 设计"></a>controller 设计</h1><h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><p>beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性。</p>
<h2 id="默认配置解析"><a href="#默认配置解析" class="headerlink" title="默认配置解析"></a>默认配置解析</h2><p>beego 默认会解析当前应用下的 <code>conf/app.conf</code> 文件。</p>
<p>通过这个文件你可以初始化很多 beego 的默认参数：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">appname</span> = beepkg<br><span class="hljs-attr">httpaddr</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">9090</span><br><span class="hljs-attr">runmode</span> =<span class="hljs-string">&quot;dev&quot;</span><br><span class="hljs-attr">autorender</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">recoverpanic</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">viewspath</span> = <span class="hljs-string">&quot;myview&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>它们都维护在结构体 <code>beego/server/web#Config</code> 。</p>
<p>上面这些参数会替换 beego 默认的一些参数, beego 的参数主要有哪些呢？请参考<a target="_blank" rel="noopener" href="https://godoc.org/github.com/beego/beego#pkg-constants">https://godoc.org/github.com/beego/beego#pkg-constants</a> 。</p>
<p>BConfig 就是 beego 里面的默认的配置，也是结构体 <code>beego/server/web#Config</code> 的实例。</p>
<p>你也可以直接通过<code>web.BConfig.AppName=&quot;beepkg&quot;</code>这样来修改，和上面的配置效果一样，只是一个在代码里面写死了，而配置文件就会显得更加灵活。</p>
<p>你也可以在配置文件中配置应用需要用的一些配置信息，例如下面所示的数据库信息：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">mysqluser</span> = <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-attr">mysqlpass</span> = <span class="hljs-string">&quot;rootpass&quot;</span><br><span class="hljs-attr">mysqlurls</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">mysqldb</span>   = <span class="hljs-string">&quot;beego&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>那么你就可以通过如下的方式获取设置的配置信息:</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">web<span class="hljs-selector-class">.AppConfig</span><span class="hljs-selector-class">.String</span>(<span class="hljs-string">&quot;mysqluser&quot;</span>)<br>web<span class="hljs-selector-class">.AppConfig</span><span class="hljs-selector-class">.String</span>(<span class="hljs-string">&quot;mysqlpass&quot;</span>)<br>web<span class="hljs-selector-class">.AppConfig</span><span class="hljs-selector-class">.String</span>(<span class="hljs-string">&quot;mysqlurls&quot;</span>)<br>web<span class="hljs-selector-class">.AppConfig</span><span class="hljs-selector-class">.String</span>(<span class="hljs-string">&quot;mysqldb&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>AppConfig 的方法如下：</p>
<ul>
<li>Set(key, val string) error</li>
<li>String(key string) string</li>
<li>Strings(key string) []string</li>
<li>Int(key string) (int, error)</li>
<li>Int64(key string) (int64, error)</li>
<li>Bool(key string) (bool, error)</li>
<li>Float(key string) (float64, error)</li>
<li>DefaultString(key string, defaultVal string) string</li>
<li>DefaultStrings(key string, defaultVal []string)</li>
<li>DefaultInt(key string, defaultVal int) int</li>
<li>DefaultInt64(key string, defaultVal int64) int64</li>
<li>DefaultBool(key string, defaultVal bool) bool</li>
<li>DefaultFloat(key string, defaultVal float64) float64</li>
<li>DIY(key string) (interface{}, error)</li>
<li>GetSection(section string) (map[string]string, error)</li>
<li>SaveConfigFile(filename string) error</li>
</ul>
<p>在使用 ini 类型的配置文件中, key 支持 section::key 模式.</p>
<p>你可以用 Default* 方法返回默认值.</p>
<p>你也可以参考 <a target="_blank" rel="noopener" href="https://beego.me/zh-CN/module/config.md">配置模块</a></p>
<h3 id="不同级别的配置"><a href="#不同级别的配置" class="headerlink" title="不同级别的配置"></a>不同级别的配置</h3><p>在配置文件里面支持 section，可以有不同的 Runmode 的配置，默认优先读取 runmode 下的配置信息，例如下面的配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">appname</span> = beepkg<br><span class="hljs-attr">httpaddr</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">9090</span><br><span class="hljs-attr">runmode</span> =<span class="hljs-string">&quot;dev&quot;</span><br><span class="hljs-attr">autorender</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">recoverpanic</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">viewspath</span> = <span class="hljs-string">&quot;myview&quot;</span><br><br><span class="hljs-section">[dev]</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">8080</span><br><span class="hljs-section">[prod]</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">8088</span><br><span class="hljs-section">[test]</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">8888</span><br></code></pre></div></td></tr></table></figure>

<p>上面的配置文件就是在不同的 runmode 下解析不同的配置，例如在 dev 模式下，httpport 是 8080，在 prod 模式下是 8088，在 test 模式下是 8888。其他配置文件同理。解析的时候优先解析 runmode 下的配置，然后解析默认的配置。</p>
<p>读取不同模式下配置参数的方法是“模式::配置参数名”，比如：beego.AppConfig.String(“dev::mysqluser”)。</p>
<p>对于自定义的参数，需使用 GetConfig(typ, key string, defaultVal interface{}) 来获取指定 runmode 下的配置（需 1.4.0 以上版本），typ 为参数类型，key 为参数名, defaultVal 为默认值。</p>
<h3 id="多个配置文件"><a href="#多个配置文件" class="headerlink" title="多个配置文件"></a>多个配置文件</h3><p>INI 格式配置支持 <code>include</code> 方式，引用多个配置文件，例如下面的两个配置文件效果同上：</p>
<p>app.conf</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">appname = beepkg<br>httpaddr = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>httpport = 9090<br><br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;app2.conf&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>app2.conf</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">runmode</span> =<span class="hljs-string">&quot;dev&quot;</span><br><span class="hljs-attr">autorender</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">recoverpanic</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">viewspath</span> = <span class="hljs-string">&quot;myview&quot;</span><br><br><span class="hljs-section">[dev]</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">8080</span><br><span class="hljs-section">[prod]</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">8088</span><br><span class="hljs-section">[test]</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-number">8888</span><br></code></pre></div></td></tr></table></figure>

<h3 id="支持环境变量配置"><a href="#支持环境变量配置" class="headerlink" title="支持环境变量配置"></a>支持环境变量配置</h3><p>配置文件解析支持从环境变量中获取配置项，配置项格式：<code>$&#123;环境变量&#125;</code>。例如下面的配置中优先使用环境变量中配置的 runmode 和 httpport，如果有配置环境变量 ProRunMode 则优先使用该环境变量值。如果不存在或者为空，则使用 “dev” 作为 runmode。</p>
<p>app.conf</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">runmode</span>  = <span class="hljs-string">&quot;$&#123;ProRunMode||dev&#125;&quot;</span><br><span class="hljs-attr">httpport</span> = <span class="hljs-string">&quot;$&#123;ProPort||9090&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>

<h3 id="系统默认参数"><a href="#系统默认参数" class="headerlink" title="系统默认参数"></a>系统默认参数</h3><p>beego 中带有很多可配置的参数，我们来一一认识一下它们，这样有利于我们在接下来的 beego 开发中可以充分的发挥他们的作用(你可以通过在 <code>conf/app.conf</code> 中设置对应的值，不区分大小写)：</p>
<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><ul>
<li>BConfig<br>保存了所有 beego 里面的系统默认参数，你可以通过 <code>web.BConfig</code> 来访问和修改底下的所有配置信息.</li>
</ul>
<blockquote>
<blockquote>
<p>配置文件路径，默认是应用程序对应的目录下的 <code>conf/app.conf</code>，用户可以在程序代码中加载自己的配置文件<br><code>beego.LoadAppConfig(&quot;ini&quot;, &quot;conf/app2.conf&quot;)</code><br>也可以加载多个文件，只要你调用多次就可以了，如果后面的文件和前面的 key 冲突，那么以最新加载的为最新值</p>
</blockquote>
</blockquote>
<h4 id="App-配置"><a href="#App-配置" class="headerlink" title="App 配置"></a>App 配置</h4><ul>
<li><p>AppName</p>
<p>应用名称，默认是 beego。通过 <code>bee new</code> 创建的是创建的项目名。</p>
<p><code>web.BConfig.AppName = &quot;beego&quot;</code></p>
</li>
<li><p>RunMode</p>
<p>应用的运行模式，可选值为 <code>prod</code>, <code>dev</code> 或者 <code>test</code>. 默认是 <code>dev</code>, 为开发模式，在开发模式下出错会提示友好的出错页面，如前面错误描述中所述。</p>
<p><code>web.BConfig.RunMode = &quot;dev&quot;</code></p>
</li>
<li><p>RouterCaseSensitive</p>
<p>是否路由忽略大小写匹配，默认是 true，区分大小写</p>
<p><code>web.BConfig.RouterCaseSensitive = true</code></p>
</li>
<li><p>ServerName</p>
<p>beego 服务器默认在请求的时候输出 server 为 beego。</p>
<p><code>web.BConfig.ServerName = &quot;beego&quot;</code></p>
</li>
<li><p>RecoverPanic</p>
<p>是否异常恢复，默认值为 true，即当应用出现异常的情况，通过 recover 恢复回来，而不会导致应用异常退出。</p>
<p><code>web.BConfig.RecoverPanic = true</code></p>
</li>
<li><p>CopyRequestBody</p>
<p>是否允许在 HTTP 请求时，返回原始请求体数据字节，默认为 false （GET or HEAD or 上传文件请求除外）。</p>
<p><code>web.BConfig.CopyRequestBody = false</code></p>
</li>
<li><p>EnableGzip</p>
<p>是否开启 gzip 支持，默认为 false 不支持 gzip，一旦开启了 gzip，那么在模板输出的内容会进行 gzip 或者 zlib 压缩，根据用户的 Accept-Encoding 来判断。</p>
<p><code>web.BConfig.EnableGzip = false</code></p>
<p>Gzip允许用户自定义压缩级别、压缩长度阈值和针对请求类型压缩:</p>
<ol>
<li>压缩级别, <code>gzipCompressLevel = 9</code>,取值为 1~9,如果不设置为 1(最快压缩)</li>
<li>压缩长度阈值, <code>gzipMinLength = 256</code>,当原始内容长度大于此阈值时才开启压缩,默认为 20B(ngnix默认长度)</li>
<li>请求类型, <code>includedMethods = get;post</code>,针对哪些请求类型进行压缩,默认只针对 GET 请求压缩</li>
</ol>
</li>
<li><p>MaxMemory</p>
<p>文件上传默认内存缓存大小，默认值是 <code>1 &lt;&lt; 26</code>(64M)。</p>
<p><code>web.BConfig.MaxMemory = 1 &lt;&lt; 26</code></p>
</li>
<li><p>EnableErrorsShow</p>
<p>是否显示系统错误信息，默认为 true。</p>
<p><code>web.BConfig.EnableErrorsShow = true</code></p>
</li>
<li><p>EnableErrorsRender</p>
<p>是否将错误信息进行渲染，默认值为 true，即出错会提示友好的出错页面，对于 API 类型的应用可能需要将该选项设置为 false 以阻止在 <code>dev</code> 模式下不必要的模板渲染信息返回。</p>
</li>
</ul>
<h4 id="Web配置"><a href="#Web配置" class="headerlink" title="Web配置"></a>Web配置</h4><ul>
<li><p>AutoRender</p>
<p>是否模板自动渲染，默认值为 true，对于 API 类型的应用，应用需要把该选项设置为 false，不需要渲染模板。</p>
<p><code>web.BConfig.WebConfig.AutoRender = true</code></p>
</li>
<li><p>EnableDocs</p>
<p>是否开启文档内置功能，默认是 false</p>
<p><code>web.BConfig.WebConfig.EnableDocs = true</code></p>
</li>
<li><p>FlashName</p>
<p>Flash 数据设置时 Cookie 的名称，默认是 BEEGO_FLASH</p>
<p><code>web.BConfig.WebConfig.FlashName = &quot;BEEGO_FLASH&quot;</code></p>
</li>
<li><p>FlashSeperator</p>
<p>Flash 数据的分隔符，默认是 BEEGOFLASH</p>
<p><code>web.BConfig.WebConfig.FlashSeparator = &quot;BEEGOFLASH&quot;</code></p>
</li>
<li><p>DirectoryIndex</p>
<p>是否开启静态目录的列表显示，默认不显示目录，返回 403 错误。</p>
<p><code>web.BConfig.WebConfig.DirectoryIndex = false</code></p>
</li>
<li><p>StaticDir</p>
<p>静态文件目录设置，默认是static</p>
<p>可配置单个或多个目录:</p>
<ol>
<li>单个目录, <code>StaticDir = download</code>. 相当于 <code>beego.SetStaticPath(&quot;/download&quot;,&quot;download&quot;)</code></li>
<li>多个目录, <code>StaticDir = download:down download2:down2</code>. 相当于 <code>beego.SetStaticPath(&quot;/download&quot;,&quot;down&quot;)</code> 和 <code>beego.SetStaticPath(&quot;/download2&quot;,&quot;down2&quot;)</code></li>
</ol>
<p><code>web.BConfig.WebConfig.StaticDir</code></p>
</li>
<li><p>StaticExtensionsToGzip</p>
<p>允许哪些后缀名的静态文件进行 gzip 压缩，默认支持 .css 和 .js</p>
<p><code>web.BConfig.WebConfig.StaticExtensionsToGzip = []string&#123;&quot;.css&quot;, &quot;.js&quot;&#125;</code></p>
<p>等价 config 文件中</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">StaticExtensionsToGzip</span> = .css, .js<br></code></pre></div></td></tr></table></figure></li>
<li><p>TemplateLeft</p>
<p>模板左标签，默认值是<code>&#123;&#123;`。

  `web.BConfig.WebConfig.TemplateLeft="&#123;&#123;"`

- TemplateRight

  模板右标签，默认值是`&#125;&#125;</code>。</p>
<p><code>web.BConfig.WebConfig.TemplateRight=&quot;&#125;&#125;&quot;</code></p>
</li>
<li><p>ViewsPath</p>
<p>模板路径，默认值是 views。</p>
<p><code>web.BConfig.WebConfig.ViewsPath=&quot;views&quot;</code></p>
</li>
<li><p>EnableXSRF</p>
<p>是否开启 XSRF，默认为 false，不开启。</p>
<p><code>web.BConfig.WebConfig.EnableXSRF = false</code></p>
</li>
<li><p>XSRFKEY</p>
<p>XSRF 的 key 信息，默认值是 beegoxsrf。 EnableXSRF＝true 才有效</p>
<p><code>web.BConfig.WebConfig.XSRFKEY = &quot;beegoxsrf&quot;</code></p>
</li>
<li><p>XSRFExpire</p>
<p>XSRF 过期时间，默认值是 0，不过期。</p>
<p><code>web.BConfig.WebConfig.XSRFExpire = 0</code></p>
</li>
<li><p>CommentRouterPath</p>
<p>CommentRouterPath 注解路由所在位置。默认值是<code>controllers</code>。 Beego 会在启动的时候扫描下面的文件生成了路由。<br><code>web.BConfig.WebConfig.CommentRouterPath = &quot;controllers&quot;</code></p>
</li>
</ul>
<h4 id="监听配置"><a href="#监听配置" class="headerlink" title="监听配置"></a>监听配置</h4><ul>
<li><p>Graceful</p>
<p>是否开启热升级，默认是 false，关闭热升级。</p>
<p><code>web.BConfig.Listen.Graceful=false</code></p>
</li>
<li><p>ServerTimeOut</p>
<p>设置 HTTP 的超时时间，默认是 0，不超时。</p>
<p><code>web.BConfig.Listen.ServerTimeOut=0</code></p>
</li>
<li><p>ListenTCP4</p>
<p>监听本地网络地址类型，默认是TCP6，可以通过设置为true设置为TCP4。</p>
<p><code>web.BConfig.Listen.ListenTCP4 = true</code></p>
</li>
<li><p>EnableHTTP</p>
<p>是否启用 HTTP 监听，默认是 true。</p>
<p><code>web.BConfig.Listen.EnableHTTP = true</code></p>
</li>
<li><p>HTTPAddr</p>
<p>应用监听地址，默认为空，监听所有的网卡 IP。</p>
<p><code>web.BConfig.Listen.HTTPAddr = &quot;&quot;</code></p>
</li>
<li><p>HTTPPort</p>
<p>应用监听端口，默认为 8080。</p>
<p><code>web.BConfig.Listen.HTTPPort = 8080</code></p>
</li>
<li><p>EnableHTTPS</p>
<p>是否启用 HTTPS，默认是 false 关闭。当需要启用时，先设置 EnableHTTPS = true，并设置 <code>HTTPSCertFile</code> 和 <code>HTTPSKeyFile</code></p>
<p><code>web.BConfig.Listen.EnableHTTPS = false</code></p>
</li>
<li><p>HTTPSAddr</p>
<p>应用监听地址，默认为空，监听所有的网卡 IP。</p>
<p><code>web.BConfig.Listen.HTTPSAddr = &quot;&quot;</code></p>
</li>
<li><p>HTTPSPort</p>
<p>应用监听端口，默认为 10443</p>
<p><code>web.BConfig.Listen.HTTPSPort = 10443</code></p>
</li>
<li><p>HTTPSCertFile</p>
<p>开启 HTTPS 后，ssl 证书路径，默认为空。</p>
<p><code>web.BConfig.Listen.HTTPSCertFile = &quot;conf/ssl.crt&quot;</code></p>
</li>
<li><p>HTTPSKeyFile</p>
<p>开启 HTTPS 之后，SSL 证书 keyfile 的路径。</p>
<p><code>web.BConfig.Listen.HTTPSKeyFile = &quot;conf/ssl.key&quot;</code></p>
</li>
<li><p>EnableAdmin</p>
<p>是否开启进程内监控模块，默认 false 关闭。</p>
<p><code>web.BConfig.Listen.EnableAdmin = false</code></p>
</li>
<li><p>AdminAddr</p>
<p>监控程序监听的地址，默认值是 localhost 。</p>
<p><code>web.BConfig.Listen.AdminAddr = &quot;localhost&quot;</code></p>
</li>
<li><p>AdminPort</p>
<p>监控程序监听的地址，默认值是 8088 。</p>
<p><code>web.BConfig.Listen.AdminPort = 8088</code></p>
</li>
<li><p>EnableFcgi</p>
<p>是否启用 fastcgi ， 默认是 false。</p>
<p><code>web.BConfig.Listen.EnableFcgi = false</code></p>
</li>
<li><p>EnableStdIo</p>
<p>通过fastcgi 标准I/O，启用 fastcgi 后才生效，默认 false。</p>
<p><code>web.BConfig.Listen.EnableStdIo = false</code></p>
</li>
</ul>
<h4 id="Session配置"><a href="#Session配置" class="headerlink" title="Session配置"></a>Session配置</h4><ul>
<li><p>SessionOn</p>
<p>session 是否开启，默认是 false。</p>
<p><code>web.BConfig.WebConfig.Session.SessionOn = false</code></p>
</li>
<li><p>SessionProvider</p>
<p>session 的引擎，默认是 memory，详细参见 <code>session 模块</code>。</p>
<p><code>web.BConfig.WebConfig.Session.SessionProvider = &quot;&quot;</code></p>
</li>
<li><p>SessionName</p>
<p>存在客户端的 cookie 名称，默认值是 beegosessionID。</p>
<p><code>web.BConfig.WebConfig.Session.SessionName = &quot;beegosessionID&quot;</code></p>
</li>
<li><p>SessionGCMaxLifetime</p>
<p>session 过期时间，默认值是 3600 秒。</p>
<p><code>web.BConfig.WebConfig.Session.SessionGCMaxLifetime = 3600</code></p>
</li>
<li><p>SessionProviderConfig</p>
<p>配置信息，根据不同的引擎设置不同的配置信息，详细的配置请看下面的引擎设置，详细参见 <a target="_blank" rel="noopener" href="https://beego.me/zh-CN/module/session.md">session 模块</a></p>
</li>
<li><p>SessionCookieLifeTime</p>
<p>session 默认存在客户端的 cookie 的时间，默认值是 3600 秒。</p>
<p><code>web.BConfig.WebConfig.Session.SessionCookieLifeTime = 3600</code></p>
</li>
<li><p>SessionAutoSetCookie</p>
<p>是否开启SetCookie, 默认值 true 开启。</p>
<p><code>web.BConfig.WebConfig.Session.SessionAutoSetCookie = true</code></p>
</li>
<li><p>SessionDomain</p>
<p>session cookie 存储域名, 默认空。</p>
<p><code>web.BConfig.WebConfig.Session.SessionDomain = &quot;&quot;</code></p>
</li>
</ul>
<h4 id="Log配置"><a href="#Log配置" class="headerlink" title="Log配置"></a>Log配置</h4><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">log详细配置，请参见 `logs 模块`。<br></code></pre></div></td></tr></table></figure>

<ul>
<li><p>AccessLogs</p>
<p>是否输出日志到 Log，默认在 prod 模式下不会输出日志，默认为 false 不输出日志。此参数不支持配置文件配置。</p>
<p><code>web.BConfig.Log.AccessLogs = false</code></p>
</li>
<li><p>FileLineNum</p>
<p>是否在日志里面显示文件名和输出日志行号，默认 true。此参数不支持配置文件配置。</p>
<p><code>web.BConfig.Log.FileLineNum = true</code></p>
</li>
<li><p>Outputs</p>
<p>日志输出配置，参考 logs 模块，console file 等配置，此参数不支持配置文件配置。</p>
<p><code>web.BConfig.Log.Outputs = map[string]string&#123;&quot;console&quot;: &quot;&quot;&#125;</code></p>
<p>or</p>
<p><code>web.BConfig.Log.Outputs[&quot;console&quot;] = &quot;&quot;</code></p>
</li>
</ul>
<h1 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h1><p>什么是路由设置呢？前面介绍的 MVC 结构执行时，介绍过 beego 存在三种方式的路由:固定路由、正则路由、自动路由，接下来详细的讲解如何使用这三种路由。</p>
<h2 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h2><p>从 beego 1.2 版本开始支持了基本的 RESTful 函数式路由,应用中的大多数路由都会定义在 <code>routers/router.go</code> 文件中。最简单的 beego 路由由 URI 和闭包函数组成。</p>
<h3 id="基本-GET-路由"><a href="#基本-GET-路由" class="headerlink" title="基本 GET 路由"></a>基本 GET 路由</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Get(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span>&#123;<br>     ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello world&quot;</span>))<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h3 id="基本-POST-路由"><a href="#基本-POST-路由" class="headerlink" title="基本 POST 路由"></a>基本 POST 路由</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Post(<span class="hljs-string">&quot;/alice&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span>&#123;<br>     ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;bob&quot;</span>))<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h3 id="注册一个可以响应任何-HTTP-的路由"><a href="#注册一个可以响应任何-HTTP-的路由" class="headerlink" title="注册一个可以响应任何 HTTP 的路由"></a>注册一个可以响应任何 HTTP 的路由</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Any(<span class="hljs-string">&quot;/foo&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span>&#123;<br>     ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;bar&quot;</span>))<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h3 id="所有的支持的基础函数如下所示"><a href="#所有的支持的基础函数如下所示" class="headerlink" title="所有的支持的基础函数如下所示"></a>所有的支持的基础函数如下所示</h3><ul>
<li>web.Get(router, web.HandleFunc)</li>
<li>web.Post(router, web.HandleFunc)</li>
<li>web.Put(router, web.HandleFunc)</li>
<li>web.Patch(router, web.HandleFunc)</li>
<li>web.Head(router, web.HandleFunc)</li>
<li>web.Options(router, web.HandleFunc)</li>
<li>web.Delete(router, web.HandleFunc)</li>
<li>web.Any(router, web.HandleFunc)</li>
</ul>
<h3 id="支持自定义的-handler-实现"><a href="#支持自定义的-handler-实现" class="headerlink" title="支持自定义的 handler 实现"></a>支持自定义的 handler 实现</h3><p>有些时候我们已经实现了一些 rpc 的应用,但是想要集成到 beego 中,或者其他的 httpserver 应用,集成到 beego 中来.现在可以很方便的集成:</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s := rpc.NewServer()<br>s.RegisterCodec(json.NewCodec(), <span class="hljs-string">&quot;application/json&quot;</span>)<br>s.RegisterService(<span class="hljs-built_in">new</span>(HelloService), <span class="hljs-string">&quot;&quot;</span>)<br>web.Handler(<span class="hljs-string">&quot;/rpc&quot;</span>, s)<br></code></pre></div></td></tr></table></figure>

<p><code>web.Handler(router, http.Handler)</code> 这个函数是关键,第一个参数表示路由 URI, 第二个就是你自己实现的 <code>http.Handler</code>, 注册之后就会把所有 rpc 作为前缀的请求分发到 <code>http.Handler</code> 中进行处理.</p>
<p>这个函数其实还有第三个参数就是是否是前缀匹配,默认是 false, 如果设置了 true, 那么就会在路由匹配的时候前缀匹配,即 <code>/rpc/user</code> 这样的也会匹配去运行</p>
<h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>后面会讲到固定路由,正则路由,这些参数一样适用于上面的这些函数</p>
<h2 id="RESTful-Controller-路由"><a href="#RESTful-Controller-路由" class="headerlink" title="RESTful Controller 路由"></a>RESTful Controller 路由</h2><p>在介绍这三种 beego 的路由实现之前先介绍 RESTful，我们知道 RESTful 是一种目前 API 开发中广泛采用的形式，beego 默认就是支持这样的请求方法，也就是用户 Get 请求就执行 Get 方法，Post 请求就执行 Post 方法。因此默认的路由是这样 RESTful 的请求方式。</p>
<h2 id="固定路由"><a href="#固定路由" class="headerlink" title="固定路由"></a>固定路由</h2><p>固定路由也就是全匹配的路由，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/&quot;</span>, &amp;controllers.MainController&#123;&#125;)<br>web.Router(<span class="hljs-string">&quot;/admin&quot;</span>, &amp;admin.UserController&#123;&#125;)<br>web.Router(<span class="hljs-string">&quot;/admin/index&quot;</span>, &amp;admin.ArticleController&#123;&#125;)<br>web.Router(<span class="hljs-string">&quot;/admin/addpkg&quot;</span>, &amp;admin.AddController&#123;&#125;)<br></code></pre></div></td></tr></table></figure>

<p>如上所示的路由就是我们最常用的路由方式，一个固定的路由，一个控制器，然后根据用户请求方法不同请求控制器中对应的方法，典型的 RESTful 方式。</p>
<h2 id="正则路由"><a href="#正则路由" class="headerlink" title="正则路由"></a>正则路由</h2><p>为了用户更加方便的路由设置，beego 参考了 sinatra 的路由实现，支持多种方式的路由：</p>
<ul>
<li><p>web.Router(“/api/?:id”, &amp;controllers.RController{})</p>
<p>默认匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”，URL”/api/“可正常匹配</p>
</li>
<li><p>web.Router(“/api/:id”, &amp;controllers.RController{})</p>
<p>默认匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”，但URL”/api/“匹配失败</p>
</li>
<li><p>web.Router(“/api/:id([0-9]+)“, &amp;controllers.RController{})</p>
<p>自定义正则匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p>
</li>
<li><p>web.Router(“/user/:username([\w]+)“, &amp;controllers.RController{})</p>
<p>正则字符串匹配 //例如对于URL”/user/astaxie”可以匹配成功，此时变量”:username”值为”astaxie”</p>
</li>
<li><p>web.Router(“/download/*.*”, &amp;controllers.RController{})</p>
<p>*匹配方式 //例如对于URL”/download/file/api.xml”可以匹配成功，此时变量”:path”值为”file/api”， “:ext”值为”xml”</p>
</li>
<li><p>web.Router(“/download/ceshi/*“, &amp;controllers.RController{})</p>
<p>*全匹配方式 //例如对于URL”/download/ceshi/file/api.json”可以匹配成功，此时变量”:splat”值为”file/api.json”</p>
</li>
<li><p>web.Router(“/:id:int”, &amp;controllers.RController{})</p>
<p>int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)</p>
</li>
<li><p>web.Router(“/:hi:string”, &amp;controllers.RController{})</p>
<p>string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)</p>
</li>
<li><p>web.Router(“/cms_:id([0-9]+).html”, &amp;controllers.CmsController{})</p>
<p>带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123</p>
</li>
</ul>
<p>可以在 Controller 中通过如下方式获取上面的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">this.Ctx.Input.Param(<span class="hljs-string">&quot;:id&quot;</span>)<br>this.Ctx.Input.Param(<span class="hljs-string">&quot;:username&quot;</span>)<br>this.Ctx.Input.Param(<span class="hljs-string">&quot;:splat&quot;</span>)<br>this.Ctx.Input.Param(<span class="hljs-string">&quot;:path&quot;</span>)<br>this.Ctx.Input.Param(<span class="hljs-string">&quot;:ext&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<h2 id="自定义方法及-RESTful-规则"><a href="#自定义方法及-RESTful-规则" class="headerlink" title="自定义方法及 RESTful 规则"></a>自定义方法及 RESTful 规则</h2><p>上面列举的是默认的请求方法名（请求的 method 和函数名一致，例如 <code>GET</code> 请求执行 <code>Get</code> 函数，<code>POST</code> 请求执行 <code>Post</code> 函数），如果用户期望自定义函数名，那么可以使用如下方式：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/&quot;</span>,&amp;IndexController&#123;&#125;,<span class="hljs-string">&quot;*:Index&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>使用第三个参数，第三个参数就是用来设置对应 method 到函数名，定义如下</p>
<ul>
<li><code>*</code>表示任意的 method 都执行该函数</li>
<li>使用 httpmethod:funcname 格式来展示</li>
<li>多个不同的格式使用 <code>;</code> 分割</li>
<li>多个 method 对应同一个 funcname，method 之间通过 <code>,</code> 来分割</li>
</ul>
<p>以下是一个 RESTful 的设计示例：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="hljs-string">&quot;get:ListFood&quot;</span>)<br>web.Router(<span class="hljs-string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="hljs-string">&quot;post:CreateFood&quot;</span>)<br>web.Router(<span class="hljs-string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="hljs-string">&quot;put:UpdateFood&quot;</span>)<br>web.Router(<span class="hljs-string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="hljs-string">&quot;delete:DeleteFood&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>以下是多个 HTTP Method 指向同一个函数的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/api&quot;</span>,&amp;RestController&#123;&#125;,<span class="hljs-string">&quot;get,post:ApiFunc&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>以下是不同的 method 对应不同的函数，通过 ; 进行分割的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/api/food&quot;</span>,&amp;RestController&#123;&#125;,<span class="hljs-string">&quot;get:ListFood;post:CreateFood;put:UpdateFood;delete:DeleteFood&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>可用的 HTTP Method：</p>
<ul>
<li>*: 包含以下所有的函数</li>
<li>get: GET 请求</li>
<li>post: POST 请求</li>
<li>put: PUT 请求</li>
<li>delete: DELETE 请求</li>
<li>patch: PATCH 请求</li>
<li>options: OPTIONS 请求</li>
<li>head: HEAD 请求</li>
</ul>
<p>如果同时存在 * 和对应的 HTTP Method，那么优先执行 HTTP Method 的方法，例如同时注册了如下所示的路由：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/simple&quot;</span>,&amp;SimpleController&#123;&#125;,<span class="hljs-string">&quot;*:AllFunc;post:PostFunc&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>那么执行 <code>POST</code> 请求的时候，执行 <code>PostFunc</code> 而不执行 <code>AllFunc</code>。</p>
<blockquote>
<blockquote>
<blockquote>
<p>自定义函数的路由默认不支持 RESTful 的方法，也就是如果你设置了 <code>web.Router(&quot;/api&quot;,&amp;RestController&#123;&#125;,&quot;post:ApiFunc&quot;)</code> 这样的路由，如果请求的方法是 <code>POST</code>，那么不会默认去执行 <code>Post</code> 函数。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="自动匹配"><a href="#自动匹配" class="headerlink" title="自动匹配"></a>自动匹配</h2><p>用户首先需要把需要路由的控制器注册到自动路由中：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.AutoRouter(&amp;controllers.ObjectController&#123;&#125;)<br></code></pre></div></td></tr></table></figure>

<p>那么 beego 就会通过反射获取该结构体中所有的实现方法，你就可以通过如下的方式访问到对应的方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">/object/login   调用 ObjectController 中的 Login 方法<br>/object/logout  调用 ObjectController 中的 Logout 方法<br></code></pre></div></td></tr></table></figure>

<p>除了前缀两个 <code>/:controller/:method</code> 的匹配之外，剩下的 url beego 会帮你自动化解析为参数，保存在 <code>this.Ctx.Input.Params</code> 当中：</p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/object/</span>blog<span class="hljs-regexp">/2013/</span><span class="hljs-number">09</span>/<span class="hljs-number">12</span>  调用 ObjectController 中的 Blog 方法，参数如下：map[<span class="hljs-number">0</span>:<span class="hljs-number">2013</span> <span class="hljs-number">1</span>:<span class="hljs-number">09</span> <span class="hljs-number">2</span>:<span class="hljs-number">12</span>]<br></code></pre></div></td></tr></table></figure>

<p>方法名在内部是保存了用户设置的，例如 Login，url 匹配的时候都会转化为小写，所以，<code>/object/LOGIN</code> 这样的 <code>url</code> 也一样可以路由到用户定义的 <code>Login</code> 方法中【实际在1.10.1版本中测试，不会转化大小写，即只能匹配<code>/object/login</code>，其他均不能正常识别】。</p>
<p>现在已经可以通过自动识别出来下面类似的所有 url，都会把请求分发到 <code>controller</code> 的 <code>simple</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">/controller/simple<br>/controller/simple.html<br>/controller/simple.json<br>/controller/simple.xml<br></code></pre></div></td></tr></table></figure>

<p>可以通过 <code>this.Ctx.Input.Param(&quot;:ext&quot;)</code> 获取后缀名。</p>
<h2 id="注解路由"><a href="#注解路由" class="headerlink" title="注解路由"></a>注解路由</h2><p>从2.0开始，我们使用配置<code>CommentRouterPath</code>来配置注解路由的扫描路径。在<code>dev</code>环境下，我们将自动扫描该配置指向的目录及其子目录，生成路由文件。</p>
<p>生成之后，用户需要显示 Include 相应地 controller。注意， controller 的 method 方法上面须有 router 注释（// @router），详细的使用请看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// CMS API</span><br><span class="hljs-keyword">type</span> CMSController <span class="hljs-keyword">struct</span> &#123;<br>    web.Controller<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CMSController)</span> <span class="hljs-title">URLMapping</span><span class="hljs-params">()</span></span> &#123;<br>    c.Mapping(<span class="hljs-string">&quot;StaticBlock&quot;</span>, c.StaticBlock)<br>    c.Mapping(<span class="hljs-string">&quot;AllBlock&quot;</span>, c.AllBlock)<br>&#125;<br><br><br><span class="hljs-comment">// @router /staticblock/:key [get]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CMSController)</span> <span class="hljs-title">StaticBlock</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// @router /all/:key [get]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CMSController)</span> <span class="hljs-title">AllBlock</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>可以在 <code>router.go</code> 中通过如下方式注册路由：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Include(&amp;CMSController&#123;&#125;)<br></code></pre></div></td></tr></table></figure>

<p>web 自动会进行源码分析，注意只会在 dev 模式下进行生成，生成的路由放在 “/routers/commentsRouter.go” 文件中。</p>
<p>这样上面的路由就支持了如下的路由：</p>
<ul>
<li>GET /staticblock/:key</li>
<li>GET /all/:key</li>
</ul>
<p>其实效果和自己通过 Router 函数注册是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">web.Router(<span class="hljs-string">&quot;/staticblock/:key&quot;</span>, &amp;CMSController&#123;&#125;, <span class="hljs-string">&quot;get:StaticBlock&quot;</span>)<br>web.Router(<span class="hljs-string">&quot;/all/:key&quot;</span>, &amp;CMSController&#123;&#125;, <span class="hljs-string">&quot;get:AllBlock&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p>同时大家注意到新版本里面增加了 URLMapping 这个函数，这是新增加的函数，用户如果没有进行注册，那么就会通过反射来执行对应的函数，如果注册了就会通过 interface 来进行执行函数，性能上面会提升很多。</p>
<h2 id="方法表达式路由"><a href="#方法表达式路由" class="headerlink" title="方法表达式路由"></a>方法表达式路由</h2><p>方法表达式路由与上面的RESTful基本相似，区别是无需在传入http method和controller方法（如：<code>&quot;get:StaticBlock&quot;</code>）。<br>只需要通过golang的method expression进行传入方法表达式。如果方法是receiver是非指针，则直接使用 <code>包名.Controller.Method</code> 方法 传入，<br>如果receiver是指针，则使用 <code>(*包名.Controller).Method</code> 进行传参。假如在同包下，包名可进行省略。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> BaseController <span class="hljs-keyword">struct</span> &#123;<br>    web.Controller<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b BaseController)</span> <span class="hljs-title">Ping</span><span class="hljs-params">()</span></span> &#123;<br>    b.Data[<span class="hljs-string">&quot;json&quot;</span>] = <span class="hljs-string">&quot;pong&quot;</span><br>    b.ServeJSON()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BaseController)</span> <span class="hljs-title">PingPointer</span><span class="hljs-params">()</span></span> &#123;<br>    b.Data[<span class="hljs-string">&quot;json&quot;</span>] = <span class="hljs-string">&quot;pong_pointer&quot;</span><br>    b.ServeJSON()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    web.CtrlGet(<span class="hljs-string">&quot;/ping&quot;</span>, BaseController.Ping)<br>    web.CtrlGet(<span class="hljs-string">&quot;/ping_pointer&quot;</span>, (*BaseController).PingPointer)<br>    web.Run()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>共有以下几种函数：</p>
<ul>
<li>web.CtrlGet(router, pkg.controller.method)</li>
<li>web.CtrlPost(router, pkg.controller.method)</li>
<li>web.CtrlPut(router, pkg.controller.method)</li>
<li>web.CtrlPatch(router, pkg.controller.method)</li>
<li>web.CtrlHead(router, pkg.controller.method)</li>
<li>web.CtrlOptions(router, pkg.controller.method)</li>
<li>web.CtrlDelete(router, pkg.controller.method)</li>
<li>web.CtrlAny(router, pkg.controller.method)</li>
</ul>
<p>同时也支持namespace的使用：</p>
<ul>
<li>web.NSCtrlGet</li>
<li>web.NSCtrlPost</li>
<li>……</li>
</ul>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//初始化 namespace</span><br>ns :=<br>web.NewNamespace(<span class="hljs-string">&quot;/v1&quot;</span>,<br>    web.NSCond(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">if</span> ctx.Input.Domain() == <span class="hljs-string">&quot;api.beego.me&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;),<br>    web.NSBefore(auth),<br>    web.NSGet(<span class="hljs-string">&quot;/notallowed&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>        ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;notAllowed&quot;</span>))<br>    &#125;),<br>    web.NSRouter(<span class="hljs-string">&quot;/version&quot;</span>, &amp;AdminController&#123;&#125;, <span class="hljs-string">&quot;get:ShowAPIVersion&quot;</span>),<br>    web.NSRouter(<span class="hljs-string">&quot;/changepassword&quot;</span>, &amp;UserController&#123;&#125;),<br>    web.NSNamespace(<span class="hljs-string">&quot;/shop&quot;</span>,<br>        web.NSBefore(sentry),<br>        web.NSGet(<span class="hljs-string">&quot;/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span></span> &#123;<br>            ctx.Output.Body([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;notAllowed&quot;</span>))<br>        &#125;),<br>    ),<br>    web.NSNamespace(<span class="hljs-string">&quot;/cms&quot;</span>,<br>        web.NSInclude(<br>            &amp;controllers.MainController&#123;&#125;,<br>            &amp;controllers.CMSController&#123;&#125;,<br>            &amp;controllers.BlockController&#123;&#125;,<br>        ),<br>    ),<br>)<br><span class="hljs-comment">//注册 namespace</span><br>web.AddNamespace(ns)<br></code></pre></div></td></tr></table></figure>

<p>上面这个代码支持了如下这样的请求 URL</p>
<ul>
<li>GET /v1/notallowed</li>
<li>GET /v1/version</li>
<li>GET /v1/changepassword</li>
<li>POST /v1/changepassword</li>
<li>GET /v1/shop/123</li>
<li>GET /v1/cms/ 对应 MainController、CMSController、BlockController 中的注解路由</li>
</ul>
<p>而且还支持前置过滤,条件判断,无限嵌套 namespace</p>
<p>namespace 的接口如下:</p>
<ul>
<li><p>NewNamespace(prefix string, funcs …interface{})</p>
<p>初始化 namespace 对象,下面这些函数都是 namespace 对象的方法,但是强烈推荐使用 NS 开头的相应函数注册，因为这样更容易通过 gofmt 工具看的更清楚路由的级别关系</p>
</li>
<li><p>NSCond(cond namespaceCond)</p>
<p>支持满足条件的就执行该 namespace, 不满足就不执行</p>
</li>
<li><p>NSBefore(filiterList …FilterFunc)</p>
</li>
<li><p>NSAfter(filiterList …FilterFunc)</p>
<p>上面分别对应 beforeRouter 和 FinishRouter 两个过滤器，可以同时注册多个过滤器</p>
</li>
<li><p>NSInclude(cList …ControllerInterface)</p>
</li>
<li><p>NSRouter(rootpath string, c ControllerInterface, mappingMethods …string)</p>
</li>
<li><p>NSGet(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSPost(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSDelete(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSPut(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSHead(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSOptions(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSPatch(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSAny(rootpath string, f HandleFunc)</p>
</li>
<li><p>NSHandler(rootpath string, h http.Handler)</p>
</li>
<li><p>NSAutoRouter(c ControllerInterface)</p>
</li>
<li><p>NSAutoPrefix(prefix string, c ControllerInterface)</p>
<p>上面这些都是设置路由的函数,详细的使用和上面 beego 的对应函数是一样的</p>
</li>
<li><p>NSNamespace(prefix string, params …innnerNamespace)</p>
<p>嵌套其他 namespace</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gos">ns :=<br>web.NewNamespace(&quot;/v1&quot;,<br>    web.NSNamespace(&quot;/shop&quot;,<br>        web.NSGet(&quot;/:id&quot;, func(ctx *context.Context) &#123;<br>            ctx.Output.Body([]byte(&quot;shopinfo&quot;))<br>        &#125;),<br>    ),<br>    web.NSNamespace(&quot;/order&quot;,<br>        web.NSGet(&quot;/:id&quot;, func(ctx *context.Context) &#123;<br>            ctx.Output.Body([]byte(&quot;orderinfo&quot;))<br>        &#125;),<br>    ),<br>    web.NSNamespace(&quot;/crm&quot;,<br>        web.NSGet(&quot;/:id&quot;, func(ctx *context.Context) &#123;<br>            ctx.Output.Body([]byte(&quot;crminfo&quot;))<br>        &#125;),<br>    ),<br>)<br></code></pre></div></td></tr></table></figure></li>
</ul>
<p>下面这些函数都是属于 *Namespace 对象的方法：不建议直接使用，当然效果和上面的 NS 开头的函数是一样的，只是上面的方式更优雅，写出来的代码更容易看得懂</p>
<ul>
<li><p>Cond(cond namespaceCond)</p>
<p>支持满足条件的就执行该 namespace, 不满足就不执行,例如你可以根据域名来控制 namespace</p>
</li>
<li><p>Filter(action string, filter FilterFunc)</p>
<p>action 表示你需要执行的位置, before 和 after 分别表示执行逻辑之前和执行逻辑之后的 filter</p>
</li>
<li><p>Router(rootpath string, c ControllerInterface, mappingMethods …string)</p>
</li>
<li><p>AutoRouter(c ControllerInterface)</p>
</li>
<li><p>AutoPrefix(prefix string, c ControllerInterface)</p>
</li>
<li><p>Get(rootpath string, f HandleFunc)</p>
</li>
<li><p>Post(rootpath string, f HandleFunc)</p>
</li>
<li><p>Delete(rootpath string, f HandleFunc)</p>
</li>
<li><p>Put(rootpath string, f HandleFunc)</p>
</li>
<li><p>Head(rootpath string, f HandleFunc)</p>
</li>
<li><p>Options(rootpath string, f HandleFunc)</p>
</li>
<li><p>Patch(rootpath string, f HandleFunc)</p>
</li>
<li><p>Any(rootpath string, f HandleFunc)</p>
</li>
<li><p>Handler(rootpath string, h http.Handler)</p>
<p>上面这些都是设置路由的函数,详细的使用和上面 beego 的对应函数是一样的</p>
</li>
<li><p>Namespace(ns …*Namespace)</p>
</li>
</ul>
<p>更多的例子代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//APIS</span><br>ns :=<br>    web.NewNamespace(<span class="hljs-string">&quot;/api&quot;</span>,<br>        <span class="hljs-comment">//此处正式版时改为验证加密请求</span><br>        web.NSCond(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx *context.Context)</span> <span class="hljs-title">bool</span></span> &#123;<br>            <span class="hljs-keyword">if</span> ua := ctx.Input.Request.UserAgent(); ua != <span class="hljs-string">&quot;&quot;</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;),<br>        web.NSNamespace(<span class="hljs-string">&quot;/ios&quot;</span>,<br>            <span class="hljs-comment">//CRUD Create(创建)、Read(读取)、Update(更新)和Delete(删除)</span><br>            web.NSNamespace(<span class="hljs-string">&quot;/create&quot;</span>,<br>                <span class="hljs-comment">// /api/ios/create/node/</span><br>                web.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.CreateNodeHandler&#123;&#125;),<br>                <span class="hljs-comment">// /api/ios/create/topic/</span><br>                web.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.CreateTopicHandler&#123;&#125;),<br>            ),<br>            web.NSNamespace(<span class="hljs-string">&quot;/read&quot;</span>,<br>                web.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.ReadNodeHandler&#123;&#125;),<br>                web.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.ReadTopicHandler&#123;&#125;),<br>            ),<br>            web.NSNamespace(<span class="hljs-string">&quot;/update&quot;</span>,<br>                web.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.UpdateNodeHandler&#123;&#125;),<br>                web.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.UpdateTopicHandler&#123;&#125;),<br>            ),<br>            web.NSNamespace(<span class="hljs-string">&quot;/delete&quot;</span>,<br>                web.NSRouter(<span class="hljs-string">&quot;/node&quot;</span>, &amp;apis.DeleteNodeHandler&#123;&#125;),<br>                web.NSRouter(<span class="hljs-string">&quot;/topic&quot;</span>, &amp;apis.DeleteTopicHandler&#123;&#125;),<br>            )<br>        ),<br>    )<br><br>web.AddNamespace(ns)<br></code></pre></div></td></tr></table></figure>

<h1 id="控制器介绍"><a href="#控制器介绍" class="headerlink" title="控制器介绍"></a>控制器介绍</h1><p>基于 beego 的 Controller 设计，只需要匿名组合 <code>beego.Controller</code> 就可以了，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> your_package<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/beego/beego/v2/server/web&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> xxxController <span class="hljs-keyword">struct</span> &#123;<br>        web.Controller<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="控制器方法"><a href="#控制器方法" class="headerlink" title="控制器方法"></a>控制器方法</h2><p><code>web.Controller</code> 实现了接口 <code>web.ControllerInterface</code>，<code>web.ControllerInterface</code> 定义了如下函数：</p>
<ul>
<li><p>Init(ctx *context.Context, controllerName, actionName string, app interface{})</p>
<p>这个函数主要初始化了 Context、相应的 Controller 名称，模板名，初始化模板参数的容器 Data，app 即为当前执行的 Controller 的 reflecttype，这个 app 可以用来执行子类的方法。</p>
</li>
<li><p>Prepare()</p>
<p>这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。</p>
</li>
<li><p>Get()</p>
<p>如果用户请求的 HTTP Method 是 GET，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Get 请求。</p>
</li>
<li><p>Post()</p>
<p>如果用户请求的 HTTP Method 是 POST，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Post 请求。</p>
</li>
<li><p>Delete()</p>
<p>如果用户请求的 HTTP Method 是 DELETE，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Delete 请求。</p>
</li>
<li><p>Put()</p>
<p>如果用户请求的 HTTP Method 是 PUT，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Put 请求.</p>
</li>
<li><p>Head()</p>
<p>如果用户请求的 HTTP Method 是 HEAD，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。</p>
</li>
<li><p>Patch()</p>
<p>如果用户请求的 HTTP Method 是 PATCH，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Patch 请求.</p>
</li>
<li><p>Options()</p>
<p>如果用户请求的HTTP Method是OPTIONS，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Options 请求。</p>
</li>
<li><p>Finish()</p>
<p>这个函数是在执行完相应的 HTTP Method 方法之后执行的，默认是空，用户可以在子 struct 中重写这个函数，执行例如数据库关闭，清理数据之类的工作。</p>
</li>
<li><p>Trace() error</p>
<p>如果用户请求的 HTTP Method 是 Trace，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。</p>
</li>
<li><p>Render() error</p>
<p>这个函数主要用来实现渲染模板，如果 beego.AutoRender 为 true 的情况下才会执行。</p>
</li>
<li><p>Mapping(method string, fn func())</p>
<p>注册一个方法。一般而言， method 是合法的 HTTP 方法名。当然，用户注册自己特定的业务逻辑方法，而后手动调用。</p>
</li>
<li><p>HandlerFunc(fnname string) bool</p>
<p>在前面 Mapping 方法里面注册的方法，可以通过该方法来使用。只会返回调用是否成功的信息——一般而言，只有方法不存在才会返回 false</p>
</li>
<li><p>RenderBytes() ([]byte, error)</p>
<p>将模板渲染成字节数组。需要注意的是，该方法并未检测<code>EnableRender</code>设置。并且，和<code>Render</code>方法相比，它并未将结果输出到<code>Response</code>。</p>
</li>
<li><p>RenderString() (string, error)</p>
<p>类似于<code>RenderBytes</code>方法。只是将结果转化为了<code>string</code>。</p>
</li>
<li><p>Redirect(url string, code int)</p>
<p>重定向。<code>url</code>是目的地址。</p>
</li>
<li><p>SetData(data interface{})</p>
<p>将<code>data</code>存储在控制的数据中。一般而言，你不会考虑用到这个方法。</p>
</li>
<li><p>Abort(code string)</p>
<p>中断当前方法的执行，直接返回该状态码，类似于<code>CustomAbort</code>。参考<a target="_blank" rel="noopener" href="https://beego.me/docs/mvc/controller/errors.md">errors</a></p>
</li>
<li><p>CustomAbort(status int, body string)</p>
<p>中断方法执行，直接返回该状态码和信息。参考<a target="_blank" rel="noopener" href="https://beego.me/docs/mvc/controller/errors.md">errors</a></p>
</li>
<li><p>StopRun()</p>
<p>直接触发<code>panic</code>。</p>
</li>
<li><p>ServeXXX(encoding …bool) error</p>
<p>返回特性类型的响应。目前我们支持 JSON，JSONP，XML，YAML。参考<a target="_blank" rel="noopener" href="https://beego.me/docs/mvc/controller/jsonxml.md">输出格式</a></p>
</li>
<li><p>ServeFormatted(encoding …bool) error</p>
<p>返回响应。其格式由客户端的<code>Accept</code>选项指定。参考<a target="_blank" rel="noopener" href="https://beego.me/docs/mvc/controller/jsonxml.md">输出格式</a></p>
</li>
<li><p>Input() (url.Values, error)</p>
<p>返回传入的参数。</p>
</li>
<li><p>ParseForm(obj interface{}) error</p>
<p>将表单反序列化到 obj 对象中。</p>
</li>
<li><p>GetXXX(key string, def…) XXX, err</p>
<p>从传入参数中，读取某个值。如果传入了默认值，那么在读取不到的情况下，返回默认值，否则返回错误。XXX 可以是 golang 所支持的基本类型，或者是 string, File 对象</p>
</li>
<li><p>SaveToFile(fromfile, tofile string) error</p>
<p>将上传的文件保存到文件系统中。其中<code>fromfile</code>是上传的文件的名字。</p>
</li>
<li><p>SetSession(name interface{}, value interface{}) error</p>
<p>往<code>Session</code>中设置值。</p>
</li>
<li><p>GetSession(name interface{}) interface{}</p>
<p>从<code>Session</code>中读取值。</p>
</li>
<li><p>DelSession(name interface{}) error</p>
<p>从<code>Session</code>中删除某项。</p>
</li>
<li><p>SessionRegenerateID() error</p>
<p>重新生成一个<code>SessionId</code>。</p>
</li>
<li><p>DestroySession() error</p>
<p>销毁<code>Session</code></p>
</li>
<li><p>IsAjax() bool</p>
<p>是否是 Ajax 请求</p>
</li>
<li><p>GetSecureCookie(Secret, key string) (string, bool)</p>
<p>从<code>Cookie</code>中读取数据。<code>bool</code>返回值，表达是否取到了数据。</p>
</li>
<li><p>SetSecureCookie(Secret, name, value string, others …interface{})</p>
<p>设置<code>Cookie</code>。</p>
</li>
<li><p>XSRFToken() string</p>
<p>创建一个<code>CSRF</code> token.</p>
</li>
<li><p>CheckXSRFCookie() bool</p>
<p>检测是否有<code>CSRF</code> token</p>
</li>
</ul>
<h2 id="子类扩展"><a href="#子类扩展" class="headerlink" title="子类扩展"></a>子类扩展</h2><p>通过子 struct 的方法重写，用户就可以实现自己的逻辑，接下来我们看一个实际的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AddController <span class="hljs-keyword">struct</span> &#123;<br>    web.Controller<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AddController)</span> <span class="hljs-title">Prepare</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AddController)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span></span> &#123;<br>    this.Data[<span class="hljs-string">&quot;content&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>    this.Layout = <span class="hljs-string">&quot;admin/layout.html&quot;</span><br>    this.TplName = <span class="hljs-string">&quot;admin/add.tpl&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AddController)</span> <span class="hljs-title">Post</span><span class="hljs-params">()</span></span> &#123;<br>    pkgname := this.GetString(<span class="hljs-string">&quot;pkgname&quot;</span>)<br>    content := this.GetString(<span class="hljs-string">&quot;content&quot;</span>)<br>    pk := models.GetCruPkg(pkgname)<br>    <span class="hljs-keyword">if</span> pk.Id == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">var</span> pp models.PkgEntity<br>        pp.Pid = <span class="hljs-number">0</span><br>        pp.Pathname = pkgname<br>        pp.Intro = pkgname<br>        models.InsertPkg(pp)<br>        pk = models.GetCruPkg(pkgname)<br>    &#125;<br>    <span class="hljs-keyword">var</span> at models.Article<br>    at.Pkgid = pk.Id<br>    at.Content = content<br>    models.InsertArticle(at)<br>    this.Ctx.Redirect(<span class="hljs-number">302</span>, <span class="hljs-string">&quot;/admin/index&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从上面的例子可以看出来，通过重写方法可以实现对应 method 的逻辑，实现 RESTFul 结构的逻辑处理。</p>
<p>下面我们再来看一种比较流行的架构，首先实现一个自己的基类 baseController，实现一些初始化的方法，然后其他所有的逻辑继承自该基类：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NestPreparer <span class="hljs-keyword">interface</span> &#123;<br>        NestPrepare()<br>&#125;<br><br><span class="hljs-comment">// baseRouter implemented global settings for all other routers.</span><br><span class="hljs-keyword">type</span> baseController <span class="hljs-keyword">struct</span> &#123;<br>        web.Controller<br>        i18n.Locale<br>        user    models.User<br>        isLogin <span class="hljs-keyword">bool</span><br>&#125;<br><span class="hljs-comment">// Prepare implemented Prepare method for baseRouter.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *baseController)</span> <span class="hljs-title">Prepare</span><span class="hljs-params">()</span></span> &#123;<br><br>        <span class="hljs-comment">// page start time</span><br>        this.Data[<span class="hljs-string">&quot;PageStartTime&quot;</span>] = time.Now()<br><br>        <span class="hljs-comment">// Setting properties.</span><br>        this.Data[<span class="hljs-string">&quot;AppDescription&quot;</span>] = utils.AppDescription<br>        this.Data[<span class="hljs-string">&quot;AppKeywords&quot;</span>] = utils.AppKeywords<br>        this.Data[<span class="hljs-string">&quot;AppName&quot;</span>] = utils.AppName<br>        this.Data[<span class="hljs-string">&quot;AppVer&quot;</span>] = utils.AppVer<br>        this.Data[<span class="hljs-string">&quot;AppUrl&quot;</span>] = utils.AppUrl<br>        this.Data[<span class="hljs-string">&quot;AppLogo&quot;</span>] = utils.AppLogo<br>        this.Data[<span class="hljs-string">&quot;AvatarURL&quot;</span>] = utils.AvatarURL<br>        this.Data[<span class="hljs-string">&quot;IsProMode&quot;</span>] = utils.IsProMode<br><br>        <span class="hljs-keyword">if</span> app, ok := this.AppController.(NestPreparer); ok &#123;<br>                app.NestPrepare()<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面定义了基类，大概是初始化了一些变量，最后有一个 Init 函数中那个 app 的应用，判断当前运行的 Controller 是否是 NestPreparer 实现，如果是的话调用子类的方法，下面我们来看一下 NestPreparer 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> BaseAdminRouter <span class="hljs-keyword">struct</span> &#123;<br>    baseController<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *BaseAdminRouter)</span> <span class="hljs-title">NestPrepare</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> this.CheckActiveRedirect() &#123;<br>            <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// if user isn&#x27;t admin, then logout user</span><br>    <span class="hljs-keyword">if</span> !this.user.IsAdmin &#123;<br>            models.LogoutUser(&amp;this.Controller)<br><br>            <span class="hljs-comment">// write flash message</span><br>            this.FlashWrite(<span class="hljs-string">&quot;NotPermit&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>)<br><br>            this.Redirect(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-number">302</span>)<br>            <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// current in admin page</span><br>    this.Data[<span class="hljs-string">&quot;IsAdmin&quot;</span>] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">if</span> app, ok := this.AppController.(ModelPreparer); ok &#123;<br>            app.ModelPrepare()<br>            <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *BaseAdminRouter)</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span></span>&#123;<br>    this.TplName = <span class="hljs-string">&quot;Get.tpl&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *BaseAdminRouter)</span> <span class="hljs-title">Post</span><span class="hljs-params">()</span></span>&#123;<br>    this.TplName = <span class="hljs-string">&quot;Post.tpl&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样我们的执行器执行的逻辑是这样的，首先执行 Prepare，这个就是 Go 语言中 struct 中寻找方法的顺序，依次往父类寻找。执行 <code>BaseAdminRouter</code> 时，查找他是否有 <code>Prepare</code> 方法，没有就寻找 <code>baseController</code>，找到了，那么就执行逻辑，然后在 <code>baseController</code> 里面的 <code>this.AppController</code> 即为当前执行的控制器 <code>BaseAdminRouter</code>，因为会执行 <code>BaseAdminRouter.NestPrepare</code> 方法。然后开始执行相应的 Get 方法或者 Post 方法。</p>
<h2 id="提前终止运行"><a href="#提前终止运行" class="headerlink" title="提前终止运行"></a>提前终止运行</h2><p>我们应用中经常会遇到这样的情况，在 Prepare 阶段进行判断，如果用户认证不通过，就输出一段信息，然后直接中止进程，之后的 Post、Get 之类的不再执行，那么如何终止呢？可以使用 <code>StopRun</code> 来终止执行逻辑，可以在任意的地方执行。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RController <span class="hljs-keyword">struct</span> &#123;<br>    beego.Controller<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RController)</span> <span class="hljs-title">Prepare</span><span class="hljs-params">()</span></span> &#123;<br>    this.Data[<span class="hljs-string">&quot;json&quot;</span>] = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;astaxie&quot;</span>&#125;<br>    this.ServeJSON()<br>    this.StopRun()<br>&#125;<br></code></pre></div></td></tr></table></figure>















<style>
    table
    {
        margin: auto;
        font-size: 80%;
    }
</style>



            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Beego/">Beego</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/go/">go</a>
                    
                      <a class="hover-with-bg" href="/tags/beego/">beego</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/30/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">go语言中函数参数的传递方式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/29/Beego%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">Beego框架入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"enable":true,"appid":"hdfxWI5ee6Nfzsnqm5izGfSs-gzGzoHsz","appkey":"Fl5THEPney6qStRSSEn3ELd3","placeholder":"说点什么","path":"window.location.pathname","avatar":"avatar.webp","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":true,"serverURLs":"https://hdfxwi5e.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":true,"requiredFields":[],"visitor":true,"comment_count":true,"appId":"hdfxWI5ee6Nfzsnqm5izGfSs-gzGzoHsz","appKey":"Fl5THEPney6qStRSSEn3ELd3"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <img src="/img/太空探索与卫星.svg" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="height:200px;">
        </div>
      </div>
    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <p style="color:#f8f9fa">我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        鄂ICP备2021008617号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?e0b23de316904d07fb7110bd99d69a80";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  <!-- hexo injector body_end end --></body>
</html>
