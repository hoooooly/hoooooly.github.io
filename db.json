{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Kratos-Rebirth/source/css/kr-dark.min.css","path":"css/kr-dark.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/kratosr.min.css","path":"css/kratosr.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/prismjs.min.css","path":"css/prismjs.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/404.webp","path":"images/404.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/about.webp","path":"images/about.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/alipay.webp","path":"images/alipay.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/avatar.webp","path":"images/avatar.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/banner.webp","path":"images/banner.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/banner_dark.webp","path":"images/banner_dark.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/bg.webp","path":"images/bg.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/failure.ico","path":"images/failure.ico","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/logo.webp","path":"images/logo.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/my.webp","path":"images/my.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/psr.webp","path":"images/psr.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/sticky.webp","path":"images/sticky.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/wechat.webp","path":"images/wechat.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/js/candy.min.js","path":"js/candy.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/js/kr-dark.min.js","path":"js/kr-dark.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/js/kratosr.min.js","path":"js/kratosr.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/js/local-search.min.js","path":"js/local-search.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/js/pjax.min.js","path":"js/pjax.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/js/snow.min.js","path":"js/snow.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/highlight/light.min.css","path":"css/highlight/light.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night-blue.min.css","path":"css/highlight/night-blue.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night-bright.min.css","path":"css/highlight/night-bright.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night-eighties.min.css","path":"css/highlight/night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night.min.css","path":"css/highlight/night.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_1.webp","path":"images/thumb/thumb_1.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_10.webp","path":"images/thumb/thumb_10.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_11.webp","path":"images/thumb/thumb_11.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_12.webp","path":"images/thumb/thumb_12.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_13.webp","path":"images/thumb/thumb_13.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_14.webp","path":"images/thumb/thumb_14.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_15.webp","path":"images/thumb/thumb_15.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_16.webp","path":"images/thumb/thumb_16.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_17.webp","path":"images/thumb/thumb_17.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_18.webp","path":"images/thumb/thumb_18.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_19.webp","path":"images/thumb/thumb_19.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_2.webp","path":"images/thumb/thumb_2.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_20.webp","path":"images/thumb/thumb_20.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_3.webp","path":"images/thumb/thumb_3.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_4.webp","path":"images/thumb/thumb_4.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_5.webp","path":"images/thumb/thumb_5.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_6.webp","path":"images/thumb/thumb_6.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_7.webp","path":"images/thumb/thumb_7.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_8.webp","path":"images/thumb/thumb_8.webp","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_9.webp","path":"images/thumb/thumb_9.webp","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/HTTP基本原理.md","hash":"189f7c12ba6d5a1abee27879696e481651365757","modified":1620748656000},{"_id":"source/_posts/Hexo创建博客.md","hash":"3a88364bc975d7c12a96d1bd084bda0d7e07a327","modified":1620634144000},{"_id":"source/_posts/Hexo在腾讯云的部署.md","hash":"a8c1a7e2454243022f7f99414507584f38399d14","modified":1620629596000},{"_id":"source/_posts/Session和Cookies.md","hash":"f7cae47eb823e43968b2e33339839fd58f0d5ba7","modified":1620790638000},{"_id":"source/_posts/git常用命令.md","hash":"a32dd321ae06b6311b95a22dc0fc1144ee546564","modified":1620570884000},{"_id":"source/_posts/python多线程基本原理.md","hash":"5ab510c168d2b68403fff79fd611be5099346024","modified":1620848530000},{"_id":"source/_posts/web网页基础.md","hash":"f03b68ea44311859dceef564860864f965188e2c","modified":1620787910000},{"_id":"source/_posts/在Hexo博客中嵌入外链视频.md","hash":"69b085e455df05e323b5463ff93f90ff68d37642","modified":1620711082000},{"_id":"source/_posts/爬虫的基本原理.md","hash":"f5a5adf0cbf3f474a1026751308d228f7930fbd9","modified":1620749568000},{"_id":"source/_posts/腾讯云配置ssl证书.md","hash":"c37b72d5eed40d6dd6117437aed85c13654dcb4d","modified":1620636652000},{"_id":"source/about/index.md","hash":"69c2d2c3c0c3c237f6ed89ed8e09f6607923aed2","modified":1620640226000},{"_id":"source/_posts/HTTP基本原理/webp_0.webp","hash":"5cda1aef076a1f77cacb4ed2a194e2834394de31","modified":1620656894000},{"_id":"source/_posts/HTTP基本原理/1.png","hash":"c7b40fc10675514ee4a907cd6ed5b451b2c84491","modified":1620656792000},{"_id":"source/_posts/HTTP基本原理/Screenshot_1.png","hash":"5adb41c8f84a13e121fc0f1c528dd40bbb856deb","modified":1620741928000},{"_id":"source/_posts/HTTP基本原理/Screenshot_2.png","hash":"ace6846527b33bf22c4956655f0bd6e3c73ae24f","modified":1620660764000},{"_id":"source/_posts/HTTP基本原理/Screenshot_3.png","hash":"378fabca423cb07c62e41766928483465e65f9a2","modified":1620661064000},{"_id":"themes/Kratos-Rebirth/Kratos-Rebirth-Manual.md","hash":"bc118fd7bed88d006f5b79ed439b0633bac9971f","modified":1620458332000},{"_id":"themes/Kratos-Rebirth/_config.yml","hash":"d30aac60db92e4bbd75469a1bcea1c844cf9a640","modified":1620639472000},{"_id":"themes/Kratos-Rebirth/LICENSE","hash":"1eba7caf09a39110ad2f542e3ed8700d1a69c6d3","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/gulpfile.js","hash":"0a7b0eb66e0f5dd368c7f2232ebc3064f205c5bf","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/package.json","hash":"a6587a398e138fa280d8df8e803ea1117cdee172","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/languages/zh-CN.yml","hash":"08638ac462cbd495b612d4b131cb2a34180229cb","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/layout/archive.ejs","hash":"8de88e53b499322599025da6395b6b4a8c489bad","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/index.ejs","hash":"c50d2ddae5c8f35ae015a6f7931aef9235809551","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/layout.ejs","hash":"b5ee6bc72a4b0499f0044aabc20a7866d7304a2e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/page.ejs","hash":"e7d5671d342ac7c594b493d30cddcc15206cd5e6","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/post.ejs","hash":"805a2ebcca65292b21b2bb216747f0a9cc09eb40","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/404.js","hash":"c8c2775fb0afe8b5d010a36dd50eaf6b72a36f77","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/cdn-optimize-helpers.js","hash":"063a81cb5d2888f52c8190aae25c29e6de41172b","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/check-update.js","hash":"645a1f30fa21237b256d5fa7c0a0923032728901","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/friends.js","hash":"2d9395526e74bfcdb46eaf3aac2dc0be748ff0b8","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/genconfig.js","hash":"bc3a7d5dd918fe1e4da17098e2f60a34e9cbbe50","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/search.js","hash":"e477a7e9a0ae009056120d4fd2040a296c28adad","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/scripts/tag-widgets.js","hash":"ed293a03ca9b5df8373b0b268ebb214ff79c634a","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_pages/404.ejs","hash":"0769195fc28d4153607bfd1ff78efdcd8f907710","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_pages/search-page.ejs","hash":"7a3fd8ceddd14dadf4e419b453bf799273430b75","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_comments/disqus.ejs","hash":"e107a146259123fe3c1bdde4d6a33836efdcd36c","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/layout/_comments/disqusjs.ejs","hash":"be784505c370fa683189a5220c51119e0afb57d5","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/layout/_comments/twikoo.ejs","hash":"cf4659ba38d851c114c91e63f4e465538fe7b75a","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/layout/_comments/valine.ejs","hash":"30942c85e9e8471e2885237b0589cf3ecf8cc0dc","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/layout/_comments/waline.ejs","hash":"ed05efb5c1a13b23e3fc50a4061434e82b82bdaf","modified":1620451968000},{"_id":"themes/Kratos-Rebirth/layout/_plugins/mermaid.ejs","hash":"3f7ed41957dda08d4e185b177685f3201bb7af60","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_partial/after-footer.ejs","hash":"d7e2ebcd3763d233f8335caef6dc5e55d54ea952","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_partial/footer.ejs","hash":"f1c8cc5fde3a25b18a11c405f939abcf1eb8ad1c","modified":1620462076000},{"_id":"themes/Kratos-Rebirth/layout/_partial/head.ejs","hash":"d3e4306db429a8a884544e76a15ce6d6e74cb03c","modified":1620459998000},{"_id":"themes/Kratos-Rebirth/layout/_partial/header.ejs","hash":"f54adfdbd4341cd25d4b0941a97c225eed6f69e5","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_partial/sidebar.ejs","hash":"33395d7d7dcfdbf7d451b320ed778ddc9409cbc3","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_tools/player.ejs","hash":"5c3ad00ab73158d9c2a5f94a637369ffba676131","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_tools/share.ejs","hash":"0384875f82a28bc4ab3fa3383f9471da16e37c27","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_widget/about.ejs","hash":"f355b8e8e1e9f2c912c77796ff616940cc34acba","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_widget/category.ejs","hash":"7141cc95eeb460f016d5cb16ce1121423a680f64","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_widget/posts.ejs","hash":"a95e8afadec17d644d590769ccf6a82911a544f9","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_widget/tagcloud.ejs","hash":"463a1e41aeaaff8b30fc4cff961181a73e007b60","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/layout/_widget/toc.ejs","hash":"3f605d61df121f80b101eaf6ff6031d3dad5320e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/kr-dark.min.css","hash":"43d3cd61925d1d03d66dba96378625124119054d","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/kratosr.min.css","hash":"57250c1136e62923d642af8a2e395423a85a59ff","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/prismjs.min.css","hash":"b1524893db1e2f62f987745a0ec9c223e581146b","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/logo.webp","hash":"0821aba064fe3b64938e9b8686e6cff5648913e7","modified":1620457696000},{"_id":"themes/Kratos-Rebirth/source/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/sticky.webp","hash":"0e9bcc89faa0a5e6112ba29e0dcf68e33681db02","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/js/candy.min.js","hash":"f047499c25170f1f5fac2471141d439b6330198f","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/js/kr-dark.min.js","hash":"469da5c1768c50d2324e458f196e2fa2ce036d8f","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/js/kratosr.min.js","hash":"493ab9b1a677bd14838f419ece32a1d88acf2729","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/js/local-search.min.js","hash":"4978657d8ab1b7f26c09300c538680c90019c94f","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/js/pjax.min.js","hash":"b02b0bbbb77c29a6bc568076300b3f85e15c796e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/js/snow.min.js","hash":"74b8138840be139836cf9a0e6b8d3d41d0c2902b","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/js/candy.js","hash":"92f106471f1b446226da12e2f407cd9c71beb6d8","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/js/kr-dark.js","hash":"2f5c290e7cce5dd8e4aa0c8492fc9111064bd7c3","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/js/kratosr.js","hash":"a7e77063e17551aec088110a627a792cd3a08a85","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/js/local-search.js","hash":"8e5f05a61c195f5e5ffcf0834ac83dc154eb34c7","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/js/pjax.js","hash":"466805aedd764376d4bd94edfc05d38d9213f956","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/js/snow.js","hash":"f38cf6daf376da460d8bf58506dce37789500d68","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/kr-dark.scss","hash":"effbc12fb602103c5fc570779a2c46192dd2e142","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/kratosr.scss","hash":"f6227b924274c6f5d667f24e27ec26bef464e122","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/prismjs.scss","hash":"2575922312729ec354d5889e28f4860917a9cac6","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/highlight/light.min.css","hash":"d3b598187c94eb55c64f125cf74e223182d24b01","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night-blue.min.css","hash":"60369b364dfa6cef9196cbf8b24a3efcac9af4b0","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night-bright.min.css","hash":"eda28126ba9b201d21bcc0eafbdc08eb25c0cb35","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night-eighties.min.css","hash":"150e68c0d67a82ae0272e808ac0306ccf98cdaf1","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/css/highlight/night.min.css","hash":"ba88183b481c9f45ac162ebf1acd1256a040d75e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/highlight/style.scss","hash":"6b9174d41d9d397e7498309eb16af5bb86ebb2ed","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/highlight/theme/light.scss","hash":"1fa05c806415127e3833315adb10443ca128b927","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/highlight/theme/night-blue.scss","hash":"9d7b9690331b850e6b92da10e57254e2bd9d294d","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/highlight/theme/night-bright.scss","hash":"8c1a12a963c0ff01d46f4e452b2c8ac7419465bd","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/highlight/theme/night-eighties.scss","hash":"770bf47845991ce76ccb87e02ea63e1158b74b39","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/src/scss/highlight/theme/night.scss","hash":"3bad0f8ac6be471a6d290f8b72a8ece8ca52f13e","modified":1620451970000},{"_id":"themes/Kratos-Rebirth/source/images/my.webp","hash":"3adb718329d17fed00f3fcd67af4bcd20002cfd7","modified":1620461408000},{"_id":"source/_posts/web网页基础/Screenshot_1.png","hash":"4466945441b85dc63432a583c23eec13419f8a5d","modified":1620747740000},{"_id":"public/config/main.json","hash":"65767c0374f3753e6c22ca74a99805eef7d7b163","modified":1620848681696},{"_id":"public/search.json","hash":"a14951013efcad62eb1d306944a6783eeda3293b","modified":1620848681696},{"_id":"public/about/index.html","hash":"61ec1ffee15921fee83aebfda72574a906a4fc2a","modified":1620848681696},{"_id":"public/categories/http/index.html","hash":"3d9dceae5ffed4e1a8b432d8b2165ee85c8f1355","modified":1620848681696},{"_id":"public/categories/Git/index.html","hash":"b776632e1532f02e11365557ef1c6721865ecfaf","modified":1620848681696},{"_id":"public/tags/web/index.html","hash":"5d00b9acd77cb8086254851c6f9100f69acce11e","modified":1620848681696},{"_id":"public/tags/Git/index.html","hash":"3823c13c06e3c58a1a0b678b2fc38cf6898ba40d","modified":1620848681696},{"_id":"public/tags/html/index.html","hash":"0c2e445de73c9cd7b731f8f5afb1b9eeaef57db6","modified":1620848681696},{"_id":"public/tags/css/index.html","hash":"21bd9d8efeac47cc6b85f83e98882a970a130003","modified":1620848681696},{"_id":"public/tags/javascript/index.html","hash":"e5c4274f083e831edeadb98c05e9ccd7e957717f","modified":1620848681696},{"_id":"public/tags/Http/index.html","hash":"91b446e10fe21c649ed9b76415087e9be8219102","modified":1620848681696},{"_id":"public/404.html","hash":"c877f574aa53afa3add267ab875692f259f0b0b1","modified":1620848681696},{"_id":"public/friends/index.html","hash":"0b875e622fa07dde2edd0945d098db57d1db9ea2","modified":1620848681696},{"_id":"public/search/index.html","hash":"dc6bf1d2a531c9e3b3545180c80cccc7a59f621b","modified":1620848681696},{"_id":"public/2021/05/13/python多线程基本原理/index.html","hash":"3156ccfdff77dc8f20796dbd8d2597d5d32bd91f","modified":1620848681696},{"_id":"public/2021/05/12/Session和Cookies/index.html","hash":"83f5c5527988993121dec4f6432345ebc6aa905d","modified":1620848681696},{"_id":"public/2021/05/12/爬虫的基本原理/index.html","hash":"5db7024dcf3cc1544c4239e5d04d0b7f77bb64dc","modified":1620848681696},{"_id":"public/2021/05/11/web网页基础/index.html","hash":"2cce440aebac1f4249757a325c46108951b90660","modified":1620848681696},{"_id":"public/2021/05/11/在Hexo博客中嵌入外链视频/index.html","hash":"1142753b623b24f394b581bfc5ec242d66d5a7a0","modified":1620848681696},{"_id":"public/2021/05/10/腾讯云配置ssl证书/index.html","hash":"048f25f3d1681a33955f7de3247b351c610fd3fb","modified":1620848681696},{"_id":"public/2021/05/10/Hexo在腾讯云的部署/index.html","hash":"81b2fcbbaf4bb51740e02722db49abcd7715e306","modified":1620848681696},{"_id":"public/2021/05/09/HTTP基本原理/index.html","hash":"dca803295c1e71205c88a883b405d331c7f898b8","modified":1620848681696},{"_id":"public/2021/05/08/git常用命令/index.html","hash":"f99201d0b59d3af86cdf3a4eb13cc4fa2e79ed2c","modified":1620848681696},{"_id":"public/2021/05/08/Hexo创建博客/index.html","hash":"19a48f137ac9efb312557604feaae672eac733a6","modified":1620848681696},{"_id":"public/archives/index.html","hash":"35d7e93cc7d258313bdf19cbbe5bef9198315fb1","modified":1620848681696},{"_id":"public/archives/2021/index.html","hash":"ec7d4a3f226a3584183643e4c50a318b2cb4e0cf","modified":1620848681696},{"_id":"public/archives/2021/05/index.html","hash":"a4cdc47ee215be953f4d8060cb93111631d64073","modified":1620848681696},{"_id":"public/categories/博客教程/index.html","hash":"9d5c4d904c4e8e210a8dc59cb9c46484cba49f80","modified":1620848681696},{"_id":"public/categories/Python/index.html","hash":"2c1533d0306a14d735acc13088fcd8da206a6a93","modified":1620848681696},{"_id":"public/categories/爬虫/index.html","hash":"e9a1453aa129ea98fa92e5182163d912c9d7c32c","modified":1620848681696},{"_id":"public/tags/Hexo/index.html","hash":"24b525d30bb0fb9a4f752809db66bdbf35d029b1","modified":1620848681696},{"_id":"public/tags/http/index.html","hash":"60b9b70435d74c6eb06e6a026ba26e793eeed440","modified":1620848681696},{"_id":"public/tags/python/index.html","hash":"97d65cb71287be85a6c1978afde1b3c00f56ce33","modified":1620848681696},{"_id":"public/tags/多线程/index.html","hash":"acbfae84b589911abda32867c89e8b87eb557ecb","modified":1620848681696},{"_id":"public/tags/threading/index.html","hash":"f16ab1f25df1d3f741d395dccfc3f11fb4594e58","modified":1620848681696},{"_id":"public/tags/爬虫/index.html","hash":"401d56144e9ab4611ba5c6cad5255e7451add9c9","modified":1620848681696},{"_id":"public/tags/nginx/index.html","hash":"7cbc4eae67d1e4d605fe0bf2dfc30a140b6dd53f","modified":1620848681696},{"_id":"public/tags/https/index.html","hash":"bf92b1b95e0110ae1d721c4e7caa73754f4c39f6","modified":1620848681696},{"_id":"public/index.html","hash":"a671f9e33d0d0427d50ae7f88ea9583d9c3b1df0","modified":1620848681696},{"_id":"public/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1620848681696},{"_id":"public/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1620848681696},{"_id":"public/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1620848681696},{"_id":"public/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1620848681696},{"_id":"public/images/logo.webp","hash":"0821aba064fe3b64938e9b8686e6cff5648913e7","modified":1620848681696},{"_id":"public/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1620848681696},{"_id":"public/images/sticky.webp","hash":"0e9bcc89faa0a5e6112ba29e0dcf68e33681db02","modified":1620848681696},{"_id":"public/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1620848681696},{"_id":"public/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1620848681696},{"_id":"public/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1620848681696},{"_id":"public/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1620848681696},{"_id":"public/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1620848681696},{"_id":"public/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1620848681696},{"_id":"public/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1620848681696},{"_id":"public/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1620848681696},{"_id":"public/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1620848681696},{"_id":"public/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1620848681696},{"_id":"public/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1620848681696},{"_id":"public/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1620848681696},{"_id":"public/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1620848681696},{"_id":"public/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1620848681696},{"_id":"public/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1620848681696},{"_id":"public/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1620848681696},{"_id":"public/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1620848681696},{"_id":"public/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1620848681696},{"_id":"public/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1620848681696},{"_id":"public/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1620848681696},{"_id":"public/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1620848681696},{"_id":"public/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1620848681696},{"_id":"public/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1620848681696},{"_id":"public/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1620848681696},{"_id":"public/2021/05/09/HTTP基本原理/webp_0.webp","hash":"5cda1aef076a1f77cacb4ed2a194e2834394de31","modified":1620848681696},{"_id":"public/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1620848681696},{"_id":"public/css/prismjs.min.css","hash":"b1524893db1e2f62f987745a0ec9c223e581146b","modified":1620848681696},{"_id":"public/js/candy.min.js","hash":"f047499c25170f1f5fac2471141d439b6330198f","modified":1620848681696},{"_id":"public/js/kr-dark.min.js","hash":"469da5c1768c50d2324e458f196e2fa2ce036d8f","modified":1620848681696},{"_id":"public/js/kratosr.min.js","hash":"493ab9b1a677bd14838f419ece32a1d88acf2729","modified":1620848681696},{"_id":"public/js/pjax.min.js","hash":"b02b0bbbb77c29a6bc568076300b3f85e15c796e","modified":1620848681696},{"_id":"public/css/highlight/light.min.css","hash":"d3b598187c94eb55c64f125cf74e223182d24b01","modified":1620848681696},{"_id":"public/js/local-search.min.js","hash":"4978657d8ab1b7f26c09300c538680c90019c94f","modified":1620848681696},{"_id":"public/css/highlight/night-blue.min.css","hash":"60369b364dfa6cef9196cbf8b24a3efcac9af4b0","modified":1620848681696},{"_id":"public/css/highlight/night-bright.min.css","hash":"eda28126ba9b201d21bcc0eafbdc08eb25c0cb35","modified":1620848681696},{"_id":"public/css/highlight/night-eighties.min.css","hash":"150e68c0d67a82ae0272e808ac0306ccf98cdaf1","modified":1620848681696},{"_id":"public/css/highlight/night.min.css","hash":"ba88183b481c9f45ac162ebf1acd1256a040d75e","modified":1620848681696},{"_id":"public/js/snow.min.js","hash":"74b8138840be139836cf9a0e6b8d3d41d0c2902b","modified":1620848681696},{"_id":"public/css/kr-dark.min.css","hash":"5409001f9e4a08ac46dace09d200c747801bc6d3","modified":1620848681696},{"_id":"public/2021/05/09/HTTP基本原理/1.png","hash":"c7b40fc10675514ee4a907cd6ed5b451b2c84491","modified":1620848681696},{"_id":"public/css/kratosr.min.css","hash":"57250c1136e62923d642af8a2e395423a85a59ff","modified":1620848681696},{"_id":"public/images/my.webp","hash":"3adb718329d17fed00f3fcd67af4bcd20002cfd7","modified":1620848681696},{"_id":"public/2021/05/09/HTTP基本原理/Screenshot_2.png","hash":"ace6846527b33bf22c4956655f0bd6e3c73ae24f","modified":1620848681696},{"_id":"public/2021/05/09/HTTP基本原理/Screenshot_3.png","hash":"378fabca423cb07c62e41766928483465e65f9a2","modified":1620848681696},{"_id":"public/2021/05/09/HTTP基本原理/Screenshot_1.png","hash":"5adb41c8f84a13e121fc0f1c528dd40bbb856deb","modified":1620848681696},{"_id":"public/2021/05/11/web网页基础/Screenshot_1.png","hash":"4466945441b85dc63432a583c23eec13419f8a5d","modified":1620848681696}],"Category":[{"name":"博客教程","_id":"ckolvgfp70003ywxuafn75vub"},{"name":"http","_id":"ckolvgfpi000aywxu7x11eez4"},{"name":"Git","_id":"ckolvgfpk000fywxu5m40agtc"},{"name":"Python","_id":"ckolvgfpv000pywxugm8h6hdh"},{"name":"爬虫","_id":"ckolvgfq2000vywxu2vvk2por"}],"Data":[],"Page":[{"title":"关于我","date":"2021-05-10T09:35:50.000Z","_content":"\n苦逼的工科生，学电子的却爱鼓捣计算机的东西。\n\n目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不精通（╮(╯▽╰)╭）。\n\n梦想成为苦逼得程序员，敲代码得感觉真的超赞（o(*￣▽￣*)ブ）。\n\n代码的秩序感让我心安，世界太╮(╯▽╰)╭了。\n\n愿世界和平，大家都发财！\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2021-05-10 17:35:50\n---\n\n苦逼的工科生，学电子的却爱鼓捣计算机的东西。\n\n目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不精通（╮(╯▽╰)╭）。\n\n梦想成为苦逼得程序员，敲代码得感觉真的超赞（o(*￣▽￣*)ブ）。\n\n代码的秩序感让我心安，世界太╮(╯▽╰)╭了。\n\n愿世界和平，大家都发财！\n","updated":"2021-05-10T09:50:26.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckolvgfow0000ywxudbja5ote","content":"<p>苦逼的工科生，学电子的却爱鼓捣计算机的东西。</p>\n<p>目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不精通（╮(╯▽╰)╭）。</p>\n<p>梦想成为苦逼得程序员，敲代码得感觉真的超赞（o(<em>￣▽￣</em>)ブ）。</p>\n<p>代码的秩序感让我心安，世界太╮(╯▽╰)╭了。</p>\n<p>愿世界和平，大家都发财！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>苦逼的工科生，学电子的却爱鼓捣计算机的东西。</p>\n<p>目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不精通（╮(╯▽╰)╭）。</p>\n<p>梦想成为苦逼得程序员，敲代码得感觉真的超赞（o(<em>￣▽￣</em>)ブ）。</p>\n<p>代码的秩序感让我心安，世界太╮(╯▽╰)╭了。</p>\n<p>愿世界和平，大家都发财！</p>\n"}],"Post":[{"title":"Hexo在腾讯云的部署","date":"2021-05-10T04:51:56.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n## 简介\n\n`Hexo`在`GitHub pages`上的访问太慢了，迁移到腾讯云服务器上。\n\n## 部署环境\n\n腾讯云服务器（Centos 64位）。\n\n## 服务器配置\n\n### 安装git\n\n```shell\nyum install git\n```\n\n创建git用户并修改权限\n\n```shell\nadduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n\n找到一下内容\n\n```shell\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL\n```\n\n在该语句下添加\n\n```shell\ngit ALL=(ALL) ALL\n```\n\n退出（esc + :wq）并修改权限\n\n```shell\nchmod 400 /etc/sudoers\n```\n\n本地使用gitbash创建密钥\n\n```shell\nssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥\n```\n\n在腾讯云中创建`ssh`，并将本地的`id_rsa.pub`中的文件内容全部复制到`authorized_keys`中。\n\n```shell\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n```\n\n修改权限\n\n```shell\ncd ~\nchmod 600 .ssh/authorized_keys\nchmod 700 .ssh\n```\n\n本地测试\n\n```shell\nssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功\n```\n\n云服务器中创建网站目录并设置权限\n\n```shell\nsu root\nmkdir /home/hexo\nchown git:git -R /home/hexo\n```\n\n### 安装nginx\n\n```shell\nyum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务\n```\n\n以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。\n\n### 配置nginx\n\n```shell\nnginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。\nvim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo\n```\n\n重启服务\n\n```shell\nsystemctl restart nginx.service\n```\n\n## 建立git仓库并修改权限\n\n```shell\nsu root\ncd /home/git\ngit init --bare blog.git\nchown git:git -R blog.git\n```\n\n同步网站根目录\n\n```shell\nvim blog.git/hooks/post-receive\n```\n\n填入如下内容\n\n```shell\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\n```\n\n修改权限\n\n```shell\nchmod +x /home/git/blog.git/hooks/post-receive\n```\n\n在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：\n\n```shell\ngit@SERVER:/home/git/blog.git   //@后为你的服务器公网IP\n```\n\n以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。","source":"_posts/Hexo在腾讯云的部署.md","raw":"---\ntitle: Hexo在腾讯云的部署\ndate: 2021-05-10 12:51:56\ncategories: 博客教程\ntags:\n- Hexo\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n## 简介\n\n`Hexo`在`GitHub pages`上的访问太慢了，迁移到腾讯云服务器上。\n\n## 部署环境\n\n腾讯云服务器（Centos 64位）。\n\n## 服务器配置\n\n### 安装git\n\n```shell\nyum install git\n```\n\n创建git用户并修改权限\n\n```shell\nadduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n\n找到一下内容\n\n```shell\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL\n```\n\n在该语句下添加\n\n```shell\ngit ALL=(ALL) ALL\n```\n\n退出（esc + :wq）并修改权限\n\n```shell\nchmod 400 /etc/sudoers\n```\n\n本地使用gitbash创建密钥\n\n```shell\nssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥\n```\n\n在腾讯云中创建`ssh`，并将本地的`id_rsa.pub`中的文件内容全部复制到`authorized_keys`中。\n\n```shell\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n```\n\n修改权限\n\n```shell\ncd ~\nchmod 600 .ssh/authorized_keys\nchmod 700 .ssh\n```\n\n本地测试\n\n```shell\nssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功\n```\n\n云服务器中创建网站目录并设置权限\n\n```shell\nsu root\nmkdir /home/hexo\nchown git:git -R /home/hexo\n```\n\n### 安装nginx\n\n```shell\nyum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务\n```\n\n以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。\n\n### 配置nginx\n\n```shell\nnginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。\nvim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo\n```\n\n重启服务\n\n```shell\nsystemctl restart nginx.service\n```\n\n## 建立git仓库并修改权限\n\n```shell\nsu root\ncd /home/git\ngit init --bare blog.git\nchown git:git -R blog.git\n```\n\n同步网站根目录\n\n```shell\nvim blog.git/hooks/post-receive\n```\n\n填入如下内容\n\n```shell\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\n```\n\n修改权限\n\n```shell\nchmod +x /home/git/blog.git/hooks/post-receive\n```\n\n在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：\n\n```shell\ngit@SERVER:/home/git/blog.git   //@后为你的服务器公网IP\n```\n\n以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。","slug":"Hexo在腾讯云的部署","published":1,"updated":"2021-05-10T06:53:16.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfp00001ywxu9eokel71","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>Hexo</code>在<code>GitHub pages</code>上的访问太慢了，迁移到腾讯云服务器上。</p>\n<h2 id=\"部署环境\"><a href=\"#部署环境\" class=\"headerlink\" title=\"部署环境\"></a>部署环境</h2><p>腾讯云服务器（Centos 64位）。</p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n\n<p>创建git用户并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser git</span><br><span class=\"line\">passwd git</span><br><span class=\"line\">chmod 740 /etc/sudoers</span><br><span class=\"line\">vim /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>找到一下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># Allow root to run any commands anywhere</span></span></span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>\n\n<p>在该语句下添加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>\n\n<p>退出（esc + :wq）并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>本地使用gitbash创建密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥</span><br></pre></td></tr></table></figure>\n\n<p>在腾讯云中创建<code>ssh</code>，并将本地的<code>id_rsa.pub</code>中的文件内容全部复制到<code>authorized_keys</code>中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su git</span><br><span class=\"line\">mkdir ~/.ssh</span><br><span class=\"line\">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">chmod 600 .ssh/authorized_keys</span><br><span class=\"line\">chmod 700 .ssh</span><br></pre></td></tr></table></figure>\n\n<p>本地测试</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功</span><br></pre></td></tr></table></figure>\n\n<p>云服务器中创建网站目录并设置权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">mkdir /home/hexo</span><br><span class=\"line\">chown git:git -R /home/hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y nginx    // 安装</span><br><span class=\"line\">systemctl start nginx.service     // 启动服务</span><br></pre></td></tr></table></figure>\n\n<p>以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。</p>\n<h3 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。</span><br><span class=\"line\">vim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建立git仓库并修改权限\"><a href=\"#建立git仓库并修改权限\" class=\"headerlink\" title=\"建立git仓库并修改权限\"></a>建立git仓库并修改权限</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">cd /home/git</span><br><span class=\"line\">git init --bare blog.git</span><br><span class=\"line\">chown git:git -R blog.git</span><br></pre></td></tr></table></figure>\n\n<p>同步网站根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>填入如下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\">git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@SERVER:/home/git/blog.git   //@后为你的服务器公网IP</span><br></pre></td></tr></table></figure>\n\n<p>以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>Hexo</code>在<code>GitHub pages</code>上的访问太慢了，迁移到腾讯云服务器上。</p>\n<h2 id=\"部署环境\"><a href=\"#部署环境\" class=\"headerlink\" title=\"部署环境\"></a>部署环境</h2><p>腾讯云服务器（Centos 64位）。</p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n\n<p>创建git用户并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser git</span><br><span class=\"line\">passwd git</span><br><span class=\"line\">chmod 740 /etc/sudoers</span><br><span class=\"line\">vim /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>找到一下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># Allow root to run any commands anywhere</span></span></span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>\n\n<p>在该语句下添加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>\n\n<p>退出（esc + :wq）并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>本地使用gitbash创建密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥</span><br></pre></td></tr></table></figure>\n\n<p>在腾讯云中创建<code>ssh</code>，并将本地的<code>id_rsa.pub</code>中的文件内容全部复制到<code>authorized_keys</code>中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su git</span><br><span class=\"line\">mkdir ~/.ssh</span><br><span class=\"line\">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">chmod 600 .ssh/authorized_keys</span><br><span class=\"line\">chmod 700 .ssh</span><br></pre></td></tr></table></figure>\n\n<p>本地测试</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功</span><br></pre></td></tr></table></figure>\n\n<p>云服务器中创建网站目录并设置权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">mkdir /home/hexo</span><br><span class=\"line\">chown git:git -R /home/hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y nginx    // 安装</span><br><span class=\"line\">systemctl start nginx.service     // 启动服务</span><br></pre></td></tr></table></figure>\n\n<p>以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。</p>\n<h3 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。</span><br><span class=\"line\">vim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建立git仓库并修改权限\"><a href=\"#建立git仓库并修改权限\" class=\"headerlink\" title=\"建立git仓库并修改权限\"></a>建立git仓库并修改权限</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">cd /home/git</span><br><span class=\"line\">git init --bare blog.git</span><br><span class=\"line\">chown git:git -R blog.git</span><br></pre></td></tr></table></figure>\n\n<p>同步网站根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>填入如下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\">git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@SERVER:/home/git/blog.git   //@后为你的服务器公网IP</span><br></pre></td></tr></table></figure>\n\n<p>以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。</p>\n"},{"title":"Hexo搭建个人博客","date":"2021-05-08T07:39:22.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n\n# Hexo\n\n[Hexo](https://hexo.io/zh-cn/)是一个快速、简洁且高效的博客框架。\n\n## 安装\n\n### git安装\n\n```shell\n    Windows：下载并安装 git.\n    Mac：使用 Homebrew, MacPorts 或者下载 安装程序。\n    Linux (Ubuntu, Debian)：sudo apt-get install git-core\n    Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n```\n\n### 安装 Node.js\n\nNode.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。\n\n其它的安装方法：\n\n```shell\n    Windows：通过 nvs（推荐）或者nvm 安装。\n    Mac：使用 Homebrew 或 MacPorts 安装。\n    Linux（DEB/RPM-based）：从 NodeSource 安装。\n    其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导\n```\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n```shell\n    npm install -g hexo-cli\n```\n\n安装完成后，`win`+`R`输入`cmd`调出命令行，输入`hexo`提示如下，说明安装正确。\n\n```shell\n    C:\\Users\\espho>hexo\n    Usage: hexo <command>\n\n    Commands:\n    help     Get help on a command.\n    init     Create a new Hexo folder.\n    version  Display version information.\n\n    Global Options:\n    --config  Specify config file instead of using _config.yml\n    --cwd     Specify the CWD\n    --debug   Display all verbose messages in the terminal\n    --draft   Display draft posts\n    --safe    Disable all plugins and scripts\n    --silent  Hide output on console\n\n    For more help, you can use 'hexo help [command]' for the detailed information\n    or you can check the docs: http://hexo.io/docs/\n```\n\n## 建站\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```shell\n    hexo init <folder>\n    cd <folder>\n    npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```shell\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n### _config.yml\n\n网站的 配置 信息，您可以在此配置大部分的参数。\n\n### package.json\n\n应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。\n\n```shell\npackage.json\n{\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^3.8.0\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-server\": \"^0.3.3\"\n  }\n}\n```\n\n### scaffolds\n\n`模版`文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\n\nHexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\n\n### source\n\n资源文件夹是存放用户资源的地方。除 `_posts`文件夹之外，开头命名为 `_ (下划线)`的文件`/文件夹`和`隐藏的文件`将会被忽略。Markdown 和 HTML 文件会被解析并放到 `public`文件夹，而其他文件会被拷贝过去。\n\n### themes\n\n`主题`文件夹。Hexo 会根据主题来生成静态页面。\n\n## 配置\n\n相关配置可直接访问[官方文档](https://hexo.io/zh-cn/docs/configuration)查看，我们先从使用别人的主题开始，[官方](https://hexo.io/themes/)提供了335个主题下载使用，你也可以根据规范制定自己的主题。\n\n## 主题\n\n创建`Hexo`主题非常容易，您只要在`themes`文件夹内，新增一个任意名称的文件夹，并修改`_config.yml`内的`theme`设定，即可切换主题。一个主题可能会有以下的结构：\n\n```shell\n.\n├── _config.yml\n├── languages\n├── layout\n├── scripts\n└── source\n```\n\n### _config.yml\n\n主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启`Hexo Server`。\n\n## 获取主题\n\n选择相应的主题，从`github`上获取到`themes`目录下。\n\n修改主目录下`_config.yml`中的配置文件，将`theme`修改为获取主题的`文件夹名`。\n\n```shell\ntheme: Kratos-Rebirth\n```\n\n## 运行\n\n在主目录下调用`cmd`命令`hexo server`运行服务，访问`http://localhost:4000`进入博客。\n\n```shell\nespho@Holy-Surface MINGW64 /e/blog\n$ hexo server\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\nINFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2\nINFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。\nINFO  预祝您使用愉快。\n```\n\n## 添加文章\n\n","source":"_posts/Hexo创建博客.md","raw":"---\ntitle: Hexo搭建个人博客\ndate: 2021-05-08 15:39:22\ncategories: 博客教程\ntags:\n- Hexo\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n\n# Hexo\n\n[Hexo](https://hexo.io/zh-cn/)是一个快速、简洁且高效的博客框架。\n\n## 安装\n\n### git安装\n\n```shell\n    Windows：下载并安装 git.\n    Mac：使用 Homebrew, MacPorts 或者下载 安装程序。\n    Linux (Ubuntu, Debian)：sudo apt-get install git-core\n    Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n```\n\n### 安装 Node.js\n\nNode.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。\n\n其它的安装方法：\n\n```shell\n    Windows：通过 nvs（推荐）或者nvm 安装。\n    Mac：使用 Homebrew 或 MacPorts 安装。\n    Linux（DEB/RPM-based）：从 NodeSource 安装。\n    其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导\n```\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n```shell\n    npm install -g hexo-cli\n```\n\n安装完成后，`win`+`R`输入`cmd`调出命令行，输入`hexo`提示如下，说明安装正确。\n\n```shell\n    C:\\Users\\espho>hexo\n    Usage: hexo <command>\n\n    Commands:\n    help     Get help on a command.\n    init     Create a new Hexo folder.\n    version  Display version information.\n\n    Global Options:\n    --config  Specify config file instead of using _config.yml\n    --cwd     Specify the CWD\n    --debug   Display all verbose messages in the terminal\n    --draft   Display draft posts\n    --safe    Disable all plugins and scripts\n    --silent  Hide output on console\n\n    For more help, you can use 'hexo help [command]' for the detailed information\n    or you can check the docs: http://hexo.io/docs/\n```\n\n## 建站\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```shell\n    hexo init <folder>\n    cd <folder>\n    npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```shell\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n### _config.yml\n\n网站的 配置 信息，您可以在此配置大部分的参数。\n\n### package.json\n\n应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。\n\n```shell\npackage.json\n{\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^3.8.0\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-server\": \"^0.3.3\"\n  }\n}\n```\n\n### scaffolds\n\n`模版`文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\n\nHexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\n\n### source\n\n资源文件夹是存放用户资源的地方。除 `_posts`文件夹之外，开头命名为 `_ (下划线)`的文件`/文件夹`和`隐藏的文件`将会被忽略。Markdown 和 HTML 文件会被解析并放到 `public`文件夹，而其他文件会被拷贝过去。\n\n### themes\n\n`主题`文件夹。Hexo 会根据主题来生成静态页面。\n\n## 配置\n\n相关配置可直接访问[官方文档](https://hexo.io/zh-cn/docs/configuration)查看，我们先从使用别人的主题开始，[官方](https://hexo.io/themes/)提供了335个主题下载使用，你也可以根据规范制定自己的主题。\n\n## 主题\n\n创建`Hexo`主题非常容易，您只要在`themes`文件夹内，新增一个任意名称的文件夹，并修改`_config.yml`内的`theme`设定，即可切换主题。一个主题可能会有以下的结构：\n\n```shell\n.\n├── _config.yml\n├── languages\n├── layout\n├── scripts\n└── source\n```\n\n### _config.yml\n\n主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启`Hexo Server`。\n\n## 获取主题\n\n选择相应的主题，从`github`上获取到`themes`目录下。\n\n修改主目录下`_config.yml`中的配置文件，将`theme`修改为获取主题的`文件夹名`。\n\n```shell\ntheme: Kratos-Rebirth\n```\n\n## 运行\n\n在主目录下调用`cmd`命令`hexo server`运行服务，访问`http://localhost:4000`进入博客。\n\n```shell\nespho@Holy-Surface MINGW64 /e/blog\n$ hexo server\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\nINFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2\nINFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。\nINFO  预祝您使用愉快。\n```\n\n## 添加文章\n\n","slug":"Hexo创建博客","published":1,"updated":"2021-05-10T08:09:04.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfp50002ywxu6o2x4132","content":"<h1 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h1><p><a href=\"https://hexo.io/zh-cn/\">Hexo</a>是一个快速、简洁且高效的博客框架。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：下载并安装 git.</span><br><span class=\"line\">Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</span><br><span class=\"line\">Linux (Ubuntu, Debian)：sudo apt-get install git-core</span><br><span class=\"line\">Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p>\n<p>其它的安装方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：通过 nvs（推荐）或者nvm 安装。</span><br><span class=\"line\">Mac：使用 Homebrew 或 MacPorts 安装。</span><br><span class=\"line\">Linux（DEB/RPM-based）：从 NodeSource 安装。</span><br><span class=\"line\">其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，<code>win</code>+<code>R</code>输入<code>cmd</code>调出命令行，输入<code>hexo</code>提示如下，说明安装正确。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\espho&gt;hexo</span><br><span class=\"line\">Usage: hexo &lt;command&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">help     Get help on a command.</span><br><span class=\"line\">init     Create a new Hexo folder.</span><br><span class=\"line\">version  Display version information.</span><br><span class=\"line\"></span><br><span class=\"line\">Global Options:</span><br><span class=\"line\">--config  Specify config file instead of using _config.yml</span><br><span class=\"line\">--cwd     Specify the CWD</span><br><span class=\"line\">--debug   Display all verbose messages in the terminal</span><br><span class=\"line\">--draft   Display draft posts</span><br><span class=\"line\">--safe    Disable all plugins and scripts</span><br><span class=\"line\">--silent  Hide output on console</span><br><span class=\"line\"></span><br><span class=\"line\">For more help, you can use &#x27;hexo help [command]&#x27; for the detailed information</span><br><span class=\"line\">or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\">cd &lt;folder&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>\n<h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scaffolds\"><a href=\"#scaffolds\" class=\"headerlink\" title=\"scaffolds\"></a>scaffolds</h3><p><code>模版</code>文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>\n<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code>文件夹之外，开头命名为 <code>_ (下划线)</code>的文件<code>/文件夹</code>和<code>隐藏的文件</code>将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code>文件夹，而其他文件会被拷贝过去。</p>\n<h3 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h3><p><code>主题</code>文件夹。Hexo 会根据主题来生成静态页面。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>相关配置可直接访问<a href=\"https://hexo.io/zh-cn/docs/configuration\">官方文档</a>查看，我们先从使用别人的主题开始，<a href=\"https://hexo.io/themes/\">官方</a>提供了335个主题下载使用，你也可以根据规范制定自己的主题。</p>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><p>创建<code>Hexo</code>主题非常容易，您只要在<code>themes</code>文件夹内，新增一个任意名称的文件夹，并修改<code>_config.yml</code>内的<code>theme</code>设定，即可切换主题。一个主题可能会有以下的结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── languages</span><br><span class=\"line\">├── layout</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">└── source</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml-1\"><a href=\"#config-yml-1\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启<code>Hexo Server</code>。</p>\n<h2 id=\"获取主题\"><a href=\"#获取主题\" class=\"headerlink\" title=\"获取主题\"></a>获取主题</h2><p>选择相应的主题，从<code>github</code>上获取到<code>themes</code>目录下。</p>\n<p>修改主目录下<code>_config.yml</code>中的配置文件，将<code>theme</code>修改为获取主题的<code>文件夹名</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: Kratos-Rebirth</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在主目录下调用<code>cmd</code>命令<code>hexo server</code>运行服务，访问<code>http://localhost:4000</code>进入博客。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">espho@Holy-Surface MINGW64 /e/blog</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo server</span></span><br><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class=\"line\">INFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2</span><br><span class=\"line\">INFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。</span><br><span class=\"line\">INFO  预祝您使用愉快。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加文章\"><a href=\"#添加文章\" class=\"headerlink\" title=\"添加文章\"></a>添加文章</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h1><p><a href=\"https://hexo.io/zh-cn/\">Hexo</a>是一个快速、简洁且高效的博客框架。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：下载并安装 git.</span><br><span class=\"line\">Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</span><br><span class=\"line\">Linux (Ubuntu, Debian)：sudo apt-get install git-core</span><br><span class=\"line\">Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p>\n<p>其它的安装方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：通过 nvs（推荐）或者nvm 安装。</span><br><span class=\"line\">Mac：使用 Homebrew 或 MacPorts 安装。</span><br><span class=\"line\">Linux（DEB/RPM-based）：从 NodeSource 安装。</span><br><span class=\"line\">其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，<code>win</code>+<code>R</code>输入<code>cmd</code>调出命令行，输入<code>hexo</code>提示如下，说明安装正确。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\espho&gt;hexo</span><br><span class=\"line\">Usage: hexo &lt;command&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">help     Get help on a command.</span><br><span class=\"line\">init     Create a new Hexo folder.</span><br><span class=\"line\">version  Display version information.</span><br><span class=\"line\"></span><br><span class=\"line\">Global Options:</span><br><span class=\"line\">--config  Specify config file instead of using _config.yml</span><br><span class=\"line\">--cwd     Specify the CWD</span><br><span class=\"line\">--debug   Display all verbose messages in the terminal</span><br><span class=\"line\">--draft   Display draft posts</span><br><span class=\"line\">--safe    Disable all plugins and scripts</span><br><span class=\"line\">--silent  Hide output on console</span><br><span class=\"line\"></span><br><span class=\"line\">For more help, you can use &#x27;hexo help [command]&#x27; for the detailed information</span><br><span class=\"line\">or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\">cd &lt;folder&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>\n<h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scaffolds\"><a href=\"#scaffolds\" class=\"headerlink\" title=\"scaffolds\"></a>scaffolds</h3><p><code>模版</code>文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>\n<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code>文件夹之外，开头命名为 <code>_ (下划线)</code>的文件<code>/文件夹</code>和<code>隐藏的文件</code>将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code>文件夹，而其他文件会被拷贝过去。</p>\n<h3 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h3><p><code>主题</code>文件夹。Hexo 会根据主题来生成静态页面。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>相关配置可直接访问<a href=\"https://hexo.io/zh-cn/docs/configuration\">官方文档</a>查看，我们先从使用别人的主题开始，<a href=\"https://hexo.io/themes/\">官方</a>提供了335个主题下载使用，你也可以根据规范制定自己的主题。</p>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><p>创建<code>Hexo</code>主题非常容易，您只要在<code>themes</code>文件夹内，新增一个任意名称的文件夹，并修改<code>_config.yml</code>内的<code>theme</code>设定，即可切换主题。一个主题可能会有以下的结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── languages</span><br><span class=\"line\">├── layout</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">└── source</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml-1\"><a href=\"#config-yml-1\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启<code>Hexo Server</code>。</p>\n<h2 id=\"获取主题\"><a href=\"#获取主题\" class=\"headerlink\" title=\"获取主题\"></a>获取主题</h2><p>选择相应的主题，从<code>github</code>上获取到<code>themes</code>目录下。</p>\n<p>修改主目录下<code>_config.yml</code>中的配置文件，将<code>theme</code>修改为获取主题的<code>文件夹名</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: Kratos-Rebirth</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在主目录下调用<code>cmd</code>命令<code>hexo server</code>运行服务，访问<code>http://localhost:4000</code>进入博客。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">espho@Holy-Surface MINGW64 /e/blog</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo server</span></span><br><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class=\"line\">INFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2</span><br><span class=\"line\">INFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。</span><br><span class=\"line\">INFO  预祝您使用愉快。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加文章\"><a href=\"#添加文章\" class=\"headerlink\" title=\"添加文章\"></a>添加文章</h2>"},{"title":"Session和Cookies","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-12T02:51:36.000Z","pic":null,"_content":"\n## 静态网页和动态网页\n\n示例代码：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>This is a Demo</title> \n  </head>\n  <body> \n    <div id=\"container\">\n      <div class=\"wrapper\"> \n        <h2 class=\"title\">Hello World</h2> \n        <p class=\"text\">Hello, this is a paragraph.</p> \n        </div> \n      </div> \n    </body> \n</html>\n```\n\n这是最基本的HTML代码，保存为一个`.html`文件，然后把它放在某台具有固定公网`IP`的主机上，主机上装上`Apache`或`Nginx`等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。\n\n这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据`URL`灵活多变地显示内容等。例如，想要给这个网页的`URL`传入一个`name`参数，让其在网页中显示出来，是无法做到的。\n\n因此，动态网页应运而生，它可以动态解析`URL`中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的`HTML`，而是可能由`JSP`、`PHP`、`Python`等语言编写的，其功能比静态网页强大和丰富太多了。\n\n此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。\n\n那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。\n\n## 无状态HTTP\n\n在了解`Session`和`Cookies`之前，还需要了解`HTTP`的一个特点，叫作无状态。\n\n`HTTP`的无状态是指`HTTP`协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。\n\n当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。\n\n这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。\n\n这时两个用于保持`HTTP`连接状态的技术就出现了，它们分别是`Session`和`Cookies`。`Session`在服务端，也就是网站的服务器，用来保存用户的`Session信息`；`Cookies`在客户端，也可以理解为**浏览器端**，有了`Cookies`，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别`Cookies`并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。\n\n可以理解为`Cookies`里面保存了登录的凭证，有了它，只需要在下次请求携带`Cookies`发送请求而不必重新输入用户名、密码等信息重新登录了。\n\n因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的`Cookies`放在请求头里面直接请求，而不必重新模拟登录。\n\n## Cookies\n\n`Cookies`指某些网站为了辨别用户身份、进行`Session`跟踪而存储在用户本地终端上的数据。\n\n## Session\n\n`Session`，中文称之为**会话**，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 `Session`。\n\n而在`Web`中，`Session对象`用来存储特定用户`Session`所需的属性及配置信息。这样，当用户在应用程序的`Web`页之间跳转时，存储在`Session`对象中的变量将不会丢失，而是在整个用户`Session`中一直存在下去。当用户请求来自应用程序的`Web`页时，如果该用户还没有`Session`，则`Web`服务器将自动创建一个 `Session`对象。当`Session`过期或被放弃后，服务器将终止该`Session`。\n\n## Session维持\n\n那么，怎样利用`Cookies`保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有`Set-Cookie`字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把`Cookies`保存起来。当浏览器下一次再请求该网站时，浏览器会把此`Cookies`放到请求头一起提交给服务器，`Cookies`携带了`SessionID` 信息，服务器检查该`Cookies`即可找到对应的`Session`是什么，然后再判断`Session`来以此来辨认用户状态。\n\n在成功登录某个网站时，服务器会告诉客户端设置哪些`Cookies`信息，在后续访问页面时客户端会把`Cookies`发送给服务器，服务器再找到对应的`Session`加以判断。如果`Session`中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。\n\n反之，如果传给服务器的`Cookies`是无效的，或者`Session`已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，`Cookies`和`Session`需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录`Session`控制。\n\n## Cookies属性结构\n\n`Cookie`有如下几个属性。\n\n- `Name`，即该`Cookie`的名称。\n- `Cookie`一旦创建，名称便不可更改。\n- `Value`，即该`Cookie`的值。如果值为`Unicode`字符，需要为字符编码。如果值为二进制数据，则需要使用`BASE64`编码。\n- `MaxAge`，即该`Cookie`失效的时间，单位秒，也常和`Expires`一起使用，通过它可以计算出其有效时间。\n- `MaxAge` 如果为正数，则该`Cookie`在`MaxAge`秒之后失效。如果为负数，则关闭浏览器时`Cookie`即失效，浏览器也不会以任何形式保存该`Cookie`。\n- `Path`，即该`Cookie`的使用路径。如果设置为`/path/`，则只有路径为`/path/`的页面可以访问该`Cookie`。如果设置为`/`，则本域名下的所有页面都可以访问该`Cookie`。\n- `Domain`，即可以访问该`Cookie`的域名。例如如果设置为`.zhihu.com`，则所有以`zhihu.com`，结尾的域名都可以访问该`Cookie`。\n- `Size`字段，即此`Cookie`的大小。\n- `Http`字段，即`Cookie`的`httponly`属性。若此属性为`true`，则只有在`HTTP Headers`中会带有此`Cookie`的信息，而不能通过`document.cookie`来访问此`Cookie`。\n- `Secure`，即该`Cookie`是否仅被使用安全协议传输。安全协议。安全协议有`HTTPS、SSL`等，在网络上传输数据之前先将数据加密。默认为`false`。\n\n## 会话会`Cookie`和持久和`Cookie`\n\n从表面意思来说，会话`Cookie`就是把`Cookie`放在浏览器内存里，浏览器在关闭之后该`Cookie`即失效；持久`Cookie`则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。\n\n严格来说，没有会话`Cookie`和持久`Cookie`之分，只是由`Cookie`的`MaxAge`或`Expires`字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把`Cookie`的有效时间和`Session`有效期设置得比较长，下次再访问页面时仍然携带之前的`Cookie`，就可以直接保持登录状态。\n\n## 常见误区\n\n在谈论`Session`机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，`Session`就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对`Session`来说，也是一样，除非程序通知服务器删除一个`Session`，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除`Session`。\n\n但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话`Cookie`来保存`Session ID`信息，而关闭浏览器后`Cookies`就消失了，再次连接服务器时，也就无法找到原来的`Session`了。如果服务器设置的`Cookies`保存到硬盘上，或者使用某种手段改写浏览器发出的`HTTP`请求头，把原来的`Cookies`发送给服务器，则再次打开浏览器，仍然能够找到原来的`Session ID`，依旧还是可以保持登录状态的。\n\n而且恰恰是由于关闭浏览器不会导致`Session`被删除，这就需要服务器为`Session`设置一个失效时间，当距离客户端上一次使用`Session`的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把`Session`删除以节省存储空间。\n","source":"_posts/Session和Cookies.md","raw":"---\ntitle: Session和Cookies\ntags:\n  - http\n  - web\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-12 10:51:36\ncategories: http\npic:\n---\n\n## 静态网页和动态网页\n\n示例代码：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>This is a Demo</title> \n  </head>\n  <body> \n    <div id=\"container\">\n      <div class=\"wrapper\"> \n        <h2 class=\"title\">Hello World</h2> \n        <p class=\"text\">Hello, this is a paragraph.</p> \n        </div> \n      </div> \n    </body> \n</html>\n```\n\n这是最基本的HTML代码，保存为一个`.html`文件，然后把它放在某台具有固定公网`IP`的主机上，主机上装上`Apache`或`Nginx`等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。\n\n这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据`URL`灵活多变地显示内容等。例如，想要给这个网页的`URL`传入一个`name`参数，让其在网页中显示出来，是无法做到的。\n\n因此，动态网页应运而生，它可以动态解析`URL`中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的`HTML`，而是可能由`JSP`、`PHP`、`Python`等语言编写的，其功能比静态网页强大和丰富太多了。\n\n此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。\n\n那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。\n\n## 无状态HTTP\n\n在了解`Session`和`Cookies`之前，还需要了解`HTTP`的一个特点，叫作无状态。\n\n`HTTP`的无状态是指`HTTP`协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。\n\n当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。\n\n这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。\n\n这时两个用于保持`HTTP`连接状态的技术就出现了，它们分别是`Session`和`Cookies`。`Session`在服务端，也就是网站的服务器，用来保存用户的`Session信息`；`Cookies`在客户端，也可以理解为**浏览器端**，有了`Cookies`，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别`Cookies`并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。\n\n可以理解为`Cookies`里面保存了登录的凭证，有了它，只需要在下次请求携带`Cookies`发送请求而不必重新输入用户名、密码等信息重新登录了。\n\n因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的`Cookies`放在请求头里面直接请求，而不必重新模拟登录。\n\n## Cookies\n\n`Cookies`指某些网站为了辨别用户身份、进行`Session`跟踪而存储在用户本地终端上的数据。\n\n## Session\n\n`Session`，中文称之为**会话**，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 `Session`。\n\n而在`Web`中，`Session对象`用来存储特定用户`Session`所需的属性及配置信息。这样，当用户在应用程序的`Web`页之间跳转时，存储在`Session`对象中的变量将不会丢失，而是在整个用户`Session`中一直存在下去。当用户请求来自应用程序的`Web`页时，如果该用户还没有`Session`，则`Web`服务器将自动创建一个 `Session`对象。当`Session`过期或被放弃后，服务器将终止该`Session`。\n\n## Session维持\n\n那么，怎样利用`Cookies`保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有`Set-Cookie`字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把`Cookies`保存起来。当浏览器下一次再请求该网站时，浏览器会把此`Cookies`放到请求头一起提交给服务器，`Cookies`携带了`SessionID` 信息，服务器检查该`Cookies`即可找到对应的`Session`是什么，然后再判断`Session`来以此来辨认用户状态。\n\n在成功登录某个网站时，服务器会告诉客户端设置哪些`Cookies`信息，在后续访问页面时客户端会把`Cookies`发送给服务器，服务器再找到对应的`Session`加以判断。如果`Session`中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。\n\n反之，如果传给服务器的`Cookies`是无效的，或者`Session`已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，`Cookies`和`Session`需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录`Session`控制。\n\n## Cookies属性结构\n\n`Cookie`有如下几个属性。\n\n- `Name`，即该`Cookie`的名称。\n- `Cookie`一旦创建，名称便不可更改。\n- `Value`，即该`Cookie`的值。如果值为`Unicode`字符，需要为字符编码。如果值为二进制数据，则需要使用`BASE64`编码。\n- `MaxAge`，即该`Cookie`失效的时间，单位秒，也常和`Expires`一起使用，通过它可以计算出其有效时间。\n- `MaxAge` 如果为正数，则该`Cookie`在`MaxAge`秒之后失效。如果为负数，则关闭浏览器时`Cookie`即失效，浏览器也不会以任何形式保存该`Cookie`。\n- `Path`，即该`Cookie`的使用路径。如果设置为`/path/`，则只有路径为`/path/`的页面可以访问该`Cookie`。如果设置为`/`，则本域名下的所有页面都可以访问该`Cookie`。\n- `Domain`，即可以访问该`Cookie`的域名。例如如果设置为`.zhihu.com`，则所有以`zhihu.com`，结尾的域名都可以访问该`Cookie`。\n- `Size`字段，即此`Cookie`的大小。\n- `Http`字段，即`Cookie`的`httponly`属性。若此属性为`true`，则只有在`HTTP Headers`中会带有此`Cookie`的信息，而不能通过`document.cookie`来访问此`Cookie`。\n- `Secure`，即该`Cookie`是否仅被使用安全协议传输。安全协议。安全协议有`HTTPS、SSL`等，在网络上传输数据之前先将数据加密。默认为`false`。\n\n## 会话会`Cookie`和持久和`Cookie`\n\n从表面意思来说，会话`Cookie`就是把`Cookie`放在浏览器内存里，浏览器在关闭之后该`Cookie`即失效；持久`Cookie`则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。\n\n严格来说，没有会话`Cookie`和持久`Cookie`之分，只是由`Cookie`的`MaxAge`或`Expires`字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把`Cookie`的有效时间和`Session`有效期设置得比较长，下次再访问页面时仍然携带之前的`Cookie`，就可以直接保持登录状态。\n\n## 常见误区\n\n在谈论`Session`机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，`Session`就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对`Session`来说，也是一样，除非程序通知服务器删除一个`Session`，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除`Session`。\n\n但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话`Cookie`来保存`Session ID`信息，而关闭浏览器后`Cookies`就消失了，再次连接服务器时，也就无法找到原来的`Session`了。如果服务器设置的`Cookies`保存到硬盘上，或者使用某种手段改写浏览器发出的`HTTP`请求头，把原来的`Cookies`发送给服务器，则再次打开浏览器，仍然能够找到原来的`Session ID`，依旧还是可以保持登录状态的。\n\n而且恰恰是由于关闭浏览器不会导致`Session`被删除，这就需要服务器为`Session`设置一个失效时间，当距离客户端上一次使用`Session`的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把`Session`删除以节省存储空间。\n","slug":"Session和Cookies","published":1,"updated":"2021-05-12T03:37:18.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfpb0005ywxudl1famty","content":"<h2 id=\"静态网页和动态网页\"><a href=\"#静态网页和动态网页\" class=\"headerlink\" title=\"静态网页和动态网页\"></a>静态网页和动态网页</h2><p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;title&quot;</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>Hello, this is a paragraph.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是最基本的HTML代码，保存为一个<code>.html</code>文件，然后把它放在某台具有固定公网<code>IP</code>的主机上，主机上装上<code>Apache</code>或<code>Nginx</code>等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。</p>\n<p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据<code>URL</code>灵活多变地显示内容等。例如，想要给这个网页的<code>URL</code>传入一个<code>name</code>参数，让其在网页中显示出来，是无法做到的。</p>\n<p>因此，动态网页应运而生，它可以动态解析<code>URL</code>中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的<code>HTML</code>，而是可能由<code>JSP</code>、<code>PHP</code>、<code>Python</code>等语言编写的，其功能比静态网页强大和丰富太多了。</p>\n<p>此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。</p>\n<p>那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。</p>\n<h2 id=\"无状态HTTP\"><a href=\"#无状态HTTP\" class=\"headerlink\" title=\"无状态HTTP\"></a>无状态HTTP</h2><p>在了解<code>Session</code>和<code>Cookies</code>之前，还需要了解<code>HTTP</code>的一个特点，叫作无状态。</p>\n<p><code>HTTP</code>的无状态是指<code>HTTP</code>协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。</p>\n<p>当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p>\n<p>这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。</p>\n<p>这时两个用于保持<code>HTTP</code>连接状态的技术就出现了，它们分别是<code>Session</code>和<code>Cookies</code>。<code>Session</code>在服务端，也就是网站的服务器，用来保存用户的<code>Session信息</code>；<code>Cookies</code>在客户端，也可以理解为<strong>浏览器端</strong>，有了<code>Cookies</code>，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别<code>Cookies</code>并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。</p>\n<p>可以理解为<code>Cookies</code>里面保存了登录的凭证，有了它，只需要在下次请求携带<code>Cookies</code>发送请求而不必重新输入用户名、密码等信息重新登录了。</p>\n<p>因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的<code>Cookies</code>放在请求头里面直接请求，而不必重新模拟登录。</p>\n<h2 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h2><p><code>Cookies</code>指某些网站为了辨别用户身份、进行<code>Session</code>跟踪而存储在用户本地终端上的数据。</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p><code>Session</code>，中文称之为<strong>会话</strong>，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 <code>Session</code>。</p>\n<p>而在<code>Web</code>中，<code>Session对象</code>用来存储特定用户<code>Session</code>所需的属性及配置信息。这样，当用户在应用程序的<code>Web</code>页之间跳转时，存储在<code>Session</code>对象中的变量将不会丢失，而是在整个用户<code>Session</code>中一直存在下去。当用户请求来自应用程序的<code>Web</code>页时，如果该用户还没有<code>Session</code>，则<code>Web</code>服务器将自动创建一个 <code>Session</code>对象。当<code>Session</code>过期或被放弃后，服务器将终止该<code>Session</code>。</p>\n<h2 id=\"Session维持\"><a href=\"#Session维持\" class=\"headerlink\" title=\"Session维持\"></a>Session维持</h2><p>那么，怎样利用<code>Cookies</code>保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有<code>Set-Cookie</code>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把<code>Cookies</code>保存起来。当浏览器下一次再请求该网站时，浏览器会把此<code>Cookies</code>放到请求头一起提交给服务器，<code>Cookies</code>携带了<code>SessionID</code> 信息，服务器检查该<code>Cookies</code>即可找到对应的<code>Session</code>是什么，然后再判断<code>Session</code>来以此来辨认用户状态。</p>\n<p>在成功登录某个网站时，服务器会告诉客户端设置哪些<code>Cookies</code>信息，在后续访问页面时客户端会把<code>Cookies</code>发送给服务器，服务器再找到对应的<code>Session</code>加以判断。如果<code>Session</code>中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p>\n<p>反之，如果传给服务器的<code>Cookies</code>是无效的，或者<code>Session</code>已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，<code>Cookies</code>和<code>Session</code>需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录<code>Session</code>控制。</p>\n<h2 id=\"Cookies属性结构\"><a href=\"#Cookies属性结构\" class=\"headerlink\" title=\"Cookies属性结构\"></a>Cookies属性结构</h2><p><code>Cookie</code>有如下几个属性。</p>\n<ul>\n<li><code>Name</code>，即该<code>Cookie</code>的名称。</li>\n<li><code>Cookie</code>一旦创建，名称便不可更改。</li>\n<li><code>Value</code>，即该<code>Cookie</code>的值。如果值为<code>Unicode</code>字符，需要为字符编码。如果值为二进制数据，则需要使用<code>BASE64</code>编码。</li>\n<li><code>MaxAge</code>，即该<code>Cookie</code>失效的时间，单位秒，也常和<code>Expires</code>一起使用，通过它可以计算出其有效时间。</li>\n<li><code>MaxAge</code> 如果为正数，则该<code>Cookie</code>在<code>MaxAge</code>秒之后失效。如果为负数，则关闭浏览器时<code>Cookie</code>即失效，浏览器也不会以任何形式保存该<code>Cookie</code>。</li>\n<li><code>Path</code>，即该<code>Cookie</code>的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该<code>Cookie</code>。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该<code>Cookie</code>。</li>\n<li><code>Domain</code>，即可以访问该<code>Cookie</code>的域名。例如如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>，结尾的域名都可以访问该<code>Cookie</code>。</li>\n<li><code>Size</code>字段，即此<code>Cookie</code>的大小。</li>\n<li><code>Http</code>字段，即<code>Cookie</code>的<code>httponly</code>属性。若此属性为<code>true</code>，则只有在<code>HTTP Headers</code>中会带有此<code>Cookie</code>的信息，而不能通过<code>document.cookie</code>来访问此<code>Cookie</code>。</li>\n<li><code>Secure</code>，即该<code>Cookie</code>是否仅被使用安全协议传输。安全协议。安全协议有<code>HTTPS、SSL</code>等，在网络上传输数据之前先将数据加密。默认为<code>false</code>。</li>\n</ul>\n<h2 id=\"会话会Cookie和持久和Cookie\"><a href=\"#会话会Cookie和持久和Cookie\" class=\"headerlink\" title=\"会话会Cookie和持久和Cookie\"></a>会话会<code>Cookie</code>和持久和<code>Cookie</code></h2><p>从表面意思来说，会话<code>Cookie</code>就是把<code>Cookie</code>放在浏览器内存里，浏览器在关闭之后该<code>Cookie</code>即失效；持久<code>Cookie</code>则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p>\n<p>严格来说，没有会话<code>Cookie</code>和持久<code>Cookie</code>之分，只是由<code>Cookie</code>的<code>MaxAge</code>或<code>Expires</code>字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把<code>Cookie</code>的有效时间和<code>Session</code>有效期设置得比较长，下次再访问页面时仍然携带之前的<code>Cookie</code>，就可以直接保持登录状态。</p>\n<h2 id=\"常见误区\"><a href=\"#常见误区\" class=\"headerlink\" title=\"常见误区\"></a>常见误区</h2><p>在谈论<code>Session</code>机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，<code>Session</code>就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对<code>Session</code>来说，也是一样，除非程序通知服务器删除一个<code>Session</code>，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除<code>Session</code>。</p>\n<p>但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话<code>Cookie</code>来保存<code>Session ID</code>信息，而关闭浏览器后<code>Cookies</code>就消失了，再次连接服务器时，也就无法找到原来的<code>Session</code>了。如果服务器设置的<code>Cookies</code>保存到硬盘上，或者使用某种手段改写浏览器发出的<code>HTTP</code>请求头，把原来的<code>Cookies</code>发送给服务器，则再次打开浏览器，仍然能够找到原来的<code>Session ID</code>，依旧还是可以保持登录状态的。</p>\n<p>而且恰恰是由于关闭浏览器不会导致<code>Session</code>被删除，这就需要服务器为<code>Session</code>设置一个失效时间，当距离客户端上一次使用<code>Session</code>的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把<code>Session</code>删除以节省存储空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"静态网页和动态网页\"><a href=\"#静态网页和动态网页\" class=\"headerlink\" title=\"静态网页和动态网页\"></a>静态网页和动态网页</h2><p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;title&quot;</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>Hello, this is a paragraph.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是最基本的HTML代码，保存为一个<code>.html</code>文件，然后把它放在某台具有固定公网<code>IP</code>的主机上，主机上装上<code>Apache</code>或<code>Nginx</code>等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。</p>\n<p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据<code>URL</code>灵活多变地显示内容等。例如，想要给这个网页的<code>URL</code>传入一个<code>name</code>参数，让其在网页中显示出来，是无法做到的。</p>\n<p>因此，动态网页应运而生，它可以动态解析<code>URL</code>中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的<code>HTML</code>，而是可能由<code>JSP</code>、<code>PHP</code>、<code>Python</code>等语言编写的，其功能比静态网页强大和丰富太多了。</p>\n<p>此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。</p>\n<p>那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。</p>\n<h2 id=\"无状态HTTP\"><a href=\"#无状态HTTP\" class=\"headerlink\" title=\"无状态HTTP\"></a>无状态HTTP</h2><p>在了解<code>Session</code>和<code>Cookies</code>之前，还需要了解<code>HTTP</code>的一个特点，叫作无状态。</p>\n<p><code>HTTP</code>的无状态是指<code>HTTP</code>协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。</p>\n<p>当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p>\n<p>这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。</p>\n<p>这时两个用于保持<code>HTTP</code>连接状态的技术就出现了，它们分别是<code>Session</code>和<code>Cookies</code>。<code>Session</code>在服务端，也就是网站的服务器，用来保存用户的<code>Session信息</code>；<code>Cookies</code>在客户端，也可以理解为<strong>浏览器端</strong>，有了<code>Cookies</code>，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别<code>Cookies</code>并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。</p>\n<p>可以理解为<code>Cookies</code>里面保存了登录的凭证，有了它，只需要在下次请求携带<code>Cookies</code>发送请求而不必重新输入用户名、密码等信息重新登录了。</p>\n<p>因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的<code>Cookies</code>放在请求头里面直接请求，而不必重新模拟登录。</p>\n<h2 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h2><p><code>Cookies</code>指某些网站为了辨别用户身份、进行<code>Session</code>跟踪而存储在用户本地终端上的数据。</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p><code>Session</code>，中文称之为<strong>会话</strong>，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 <code>Session</code>。</p>\n<p>而在<code>Web</code>中，<code>Session对象</code>用来存储特定用户<code>Session</code>所需的属性及配置信息。这样，当用户在应用程序的<code>Web</code>页之间跳转时，存储在<code>Session</code>对象中的变量将不会丢失，而是在整个用户<code>Session</code>中一直存在下去。当用户请求来自应用程序的<code>Web</code>页时，如果该用户还没有<code>Session</code>，则<code>Web</code>服务器将自动创建一个 <code>Session</code>对象。当<code>Session</code>过期或被放弃后，服务器将终止该<code>Session</code>。</p>\n<h2 id=\"Session维持\"><a href=\"#Session维持\" class=\"headerlink\" title=\"Session维持\"></a>Session维持</h2><p>那么，怎样利用<code>Cookies</code>保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有<code>Set-Cookie</code>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把<code>Cookies</code>保存起来。当浏览器下一次再请求该网站时，浏览器会把此<code>Cookies</code>放到请求头一起提交给服务器，<code>Cookies</code>携带了<code>SessionID</code> 信息，服务器检查该<code>Cookies</code>即可找到对应的<code>Session</code>是什么，然后再判断<code>Session</code>来以此来辨认用户状态。</p>\n<p>在成功登录某个网站时，服务器会告诉客户端设置哪些<code>Cookies</code>信息，在后续访问页面时客户端会把<code>Cookies</code>发送给服务器，服务器再找到对应的<code>Session</code>加以判断。如果<code>Session</code>中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p>\n<p>反之，如果传给服务器的<code>Cookies</code>是无效的，或者<code>Session</code>已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，<code>Cookies</code>和<code>Session</code>需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录<code>Session</code>控制。</p>\n<h2 id=\"Cookies属性结构\"><a href=\"#Cookies属性结构\" class=\"headerlink\" title=\"Cookies属性结构\"></a>Cookies属性结构</h2><p><code>Cookie</code>有如下几个属性。</p>\n<ul>\n<li><code>Name</code>，即该<code>Cookie</code>的名称。</li>\n<li><code>Cookie</code>一旦创建，名称便不可更改。</li>\n<li><code>Value</code>，即该<code>Cookie</code>的值。如果值为<code>Unicode</code>字符，需要为字符编码。如果值为二进制数据，则需要使用<code>BASE64</code>编码。</li>\n<li><code>MaxAge</code>，即该<code>Cookie</code>失效的时间，单位秒，也常和<code>Expires</code>一起使用，通过它可以计算出其有效时间。</li>\n<li><code>MaxAge</code> 如果为正数，则该<code>Cookie</code>在<code>MaxAge</code>秒之后失效。如果为负数，则关闭浏览器时<code>Cookie</code>即失效，浏览器也不会以任何形式保存该<code>Cookie</code>。</li>\n<li><code>Path</code>，即该<code>Cookie</code>的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该<code>Cookie</code>。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该<code>Cookie</code>。</li>\n<li><code>Domain</code>，即可以访问该<code>Cookie</code>的域名。例如如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>，结尾的域名都可以访问该<code>Cookie</code>。</li>\n<li><code>Size</code>字段，即此<code>Cookie</code>的大小。</li>\n<li><code>Http</code>字段，即<code>Cookie</code>的<code>httponly</code>属性。若此属性为<code>true</code>，则只有在<code>HTTP Headers</code>中会带有此<code>Cookie</code>的信息，而不能通过<code>document.cookie</code>来访问此<code>Cookie</code>。</li>\n<li><code>Secure</code>，即该<code>Cookie</code>是否仅被使用安全协议传输。安全协议。安全协议有<code>HTTPS、SSL</code>等，在网络上传输数据之前先将数据加密。默认为<code>false</code>。</li>\n</ul>\n<h2 id=\"会话会Cookie和持久和Cookie\"><a href=\"#会话会Cookie和持久和Cookie\" class=\"headerlink\" title=\"会话会Cookie和持久和Cookie\"></a>会话会<code>Cookie</code>和持久和<code>Cookie</code></h2><p>从表面意思来说，会话<code>Cookie</code>就是把<code>Cookie</code>放在浏览器内存里，浏览器在关闭之后该<code>Cookie</code>即失效；持久<code>Cookie</code>则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p>\n<p>严格来说，没有会话<code>Cookie</code>和持久<code>Cookie</code>之分，只是由<code>Cookie</code>的<code>MaxAge</code>或<code>Expires</code>字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把<code>Cookie</code>的有效时间和<code>Session</code>有效期设置得比较长，下次再访问页面时仍然携带之前的<code>Cookie</code>，就可以直接保持登录状态。</p>\n<h2 id=\"常见误区\"><a href=\"#常见误区\" class=\"headerlink\" title=\"常见误区\"></a>常见误区</h2><p>在谈论<code>Session</code>机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，<code>Session</code>就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对<code>Session</code>来说，也是一样，除非程序通知服务器删除一个<code>Session</code>，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除<code>Session</code>。</p>\n<p>但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话<code>Cookie</code>来保存<code>Session ID</code>信息，而关闭浏览器后<code>Cookies</code>就消失了，再次连接服务器时，也就无法找到原来的<code>Session</code>了。如果服务器设置的<code>Cookies</code>保存到硬盘上，或者使用某种手段改写浏览器发出的<code>HTTP</code>请求头，把原来的<code>Cookies</code>发送给服务器，则再次打开浏览器，仍然能够找到原来的<code>Session ID</code>，依旧还是可以保持登录状态的。</p>\n<p>而且恰恰是由于关闭浏览器不会导致<code>Session</code>被删除，这就需要服务器为<code>Session</code>设置一个失效时间，当距离客户端上一次使用<code>Session</code>的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把<code>Session</code>删除以节省存储空间。</p>\n"},{"title":"Git常用命令","date":"2021-05-08T10:03:19.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n# Git常用命令\n\n## 仓库\n\n在当前目录新建一个Git代码库\n\n```shell\ngit init\n```\n\n新建一个目录，将其初始化为Git代码库\n\n```shell\ngit init [project-name]\n```\n\n下载一个项目和它的整个代码历史\n\n```shell\ngit clone [url]\n```\n\n## 配置\n\n显示当前的Git配置\n\n```shell\ngit config --list\n```\n\n编辑Git配置文件\n\n```shell\ngit config -e [--global]\n```\n\n设置提交代码时的用户信息\n\n```shell\ngit config [--global] user.name \"[name]\"\ngit config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n\n添加指定文件到暂存区\n\n```shell\ngit add [file1] [file2] ...\n```\n\n添加指定目录到暂存区，包括子目录\n\n```shell\ngit add [dir]\n```\n\n添加当前目录的所有文件到暂存区\n\n```shell\ngit add .\n```\n\n## 添加每个变化前，都会要求确认\n\n对于同一个文件的多处变化，可以实现分次提交\n\n```shell\ngit add -p\n````\n\n删除工作区文件，并且将这次删除放入暂存区\n\n```shell\ngit rm [file1] [file2] ...\n```\n\n停止追踪指定文件，但该文件会保留在工作区\n\n```shell\ngit rm --cached [file]\n```\n\n改名文件，并且将这个改名放入暂存区\n\n```shell\ngit mv [file-original] [file-renamed]\n```\n\n## 代码提交\n\n提交暂存区到仓库区\n\n```shell\ngit commit -m [message]\n```\n\n提交暂存区的指定文件到仓库区\n\n```shell\ngit commit [file1] [file2] ... -m [message]\n```\n\n提交工作区自上次commit之后的变化，直接到仓库区\n\n```shell\ngit commit -a\n```\n\n提交时显示所有diff信息\n\n```shell\ngit commit -v\n```\n\n使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息\n\n```shell\ngit commit --amend -m [message]\n```\n\n重做上一次commit，并包括指定文件的新变化\n\n```shell\ngit commit --amend [file1] [file2] ...\n```\n\n## 分支\n\n列出所有本地分支\n\n```shell\ngit branch\n```\n\n列出所有远程分支\n\n```shell\ngit branch -r\n```\n\n列出所有本地分支和远程分支\n\n```shell\ngit branch -a\n```\n\n新建一个分支，但依然停留在当前分支\n\n```shell\ngit branch [branch-name]\n```\n\n新建一个分支，并切换到该分支\n\n```shell\ngit checkout -b [branch]\n```\n\n新建一个分支，指向指定commit\n\n```shell\ngit branch [branch] [commit]\n```\n\n新建一个分支，与指定的远程分支建立追踪关系\n\n```shell\ngit branch --track [branch] [remote-branch]\n```\n\n切换到指定分支，并更新工作区\n\n```shell\ngit checkout [branch-name]\n```\n\n切换到上一个分支\n\n```shell\ngit checkout -\n```\n\n建立追踪关系，在现有分支与指定的远程分支之间\n\n```shell\ngit branch --set-upstream [branch] [remote-branch]\n```\n\n合并指定分支到当前分支\n\n```shell\ngit merge [branch]\n```\n\n选择一个commit，合并进当前分支\n\n```shell\ngit cherry-pick [commit]\n```\n\n删除分支\n\n```shell\ngit branch -d [branch-name]\n```\n\n删除远程分支\n\n```shell\ngit push origin --delete [branch-name]\ngit branch -dr [remote/branch]\n```\n\n## 标签\n\n列出所有tag\n\n```shell\ngit tag\n```\n\n新建一个tag在当前commit\n\n```shell\ngit tag [tag]\n```\n\n新建一个tag在指定commit\n\n```shell\ngit tag [tag] [commit]\n```\n\n删除本地tag\n\n```shell\ngit tag -d [tag]\n```\n\n删除远程tag\n\n```shell\ngit push origin :refs/tags/[tagName]\n```\n\n查看tag信息\n\n```shell\ngit show [tag]\n```\n\n提交指定tag\n\n```shell\ngit push [remote] [tag]\n```\n\n提交所有tag\n\n```shell\ngit push [remote] --tags\n```\n\n新建一个分支，指向某个tag\n\n```shell\ngit checkout -b [branch] [tag]\n```\n\n## 查看信息\n\n显示有变更的文件\n\n```shell\ngit status\n```\n\n显示当前分支的版本历史\n\n```shell\ngit log\n```\n\n显示commit历史，以及每次commit发生变更的文件\n\n```shell\ngit log --stat\n```\n\n搜索提交历史，根据关键词\n\n```shell\ngit log -S [keyword]\n```\n\n显示某个commit之后的所有变动，每个commit占据一行\n\n```shell\ngit log [tag] HEAD --pretty=format:%s\n```\n\n显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n```shell\ngit log [tag] HEAD --grep feature\n```\n\n显示某个文件的版本历史，包括文件改名\n\n```shell\ngit log --follow [file]\ngit whatchanged [file]\n```\n\n显示指定文件相关的每一次diff\n\n```shell\ngit log -p [file]\n```\n\n显示过去5次提交\n\n```shell\ngit log -5 --pretty --oneline\n```\n\n显示所有提交过的用户，按提交次数排序\n\n```shell\ngit shortlog -sn\n```\n\n显示指定文件是什么人在什么时间修改过\n\n```shell\ngit blame [file]\n```\n\n显示暂存区和工作区的差异\n\n```shell\ngit diff\n```\n\n显示暂存区和上一个commit的差异\n\n```shell\ngit diff --cached [file]\n```\n\n显示工作区与当前分支最新commit之间的差异\n\n```shell\ngit diff HEAD\n```\n\n显示两次提交之间的差异\n\n```shell\ngit diff [first-branch]...[second-branch]\n```\n\n显示今天你写了多少行代码\n\n```shell\ngit diff --shortstat \"@{0 day ago}\"\n```\n\n显示某次提交的元数据和内容变化\n\n```shell\ngit show [commit]\n```\n\n显示某次提交发生变化的文件\n\n```shell\ngit show --name-only [commit]\n```\n\n显示某次提交时，某个文件的内容\n\n```shell\ngit show [commit]:[filename]\n```\n\n显示当前分支的最近几次提交\n\n```shell\ngit reflog\n```\n\n## 远程同步\n\n下载远程仓库的所有变动\n\n```shell\ngit fetch [remote]\n```\n\n显示所有远程仓库\n\n```shell\ngit remote -v\n```\n\n显示某个远程仓库的信息\n\n```shell\ngit remote show [remote]\n```\n\n增加一个新的远程仓库，并命名\n\n```shell\ngit remote add [shortname] [url]\n```\n\n取回远程仓库的变化，并与本地分支合并\n\n```shell\ngit pull [remote] [branch]\n```\n\n上传本地指定分支到远程仓库\n\n```shell\ngit push [remote] [branch]\n```\n\n强行推送当前分支到远程仓库，即使有冲突\n\n```shell\ngit push [remote] --force\n```\n\n推送所有分支到远程仓库\n\n```shell\ngit push [remote] --all\n```\n\n## 撤销\n\n恢复暂存区的指定文件到工作区\n\n```shell\ngit checkout [file]\n```\n\n恢复某个commit的指定文件到暂存区和工作区\n\n```shell\ngit checkout [commit] [file]\n```\n\n恢复暂存区的所有文件到工作区\n\n```shell\ngit checkout .\n```\n\n重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n```shell\ngit reset [file]\n```\n\n重置暂存区与工作区，与上一次commit保持一致\n\n```shell\ngit reset --hard\n```\n\n重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n\n```shell\ngit reset [commit]\n```\n\n重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n\n```shell\ngit reset --hard [commit]\n```\n\n重置当前HEAD为指定commit，但保持暂存区和工作区不变\n\n```shell\ngit reset --keep [commit]\n```\n\n新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支\n\n```shell\ngit revert [commit]\n```\n\n暂时将未提交的变化移除，稍后再移入\n\n```shell\ngit stash\ngit stash pop\n```\n\n## 其他\n\n生成一个可供发布的压缩包\n\n```shell\ngit archive\n```\n","source":"_posts/git常用命令.md","raw":"---\ntitle: Git常用命令\ndate: 2021-05-08 18:03:19\ncategories: Git\ntags:\n- Git\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n# Git常用命令\n\n## 仓库\n\n在当前目录新建一个Git代码库\n\n```shell\ngit init\n```\n\n新建一个目录，将其初始化为Git代码库\n\n```shell\ngit init [project-name]\n```\n\n下载一个项目和它的整个代码历史\n\n```shell\ngit clone [url]\n```\n\n## 配置\n\n显示当前的Git配置\n\n```shell\ngit config --list\n```\n\n编辑Git配置文件\n\n```shell\ngit config -e [--global]\n```\n\n设置提交代码时的用户信息\n\n```shell\ngit config [--global] user.name \"[name]\"\ngit config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n\n添加指定文件到暂存区\n\n```shell\ngit add [file1] [file2] ...\n```\n\n添加指定目录到暂存区，包括子目录\n\n```shell\ngit add [dir]\n```\n\n添加当前目录的所有文件到暂存区\n\n```shell\ngit add .\n```\n\n## 添加每个变化前，都会要求确认\n\n对于同一个文件的多处变化，可以实现分次提交\n\n```shell\ngit add -p\n````\n\n删除工作区文件，并且将这次删除放入暂存区\n\n```shell\ngit rm [file1] [file2] ...\n```\n\n停止追踪指定文件，但该文件会保留在工作区\n\n```shell\ngit rm --cached [file]\n```\n\n改名文件，并且将这个改名放入暂存区\n\n```shell\ngit mv [file-original] [file-renamed]\n```\n\n## 代码提交\n\n提交暂存区到仓库区\n\n```shell\ngit commit -m [message]\n```\n\n提交暂存区的指定文件到仓库区\n\n```shell\ngit commit [file1] [file2] ... -m [message]\n```\n\n提交工作区自上次commit之后的变化，直接到仓库区\n\n```shell\ngit commit -a\n```\n\n提交时显示所有diff信息\n\n```shell\ngit commit -v\n```\n\n使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息\n\n```shell\ngit commit --amend -m [message]\n```\n\n重做上一次commit，并包括指定文件的新变化\n\n```shell\ngit commit --amend [file1] [file2] ...\n```\n\n## 分支\n\n列出所有本地分支\n\n```shell\ngit branch\n```\n\n列出所有远程分支\n\n```shell\ngit branch -r\n```\n\n列出所有本地分支和远程分支\n\n```shell\ngit branch -a\n```\n\n新建一个分支，但依然停留在当前分支\n\n```shell\ngit branch [branch-name]\n```\n\n新建一个分支，并切换到该分支\n\n```shell\ngit checkout -b [branch]\n```\n\n新建一个分支，指向指定commit\n\n```shell\ngit branch [branch] [commit]\n```\n\n新建一个分支，与指定的远程分支建立追踪关系\n\n```shell\ngit branch --track [branch] [remote-branch]\n```\n\n切换到指定分支，并更新工作区\n\n```shell\ngit checkout [branch-name]\n```\n\n切换到上一个分支\n\n```shell\ngit checkout -\n```\n\n建立追踪关系，在现有分支与指定的远程分支之间\n\n```shell\ngit branch --set-upstream [branch] [remote-branch]\n```\n\n合并指定分支到当前分支\n\n```shell\ngit merge [branch]\n```\n\n选择一个commit，合并进当前分支\n\n```shell\ngit cherry-pick [commit]\n```\n\n删除分支\n\n```shell\ngit branch -d [branch-name]\n```\n\n删除远程分支\n\n```shell\ngit push origin --delete [branch-name]\ngit branch -dr [remote/branch]\n```\n\n## 标签\n\n列出所有tag\n\n```shell\ngit tag\n```\n\n新建一个tag在当前commit\n\n```shell\ngit tag [tag]\n```\n\n新建一个tag在指定commit\n\n```shell\ngit tag [tag] [commit]\n```\n\n删除本地tag\n\n```shell\ngit tag -d [tag]\n```\n\n删除远程tag\n\n```shell\ngit push origin :refs/tags/[tagName]\n```\n\n查看tag信息\n\n```shell\ngit show [tag]\n```\n\n提交指定tag\n\n```shell\ngit push [remote] [tag]\n```\n\n提交所有tag\n\n```shell\ngit push [remote] --tags\n```\n\n新建一个分支，指向某个tag\n\n```shell\ngit checkout -b [branch] [tag]\n```\n\n## 查看信息\n\n显示有变更的文件\n\n```shell\ngit status\n```\n\n显示当前分支的版本历史\n\n```shell\ngit log\n```\n\n显示commit历史，以及每次commit发生变更的文件\n\n```shell\ngit log --stat\n```\n\n搜索提交历史，根据关键词\n\n```shell\ngit log -S [keyword]\n```\n\n显示某个commit之后的所有变动，每个commit占据一行\n\n```shell\ngit log [tag] HEAD --pretty=format:%s\n```\n\n显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n```shell\ngit log [tag] HEAD --grep feature\n```\n\n显示某个文件的版本历史，包括文件改名\n\n```shell\ngit log --follow [file]\ngit whatchanged [file]\n```\n\n显示指定文件相关的每一次diff\n\n```shell\ngit log -p [file]\n```\n\n显示过去5次提交\n\n```shell\ngit log -5 --pretty --oneline\n```\n\n显示所有提交过的用户，按提交次数排序\n\n```shell\ngit shortlog -sn\n```\n\n显示指定文件是什么人在什么时间修改过\n\n```shell\ngit blame [file]\n```\n\n显示暂存区和工作区的差异\n\n```shell\ngit diff\n```\n\n显示暂存区和上一个commit的差异\n\n```shell\ngit diff --cached [file]\n```\n\n显示工作区与当前分支最新commit之间的差异\n\n```shell\ngit diff HEAD\n```\n\n显示两次提交之间的差异\n\n```shell\ngit diff [first-branch]...[second-branch]\n```\n\n显示今天你写了多少行代码\n\n```shell\ngit diff --shortstat \"@{0 day ago}\"\n```\n\n显示某次提交的元数据和内容变化\n\n```shell\ngit show [commit]\n```\n\n显示某次提交发生变化的文件\n\n```shell\ngit show --name-only [commit]\n```\n\n显示某次提交时，某个文件的内容\n\n```shell\ngit show [commit]:[filename]\n```\n\n显示当前分支的最近几次提交\n\n```shell\ngit reflog\n```\n\n## 远程同步\n\n下载远程仓库的所有变动\n\n```shell\ngit fetch [remote]\n```\n\n显示所有远程仓库\n\n```shell\ngit remote -v\n```\n\n显示某个远程仓库的信息\n\n```shell\ngit remote show [remote]\n```\n\n增加一个新的远程仓库，并命名\n\n```shell\ngit remote add [shortname] [url]\n```\n\n取回远程仓库的变化，并与本地分支合并\n\n```shell\ngit pull [remote] [branch]\n```\n\n上传本地指定分支到远程仓库\n\n```shell\ngit push [remote] [branch]\n```\n\n强行推送当前分支到远程仓库，即使有冲突\n\n```shell\ngit push [remote] --force\n```\n\n推送所有分支到远程仓库\n\n```shell\ngit push [remote] --all\n```\n\n## 撤销\n\n恢复暂存区的指定文件到工作区\n\n```shell\ngit checkout [file]\n```\n\n恢复某个commit的指定文件到暂存区和工作区\n\n```shell\ngit checkout [commit] [file]\n```\n\n恢复暂存区的所有文件到工作区\n\n```shell\ngit checkout .\n```\n\n重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n```shell\ngit reset [file]\n```\n\n重置暂存区与工作区，与上一次commit保持一致\n\n```shell\ngit reset --hard\n```\n\n重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n\n```shell\ngit reset [commit]\n```\n\n重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n\n```shell\ngit reset --hard [commit]\n```\n\n重置当前HEAD为指定commit，但保持暂存区和工作区不变\n\n```shell\ngit reset --keep [commit]\n```\n\n新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支\n\n```shell\ngit revert [commit]\n```\n\n暂时将未提交的变化移除，稍后再移入\n\n```shell\ngit stash\ngit stash pop\n```\n\n## 其他\n\n生成一个可供发布的压缩包\n\n```shell\ngit archive\n```\n","slug":"git常用命令","published":1,"updated":"2021-05-09T14:34:44.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfpd0006ywxuhwv30zh2","content":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>在当前目录新建一个Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>新建一个目录，将其初始化为Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init [project-name]</span><br></pre></td></tr></table></figure>\n\n<p>下载一个项目和它的整个代码历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone [url]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>显示当前的Git配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --list</span><br></pre></td></tr></table></figure>\n\n<p>编辑Git配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -e [--global]</span><br></pre></td></tr></table></figure>\n\n<p>设置提交代码时的用户信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h2><p>添加指定文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>添加指定目录到暂存区，包括子目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [dir]</span><br></pre></td></tr></table></figure>\n\n<p>添加当前目录的所有文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加每个变化前，都会要求确认\"><a href=\"#添加每个变化前，都会要求确认\" class=\"headerlink\" title=\"添加每个变化前，都会要求确认\"></a>添加每个变化前，都会要求确认</h2><p>对于同一个文件的多处变化，可以实现分次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -p</span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\">删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\"></span><br><span class=\"line\">```shell</span><br><span class=\"line\">git rm [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>停止追踪指定文件，但该文件会保留在工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>改名文件，并且将这个改名放入暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h2><p>提交暂存区到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交暂存区的指定文件到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交工作区自上次commit之后的变化，直接到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -a</span><br></pre></td></tr></table></figure>\n\n<p>提交时显示所有diff信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -v</span><br></pre></td></tr></table></figure>\n\n<p>使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>重做上一次commit，并包括指定文件的新变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>列出所有本地分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<p>列出所有远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n\n<p>列出所有本地分支和远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，但依然停留在当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，并切换到该分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，与指定的远程分支建立追踪关系</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>切换到指定分支，并更新工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>切换到上一个分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n\n<p>建立追踪关系，在现有分支与指定的远程分支之间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>合并指定分支到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge [branch]</span><br></pre></td></tr></table></figure>\n\n<p>选择一个commit，合并进当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete [branch-name]</span><br><span class=\"line\">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>列出所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在当前commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除本地tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d [tag]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure>\n\n<p>查看tag信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交指定tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --tags</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向某个tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h2><p>显示有变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的版本历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br></pre></td></tr></table></figure>\n\n<p>显示commit历史，以及每次commit发生变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --stat</span><br></pre></td></tr></table></figure>\n\n<p>搜索提交历史，根据关键词</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -S [keyword]</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，每个commit占据一行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure>\n\n<p>显示某个文件的版本历史，包括文件改名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --follow [file]</span><br><span class=\"line\">git whatchanged [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件相关的每一次diff</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -p [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示过去5次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -5 --pretty --oneline</span><br></pre></td></tr></table></figure>\n\n<p>显示所有提交过的用户，按提交次数排序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git shortlog -sn</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件是什么人在什么时间修改过</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git blame [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和工作区的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和上一个commit的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示工作区与当前分支最新commit之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff HEAD</span><br></pre></td></tr></table></figure>\n\n<p>显示两次提交之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>\n\n<p>显示今天你写了多少行代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交的元数据和内容变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交发生变化的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show --name-only [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交时，某个文件的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的最近几次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h2><p>下载远程仓库的所有变动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch [remote]</span><br></pre></td></tr></table></figure>\n\n<p>显示所有远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<p>显示某个远程仓库的信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show [remote]</span><br></pre></td></tr></table></figure>\n\n<p>增加一个新的远程仓库，并命名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>\n\n<p>取回远程仓库的变化，并与本地分支合并</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>上传本地指定分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>强行推送当前分支到远程仓库，即使有冲突</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --force</span><br></pre></td></tr></table></figure>\n\n<p>推送所有分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>恢复暂存区的指定文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复某个commit的指定文件到暂存区和工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [commit] [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复暂存区的所有文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [file]</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区与工作区，与上一次commit保持一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --keep [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert [commit]</span><br></pre></td></tr></table></figure>\n\n<p>暂时将未提交的变化移除，稍后再移入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>生成一个可供发布的压缩包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git archive</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>在当前目录新建一个Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>新建一个目录，将其初始化为Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init [project-name]</span><br></pre></td></tr></table></figure>\n\n<p>下载一个项目和它的整个代码历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone [url]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>显示当前的Git配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --list</span><br></pre></td></tr></table></figure>\n\n<p>编辑Git配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -e [--global]</span><br></pre></td></tr></table></figure>\n\n<p>设置提交代码时的用户信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h2><p>添加指定文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>添加指定目录到暂存区，包括子目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [dir]</span><br></pre></td></tr></table></figure>\n\n<p>添加当前目录的所有文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加每个变化前，都会要求确认\"><a href=\"#添加每个变化前，都会要求确认\" class=\"headerlink\" title=\"添加每个变化前，都会要求确认\"></a>添加每个变化前，都会要求确认</h2><p>对于同一个文件的多处变化，可以实现分次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -p</span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\">删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\"></span><br><span class=\"line\">```shell</span><br><span class=\"line\">git rm [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>停止追踪指定文件，但该文件会保留在工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>改名文件，并且将这个改名放入暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h2><p>提交暂存区到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交暂存区的指定文件到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交工作区自上次commit之后的变化，直接到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -a</span><br></pre></td></tr></table></figure>\n\n<p>提交时显示所有diff信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -v</span><br></pre></td></tr></table></figure>\n\n<p>使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>重做上一次commit，并包括指定文件的新变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>列出所有本地分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<p>列出所有远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n\n<p>列出所有本地分支和远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，但依然停留在当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，并切换到该分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，与指定的远程分支建立追踪关系</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>切换到指定分支，并更新工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>切换到上一个分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n\n<p>建立追踪关系，在现有分支与指定的远程分支之间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>合并指定分支到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge [branch]</span><br></pre></td></tr></table></figure>\n\n<p>选择一个commit，合并进当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete [branch-name]</span><br><span class=\"line\">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>列出所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在当前commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除本地tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d [tag]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure>\n\n<p>查看tag信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交指定tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --tags</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向某个tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h2><p>显示有变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的版本历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br></pre></td></tr></table></figure>\n\n<p>显示commit历史，以及每次commit发生变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --stat</span><br></pre></td></tr></table></figure>\n\n<p>搜索提交历史，根据关键词</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -S [keyword]</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，每个commit占据一行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure>\n\n<p>显示某个文件的版本历史，包括文件改名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --follow [file]</span><br><span class=\"line\">git whatchanged [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件相关的每一次diff</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -p [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示过去5次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -5 --pretty --oneline</span><br></pre></td></tr></table></figure>\n\n<p>显示所有提交过的用户，按提交次数排序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git shortlog -sn</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件是什么人在什么时间修改过</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git blame [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和工作区的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和上一个commit的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示工作区与当前分支最新commit之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff HEAD</span><br></pre></td></tr></table></figure>\n\n<p>显示两次提交之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>\n\n<p>显示今天你写了多少行代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交的元数据和内容变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交发生变化的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show --name-only [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交时，某个文件的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的最近几次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h2><p>下载远程仓库的所有变动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch [remote]</span><br></pre></td></tr></table></figure>\n\n<p>显示所有远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<p>显示某个远程仓库的信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show [remote]</span><br></pre></td></tr></table></figure>\n\n<p>增加一个新的远程仓库，并命名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>\n\n<p>取回远程仓库的变化，并与本地分支合并</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>上传本地指定分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>强行推送当前分支到远程仓库，即使有冲突</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --force</span><br></pre></td></tr></table></figure>\n\n<p>推送所有分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>恢复暂存区的指定文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复某个commit的指定文件到暂存区和工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [commit] [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复暂存区的所有文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [file]</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区与工作区，与上一次commit保持一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --keep [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert [commit]</span><br></pre></td></tr></table></figure>\n\n<p>暂时将未提交的变化移除，稍后再移入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>生成一个可供发布的压缩包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git archive</span><br></pre></td></tr></table></figure>\n"},{"title":"python多线程基本原理","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-12T19:42:12.000Z","pic":null,"_content":"\n\n## 多线程的含义\n\n说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。\n\n进程我们可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，我们可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。\n\n而进程呢？它就是**线程的集合**，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播 放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。\n\n了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。\n\n`并发和并行`\n\n并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。我们知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。\n\n并发，英文叫作`concurrency`。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程`A`的指令一段时间，再执行线程`B`的指令一段时间，再切回到线程`A`执行一段时间。\n\n由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。\n\n并行，英文叫作`parallel`。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。\n\n并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。\n\n举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。\n\n## 多线程适用场景\n\n多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。\n\n像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于`IO`密集型任务。对于这种任务，如果我们启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。\n\n但并不是所有的任务都是`IO`密集型任务，还有一种任务叫作计算密集型任务，也可以称之为`CPU`密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果我们开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。\n\n所以，如果任务不全是计算密集型任务，我们可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种 IO 密集型任务来说，使用多线程会大大提高程序整体的爬取效率。\n\n## Python实现多线程\n\n实在`Python`中，实现多线程的模块叫作`threading`，是`Python`自带的模块。使用`threading`实现多线程的方法。\n\n### Thread直接创建子线程\n\n首先，我们可以使用`Thread`类来创建一个线程，创建时需要指定`target`参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过`Thread`的`args`参数来指定。示例如下：\n\n","source":"_posts/python多线程基本原理.md","raw":"---\ntitle: python多线程基本原理\ntags:\n  - python\n  - 多线程\n  - threading\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-13 03:42:12\ncategories: Python\npic:\n---\n\n\n## 多线程的含义\n\n说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。\n\n进程我们可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，我们可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。\n\n而进程呢？它就是**线程的集合**，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播 放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。\n\n了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。\n\n`并发和并行`\n\n并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。我们知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。\n\n并发，英文叫作`concurrency`。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程`A`的指令一段时间，再执行线程`B`的指令一段时间，再切回到线程`A`执行一段时间。\n\n由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。\n\n并行，英文叫作`parallel`。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。\n\n并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。\n\n举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。\n\n## 多线程适用场景\n\n多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。\n\n像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于`IO`密集型任务。对于这种任务，如果我们启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。\n\n但并不是所有的任务都是`IO`密集型任务，还有一种任务叫作计算密集型任务，也可以称之为`CPU`密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果我们开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。\n\n所以，如果任务不全是计算密集型任务，我们可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种 IO 密集型任务来说，使用多线程会大大提高程序整体的爬取效率。\n\n## Python实现多线程\n\n实在`Python`中，实现多线程的模块叫作`threading`，是`Python`自带的模块。使用`threading`实现多线程的方法。\n\n### Thread直接创建子线程\n\n首先，我们可以使用`Thread`类来创建一个线程，创建时需要指定`target`参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过`Thread`的`args`参数来指定。示例如下：\n\n","slug":"python多线程基本原理","published":1,"updated":"2021-05-12T19:42:10.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfps000nywxuaq36hz2v","content":"<h2 id=\"多线程的含义\"><a href=\"#多线程的含义\" class=\"headerlink\" title=\"多线程的含义\"></a>多线程的含义</h2><p>说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。</p>\n<p>进程我们可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，我们可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。</p>\n<p>而进程呢？它就是<strong>线程的集合</strong>，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播 放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。</p>\n<p>了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。</p>\n<p><code>并发和并行</code></p>\n<p>并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。我们知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。</p>\n<p>并发，英文叫作<code>concurrency</code>。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程<code>A</code>的指令一段时间，再执行线程<code>B</code>的指令一段时间，再切回到线程<code>A</code>执行一段时间。</p>\n<p>由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。</p>\n<p>并行，英文叫作<code>parallel</code>。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。</p>\n<p>并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。</p>\n<p>举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p>\n<h2 id=\"多线程适用场景\"><a href=\"#多线程适用场景\" class=\"headerlink\" title=\"多线程适用场景\"></a>多线程适用场景</h2><p>多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。</p>\n<p>像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于<code>IO</code>密集型任务。对于这种任务，如果我们启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。</p>\n<p>但并不是所有的任务都是<code>IO</code>密集型任务，还有一种任务叫作计算密集型任务，也可以称之为<code>CPU</code>密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果我们开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p>\n<p>所以，如果任务不全是计算密集型任务，我们可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种 IO 密集型任务来说，使用多线程会大大提高程序整体的爬取效率。</p>\n<h2 id=\"Python实现多线程\"><a href=\"#Python实现多线程\" class=\"headerlink\" title=\"Python实现多线程\"></a>Python实现多线程</h2><p>实在<code>Python</code>中，实现多线程的模块叫作<code>threading</code>，是<code>Python</code>自带的模块。使用<code>threading</code>实现多线程的方法。</p>\n<h3 id=\"Thread直接创建子线程\"><a href=\"#Thread直接创建子线程\" class=\"headerlink\" title=\"Thread直接创建子线程\"></a>Thread直接创建子线程</h3><p>首先，我们可以使用<code>Thread</code>类来创建一个线程，创建时需要指定<code>target</code>参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过<code>Thread</code>的<code>args</code>参数来指定。示例如下：</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"多线程的含义\"><a href=\"#多线程的含义\" class=\"headerlink\" title=\"多线程的含义\"></a>多线程的含义</h2><p>说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。</p>\n<p>进程我们可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，我们可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。</p>\n<p>而进程呢？它就是<strong>线程的集合</strong>，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播 放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。</p>\n<p>了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。</p>\n<p><code>并发和并行</code></p>\n<p>并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。我们知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。</p>\n<p>并发，英文叫作<code>concurrency</code>。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程<code>A</code>的指令一段时间，再执行线程<code>B</code>的指令一段时间，再切回到线程<code>A</code>执行一段时间。</p>\n<p>由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。</p>\n<p>并行，英文叫作<code>parallel</code>。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。</p>\n<p>并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。</p>\n<p>举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p>\n<h2 id=\"多线程适用场景\"><a href=\"#多线程适用场景\" class=\"headerlink\" title=\"多线程适用场景\"></a>多线程适用场景</h2><p>多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。</p>\n<p>像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于<code>IO</code>密集型任务。对于这种任务，如果我们启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。</p>\n<p>但并不是所有的任务都是<code>IO</code>密集型任务，还有一种任务叫作计算密集型任务，也可以称之为<code>CPU</code>密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果我们开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p>\n<p>所以，如果任务不全是计算密集型任务，我们可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种 IO 密集型任务来说，使用多线程会大大提高程序整体的爬取效率。</p>\n<h2 id=\"Python实现多线程\"><a href=\"#Python实现多线程\" class=\"headerlink\" title=\"Python实现多线程\"></a>Python实现多线程</h2><p>实在<code>Python</code>中，实现多线程的模块叫作<code>threading</code>，是<code>Python</code>自带的模块。使用<code>threading</code>实现多线程的方法。</p>\n<h3 id=\"Thread直接创建子线程\"><a href=\"#Thread直接创建子线程\" class=\"headerlink\" title=\"Thread直接创建子线程\"></a>Thread直接创建子线程</h3><p>首先，我们可以使用<code>Thread</code>类来创建一个线程，创建时需要指定<code>target</code>参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过<code>Thread</code>的<code>args</code>参数来指定。示例如下：</p>\n"},{"title":"web网页基础","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-11T15:32:38.000Z","pic":null,"_content":"\n# 网页的组成\n\n首先，我们来了解网页的基本组成，网页可以分为三大部分：`HTML`、`CSS`和`JavaScript`。 如果把网页比作一个人的话，`HTML`相当于骨架，`JavaScript`相当于肌肉，`CSS`相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。\n\n## HTML\n\n`HTML`是用来描述网页的一种语言，其全称叫作`Hyper Text Markup Language`，即超文本标记语言。\n\n我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是`HTML`。不同类型的元素通过不同类型的标签来表示，如图片用`img`标签表示，视频用`video`标签表示，段落用`p`标签表示，它们之间的布局又常通过布局标签`div`嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 \n\n在`Chrome`浏览器中打开百度，右击并选择 “检查”项（或按`F12键`），打开开发者模式，这时在`Elements`选项卡中即可看到网页的源代码，如图所示。\n\n![HTML结构](Screenshot_1.png)\n\n这就是`HTML`，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。\n\n## CSS\n\n虽然`HTML`定义了网页的结构，但是只有`HTML`页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助`CSS`了。\n\n`CSS`，全称叫作`Cascading Style Sheets`，即`层叠样式表`。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。\n\n`CSS`是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：\n\n```css\n#head_wrapper.s-ps-islite .s-p-top { \n    position: absolute; \n    bottom: 40px; \n    width: 100%; \n    height: 181px; \n    }\n```\n\n这就是一个`CSS`样式。大括号前面是一个`CSS选择器`。此选择器的作用是首先选中`id`为`head_wrapper`且`class` 为`s-ps-islite`的节点，然后再选中其内部的`class`为`s-p-top`的节点。大括号内部写的就是一条条样式规则，例如`position`指定了这个元素的布局方式为**绝对布局**，`bottom`指定元素的下边距为**40像素**，`width`指定了宽度为**100%**占满父元素，`height`则指定了元素的**高度**。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上`CSS`选择器，这就代表这个样式对`CSS`选择器选中的元素生效，元素就会根据此样式来展示了。\n\n在网页中，一般会统一定义整个网页的样式规则，并写入`CSS`文件中（其后缀为css）。在HTML中，只需要用`link`标签即可引入写好的`CSS`文件，这样整个页面就会变得美观、优雅。\n\n## JavaScript \n\n`JavaScript`，简称`JS`，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是`JavaScript`的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种**实时、动态、交互**的页面功能。\n\n`JavaScript`通常也是以单独的文件形式加载的，后缀为`js`，在 HTML中通过`script标签`即可引入，例如:\n\n```html\n<script src=\"jquery-2.1.0.js\"></script>\n```\n\n综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，`JavaScript`定义了网页的行为。\n","source":"_posts/web网页基础.md","raw":"---\ntitle: web网页基础\ntags:\n  - html\n  - css\n  - javascript\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-11 23:32:38\ncategories: 爬虫\npic:\n---\n\n# 网页的组成\n\n首先，我们来了解网页的基本组成，网页可以分为三大部分：`HTML`、`CSS`和`JavaScript`。 如果把网页比作一个人的话，`HTML`相当于骨架，`JavaScript`相当于肌肉，`CSS`相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。\n\n## HTML\n\n`HTML`是用来描述网页的一种语言，其全称叫作`Hyper Text Markup Language`，即超文本标记语言。\n\n我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是`HTML`。不同类型的元素通过不同类型的标签来表示，如图片用`img`标签表示，视频用`video`标签表示，段落用`p`标签表示，它们之间的布局又常通过布局标签`div`嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 \n\n在`Chrome`浏览器中打开百度，右击并选择 “检查”项（或按`F12键`），打开开发者模式，这时在`Elements`选项卡中即可看到网页的源代码，如图所示。\n\n![HTML结构](Screenshot_1.png)\n\n这就是`HTML`，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。\n\n## CSS\n\n虽然`HTML`定义了网页的结构，但是只有`HTML`页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助`CSS`了。\n\n`CSS`，全称叫作`Cascading Style Sheets`，即`层叠样式表`。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。\n\n`CSS`是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：\n\n```css\n#head_wrapper.s-ps-islite .s-p-top { \n    position: absolute; \n    bottom: 40px; \n    width: 100%; \n    height: 181px; \n    }\n```\n\n这就是一个`CSS`样式。大括号前面是一个`CSS选择器`。此选择器的作用是首先选中`id`为`head_wrapper`且`class` 为`s-ps-islite`的节点，然后再选中其内部的`class`为`s-p-top`的节点。大括号内部写的就是一条条样式规则，例如`position`指定了这个元素的布局方式为**绝对布局**，`bottom`指定元素的下边距为**40像素**，`width`指定了宽度为**100%**占满父元素，`height`则指定了元素的**高度**。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上`CSS`选择器，这就代表这个样式对`CSS`选择器选中的元素生效，元素就会根据此样式来展示了。\n\n在网页中，一般会统一定义整个网页的样式规则，并写入`CSS`文件中（其后缀为css）。在HTML中，只需要用`link`标签即可引入写好的`CSS`文件，这样整个页面就会变得美观、优雅。\n\n## JavaScript \n\n`JavaScript`，简称`JS`，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是`JavaScript`的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种**实时、动态、交互**的页面功能。\n\n`JavaScript`通常也是以单独的文件形式加载的，后缀为`js`，在 HTML中通过`script标签`即可引入，例如:\n\n```html\n<script src=\"jquery-2.1.0.js\"></script>\n```\n\n综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，`JavaScript`定义了网页的行为。\n","slug":"web网页基础","published":1,"updated":"2021-05-12T02:51:50.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfpt000oywxu6hra69wz","content":"<h1 id=\"网页的组成\"><a href=\"#网页的组成\" class=\"headerlink\" title=\"网页的组成\"></a>网页的组成</h1><p>首先，我们来了解网页的基本组成，网页可以分为三大部分：<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>。 如果把网页比作一个人的话，<code>HTML</code>相当于骨架，<code>JavaScript</code>相当于肌肉，<code>CSS</code>相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p><code>HTML</code>是用来描述网页的一种语言，其全称叫作<code>Hyper Text Markup Language</code>，即超文本标记语言。</p>\n<p>我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是<code>HTML</code>。不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示，它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 </p>\n<p>在<code>Chrome</code>浏览器中打开百度，右击并选择 “检查”项（或按<code>F12键</code>），打开开发者模式，这时在<code>Elements</code>选项卡中即可看到网页的源代码，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"HTML结构\"></p>\n<p>这就是<code>HTML</code>，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>虽然<code>HTML</code>定义了网页的结构，但是只有<code>HTML</code>页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助<code>CSS</code>了。</p>\n<p><code>CSS</code>，全称叫作<code>Cascading Style Sheets</code>，即<code>层叠样式表</code>。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。</p>\n<p><code>CSS</code>是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#head_wrapper</span><span class=\"selector-class\">.s-ps-islite</span> <span class=\"selector-class\">.s-p-top</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">181px</span>; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个<code>CSS</code>样式。大括号前面是一个<code>CSS选择器</code>。此选择器的作用是首先选中<code>id</code>为<code>head_wrapper</code>且<code>class</code> 为<code>s-ps-islite</code>的节点，然后再选中其内部的<code>class</code>为<code>s-p-top</code>的节点。大括号内部写的就是一条条样式规则，例如<code>position</code>指定了这个元素的布局方式为<strong>绝对布局</strong>，<code>bottom</code>指定元素的下边距为<strong>40像素</strong>，<code>width</code>指定了宽度为<strong>100%<strong>占满父元素，<code>height</code>则指定了元素的</strong>高度</strong>。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上<code>CSS</code>选择器，这就代表这个样式对<code>CSS</code>选择器选中的元素生效，元素就会根据此样式来展示了。</p>\n<p>在网页中，一般会统一定义整个网页的样式规则，并写入<code>CSS</code>文件中（其后缀为css）。在HTML中，只需要用<code>link</code>标签即可引入写好的<code>CSS</code>文件，这样整个页面就会变得美观、优雅。</p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p><code>JavaScript</code>，简称<code>JS</code>，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是<code>JavaScript</code>的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种<strong>实时、动态、交互</strong>的页面功能。</p>\n<p><code>JavaScript</code>通常也是以单独的文件形式加载的，后缀为<code>js</code>，在 HTML中通过<code>script标签</code>即可引入，例如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;jquery-2.1.0.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，<code>JavaScript</code>定义了网页的行为。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网页的组成\"><a href=\"#网页的组成\" class=\"headerlink\" title=\"网页的组成\"></a>网页的组成</h1><p>首先，我们来了解网页的基本组成，网页可以分为三大部分：<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>。 如果把网页比作一个人的话，<code>HTML</code>相当于骨架，<code>JavaScript</code>相当于肌肉，<code>CSS</code>相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p><code>HTML</code>是用来描述网页的一种语言，其全称叫作<code>Hyper Text Markup Language</code>，即超文本标记语言。</p>\n<p>我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是<code>HTML</code>。不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示，它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 </p>\n<p>在<code>Chrome</code>浏览器中打开百度，右击并选择 “检查”项（或按<code>F12键</code>），打开开发者模式，这时在<code>Elements</code>选项卡中即可看到网页的源代码，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"HTML结构\"></p>\n<p>这就是<code>HTML</code>，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>虽然<code>HTML</code>定义了网页的结构，但是只有<code>HTML</code>页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助<code>CSS</code>了。</p>\n<p><code>CSS</code>，全称叫作<code>Cascading Style Sheets</code>，即<code>层叠样式表</code>。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。</p>\n<p><code>CSS</code>是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#head_wrapper</span><span class=\"selector-class\">.s-ps-islite</span> <span class=\"selector-class\">.s-p-top</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">181px</span>; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个<code>CSS</code>样式。大括号前面是一个<code>CSS选择器</code>。此选择器的作用是首先选中<code>id</code>为<code>head_wrapper</code>且<code>class</code> 为<code>s-ps-islite</code>的节点，然后再选中其内部的<code>class</code>为<code>s-p-top</code>的节点。大括号内部写的就是一条条样式规则，例如<code>position</code>指定了这个元素的布局方式为<strong>绝对布局</strong>，<code>bottom</code>指定元素的下边距为<strong>40像素</strong>，<code>width</code>指定了宽度为<strong>100%<strong>占满父元素，<code>height</code>则指定了元素的</strong>高度</strong>。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上<code>CSS</code>选择器，这就代表这个样式对<code>CSS</code>选择器选中的元素生效，元素就会根据此样式来展示了。</p>\n<p>在网页中，一般会统一定义整个网页的样式规则，并写入<code>CSS</code>文件中（其后缀为css）。在HTML中，只需要用<code>link</code>标签即可引入写好的<code>CSS</code>文件，这样整个页面就会变得美观、优雅。</p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p><code>JavaScript</code>，简称<code>JS</code>，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是<code>JavaScript</code>的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种<strong>实时、动态、交互</strong>的页面功能。</p>\n<p><code>JavaScript</code>通常也是以单独的文件形式加载的，后缀为<code>js</code>，在 HTML中通过<code>script标签</code>即可引入，例如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;jquery-2.1.0.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，<code>JavaScript</code>定义了网页的行为。</p>\n"},{"title":"在Hexo博客中嵌入外链视频","date":"2021-05-11T01:12:11.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n# 嵌入的视频\n\nHexo支持Youtube视频的嵌入，可以参考其实现方式。\n\n首先，在`node_modules/hexo/lib/plugins/tag/index.js`中添加以下代码。\n\n```javascript\n  // 添加哔哩哔哩\n  tag.register('bilibili', require('./bilibili'));\n```\n\n然后在`node_modules/hexo/lib/plugins/tag/`目录下新建`bilibili.js`文件，打开并添加如下代码：\n\n```javascript\n'use strict';\n\nconst { htmlTag } = require('hexo-util');\n\n/**\n* bilibili tag\n*\n* Syntax:\n*   {% bilibili id %}\n*/\n\nfunction bilibiliTag(args, content) {\n  var id = args[0];\n  return `<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?${id}\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>`;\n}\n\nmodule.exports = bilibiliTag;\n\n```\n\n重新启动下`Hexo Server`,在`md`页面中添加下列：\n\n```javascript\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}\n```\n\n重新刷新页面，就可以看到视频正常加载了。\n\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}","source":"_posts/在Hexo博客中嵌入外链视频.md","raw":"---\ntitle: 在Hexo博客中嵌入外链视频\ndate: 2021-05-11 09:12:11\ncategories: 博客教程\ntags:\n- Hexo\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n# 嵌入的视频\n\nHexo支持Youtube视频的嵌入，可以参考其实现方式。\n\n首先，在`node_modules/hexo/lib/plugins/tag/index.js`中添加以下代码。\n\n```javascript\n  // 添加哔哩哔哩\n  tag.register('bilibili', require('./bilibili'));\n```\n\n然后在`node_modules/hexo/lib/plugins/tag/`目录下新建`bilibili.js`文件，打开并添加如下代码：\n\n```javascript\n'use strict';\n\nconst { htmlTag } = require('hexo-util');\n\n/**\n* bilibili tag\n*\n* Syntax:\n*   {% bilibili id %}\n*/\n\nfunction bilibiliTag(args, content) {\n  var id = args[0];\n  return `<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?${id}\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>`;\n}\n\nmodule.exports = bilibiliTag;\n\n```\n\n重新启动下`Hexo Server`,在`md`页面中添加下列：\n\n```javascript\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}\n```\n\n重新刷新页面，就可以看到视频正常加载了。\n\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}","slug":"在Hexo博客中嵌入外链视频","published":1,"updated":"2021-05-11T05:31:22.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfpw000rywxuaznxh5yg","content":"<h1 id=\"嵌入的视频\"><a href=\"#嵌入的视频\" class=\"headerlink\" title=\"嵌入的视频\"></a>嵌入的视频</h1><p>Hexo支持Youtube视频的嵌入，可以参考其实现方式。</p>\n<p>首先，在<code>node_modules/hexo/lib/plugins/tag/index.js</code>中添加以下代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加哔哩哔哩</span></span><br><span class=\"line\">tag.register(<span class=\"string\">&#x27;bilibili&#x27;</span>, <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./bilibili&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>node_modules/hexo/lib/plugins/tag/</code>目录下新建<code>bilibili.js</code>文件，打开并添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; htmlTag &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;hexo-util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* bilibili tag</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* Syntax:</span></span><br><span class=\"line\"><span class=\"comment\">*   &#123;% bilibili id %&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bilibiliTag</span>(<span class=\"params\">args, content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?<span class=\"subst\">$&#123;id&#125;</span>&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = bilibiliTag;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重新启动下<code>Hexo Server</code>,在<code>md</code>页面中添加下列：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% bilibili aid=<span class=\"number\">586894170</span>&amp;bvid=BV1uz4y1m72t&amp;cid=<span class=\"number\">305401685</span>&amp;page=<span class=\"number\">1</span> %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新刷新页面，就可以看到视频正常加载了。</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"嵌入的视频\"><a href=\"#嵌入的视频\" class=\"headerlink\" title=\"嵌入的视频\"></a>嵌入的视频</h1><p>Hexo支持Youtube视频的嵌入，可以参考其实现方式。</p>\n<p>首先，在<code>node_modules/hexo/lib/plugins/tag/index.js</code>中添加以下代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加哔哩哔哩</span></span><br><span class=\"line\">tag.register(<span class=\"string\">&#x27;bilibili&#x27;</span>, <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./bilibili&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>node_modules/hexo/lib/plugins/tag/</code>目录下新建<code>bilibili.js</code>文件，打开并添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; htmlTag &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;hexo-util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* bilibili tag</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* Syntax:</span></span><br><span class=\"line\"><span class=\"comment\">*   &#123;% bilibili id %&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bilibiliTag</span>(<span class=\"params\">args, content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?<span class=\"subst\">$&#123;id&#125;</span>&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = bilibiliTag;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重新启动下<code>Hexo Server</code>,在<code>md</code>页面中添加下列：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% bilibili aid=<span class=\"number\">586894170</span>&amp;bvid=BV1uz4y1m72t&amp;cid=<span class=\"number\">305401685</span>&amp;page=<span class=\"number\">1</span> %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新刷新页面，就可以看到视频正常加载了。</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>"},{"title":"爬虫的基本原理","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-11T16:12:50.000Z","pic":null,"_content":"\n我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。\n\n## 爬虫概述\n\n简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。\n\n### 获取网页\n\n获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。\n\n源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。\n\n前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？\n\n`Python`提供了许多库来帮助我们实现这个操作，如`urllib`、`requests`等。可以用这些库来帮助我们实现`HTTP`请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的`Body`部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 \n\n### 提取信息\n\n提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用`正则表达式`提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。\n\n另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或`XPath`来提取网页信息的库，如`Beautiful Soup`、`pyquery`、`lxml`等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。\n\n提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。\n\n### 保存数据\n\n提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为`TXT文本`或`JSON文本`，也可以保存到数据库，如`MySQL`和`MongoDB`等，还可保存至远程服务器，如借助`SFTP`进行操作等。\n\n### 自动化程序\n\n自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。\n\n### 能抓怎样的数据\n\n能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是`HTML源代码`。\n\n另外，可能有些网页返回的不是`HTML代码`，而是一个`JSON字符串`（其中`API`接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。\n\n此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。\n\n另外，还可以看到各种扩展名的文件，如`CSS`、`JavaScript`和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。\n\n上述内容其实都对应各自的`URL`，是基于`HTTP`或`HTTPS`协议的，只要是这种数据，爬虫都可以抓取。\n\n### JavaScript渲染页面\n\n有时候，在用`urllib`或`requests`抓取网页时，得到的源代码实际和浏览器中看到的不一样。\n\n这是一个非常常见的问题。现在网页越来越多地采用`Ajax`、`前端模块化工具`来构建，整个网页可能都是由`JavaScript`渲染出来的，也就是说原始的`HTML代码`就是一个空壳，例如：\n\n```html\n<!DOCTYPE html> \n<html> \n  <head> \n    <meta charset=\"UTF-8\"> \n    <title>This is a Demo</title> \n  </head> \n  <body>\n    <div id=\"container\"> </div> \n  </body> \n  <script src=\"app.js\"></script> \n</html> \n```\n\n`body`节点里面只有一个`id`为`container`的节点，但是需要注意在`body`节点后引入了`app.js`，它便负责整个网站的渲染。\n\n在浏览器中打开这个页面时，首先会加载这个`HTML`内容，接着浏览器会发现其中引入了一个`app.js`文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的`JavaScript`代码，而`JavaScript`则会改变`HTML`中的节点，向其添加内容，最后得到完整的页面。\n\n但是在用`urllib`或`requests`等库请求当前页面时，我们得到的只是这个`HTML代码`，它不会帮助我们去继续加载这个`JavaScript`文件，这样也就看不到浏览器中的内容。\n\n这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。\n\n因此，使用基本`HTTP`请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台`Ajax`接口，也可使用`Selenium`、`Splash`这样的库来实现模拟`JavaScript`渲染。\n","source":"_posts/爬虫的基本原理.md","raw":"---\ntitle: 爬虫的基本原理\ntags:\n  - http\n  - 爬虫\n  - python\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-12 00:12:50\ncategories: 爬虫\npic:\n---\n\n我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。\n\n## 爬虫概述\n\n简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。\n\n### 获取网页\n\n获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。\n\n源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。\n\n前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？\n\n`Python`提供了许多库来帮助我们实现这个操作，如`urllib`、`requests`等。可以用这些库来帮助我们实现`HTTP`请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的`Body`部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 \n\n### 提取信息\n\n提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用`正则表达式`提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。\n\n另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或`XPath`来提取网页信息的库，如`Beautiful Soup`、`pyquery`、`lxml`等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。\n\n提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。\n\n### 保存数据\n\n提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为`TXT文本`或`JSON文本`，也可以保存到数据库，如`MySQL`和`MongoDB`等，还可保存至远程服务器，如借助`SFTP`进行操作等。\n\n### 自动化程序\n\n自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。\n\n### 能抓怎样的数据\n\n能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是`HTML源代码`。\n\n另外，可能有些网页返回的不是`HTML代码`，而是一个`JSON字符串`（其中`API`接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。\n\n此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。\n\n另外，还可以看到各种扩展名的文件，如`CSS`、`JavaScript`和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。\n\n上述内容其实都对应各自的`URL`，是基于`HTTP`或`HTTPS`协议的，只要是这种数据，爬虫都可以抓取。\n\n### JavaScript渲染页面\n\n有时候，在用`urllib`或`requests`抓取网页时，得到的源代码实际和浏览器中看到的不一样。\n\n这是一个非常常见的问题。现在网页越来越多地采用`Ajax`、`前端模块化工具`来构建，整个网页可能都是由`JavaScript`渲染出来的，也就是说原始的`HTML代码`就是一个空壳，例如：\n\n```html\n<!DOCTYPE html> \n<html> \n  <head> \n    <meta charset=\"UTF-8\"> \n    <title>This is a Demo</title> \n  </head> \n  <body>\n    <div id=\"container\"> </div> \n  </body> \n  <script src=\"app.js\"></script> \n</html> \n```\n\n`body`节点里面只有一个`id`为`container`的节点，但是需要注意在`body`节点后引入了`app.js`，它便负责整个网站的渲染。\n\n在浏览器中打开这个页面时，首先会加载这个`HTML`内容，接着浏览器会发现其中引入了一个`app.js`文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的`JavaScript`代码，而`JavaScript`则会改变`HTML`中的节点，向其添加内容，最后得到完整的页面。\n\n但是在用`urllib`或`requests`等库请求当前页面时，我们得到的只是这个`HTML代码`，它不会帮助我们去继续加载这个`JavaScript`文件，这样也就看不到浏览器中的内容。\n\n这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。\n\n因此，使用基本`HTTP`请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台`Ajax`接口，也可使用`Selenium`、`Splash`这样的库来实现模拟`JavaScript`渲染。\n","slug":"爬虫的基本原理","published":1,"updated":"2021-05-11T16:12:48.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfpz000sywxuhd2ncat8","content":"<p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>\n<h2 id=\"爬虫概述\"><a href=\"#爬虫概述\" class=\"headerlink\" title=\"爬虫概述\"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。</p>\n<h3 id=\"获取网页\"><a href=\"#获取网页\" class=\"headerlink\" title=\"获取网页\"></a>获取网页</h3><p>获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。</p>\n<p>源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</p>\n<p>前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？</p>\n<p><code>Python</code>提供了许多库来帮助我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。可以用这些库来帮助我们实现<code>HTTP</code>请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的<code>Body</code>部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 </p>\n<h3 id=\"提取信息\"><a href=\"#提取信息\" class=\"headerlink\" title=\"提取信息\"></a>提取信息</h3><p>提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用<code>正则表达式</code>提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p>\n<p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或<code>XPath</code>来提取网页信息的库，如<code>Beautiful Soup</code>、<code>pyquery</code>、<code>lxml</code>等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。</p>\n<p>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p>\n<h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为<code>TXT文本</code>或<code>JSON文本</code>，也可以保存到数据库，如<code>MySQL</code>和<code>MongoDB</code>等，还可保存至远程服务器，如借助<code>SFTP</code>进行操作等。</p>\n<h3 id=\"自动化程序\"><a href=\"#自动化程序\" class=\"headerlink\" title=\"自动化程序\"></a>自动化程序</h3><p>自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>\n<h3 id=\"能抓怎样的数据\"><a href=\"#能抓怎样的数据\" class=\"headerlink\" title=\"能抓怎样的数据\"></a>能抓怎样的数据</h3><p>能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是<code>HTML源代码</code>。</p>\n<p>另外，可能有些网页返回的不是<code>HTML代码</code>，而是一个<code>JSON字符串</code>（其中<code>API</code>接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p>\n<p>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p>\n<p>另外，还可以看到各种扩展名的文件，如<code>CSS</code>、<code>JavaScript</code>和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</p>\n<p>上述内容其实都对应各自的<code>URL</code>，是基于<code>HTTP</code>或<code>HTTPS</code>协议的，只要是这种数据，爬虫都可以抓取。</p>\n<h3 id=\"JavaScript渲染页面\"><a href=\"#JavaScript渲染页面\" class=\"headerlink\" title=\"JavaScript渲染页面\"></a>JavaScript渲染页面</h3><p>有时候，在用<code>urllib</code>或<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p>\n<p>这是一个非常常见的问题。现在网页越来越多地采用<code>Ajax</code>、<code>前端模块化工具</code>来构建，整个网页可能都是由<code>JavaScript</code>渲染出来的，也就是说原始的<code>HTML代码</code>就是一个空壳，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;app.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p><code>body</code>节点里面只有一个<code>id</code>为<code>container</code>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p>\n<p>在浏览器中打开这个页面时，首先会加载这个<code>HTML</code>内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的<code>JavaScript</code>代码，而<code>JavaScript</code>则会改变<code>HTML</code>中的节点，向其添加内容，最后得到完整的页面。</p>\n<p>但是在用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个<code>HTML代码</code>，它不会帮助我们去继续加载这个<code>JavaScript</code>文件，这样也就看不到浏览器中的内容。</p>\n<p>这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p>\n<p>因此，使用基本<code>HTTP</code>请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台<code>Ajax</code>接口，也可使用<code>Selenium</code>、<code>Splash</code>这样的库来实现模拟<code>JavaScript</code>渲染。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>\n<h2 id=\"爬虫概述\"><a href=\"#爬虫概述\" class=\"headerlink\" title=\"爬虫概述\"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。</p>\n<h3 id=\"获取网页\"><a href=\"#获取网页\" class=\"headerlink\" title=\"获取网页\"></a>获取网页</h3><p>获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。</p>\n<p>源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</p>\n<p>前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？</p>\n<p><code>Python</code>提供了许多库来帮助我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。可以用这些库来帮助我们实现<code>HTTP</code>请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的<code>Body</code>部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 </p>\n<h3 id=\"提取信息\"><a href=\"#提取信息\" class=\"headerlink\" title=\"提取信息\"></a>提取信息</h3><p>提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用<code>正则表达式</code>提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p>\n<p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或<code>XPath</code>来提取网页信息的库，如<code>Beautiful Soup</code>、<code>pyquery</code>、<code>lxml</code>等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。</p>\n<p>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p>\n<h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为<code>TXT文本</code>或<code>JSON文本</code>，也可以保存到数据库，如<code>MySQL</code>和<code>MongoDB</code>等，还可保存至远程服务器，如借助<code>SFTP</code>进行操作等。</p>\n<h3 id=\"自动化程序\"><a href=\"#自动化程序\" class=\"headerlink\" title=\"自动化程序\"></a>自动化程序</h3><p>自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>\n<h3 id=\"能抓怎样的数据\"><a href=\"#能抓怎样的数据\" class=\"headerlink\" title=\"能抓怎样的数据\"></a>能抓怎样的数据</h3><p>能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是<code>HTML源代码</code>。</p>\n<p>另外，可能有些网页返回的不是<code>HTML代码</code>，而是一个<code>JSON字符串</code>（其中<code>API</code>接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p>\n<p>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p>\n<p>另外，还可以看到各种扩展名的文件，如<code>CSS</code>、<code>JavaScript</code>和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</p>\n<p>上述内容其实都对应各自的<code>URL</code>，是基于<code>HTTP</code>或<code>HTTPS</code>协议的，只要是这种数据，爬虫都可以抓取。</p>\n<h3 id=\"JavaScript渲染页面\"><a href=\"#JavaScript渲染页面\" class=\"headerlink\" title=\"JavaScript渲染页面\"></a>JavaScript渲染页面</h3><p>有时候，在用<code>urllib</code>或<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p>\n<p>这是一个非常常见的问题。现在网页越来越多地采用<code>Ajax</code>、<code>前端模块化工具</code>来构建，整个网页可能都是由<code>JavaScript</code>渲染出来的，也就是说原始的<code>HTML代码</code>就是一个空壳，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;app.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p><code>body</code>节点里面只有一个<code>id</code>为<code>container</code>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p>\n<p>在浏览器中打开这个页面时，首先会加载这个<code>HTML</code>内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的<code>JavaScript</code>代码，而<code>JavaScript</code>则会改变<code>HTML</code>中的节点，向其添加内容，最后得到完整的页面。</p>\n<p>但是在用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个<code>HTML代码</code>，它不会帮助我们去继续加载这个<code>JavaScript</code>文件，这样也就看不到浏览器中的内容。</p>\n<p>这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p>\n<p>因此，使用基本<code>HTTP</code>请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台<code>Ajax</code>接口，也可使用<code>Selenium</code>、<code>Splash</code>这样的库来实现模拟<code>JavaScript</code>渲染。</p>\n"},{"title":"腾讯云配置ssl证书","date":"2021-05-10T07:36:11.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n## 什么是SSL证书？\n\nSSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。\n\n## 申请腾讯云SSL证书\n\n百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。\n\n## nginx配置修改\n\n下载SSL证书，上传到服务器`/etc/pki/nginx/`目录下。\n\n修改`/etc/`配置文件，注意SSL证书的路径和实际上传的路径和名称一致。\n\n```shell\n    # server {\n    #     listen       80 default_server;\n    #     listen       [::]:80 default_server;\n    #     server_name  www.holychan.ltd;\n    #     root         /home/hexo;\n\n    #     # Load configuration files for the default server block.\n    #     include /etc/nginx/default.d/*.conf;\n\n    #     location / {\n    #     }\n\n    #     error_page 404 /404.html;\n    #         location = /40x.html {\n    #     }\n\n    #     error_page 500 502 503 504 /50x.html;\n    #         location = /50x.html {\n    #     }\n    # }\n    # 以上的配置注释，使用下面的配置\n\n    # Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  www.holychan.ltd;\n        root         /home/hexo;    # 根目录\n\n        ssl_certificate \"/etc/pki/nginx/1_holychan.ltd_bundle.crt\";    # ssl证书路径\n        ssl_certificate_key \"/etc/pki/nginx/2_holychan.ltd.key\"; # ssl证书密钥\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_ciphers PROFILE=SYSTEM;\n        ssl_prefer_server_ciphers on;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n}\n```","source":"_posts/腾讯云配置ssl证书.md","raw":"---\ntitle: 腾讯云配置ssl证书\ndate: 2021-05-10 15:36:11\ncategories: 博客教程\ntags:\n- nginx\n- https\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n## 什么是SSL证书？\n\nSSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。\n\n## 申请腾讯云SSL证书\n\n百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。\n\n## nginx配置修改\n\n下载SSL证书，上传到服务器`/etc/pki/nginx/`目录下。\n\n修改`/etc/`配置文件，注意SSL证书的路径和实际上传的路径和名称一致。\n\n```shell\n    # server {\n    #     listen       80 default_server;\n    #     listen       [::]:80 default_server;\n    #     server_name  www.holychan.ltd;\n    #     root         /home/hexo;\n\n    #     # Load configuration files for the default server block.\n    #     include /etc/nginx/default.d/*.conf;\n\n    #     location / {\n    #     }\n\n    #     error_page 404 /404.html;\n    #         location = /40x.html {\n    #     }\n\n    #     error_page 500 502 503 504 /50x.html;\n    #         location = /50x.html {\n    #     }\n    # }\n    # 以上的配置注释，使用下面的配置\n\n    # Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  www.holychan.ltd;\n        root         /home/hexo;    # 根目录\n\n        ssl_certificate \"/etc/pki/nginx/1_holychan.ltd_bundle.crt\";    # ssl证书路径\n        ssl_certificate_key \"/etc/pki/nginx/2_holychan.ltd.key\"; # ssl证书密钥\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_ciphers PROFILE=SYSTEM;\n        ssl_prefer_server_ciphers on;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n}\n```","slug":"腾讯云配置ssl证书","published":1,"updated":"2021-05-10T08:50:52.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfq1000uywxuax98d9rn","content":"<h2 id=\"什么是SSL证书？\"><a href=\"#什么是SSL证书？\" class=\"headerlink\" title=\"什么是SSL证书？\"></a>什么是SSL证书？</h2><p>SSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。</p>\n<h2 id=\"申请腾讯云SSL证书\"><a href=\"#申请腾讯云SSL证书\" class=\"headerlink\" title=\"申请腾讯云SSL证书\"></a>申请腾讯云SSL证书</h2><p>百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。</p>\n<h2 id=\"nginx配置修改\"><a href=\"#nginx配置修改\" class=\"headerlink\" title=\"nginx配置修改\"></a>nginx配置修改</h2><p>下载SSL证书，上传到服务器<code>/etc/pki/nginx/</code>目录下。</p>\n<p>修改<code>/etc/</code>配置文件，注意SSL证书的路径和实际上传的路径和名称一致。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    # server &#123;</span><br><span class=\"line\">    #     listen       80 default_server;</span><br><span class=\"line\">    #     listen       [::]:80 default_server;</span><br><span class=\"line\">    #     server_name  www.holychan.ltd;</span><br><span class=\"line\">    #     root         /home/hexo;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     # Load configuration files for the default server block.</span><br><span class=\"line\">    #     include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     location / &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 404 /404.html;</span><br><span class=\"line\">    #         location = /40x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">    #         location = /50x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\">    # &#125;</span><br><span class=\"line\">    # 以上的配置注释，使用下面的配置</span><br><span class=\"line\"></span><br><span class=\"line\">    # Settings for a TLS enabled server.</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  www.holychan.ltd;</span><br><span class=\"line\">        root         /home/hexo;    # 根目录</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_certificate &quot;/etc/pki/nginx/1_holychan.ltd_bundle.crt&quot;;    # ssl证书路径</span><br><span class=\"line\">        ssl_certificate_key &quot;/etc/pki/nginx/2_holychan.ltd.key&quot;; # ssl证书密钥</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_ciphers PROFILE=SYSTEM;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是SSL证书？\"><a href=\"#什么是SSL证书？\" class=\"headerlink\" title=\"什么是SSL证书？\"></a>什么是SSL证书？</h2><p>SSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。</p>\n<h2 id=\"申请腾讯云SSL证书\"><a href=\"#申请腾讯云SSL证书\" class=\"headerlink\" title=\"申请腾讯云SSL证书\"></a>申请腾讯云SSL证书</h2><p>百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。</p>\n<h2 id=\"nginx配置修改\"><a href=\"#nginx配置修改\" class=\"headerlink\" title=\"nginx配置修改\"></a>nginx配置修改</h2><p>下载SSL证书，上传到服务器<code>/etc/pki/nginx/</code>目录下。</p>\n<p>修改<code>/etc/</code>配置文件，注意SSL证书的路径和实际上传的路径和名称一致。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    # server &#123;</span><br><span class=\"line\">    #     listen       80 default_server;</span><br><span class=\"line\">    #     listen       [::]:80 default_server;</span><br><span class=\"line\">    #     server_name  www.holychan.ltd;</span><br><span class=\"line\">    #     root         /home/hexo;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     # Load configuration files for the default server block.</span><br><span class=\"line\">    #     include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     location / &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 404 /404.html;</span><br><span class=\"line\">    #         location = /40x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">    #         location = /50x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\">    # &#125;</span><br><span class=\"line\">    # 以上的配置注释，使用下面的配置</span><br><span class=\"line\"></span><br><span class=\"line\">    # Settings for a TLS enabled server.</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  www.holychan.ltd;</span><br><span class=\"line\">        root         /home/hexo;    # 根目录</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_certificate &quot;/etc/pki/nginx/1_holychan.ltd_bundle.crt&quot;;    # ssl证书路径</span><br><span class=\"line\">        ssl_certificate_key &quot;/etc/pki/nginx/2_holychan.ltd.key&quot;; # ssl证书密钥</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_ciphers PROFILE=SYSTEM;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HTTP基本原理","date":"2021-05-09T12:48:23.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n\n## URI和URL\n\n`URI （Uniform Resource Identifier）` 即**统一资源标志符**。\n`URL （Uniform Resource Locator` 即**统一资源定位符**。\n\n例如：\n`https://github.com/favicon.ico`既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称`favicon.ico`。\n\nURL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。\n\nURI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。\n\n## 超文本\n\n`Hypertext`，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如`img`显示图片，`p`指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码`HTML`就可以称作超文本。\n\n## HTTP和HTTPS\n\n`HTTP`的全称是Hyper Text Transfer Protocol，中文名叫作**超文本传输协议**，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是`HTTP 1.1`版本。\n\n`HTTPS`的全称是`Hyper Text Transfer Protocol over Secure Socket Layer`，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入`SSL`层，简称为`HTTPS`。\n\n`HTTPS`的安全基础是`SSL`，因此通过它传输的内容都是经过`SSL`加密的，它的主要作用可以分为两种：\n\n- 建立一个信息安全通道，来保证数据传输的安全。\n- 确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过`CA`机构颁发的安全签章来查询。\n  \n现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：\n\n- 苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。\n- 谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。\n- 腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。\n  \n因此，HTTPS 已经已经是大势所趋。\n\n## HTTP请求过程\n\n我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的**响应**，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：\n\n![传输模型](1.png)\n\n此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。\n\n为了更直观地说明这个过程，这里用浏览器的开发者模式下的`Network监听组件`来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度`http://www.baidu.com/`，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在`Network`页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:\n\n![Network监听](Screenshot_2.png)\n\n我们先观察第一个网络请求，即`www.baidu.com`，其中各列的含义如下。\n\n- 第一列 `Name：请求的名称`，一般会将 URL的最后一部分内容当作名称。\n- 第二列 `Status：响应的状态码`，这里显示为 `200`，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 \n- 第三列 `Type：请求的文档类型`。这里为`document`，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。\n- 第四列 `Initiator：请求源`。用来标记请求是由哪个对象或进程发起的。\n- 第五列 `Size：从服务器下载的文件和请求的资源大小`。如果是从缓存中取得的资源，则该列会显示 fromcache。\n- 第六列 `Time：发起请求到获取响应所用的总时间`。\n- 第七列 `Waterfall：网络请求的可视化瀑布流`。 我们点击这个条目即可看到其更详细的信息，如图所示。\n\n![详细信息](Screenshot_3.png)\n\n首先是`General`部分，`Request URL`为请求的URL，`Request Method`为请求的方法，`Status Code`为响应状态码，`Remote Address`为远程服务器的地址和端口，`Referrer Policy`为 Referrer判别策略。 \n\n再继续往下，可以看到，有`Response Headers`和`Request Headers`，这分别代表`响应头`和`请求头`。请求头里带有许多请求信息，例如`浏览器标识、Cookies、Host`等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的`Response Headers`就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。\n\n## 请求\n\n**请求**，由客户端向服务端发出，可以分为4部分内容：`请求方法（Request Method`、`请求的网址（Request URL）`、`请求头（Request Headers）`、`请求体（Request Body）`。\n\n### 请求方法\n\n常见的请求方法有两种：`GET`和`POST`。 在浏览器中直接输入URL并回车，这便发起了一个`GET请求`，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为`https://www.baidu.com/s?wd=Python`，其中URL中包 含了请求的参数信息，这里参数`wd`表示要搜寻的关键字。`POST请求`大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个`POST请求`，其数据通常 以表单的形式传输，而不会体现在URL中。\n\n`GET`和`POST`请求方法有如下区别。\n\n- `GET请求`中的参数包含在URL里面，数据可以在URL中看到，而`POST请求`的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。\n- `GET请求`提交的数据最多只有*1024字节*，而`POST请求`没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用`GET方式`请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以`POST方式`发送。上传文件时，由于文件内容比较大，也会选用`POST方式`。 我们平常遇到的绝大部分请求都是`GET`或`POST`请求，另外还有一些请求方法，如`HEAD`、`PUT`、`DELETE`、`OPTIONS`、`CONNECT`、`TRACE`等，我们简单将其总结为下表。\n\n| 方法 | 描述 |\n| :--- | :---- |\n| GET | 请求页面，并返回页面内容 |\n| HEAD | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 |\n| POST | 大多用于表单提交或上传文件，数据包含在请求体中 |\n| PUT | 从客户端向服务器传送的数据取代指定文档中的内容 |\n| DELETE | 请求服务器删除指定的页面 |\n| CONNECT | 把服务器当作跳板，让服务器代替客户端访问其他网页 |\n| OPTIONS | 允许客户端查看服务器的性能 |\n| TRACE | 回显服务器收到的请求，主要用于测试或诊断 |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。\n\n### 请求头\n\n请求头，用来说明服务器要使用的附加信息，比较重要的信息有`Cookie`、`Referer`、`User-Agent`等。下面简要说明一些常用的头信息。\n\n- `Accept`：请求报头域，用于指定客户端可接受哪些类型的信息。\n- `Accept-Language`：指定客户端可接受的语言类型。\n- `Accept-Encoding`：指定客户端可接受的内容编码。\n- `Host`：用于指定请求资源的主机`IP`和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。\n- `Cookie`：也常用复数形式`Cookies`，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是`Cookies`的功劳。`Cookies`里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上`Cookies`并将其发送给服务器，服务器通过`Cookies`识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。\n- `Referer`：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。\n- `User-Agent`：简称`UA`，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。\n- `Content-Type`：也叫互联网媒体类型`（Internet Media Type）`或者`MIME类型`，在`HTTP`协议消息头中，它用来表示具体请求中的媒体类型信息。例如，`text/html`代表`HTML`格式，`image/gif`代表`GIF`图片，`application/json`代表`JSON`类型，更多对应关系可以查看此对照表：`http://tool.oschina.net/commons`。\n\n因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。\n\n### 请求体\n\n请请求体一般承载的内容是`POST`请求中的表单数据，而对于`GET`请求，请求体则为空。\n\n登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意`Request Headers`中指定`Content-Type`为`application/x-www-form-urlencoded`。只有设置`Content-Type`为`application/x-www-form-urlencoded`，才会以表单数据的形式提交。另外，我们也可以将`Content-Type`设置为`application/json`来提交`JSON`数据，或者设置为`multipart/form-data`来上传文件。 \n\n表格中列出了`Content-Type`和`POST`提交数据方式的关系。\n\n| Content-Type | 提交数据的方式 |\n| :--- | :---- |\n| application/x-www-form-urlencodeed | 表单数据 |\n| multipart/form-data | 表单文件上传 |\n| application/json | 序列化JSON数据 |\n| text/xml | XML数据 |\n\n在爬虫中，如果要构造`POST`请求，需要使用正确的`Content-Type`，并了解各种请求库的各个参数设置时使用的是哪种`Content-Type`，不然可能会导致`POST`提交后无法正常响应。\n\n## 响应\n\n响应，由服务端返回给客户端，可以分为三部分：`响应状态码（Response Status Code）`、`响应头（Response Headers）`和`响应体（Response Body）`。\n\n### 响应状态码\n\n响应状态码表示服务器的响应状态，如`200`代表服务器正常响应，`404`代表页面未找到，`500`代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为`200`，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。\n\n| 状态码 | 说明 | 详情 |\n| :---- | :---: | :----- |\n| 100 | 继续 | 请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分 |\n| 101 | 切换协议 | 请求者已要求服务器切换协议，服务器已确认并确认切换 |\n| 200 | 成功 | 服务器已成功处理了请求 |\n| 201 | 已创建 | 请求成功并且服务器创建了新的资源 |\n| 202 | 已接受 | 服务器已接受请求，但尚未处理 |\n| 203 | 非授权信息 | 服务器已经成功处理请求，但返回的信息可能来自另一个源 |\n| 204 | 无内容 | 服务器成功处理了请求，但没有返回任何内容 |\n| 205 | 重置内容 | 服务器成功处理了请求，但内容被重置 |\n| 206 | 部分内容 | 服务器成功处理了部分请求 |\n| 300 | 多种选择 | 针对请求，服务器可执行多种操作 |\n| 301 | 永久移动 | 请求的网页已永久移动到新位置，即永久重定向 |\n| 302 | 临时移动 | 请求的网页暂时跳转到其他页面，即暂时重定向 |\n| 303 | 查看其他位置 | 如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源 |\n| 304 | 未修改 | 此次请求返回的网页未修改，继续使用上次的资源 |\n| 305 | 使用代理 | 请求者应该使用代理访问该网页 |\n| 307 | 临时重定向 | 请求的资源临时从其他位置响应 |\n| 400 | 错误请求 | 服务器无法解析该请求 |\n| 401 | 未授权 | 请求没有进行身份验证或验证未通过 |\n| 403 | 禁止访问 | 服务器拒绝此请求 |\n| 404 | 未找到 | 服务器找不到请求的网页 |\n| 405 | 方法禁用 | 服务器禁用了请求中指定的方法 |\n| 406 | 不接受 | 无法使用请求的内容响应请求的网页 |\n| 407 | 需要代理授权 | 请求者需要使用代理授权 |\n| 408 | 请求超时 | 服务器请求超时 |\n| 409 | 冲突 | 服务器在完成请求时发生冲突 |\n| 410 | 已删除 | 请求的资源已永久删除 |\n| 411 | 需要有效长度 | 服务器不接受不含有效内容长度标头字段的请求 |\n| 412 | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |\n| 413 | 请求实体过大 | 请求实体过大，超出服务器的处理能力 |\n| 415 | 请求URL过长 | 请求的网址过长，服务器无法处理 |\n| 416 | 请求范围不符 | 页面无法提供请求页面支持 |\n| 417 | 未满足期望值 | 服务器为满足期望请求标头字段的要求 |\n| 500 | 服务器内部错误 | 服务器遇到错误，无法完成请求 |\n| 501 | 未实现 | 服务器不具备完成请求的功能 |\n| 502 | 错误网关 | 服务器作为网关或代理，从上游服务器收到无效响应 |\n| 503 | 服务不可用 | 服务器目前无法使用 |\n| 504 | 网关超时 | 服务器作为网关或代理，但是没有及时从上游服务器收到响应 |\n| 505 | HTTP版本不支持 | 服务器不支持请求中所用的HTTP协议版本 |\n\n响应头包含了服务器对请求的应答信息，如`Content-Type`、`Server`、`Set-Cookie`等。下面简要说明一些常用的响应头信息。 \n\n- `Date`：标识响应产生的时间。\n- `Last-Modified`：指定资源的最后修改时间。\n- `Content-Encoding`：指定响应内容的编码。\n- `Server`：包含服务器的信息，比如名称、版本号等。\n- `Content-Type`：文档类型，指定返回的数据类型是什么，如`text/html`代表返回`HTML`文档，`application/x-javascript`则代表返回`JavaScript`文件，`image/jpeg`则代表返回图片。\n- `Set-Cookie`：设置`Cookies`。响应头中的`Set-Cookie`告诉浏览器需要将此内容放在`Cookies`中，下次请求携带`Cookies`请求。\n- `Expires`：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。\n\n### 响应体\n\n最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的`HTML`代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。\n\n![响应体](Screenshot_1.png)\n\n在浏览器开发者工具中点击`Response`，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、`JSON`数据等，然后从中做相应内容的提取。\n","source":"_posts/HTTP基本原理.md","raw":"---\ntitle: HTTP基本原理\ndate: 2021-05-09 20:48:23\ncategories: 爬虫\ntags:\n- Http\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n\n## URI和URL\n\n`URI （Uniform Resource Identifier）` 即**统一资源标志符**。\n`URL （Uniform Resource Locator` 即**统一资源定位符**。\n\n例如：\n`https://github.com/favicon.ico`既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称`favicon.ico`。\n\nURL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。\n\nURI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。\n\n## 超文本\n\n`Hypertext`，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如`img`显示图片，`p`指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码`HTML`就可以称作超文本。\n\n## HTTP和HTTPS\n\n`HTTP`的全称是Hyper Text Transfer Protocol，中文名叫作**超文本传输协议**，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是`HTTP 1.1`版本。\n\n`HTTPS`的全称是`Hyper Text Transfer Protocol over Secure Socket Layer`，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入`SSL`层，简称为`HTTPS`。\n\n`HTTPS`的安全基础是`SSL`，因此通过它传输的内容都是经过`SSL`加密的，它的主要作用可以分为两种：\n\n- 建立一个信息安全通道，来保证数据传输的安全。\n- 确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过`CA`机构颁发的安全签章来查询。\n  \n现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：\n\n- 苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。\n- 谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。\n- 腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。\n  \n因此，HTTPS 已经已经是大势所趋。\n\n## HTTP请求过程\n\n我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的**响应**，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：\n\n![传输模型](1.png)\n\n此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。\n\n为了更直观地说明这个过程，这里用浏览器的开发者模式下的`Network监听组件`来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度`http://www.baidu.com/`，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在`Network`页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:\n\n![Network监听](Screenshot_2.png)\n\n我们先观察第一个网络请求，即`www.baidu.com`，其中各列的含义如下。\n\n- 第一列 `Name：请求的名称`，一般会将 URL的最后一部分内容当作名称。\n- 第二列 `Status：响应的状态码`，这里显示为 `200`，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 \n- 第三列 `Type：请求的文档类型`。这里为`document`，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。\n- 第四列 `Initiator：请求源`。用来标记请求是由哪个对象或进程发起的。\n- 第五列 `Size：从服务器下载的文件和请求的资源大小`。如果是从缓存中取得的资源，则该列会显示 fromcache。\n- 第六列 `Time：发起请求到获取响应所用的总时间`。\n- 第七列 `Waterfall：网络请求的可视化瀑布流`。 我们点击这个条目即可看到其更详细的信息，如图所示。\n\n![详细信息](Screenshot_3.png)\n\n首先是`General`部分，`Request URL`为请求的URL，`Request Method`为请求的方法，`Status Code`为响应状态码，`Remote Address`为远程服务器的地址和端口，`Referrer Policy`为 Referrer判别策略。 \n\n再继续往下，可以看到，有`Response Headers`和`Request Headers`，这分别代表`响应头`和`请求头`。请求头里带有许多请求信息，例如`浏览器标识、Cookies、Host`等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的`Response Headers`就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。\n\n## 请求\n\n**请求**，由客户端向服务端发出，可以分为4部分内容：`请求方法（Request Method`、`请求的网址（Request URL）`、`请求头（Request Headers）`、`请求体（Request Body）`。\n\n### 请求方法\n\n常见的请求方法有两种：`GET`和`POST`。 在浏览器中直接输入URL并回车，这便发起了一个`GET请求`，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为`https://www.baidu.com/s?wd=Python`，其中URL中包 含了请求的参数信息，这里参数`wd`表示要搜寻的关键字。`POST请求`大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个`POST请求`，其数据通常 以表单的形式传输，而不会体现在URL中。\n\n`GET`和`POST`请求方法有如下区别。\n\n- `GET请求`中的参数包含在URL里面，数据可以在URL中看到，而`POST请求`的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。\n- `GET请求`提交的数据最多只有*1024字节*，而`POST请求`没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用`GET方式`请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以`POST方式`发送。上传文件时，由于文件内容比较大，也会选用`POST方式`。 我们平常遇到的绝大部分请求都是`GET`或`POST`请求，另外还有一些请求方法，如`HEAD`、`PUT`、`DELETE`、`OPTIONS`、`CONNECT`、`TRACE`等，我们简单将其总结为下表。\n\n| 方法 | 描述 |\n| :--- | :---- |\n| GET | 请求页面，并返回页面内容 |\n| HEAD | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 |\n| POST | 大多用于表单提交或上传文件，数据包含在请求体中 |\n| PUT | 从客户端向服务器传送的数据取代指定文档中的内容 |\n| DELETE | 请求服务器删除指定的页面 |\n| CONNECT | 把服务器当作跳板，让服务器代替客户端访问其他网页 |\n| OPTIONS | 允许客户端查看服务器的性能 |\n| TRACE | 回显服务器收到的请求，主要用于测试或诊断 |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。\n\n### 请求头\n\n请求头，用来说明服务器要使用的附加信息，比较重要的信息有`Cookie`、`Referer`、`User-Agent`等。下面简要说明一些常用的头信息。\n\n- `Accept`：请求报头域，用于指定客户端可接受哪些类型的信息。\n- `Accept-Language`：指定客户端可接受的语言类型。\n- `Accept-Encoding`：指定客户端可接受的内容编码。\n- `Host`：用于指定请求资源的主机`IP`和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。\n- `Cookie`：也常用复数形式`Cookies`，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是`Cookies`的功劳。`Cookies`里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上`Cookies`并将其发送给服务器，服务器通过`Cookies`识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。\n- `Referer`：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。\n- `User-Agent`：简称`UA`，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。\n- `Content-Type`：也叫互联网媒体类型`（Internet Media Type）`或者`MIME类型`，在`HTTP`协议消息头中，它用来表示具体请求中的媒体类型信息。例如，`text/html`代表`HTML`格式，`image/gif`代表`GIF`图片，`application/json`代表`JSON`类型，更多对应关系可以查看此对照表：`http://tool.oschina.net/commons`。\n\n因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。\n\n### 请求体\n\n请请求体一般承载的内容是`POST`请求中的表单数据，而对于`GET`请求，请求体则为空。\n\n登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意`Request Headers`中指定`Content-Type`为`application/x-www-form-urlencoded`。只有设置`Content-Type`为`application/x-www-form-urlencoded`，才会以表单数据的形式提交。另外，我们也可以将`Content-Type`设置为`application/json`来提交`JSON`数据，或者设置为`multipart/form-data`来上传文件。 \n\n表格中列出了`Content-Type`和`POST`提交数据方式的关系。\n\n| Content-Type | 提交数据的方式 |\n| :--- | :---- |\n| application/x-www-form-urlencodeed | 表单数据 |\n| multipart/form-data | 表单文件上传 |\n| application/json | 序列化JSON数据 |\n| text/xml | XML数据 |\n\n在爬虫中，如果要构造`POST`请求，需要使用正确的`Content-Type`，并了解各种请求库的各个参数设置时使用的是哪种`Content-Type`，不然可能会导致`POST`提交后无法正常响应。\n\n## 响应\n\n响应，由服务端返回给客户端，可以分为三部分：`响应状态码（Response Status Code）`、`响应头（Response Headers）`和`响应体（Response Body）`。\n\n### 响应状态码\n\n响应状态码表示服务器的响应状态，如`200`代表服务器正常响应，`404`代表页面未找到，`500`代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为`200`，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。\n\n| 状态码 | 说明 | 详情 |\n| :---- | :---: | :----- |\n| 100 | 继续 | 请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分 |\n| 101 | 切换协议 | 请求者已要求服务器切换协议，服务器已确认并确认切换 |\n| 200 | 成功 | 服务器已成功处理了请求 |\n| 201 | 已创建 | 请求成功并且服务器创建了新的资源 |\n| 202 | 已接受 | 服务器已接受请求，但尚未处理 |\n| 203 | 非授权信息 | 服务器已经成功处理请求，但返回的信息可能来自另一个源 |\n| 204 | 无内容 | 服务器成功处理了请求，但没有返回任何内容 |\n| 205 | 重置内容 | 服务器成功处理了请求，但内容被重置 |\n| 206 | 部分内容 | 服务器成功处理了部分请求 |\n| 300 | 多种选择 | 针对请求，服务器可执行多种操作 |\n| 301 | 永久移动 | 请求的网页已永久移动到新位置，即永久重定向 |\n| 302 | 临时移动 | 请求的网页暂时跳转到其他页面，即暂时重定向 |\n| 303 | 查看其他位置 | 如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源 |\n| 304 | 未修改 | 此次请求返回的网页未修改，继续使用上次的资源 |\n| 305 | 使用代理 | 请求者应该使用代理访问该网页 |\n| 307 | 临时重定向 | 请求的资源临时从其他位置响应 |\n| 400 | 错误请求 | 服务器无法解析该请求 |\n| 401 | 未授权 | 请求没有进行身份验证或验证未通过 |\n| 403 | 禁止访问 | 服务器拒绝此请求 |\n| 404 | 未找到 | 服务器找不到请求的网页 |\n| 405 | 方法禁用 | 服务器禁用了请求中指定的方法 |\n| 406 | 不接受 | 无法使用请求的内容响应请求的网页 |\n| 407 | 需要代理授权 | 请求者需要使用代理授权 |\n| 408 | 请求超时 | 服务器请求超时 |\n| 409 | 冲突 | 服务器在完成请求时发生冲突 |\n| 410 | 已删除 | 请求的资源已永久删除 |\n| 411 | 需要有效长度 | 服务器不接受不含有效内容长度标头字段的请求 |\n| 412 | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |\n| 413 | 请求实体过大 | 请求实体过大，超出服务器的处理能力 |\n| 415 | 请求URL过长 | 请求的网址过长，服务器无法处理 |\n| 416 | 请求范围不符 | 页面无法提供请求页面支持 |\n| 417 | 未满足期望值 | 服务器为满足期望请求标头字段的要求 |\n| 500 | 服务器内部错误 | 服务器遇到错误，无法完成请求 |\n| 501 | 未实现 | 服务器不具备完成请求的功能 |\n| 502 | 错误网关 | 服务器作为网关或代理，从上游服务器收到无效响应 |\n| 503 | 服务不可用 | 服务器目前无法使用 |\n| 504 | 网关超时 | 服务器作为网关或代理，但是没有及时从上游服务器收到响应 |\n| 505 | HTTP版本不支持 | 服务器不支持请求中所用的HTTP协议版本 |\n\n响应头包含了服务器对请求的应答信息，如`Content-Type`、`Server`、`Set-Cookie`等。下面简要说明一些常用的响应头信息。 \n\n- `Date`：标识响应产生的时间。\n- `Last-Modified`：指定资源的最后修改时间。\n- `Content-Encoding`：指定响应内容的编码。\n- `Server`：包含服务器的信息，比如名称、版本号等。\n- `Content-Type`：文档类型，指定返回的数据类型是什么，如`text/html`代表返回`HTML`文档，`application/x-javascript`则代表返回`JavaScript`文件，`image/jpeg`则代表返回图片。\n- `Set-Cookie`：设置`Cookies`。响应头中的`Set-Cookie`告诉浏览器需要将此内容放在`Cookies`中，下次请求携带`Cookies`请求。\n- `Expires`：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。\n\n### 响应体\n\n最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的`HTML`代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。\n\n![响应体](Screenshot_1.png)\n\n在浏览器开发者工具中点击`Response`，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、`JSON`数据等，然后从中做相应内容的提取。\n","slug":"HTTP基本原理","published":1,"updated":"2021-05-11T15:57:36.000Z","layout":"post","photos":[],"link":"","_id":"ckolvgfq3000xywxu6ir92rpy","content":"<h2 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h2><p><code>URI （Uniform Resource Identifier）</code> 即<strong>统一资源标志符</strong>。<br><code>URL （Uniform Resource Locator</code> 即<strong>统一资源定位符</strong>。</p>\n<p>例如：<br><code>https://github.com/favicon.ico</code>既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称<code>favicon.ico</code>。</p>\n<p>URL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。</p>\n<p>URI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。</p>\n<h2 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h2><p><code>Hypertext</code>，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如<code>img</code>显示图片，<code>p</code>指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码<code>HTML</code>就可以称作超文本。</p>\n<h2 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h2><p><code>HTTP</code>的全称是Hyper Text Transfer Protocol，中文名叫作<strong>超文本传输协议</strong>，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是<code>HTTP 1.1</code>版本。</p>\n<p><code>HTTPS</code>的全称是<code>Hyper Text Transfer Protocol over Secure Socket Layer</code>，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入<code>SSL</code>层，简称为<code>HTTPS</code>。</p>\n<p><code>HTTPS</code>的安全基础是<code>SSL</code>，因此通过它传输的内容都是经过<code>SSL</code>加密的，它的主要作用可以分为两种：</p>\n<ul>\n<li>建立一个信息安全通道，来保证数据传输的安全。</li>\n<li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过<code>CA</code>机构颁发的安全签章来查询。</li>\n</ul>\n<p>现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：</p>\n<ul>\n<li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。</li>\n<li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。</li>\n<li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li>\n</ul>\n<p>因此，HTTPS 已经已经是大势所趋。</p>\n<h2 id=\"HTTP请求过程\"><a href=\"#HTTP请求过程\" class=\"headerlink\" title=\"HTTP请求过程\"></a>HTTP请求过程</h2><p>我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的<strong>响应</strong>，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：</p>\n<p><img src=\"1.png\" alt=\"传输模型\"></p>\n<p>此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。</p>\n<p>为了更直观地说明这个过程，这里用浏览器的开发者模式下的<code>Network监听组件</code>来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度<code>http://www.baidu.com/</code>，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在<code>Network</code>页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:</p>\n<p><img src=\"Screenshot_2.png\" alt=\"Network监听\"></p>\n<p>我们先观察第一个网络请求，即<code>www.baidu.com</code>，其中各列的含义如下。</p>\n<ul>\n<li>第一列 <code>Name：请求的名称</code>，一般会将 URL的最后一部分内容当作名称。</li>\n<li>第二列 <code>Status：响应的状态码</code>，这里显示为 <code>200</code>，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 </li>\n<li>第三列 <code>Type：请求的文档类型</code>。这里为<code>document</code>，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。</li>\n<li>第四列 <code>Initiator：请求源</code>。用来标记请求是由哪个对象或进程发起的。</li>\n<li>第五列 <code>Size：从服务器下载的文件和请求的资源大小</code>。如果是从缓存中取得的资源，则该列会显示 fromcache。</li>\n<li>第六列 <code>Time：发起请求到获取响应所用的总时间</code>。</li>\n<li>第七列 <code>Waterfall：网络请求的可视化瀑布流</code>。 我们点击这个条目即可看到其更详细的信息，如图所示。</li>\n</ul>\n<p><img src=\"Screenshot_3.png\" alt=\"详细信息\"></p>\n<p>首先是<code>General</code>部分，<code>Request URL</code>为请求的URL，<code>Request Method</code>为请求的方法，<code>Status Code</code>为响应状态码，<code>Remote Address</code>为远程服务器的地址和端口，<code>Referrer Policy</code>为 Referrer判别策略。 </p>\n<p>再继续往下，可以看到，有<code>Response Headers</code>和<code>Request Headers</code>，这分别代表<code>响应头</code>和<code>请求头</code>。请求头里带有许多请求信息，例如<code>浏览器标识、Cookies、Host</code>等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的<code>Response Headers</code>就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p>\n<h2 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h2><p><strong>请求</strong>，由客户端向服务端发出，可以分为4部分内容：<code>请求方法（Request Method</code>、<code>请求的网址（Request URL）</code>、<code>请求头（Request Headers）</code>、<code>请求体（Request Body）</code>。</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>常见的请求方法有两种：<code>GET</code>和<code>POST</code>。 在浏览器中直接输入URL并回车，这便发起了一个<code>GET请求</code>，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为<code>https://www.baidu.com/s?wd=Python</code>，其中URL中包 含了请求的参数信息，这里参数<code>wd</code>表示要搜寻的关键字。<code>POST请求</code>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个<code>POST请求</code>，其数据通常 以表单的形式传输，而不会体现在URL中。</p>\n<p><code>GET</code>和<code>POST</code>请求方法有如下区别。</p>\n<ul>\n<li><code>GET请求</code>中的参数包含在URL里面，数据可以在URL中看到，而<code>POST请求</code>的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li>\n<li><code>GET请求</code>提交的数据最多只有<em>1024字节</em>，而<code>POST请求</code>没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用<code>GET方式</code>请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以<code>POST方式</code>发送。上传文件时，由于文件内容比较大，也会选用<code>POST方式</code>。 我们平常遇到的绝大部分请求都是<code>GET</code>或<code>POST</code>请求，另外还有一些请求方法，如<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>CONNECT</code>、<code>TRACE</code>等，我们简单将其总结为下表。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GET</td>\n<td align=\"left\">请求页面，并返回页面内容</td>\n</tr>\n<tr>\n<td align=\"left\">HEAD</td>\n<td align=\"left\">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td align=\"left\">POST</td>\n<td align=\"left\">大多用于表单提交或上传文件，数据包含在请求体中</td>\n</tr>\n<tr>\n<td align=\"left\">PUT</td>\n<td align=\"left\">从客户端向服务器传送的数据取代指定文档中的内容</td>\n</tr>\n<tr>\n<td align=\"left\">DELETE</td>\n<td align=\"left\">请求服务器删除指定的页面</td>\n</tr>\n<tr>\n<td align=\"left\">CONNECT</td>\n<td align=\"left\">把服务器当作跳板，让服务器代替客户端访问其他网页</td>\n</tr>\n<tr>\n<td align=\"left\">OPTIONS</td>\n<td align=\"left\">允许客户端查看服务器的性能</td>\n</tr>\n<tr>\n<td align=\"left\">TRACE</td>\n<td align=\"left\">回显服务器收到的请求，主要用于测试或诊断</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n<p>请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>请求头，用来说明服务器要使用的附加信息，比较重要的信息有<code>Cookie</code>、<code>Referer</code>、<code>User-Agent</code>等。下面简要说明一些常用的头信息。</p>\n<ul>\n<li><code>Accept</code>：请求报头域，用于指定客户端可接受哪些类型的信息。</li>\n<li><code>Accept-Language</code>：指定客户端可接受的语言类型。</li>\n<li><code>Accept-Encoding</code>：指定客户端可接受的内容编码。</li>\n<li><code>Host</code>：用于指定请求资源的主机<code>IP</code>和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li>\n<li><code>Cookie</code>：也常用复数形式<code>Cookies</code>，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是<code>Cookies</code>的功劳。<code>Cookies</code>里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上<code>Cookies</code>并将其发送给服务器，服务器通过<code>Cookies</code>识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li>\n<li><code>Referer</code>：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li>\n<li><code>User-Agent</code>：简称<code>UA</code>，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li>\n<li><code>Content-Type</code>：也叫互联网媒体类型<code>（Internet Media Type）</code>或者<code>MIME类型</code>，在<code>HTTP</code>协议消息头中，它用来表示具体请求中的媒体类型信息。例如，<code>text/html</code>代表<code>HTML</code>格式，<code>image/gif</code>代表<code>GIF</code>图片，<code>application/json</code>代表<code>JSON</code>类型，更多对应关系可以查看此对照表：<code>http://tool.oschina.net/commons</code>。</li>\n</ul>\n<p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p>\n<h3 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h3><p>请请求体一般承载的内容是<code>POST</code>请求中的表单数据，而对于<code>GET</code>请求，请求体则为空。</p>\n<p>登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意<code>Request Headers</code>中指定<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>。只有设置<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>，才会以表单数据的形式提交。另外，我们也可以将<code>Content-Type</code>设置为<code>application/json</code>来提交<code>JSON</code>数据，或者设置为<code>multipart/form-data</code>来上传文件。 </p>\n<p>表格中列出了<code>Content-Type</code>和<code>POST</code>提交数据方式的关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Content-Type</th>\n<th align=\"left\">提交数据的方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">application/x-www-form-urlencodeed</td>\n<td align=\"left\">表单数据</td>\n</tr>\n<tr>\n<td align=\"left\">multipart/form-data</td>\n<td align=\"left\">表单文件上传</td>\n</tr>\n<tr>\n<td align=\"left\">application/json</td>\n<td align=\"left\">序列化JSON数据</td>\n</tr>\n<tr>\n<td align=\"left\">text/xml</td>\n<td align=\"left\">XML数据</td>\n</tr>\n</tbody></table>\n<p>在爬虫中，如果要构造<code>POST</code>请求，需要使用正确的<code>Content-Type</code>，并了解各种请求库的各个参数设置时使用的是哪种<code>Content-Type</code>，不然可能会导致<code>POST</code>提交后无法正常响应。</p>\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><p>响应，由服务端返回给客户端，可以分为三部分：<code>响应状态码（Response Status Code）</code>、<code>响应头（Response Headers）</code>和<code>响应体（Response Body）</code>。</p>\n<h3 id=\"响应状态码\"><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<code>200</code>代表服务器正常响应，<code>404</code>代表页面未找到，<code>500</code>代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为<code>200</code>，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">状态码</th>\n<th align=\"center\">说明</th>\n<th align=\"left\">详情</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">100</td>\n<td align=\"center\">继续</td>\n<td align=\"left\">请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分</td>\n</tr>\n<tr>\n<td align=\"left\">101</td>\n<td align=\"center\">切换协议</td>\n<td align=\"left\">请求者已要求服务器切换协议，服务器已确认并确认切换</td>\n</tr>\n<tr>\n<td align=\"left\">200</td>\n<td align=\"center\">成功</td>\n<td align=\"left\">服务器已成功处理了请求</td>\n</tr>\n<tr>\n<td align=\"left\">201</td>\n<td align=\"center\">已创建</td>\n<td align=\"left\">请求成功并且服务器创建了新的资源</td>\n</tr>\n<tr>\n<td align=\"left\">202</td>\n<td align=\"center\">已接受</td>\n<td align=\"left\">服务器已接受请求，但尚未处理</td>\n</tr>\n<tr>\n<td align=\"left\">203</td>\n<td align=\"center\">非授权信息</td>\n<td align=\"left\">服务器已经成功处理请求，但返回的信息可能来自另一个源</td>\n</tr>\n<tr>\n<td align=\"left\">204</td>\n<td align=\"center\">无内容</td>\n<td align=\"left\">服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td align=\"left\">205</td>\n<td align=\"center\">重置内容</td>\n<td align=\"left\">服务器成功处理了请求，但内容被重置</td>\n</tr>\n<tr>\n<td align=\"left\">206</td>\n<td align=\"center\">部分内容</td>\n<td align=\"left\">服务器成功处理了部分请求</td>\n</tr>\n<tr>\n<td align=\"left\">300</td>\n<td align=\"center\">多种选择</td>\n<td align=\"left\">针对请求，服务器可执行多种操作</td>\n</tr>\n<tr>\n<td align=\"left\">301</td>\n<td align=\"center\">永久移动</td>\n<td align=\"left\">请求的网页已永久移动到新位置，即永久重定向</td>\n</tr>\n<tr>\n<td align=\"left\">302</td>\n<td align=\"center\">临时移动</td>\n<td align=\"left\">请求的网页暂时跳转到其他页面，即暂时重定向</td>\n</tr>\n<tr>\n<td align=\"left\">303</td>\n<td align=\"center\">查看其他位置</td>\n<td align=\"left\">如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源</td>\n</tr>\n<tr>\n<td align=\"left\">304</td>\n<td align=\"center\">未修改</td>\n<td align=\"left\">此次请求返回的网页未修改，继续使用上次的资源</td>\n</tr>\n<tr>\n<td align=\"left\">305</td>\n<td align=\"center\">使用代理</td>\n<td align=\"left\">请求者应该使用代理访问该网页</td>\n</tr>\n<tr>\n<td align=\"left\">307</td>\n<td align=\"center\">临时重定向</td>\n<td align=\"left\">请求的资源临时从其他位置响应</td>\n</tr>\n<tr>\n<td align=\"left\">400</td>\n<td align=\"center\">错误请求</td>\n<td align=\"left\">服务器无法解析该请求</td>\n</tr>\n<tr>\n<td align=\"left\">401</td>\n<td align=\"center\">未授权</td>\n<td align=\"left\">请求没有进行身份验证或验证未通过</td>\n</tr>\n<tr>\n<td align=\"left\">403</td>\n<td align=\"center\">禁止访问</td>\n<td align=\"left\">服务器拒绝此请求</td>\n</tr>\n<tr>\n<td align=\"left\">404</td>\n<td align=\"center\">未找到</td>\n<td align=\"left\">服务器找不到请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">405</td>\n<td align=\"center\">方法禁用</td>\n<td align=\"left\">服务器禁用了请求中指定的方法</td>\n</tr>\n<tr>\n<td align=\"left\">406</td>\n<td align=\"center\">不接受</td>\n<td align=\"left\">无法使用请求的内容响应请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">407</td>\n<td align=\"center\">需要代理授权</td>\n<td align=\"left\">请求者需要使用代理授权</td>\n</tr>\n<tr>\n<td align=\"left\">408</td>\n<td align=\"center\">请求超时</td>\n<td align=\"left\">服务器请求超时</td>\n</tr>\n<tr>\n<td align=\"left\">409</td>\n<td align=\"center\">冲突</td>\n<td align=\"left\">服务器在完成请求时发生冲突</td>\n</tr>\n<tr>\n<td align=\"left\">410</td>\n<td align=\"center\">已删除</td>\n<td align=\"left\">请求的资源已永久删除</td>\n</tr>\n<tr>\n<td align=\"left\">411</td>\n<td align=\"center\">需要有效长度</td>\n<td align=\"left\">服务器不接受不含有效内容长度标头字段的请求</td>\n</tr>\n<tr>\n<td align=\"left\">412</td>\n<td align=\"center\">未满足前提条件</td>\n<td align=\"left\">服务器未满足请求者在请求中设置的其中一个前提条件</td>\n</tr>\n<tr>\n<td align=\"left\">413</td>\n<td align=\"center\">请求实体过大</td>\n<td align=\"left\">请求实体过大，超出服务器的处理能力</td>\n</tr>\n<tr>\n<td align=\"left\">415</td>\n<td align=\"center\">请求URL过长</td>\n<td align=\"left\">请求的网址过长，服务器无法处理</td>\n</tr>\n<tr>\n<td align=\"left\">416</td>\n<td align=\"center\">请求范围不符</td>\n<td align=\"left\">页面无法提供请求页面支持</td>\n</tr>\n<tr>\n<td align=\"left\">417</td>\n<td align=\"center\">未满足期望值</td>\n<td align=\"left\">服务器为满足期望请求标头字段的要求</td>\n</tr>\n<tr>\n<td align=\"left\">500</td>\n<td align=\"center\">服务器内部错误</td>\n<td align=\"left\">服务器遇到错误，无法完成请求</td>\n</tr>\n<tr>\n<td align=\"left\">501</td>\n<td align=\"center\">未实现</td>\n<td align=\"left\">服务器不具备完成请求的功能</td>\n</tr>\n<tr>\n<td align=\"left\">502</td>\n<td align=\"center\">错误网关</td>\n<td align=\"left\">服务器作为网关或代理，从上游服务器收到无效响应</td>\n</tr>\n<tr>\n<td align=\"left\">503</td>\n<td align=\"center\">服务不可用</td>\n<td align=\"left\">服务器目前无法使用</td>\n</tr>\n<tr>\n<td align=\"left\">504</td>\n<td align=\"center\">网关超时</td>\n<td align=\"left\">服务器作为网关或代理，但是没有及时从上游服务器收到响应</td>\n</tr>\n<tr>\n<td align=\"left\">505</td>\n<td align=\"center\">HTTP版本不支持</td>\n<td align=\"left\">服务器不支持请求中所用的HTTP协议版本</td>\n</tr>\n</tbody></table>\n<p>响应头包含了服务器对请求的应答信息，如<code>Content-Type</code>、<code>Server</code>、<code>Set-Cookie</code>等。下面简要说明一些常用的响应头信息。 </p>\n<ul>\n<li><code>Date</code>：标识响应产生的时间。</li>\n<li><code>Last-Modified</code>：指定资源的最后修改时间。</li>\n<li><code>Content-Encoding</code>：指定响应内容的编码。</li>\n<li><code>Server</code>：包含服务器的信息，比如名称、版本号等。</li>\n<li><code>Content-Type</code>：文档类型，指定返回的数据类型是什么，如<code>text/html</code>代表返回<code>HTML</code>文档，<code>application/x-javascript</code>则代表返回<code>JavaScript</code>文件，<code>image/jpeg</code>则代表返回图片。</li>\n<li><code>Set-Cookie</code>：设置<code>Cookies</code>。响应头中的<code>Set-Cookie</code>告诉浏览器需要将此内容放在<code>Cookies</code>中，下次请求携带<code>Cookies</code>请求。</li>\n<li><code>Expires</code>：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li>\n</ul>\n<h3 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h3><p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的<code>HTML</code>代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"响应体\"></p>\n<p>在浏览器开发者工具中点击<code>Response</code>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、<code>JSON</code>数据等，然后从中做相应内容的提取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h2><p><code>URI （Uniform Resource Identifier）</code> 即<strong>统一资源标志符</strong>。<br><code>URL （Uniform Resource Locator</code> 即<strong>统一资源定位符</strong>。</p>\n<p>例如：<br><code>https://github.com/favicon.ico</code>既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称<code>favicon.ico</code>。</p>\n<p>URL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。</p>\n<p>URI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。</p>\n<h2 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h2><p><code>Hypertext</code>，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如<code>img</code>显示图片，<code>p</code>指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码<code>HTML</code>就可以称作超文本。</p>\n<h2 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h2><p><code>HTTP</code>的全称是Hyper Text Transfer Protocol，中文名叫作<strong>超文本传输协议</strong>，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是<code>HTTP 1.1</code>版本。</p>\n<p><code>HTTPS</code>的全称是<code>Hyper Text Transfer Protocol over Secure Socket Layer</code>，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入<code>SSL</code>层，简称为<code>HTTPS</code>。</p>\n<p><code>HTTPS</code>的安全基础是<code>SSL</code>，因此通过它传输的内容都是经过<code>SSL</code>加密的，它的主要作用可以分为两种：</p>\n<ul>\n<li>建立一个信息安全通道，来保证数据传输的安全。</li>\n<li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过<code>CA</code>机构颁发的安全签章来查询。</li>\n</ul>\n<p>现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：</p>\n<ul>\n<li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。</li>\n<li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。</li>\n<li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li>\n</ul>\n<p>因此，HTTPS 已经已经是大势所趋。</p>\n<h2 id=\"HTTP请求过程\"><a href=\"#HTTP请求过程\" class=\"headerlink\" title=\"HTTP请求过程\"></a>HTTP请求过程</h2><p>我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的<strong>响应</strong>，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：</p>\n<p><img src=\"1.png\" alt=\"传输模型\"></p>\n<p>此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。</p>\n<p>为了更直观地说明这个过程，这里用浏览器的开发者模式下的<code>Network监听组件</code>来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度<code>http://www.baidu.com/</code>，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在<code>Network</code>页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:</p>\n<p><img src=\"Screenshot_2.png\" alt=\"Network监听\"></p>\n<p>我们先观察第一个网络请求，即<code>www.baidu.com</code>，其中各列的含义如下。</p>\n<ul>\n<li>第一列 <code>Name：请求的名称</code>，一般会将 URL的最后一部分内容当作名称。</li>\n<li>第二列 <code>Status：响应的状态码</code>，这里显示为 <code>200</code>，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 </li>\n<li>第三列 <code>Type：请求的文档类型</code>。这里为<code>document</code>，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。</li>\n<li>第四列 <code>Initiator：请求源</code>。用来标记请求是由哪个对象或进程发起的。</li>\n<li>第五列 <code>Size：从服务器下载的文件和请求的资源大小</code>。如果是从缓存中取得的资源，则该列会显示 fromcache。</li>\n<li>第六列 <code>Time：发起请求到获取响应所用的总时间</code>。</li>\n<li>第七列 <code>Waterfall：网络请求的可视化瀑布流</code>。 我们点击这个条目即可看到其更详细的信息，如图所示。</li>\n</ul>\n<p><img src=\"Screenshot_3.png\" alt=\"详细信息\"></p>\n<p>首先是<code>General</code>部分，<code>Request URL</code>为请求的URL，<code>Request Method</code>为请求的方法，<code>Status Code</code>为响应状态码，<code>Remote Address</code>为远程服务器的地址和端口，<code>Referrer Policy</code>为 Referrer判别策略。 </p>\n<p>再继续往下，可以看到，有<code>Response Headers</code>和<code>Request Headers</code>，这分别代表<code>响应头</code>和<code>请求头</code>。请求头里带有许多请求信息，例如<code>浏览器标识、Cookies、Host</code>等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的<code>Response Headers</code>就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p>\n<h2 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h2><p><strong>请求</strong>，由客户端向服务端发出，可以分为4部分内容：<code>请求方法（Request Method</code>、<code>请求的网址（Request URL）</code>、<code>请求头（Request Headers）</code>、<code>请求体（Request Body）</code>。</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>常见的请求方法有两种：<code>GET</code>和<code>POST</code>。 在浏览器中直接输入URL并回车，这便发起了一个<code>GET请求</code>，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为<code>https://www.baidu.com/s?wd=Python</code>，其中URL中包 含了请求的参数信息，这里参数<code>wd</code>表示要搜寻的关键字。<code>POST请求</code>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个<code>POST请求</code>，其数据通常 以表单的形式传输，而不会体现在URL中。</p>\n<p><code>GET</code>和<code>POST</code>请求方法有如下区别。</p>\n<ul>\n<li><code>GET请求</code>中的参数包含在URL里面，数据可以在URL中看到，而<code>POST请求</code>的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li>\n<li><code>GET请求</code>提交的数据最多只有<em>1024字节</em>，而<code>POST请求</code>没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用<code>GET方式</code>请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以<code>POST方式</code>发送。上传文件时，由于文件内容比较大，也会选用<code>POST方式</code>。 我们平常遇到的绝大部分请求都是<code>GET</code>或<code>POST</code>请求，另外还有一些请求方法，如<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>CONNECT</code>、<code>TRACE</code>等，我们简单将其总结为下表。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GET</td>\n<td align=\"left\">请求页面，并返回页面内容</td>\n</tr>\n<tr>\n<td align=\"left\">HEAD</td>\n<td align=\"left\">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td align=\"left\">POST</td>\n<td align=\"left\">大多用于表单提交或上传文件，数据包含在请求体中</td>\n</tr>\n<tr>\n<td align=\"left\">PUT</td>\n<td align=\"left\">从客户端向服务器传送的数据取代指定文档中的内容</td>\n</tr>\n<tr>\n<td align=\"left\">DELETE</td>\n<td align=\"left\">请求服务器删除指定的页面</td>\n</tr>\n<tr>\n<td align=\"left\">CONNECT</td>\n<td align=\"left\">把服务器当作跳板，让服务器代替客户端访问其他网页</td>\n</tr>\n<tr>\n<td align=\"left\">OPTIONS</td>\n<td align=\"left\">允许客户端查看服务器的性能</td>\n</tr>\n<tr>\n<td align=\"left\">TRACE</td>\n<td align=\"left\">回显服务器收到的请求，主要用于测试或诊断</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n<p>请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>请求头，用来说明服务器要使用的附加信息，比较重要的信息有<code>Cookie</code>、<code>Referer</code>、<code>User-Agent</code>等。下面简要说明一些常用的头信息。</p>\n<ul>\n<li><code>Accept</code>：请求报头域，用于指定客户端可接受哪些类型的信息。</li>\n<li><code>Accept-Language</code>：指定客户端可接受的语言类型。</li>\n<li><code>Accept-Encoding</code>：指定客户端可接受的内容编码。</li>\n<li><code>Host</code>：用于指定请求资源的主机<code>IP</code>和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li>\n<li><code>Cookie</code>：也常用复数形式<code>Cookies</code>，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是<code>Cookies</code>的功劳。<code>Cookies</code>里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上<code>Cookies</code>并将其发送给服务器，服务器通过<code>Cookies</code>识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li>\n<li><code>Referer</code>：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li>\n<li><code>User-Agent</code>：简称<code>UA</code>，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li>\n<li><code>Content-Type</code>：也叫互联网媒体类型<code>（Internet Media Type）</code>或者<code>MIME类型</code>，在<code>HTTP</code>协议消息头中，它用来表示具体请求中的媒体类型信息。例如，<code>text/html</code>代表<code>HTML</code>格式，<code>image/gif</code>代表<code>GIF</code>图片，<code>application/json</code>代表<code>JSON</code>类型，更多对应关系可以查看此对照表：<code>http://tool.oschina.net/commons</code>。</li>\n</ul>\n<p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p>\n<h3 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h3><p>请请求体一般承载的内容是<code>POST</code>请求中的表单数据，而对于<code>GET</code>请求，请求体则为空。</p>\n<p>登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意<code>Request Headers</code>中指定<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>。只有设置<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>，才会以表单数据的形式提交。另外，我们也可以将<code>Content-Type</code>设置为<code>application/json</code>来提交<code>JSON</code>数据，或者设置为<code>multipart/form-data</code>来上传文件。 </p>\n<p>表格中列出了<code>Content-Type</code>和<code>POST</code>提交数据方式的关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Content-Type</th>\n<th align=\"left\">提交数据的方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">application/x-www-form-urlencodeed</td>\n<td align=\"left\">表单数据</td>\n</tr>\n<tr>\n<td align=\"left\">multipart/form-data</td>\n<td align=\"left\">表单文件上传</td>\n</tr>\n<tr>\n<td align=\"left\">application/json</td>\n<td align=\"left\">序列化JSON数据</td>\n</tr>\n<tr>\n<td align=\"left\">text/xml</td>\n<td align=\"left\">XML数据</td>\n</tr>\n</tbody></table>\n<p>在爬虫中，如果要构造<code>POST</code>请求，需要使用正确的<code>Content-Type</code>，并了解各种请求库的各个参数设置时使用的是哪种<code>Content-Type</code>，不然可能会导致<code>POST</code>提交后无法正常响应。</p>\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><p>响应，由服务端返回给客户端，可以分为三部分：<code>响应状态码（Response Status Code）</code>、<code>响应头（Response Headers）</code>和<code>响应体（Response Body）</code>。</p>\n<h3 id=\"响应状态码\"><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<code>200</code>代表服务器正常响应，<code>404</code>代表页面未找到，<code>500</code>代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为<code>200</code>，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">状态码</th>\n<th align=\"center\">说明</th>\n<th align=\"left\">详情</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">100</td>\n<td align=\"center\">继续</td>\n<td align=\"left\">请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分</td>\n</tr>\n<tr>\n<td align=\"left\">101</td>\n<td align=\"center\">切换协议</td>\n<td align=\"left\">请求者已要求服务器切换协议，服务器已确认并确认切换</td>\n</tr>\n<tr>\n<td align=\"left\">200</td>\n<td align=\"center\">成功</td>\n<td align=\"left\">服务器已成功处理了请求</td>\n</tr>\n<tr>\n<td align=\"left\">201</td>\n<td align=\"center\">已创建</td>\n<td align=\"left\">请求成功并且服务器创建了新的资源</td>\n</tr>\n<tr>\n<td align=\"left\">202</td>\n<td align=\"center\">已接受</td>\n<td align=\"left\">服务器已接受请求，但尚未处理</td>\n</tr>\n<tr>\n<td align=\"left\">203</td>\n<td align=\"center\">非授权信息</td>\n<td align=\"left\">服务器已经成功处理请求，但返回的信息可能来自另一个源</td>\n</tr>\n<tr>\n<td align=\"left\">204</td>\n<td align=\"center\">无内容</td>\n<td align=\"left\">服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td align=\"left\">205</td>\n<td align=\"center\">重置内容</td>\n<td align=\"left\">服务器成功处理了请求，但内容被重置</td>\n</tr>\n<tr>\n<td align=\"left\">206</td>\n<td align=\"center\">部分内容</td>\n<td align=\"left\">服务器成功处理了部分请求</td>\n</tr>\n<tr>\n<td align=\"left\">300</td>\n<td align=\"center\">多种选择</td>\n<td align=\"left\">针对请求，服务器可执行多种操作</td>\n</tr>\n<tr>\n<td align=\"left\">301</td>\n<td align=\"center\">永久移动</td>\n<td align=\"left\">请求的网页已永久移动到新位置，即永久重定向</td>\n</tr>\n<tr>\n<td align=\"left\">302</td>\n<td align=\"center\">临时移动</td>\n<td align=\"left\">请求的网页暂时跳转到其他页面，即暂时重定向</td>\n</tr>\n<tr>\n<td align=\"left\">303</td>\n<td align=\"center\">查看其他位置</td>\n<td align=\"left\">如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源</td>\n</tr>\n<tr>\n<td align=\"left\">304</td>\n<td align=\"center\">未修改</td>\n<td align=\"left\">此次请求返回的网页未修改，继续使用上次的资源</td>\n</tr>\n<tr>\n<td align=\"left\">305</td>\n<td align=\"center\">使用代理</td>\n<td align=\"left\">请求者应该使用代理访问该网页</td>\n</tr>\n<tr>\n<td align=\"left\">307</td>\n<td align=\"center\">临时重定向</td>\n<td align=\"left\">请求的资源临时从其他位置响应</td>\n</tr>\n<tr>\n<td align=\"left\">400</td>\n<td align=\"center\">错误请求</td>\n<td align=\"left\">服务器无法解析该请求</td>\n</tr>\n<tr>\n<td align=\"left\">401</td>\n<td align=\"center\">未授权</td>\n<td align=\"left\">请求没有进行身份验证或验证未通过</td>\n</tr>\n<tr>\n<td align=\"left\">403</td>\n<td align=\"center\">禁止访问</td>\n<td align=\"left\">服务器拒绝此请求</td>\n</tr>\n<tr>\n<td align=\"left\">404</td>\n<td align=\"center\">未找到</td>\n<td align=\"left\">服务器找不到请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">405</td>\n<td align=\"center\">方法禁用</td>\n<td align=\"left\">服务器禁用了请求中指定的方法</td>\n</tr>\n<tr>\n<td align=\"left\">406</td>\n<td align=\"center\">不接受</td>\n<td align=\"left\">无法使用请求的内容响应请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">407</td>\n<td align=\"center\">需要代理授权</td>\n<td align=\"left\">请求者需要使用代理授权</td>\n</tr>\n<tr>\n<td align=\"left\">408</td>\n<td align=\"center\">请求超时</td>\n<td align=\"left\">服务器请求超时</td>\n</tr>\n<tr>\n<td align=\"left\">409</td>\n<td align=\"center\">冲突</td>\n<td align=\"left\">服务器在完成请求时发生冲突</td>\n</tr>\n<tr>\n<td align=\"left\">410</td>\n<td align=\"center\">已删除</td>\n<td align=\"left\">请求的资源已永久删除</td>\n</tr>\n<tr>\n<td align=\"left\">411</td>\n<td align=\"center\">需要有效长度</td>\n<td align=\"left\">服务器不接受不含有效内容长度标头字段的请求</td>\n</tr>\n<tr>\n<td align=\"left\">412</td>\n<td align=\"center\">未满足前提条件</td>\n<td align=\"left\">服务器未满足请求者在请求中设置的其中一个前提条件</td>\n</tr>\n<tr>\n<td align=\"left\">413</td>\n<td align=\"center\">请求实体过大</td>\n<td align=\"left\">请求实体过大，超出服务器的处理能力</td>\n</tr>\n<tr>\n<td align=\"left\">415</td>\n<td align=\"center\">请求URL过长</td>\n<td align=\"left\">请求的网址过长，服务器无法处理</td>\n</tr>\n<tr>\n<td align=\"left\">416</td>\n<td align=\"center\">请求范围不符</td>\n<td align=\"left\">页面无法提供请求页面支持</td>\n</tr>\n<tr>\n<td align=\"left\">417</td>\n<td align=\"center\">未满足期望值</td>\n<td align=\"left\">服务器为满足期望请求标头字段的要求</td>\n</tr>\n<tr>\n<td align=\"left\">500</td>\n<td align=\"center\">服务器内部错误</td>\n<td align=\"left\">服务器遇到错误，无法完成请求</td>\n</tr>\n<tr>\n<td align=\"left\">501</td>\n<td align=\"center\">未实现</td>\n<td align=\"left\">服务器不具备完成请求的功能</td>\n</tr>\n<tr>\n<td align=\"left\">502</td>\n<td align=\"center\">错误网关</td>\n<td align=\"left\">服务器作为网关或代理，从上游服务器收到无效响应</td>\n</tr>\n<tr>\n<td align=\"left\">503</td>\n<td align=\"center\">服务不可用</td>\n<td align=\"left\">服务器目前无法使用</td>\n</tr>\n<tr>\n<td align=\"left\">504</td>\n<td align=\"center\">网关超时</td>\n<td align=\"left\">服务器作为网关或代理，但是没有及时从上游服务器收到响应</td>\n</tr>\n<tr>\n<td align=\"left\">505</td>\n<td align=\"center\">HTTP版本不支持</td>\n<td align=\"left\">服务器不支持请求中所用的HTTP协议版本</td>\n</tr>\n</tbody></table>\n<p>响应头包含了服务器对请求的应答信息，如<code>Content-Type</code>、<code>Server</code>、<code>Set-Cookie</code>等。下面简要说明一些常用的响应头信息。 </p>\n<ul>\n<li><code>Date</code>：标识响应产生的时间。</li>\n<li><code>Last-Modified</code>：指定资源的最后修改时间。</li>\n<li><code>Content-Encoding</code>：指定响应内容的编码。</li>\n<li><code>Server</code>：包含服务器的信息，比如名称、版本号等。</li>\n<li><code>Content-Type</code>：文档类型，指定返回的数据类型是什么，如<code>text/html</code>代表返回<code>HTML</code>文档，<code>application/x-javascript</code>则代表返回<code>JavaScript</code>文件，<code>image/jpeg</code>则代表返回图片。</li>\n<li><code>Set-Cookie</code>：设置<code>Cookies</code>。响应头中的<code>Set-Cookie</code>告诉浏览器需要将此内容放在<code>Cookies</code>中，下次请求携带<code>Cookies</code>请求。</li>\n<li><code>Expires</code>：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li>\n</ul>\n<h3 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h3><p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的<code>HTML</code>代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"响应体\"></p>\n<p>在浏览器开发者工具中点击<code>Response</code>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、<code>JSON</code>数据等，然后从中做相应内容的提取。</p>\n"}],"PostAsset":[{"_id":"source/_posts/web网页基础/Screenshot_1.png","post":"ckolvgfpt000oywxu6hra69wz","slug":"Screenshot_1.png","modified":1,"renderable":1},{"_id":"source/_posts/HTTP基本原理/webp_0.webp","post":"ckolvgfq3000xywxu6ir92rpy","slug":"webp_0.webp","modified":1,"renderable":1},{"_id":"source/_posts/HTTP基本原理/1.png","post":"ckolvgfq3000xywxu6ir92rpy","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/HTTP基本原理/Screenshot_2.png","post":"ckolvgfq3000xywxu6ir92rpy","slug":"Screenshot_2.png","modified":1,"renderable":1},{"_id":"source/_posts/HTTP基本原理/Screenshot_3.png","post":"ckolvgfq3000xywxu6ir92rpy","slug":"Screenshot_3.png","modified":1,"renderable":1},{"_id":"source/_posts/HTTP基本原理/Screenshot_1.png","post":"ckolvgfq3000xywxu6ir92rpy","slug":"Screenshot_1.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckolvgfp00001ywxu9eokel71","category_id":"ckolvgfp70003ywxuafn75vub","_id":"ckolvgfpj000bywxu07wcgsb8"},{"post_id":"ckolvgfp50002ywxu6o2x4132","category_id":"ckolvgfp70003ywxuafn75vub","_id":"ckolvgfpk000eywxuancq8wvp"},{"post_id":"ckolvgfpb0005ywxudl1famty","category_id":"ckolvgfpi000aywxu7x11eez4","_id":"ckolvgfpl000hywxu8v3jf4zw"},{"post_id":"ckolvgfpd0006ywxuhwv30zh2","category_id":"ckolvgfpk000fywxu5m40agtc","_id":"ckolvgfpm000lywxufjpuabhb"},{"post_id":"ckolvgfpw000rywxuaznxh5yg","category_id":"ckolvgfp70003ywxuafn75vub","_id":"ckolvgfq4000yywxua2ba4lpe"},{"post_id":"ckolvgfps000nywxuaq36hz2v","category_id":"ckolvgfpv000pywxugm8h6hdh","_id":"ckolvgfq5000zywxucdb6cxqy"},{"post_id":"ckolvgfq1000uywxuax98d9rn","category_id":"ckolvgfp70003ywxuafn75vub","_id":"ckolvgfq70012ywxu2ysy1hw3"},{"post_id":"ckolvgfq3000xywxu6ir92rpy","category_id":"ckolvgfq2000vywxu2vvk2por","_id":"ckolvgfq70013ywxu3ra212vr"},{"post_id":"ckolvgfpt000oywxu6hra69wz","category_id":"ckolvgfq2000vywxu2vvk2por","_id":"ckolvgfqa0015ywxuc2xeecdq"},{"post_id":"ckolvgfpz000sywxuhd2ncat8","category_id":"ckolvgfq2000vywxu2vvk2por","_id":"ckolvgfqa0017ywxufcajhqwt"}],"PostTag":[{"post_id":"ckolvgfp00001ywxu9eokel71","tag_id":"ckolvgfpa0004ywxub3d2hehg","_id":"ckolvgfpi0009ywxu6jh12v5h"},{"post_id":"ckolvgfp50002ywxu6o2x4132","tag_id":"ckolvgfpa0004ywxub3d2hehg","_id":"ckolvgfpk000dywxu2mfy862y"},{"post_id":"ckolvgfpb0005ywxudl1famty","tag_id":"ckolvgfpj000cywxu2ihm0mzl","_id":"ckolvgfpm000jywxu9mdhehr1"},{"post_id":"ckolvgfpb0005ywxudl1famty","tag_id":"ckolvgfpk000gywxuh9tc2t81","_id":"ckolvgfpm000kywxu0ri9bxae"},{"post_id":"ckolvgfpd0006ywxuhwv30zh2","tag_id":"ckolvgfpl000iywxu7wsu6pcv","_id":"ckolvgfpm000mywxu47ee3zsj"},{"post_id":"ckolvgfpw000rywxuaznxh5yg","tag_id":"ckolvgfpa0004ywxub3d2hehg","_id":"ckolvgfq1000tywxu3tld67vn"},{"post_id":"ckolvgfps000nywxuaq36hz2v","tag_id":"ckolvgfpw000qywxu6nna7a3z","_id":"ckolvgfqa0016ywxu9i8vga0o"},{"post_id":"ckolvgfps000nywxuaq36hz2v","tag_id":"ckolvgfq2000wywxu4hhugygj","_id":"ckolvgfqa0018ywxubuxjbfgu"},{"post_id":"ckolvgfps000nywxuaq36hz2v","tag_id":"ckolvgfq60011ywxufnx897de","_id":"ckolvgfqb001aywxu9c35eapn"},{"post_id":"ckolvgfpt000oywxu6hra69wz","tag_id":"ckolvgfq90014ywxu24v08zok","_id":"ckolvgfqd001dywxu2d7290wo"},{"post_id":"ckolvgfpt000oywxu6hra69wz","tag_id":"ckolvgfqa0019ywxu7me4dz3z","_id":"ckolvgfqd001eywxu0u9whris"},{"post_id":"ckolvgfpt000oywxu6hra69wz","tag_id":"ckolvgfqb001bywxu89wz8rr1","_id":"ckolvgfqd001gywxu265557vf"},{"post_id":"ckolvgfpz000sywxuhd2ncat8","tag_id":"ckolvgfpj000cywxu2ihm0mzl","_id":"ckolvgfqe001hywxuhhwxfexv"},{"post_id":"ckolvgfpz000sywxuhd2ncat8","tag_id":"ckolvgfqc001cywxucwb90ove","_id":"ckolvgfqf001jywxugvop6pq7"},{"post_id":"ckolvgfpz000sywxuhd2ncat8","tag_id":"ckolvgfpw000qywxu6nna7a3z","_id":"ckolvgfqf001kywxu0id2boyq"},{"post_id":"ckolvgfq1000uywxuax98d9rn","tag_id":"ckolvgfqd001fywxu8v0d79j3","_id":"ckolvgfqf001mywxu937sc8jw"},{"post_id":"ckolvgfq1000uywxuax98d9rn","tag_id":"ckolvgfqe001iywxub7prh9nb","_id":"ckolvgfqg001nywxu7n7w5rao"},{"post_id":"ckolvgfq3000xywxu6ir92rpy","tag_id":"ckolvgfqf001lywxufgfx9yag","_id":"ckolvgfqg001oywxu4brh27i1"}],"Tag":[{"name":"Hexo","_id":"ckolvgfpa0004ywxub3d2hehg"},{"name":"http","_id":"ckolvgfpj000cywxu2ihm0mzl"},{"name":"web","_id":"ckolvgfpk000gywxuh9tc2t81"},{"name":"Git","_id":"ckolvgfpl000iywxu7wsu6pcv"},{"name":"python","_id":"ckolvgfpw000qywxu6nna7a3z"},{"name":"多线程","_id":"ckolvgfq2000wywxu4hhugygj"},{"name":"threading","_id":"ckolvgfq60011ywxufnx897de"},{"name":"html","_id":"ckolvgfq90014ywxu24v08zok"},{"name":"css","_id":"ckolvgfqa0019ywxu7me4dz3z"},{"name":"javascript","_id":"ckolvgfqb001bywxu89wz8rr1"},{"name":"爬虫","_id":"ckolvgfqc001cywxucwb90ove"},{"name":"nginx","_id":"ckolvgfqd001fywxu8v0d79j3"},{"name":"https","_id":"ckolvgfqe001iywxub7prh9nb"},{"name":"Http","_id":"ckolvgfqf001lywxufgfx9yag"}]}}