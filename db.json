{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/kr-dark.min.js","path":"js/kr-dark.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/kratosr.min.js","path":"js/kratosr.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/local-search.min.js","path":"js/local-search.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/pjax.min.js","path":"js/pjax.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/snow.min.js","path":"js/snow.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/candy.min.js","path":"js/candy.min.js","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/kr-dark.min.css","path":"css/kr-dark.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/prismjs.min.css","path":"css/prismjs.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/kratosr.min.css","path":"css/kratosr.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/404.webp","path":"images/404.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/about.webp","path":"images/about.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/alipay.webp","path":"images/alipay.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/avatar.webp","path":"images/avatar.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/banner.webp","path":"images/banner.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/banner_dark.webp","path":"images/banner_dark.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/bg.webp","path":"images/bg.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/failure.ico","path":"images/failure.ico","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/logo.webp","path":"images/logo.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/my.webp","path":"images/my.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/psr.webp","path":"images/psr.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/candy.min.js.map","path":"maps/candy.min.js.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kr-dark.min.css.map","path":"maps/kr-dark.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kr-dark.min.js.map","path":"maps/kr-dark.min.js.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kratosr.min.css.map","path":"maps/kratosr.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kratosr.min.js.map","path":"maps/kratosr.min.js.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/light.min.css.map","path":"maps/light.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night-blue.min.css.map","path":"maps/night-blue.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/local-search.min.js.map","path":"maps/local-search.min.js.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night-bright.min.css.map","path":"maps/night-bright.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/wechat.webp","path":"images/wechat.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night-eighties.min.css.map","path":"maps/night-eighties.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night.min.css.map","path":"maps/night.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/pjax.min.js.map","path":"maps/pjax.min.js.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/prismjs.min.css.map","path":"maps/prismjs.min.css.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/snow.min.js.map","path":"maps/snow.min.js.map","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/light.min.css","path":"css/highlight/light.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night-blue.min.css","path":"css/highlight/night-blue.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night-bright.min.css","path":"css/highlight/night-bright.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night.min.css","path":"css/highlight/night.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night-eighties.min.css","path":"css/highlight/night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_10.webp","path":"images/thumb/thumb_10.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_1.webp","path":"images/thumb/thumb_1.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_11.webp","path":"images/thumb/thumb_11.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_12.webp","path":"images/thumb/thumb_12.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_13.webp","path":"images/thumb/thumb_13.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_14.webp","path":"images/thumb/thumb_14.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_15.webp","path":"images/thumb/thumb_15.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_16.webp","path":"images/thumb/thumb_16.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_17.webp","path":"images/thumb/thumb_17.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_18.webp","path":"images/thumb/thumb_18.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_19.webp","path":"images/thumb/thumb_19.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_2.webp","path":"images/thumb/thumb_2.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_20.webp","path":"images/thumb/thumb_20.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_3.webp","path":"images/thumb/thumb_3.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_4.webp","path":"images/thumb/thumb_4.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_5.webp","path":"images/thumb/thumb_5.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_6.webp","path":"images/thumb/thumb_6.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_7.webp","path":"images/thumb/thumb_7.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_8.webp","path":"images/thumb/thumb_8.webp","modified":0,"renderable":1},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_9.webp","path":"images/thumb/thumb_9.webp","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Ajax爬取案例实战.md","hash":"162e733be2c18b7497994462409e2760b0f634af","modified":1623727451420},{"_id":"source/_posts/Ajax的原理和解析.md","hash":"6edfc2c572aa9fced21049f592c1adf46e3d7679","modified":1623727451428},{"_id":"source/_posts/HTTP基本原理.md","hash":"9af756c40867902147fda856a40260ddf8bdc631","modified":1623727451442},{"_id":"source/_posts/Hexo创建博客.md","hash":"8db5187c9ea50fc851ac59531030e0fa4b716996","modified":1623727451460},{"_id":"source/_posts/Hexo在腾讯云的部署.md","hash":"c359cdfc520565ee06b574ca1438e3bedcd0e186","modified":1623727451461},{"_id":"source/_posts/MongoDB数据库的使用.md","hash":"dad1070c5b7335643cdcf230b2ed5088d8d16b74","modified":1623727451461},{"_id":"source/_posts/Nginx配置详解.md","hash":"283ef858a7ce86d8003c91024860ddc34228baa4","modified":1623727451462},{"_id":"source/_posts/Selenium的基本使用.md","hash":"bbbb8c0dc7e9c265115b548318f1ed7625f4d535","modified":1623727451475},{"_id":"source/_posts/Pyquery的使用.md","hash":"acd799f76a0d3649ddbb968cd840cc3d0eb71406","modified":1623727451474},{"_id":"source/_posts/go语言的下载和安装.md","hash":"247de876ffd5fe4caa2f3fdf35716d3fd02b2c71","modified":1623727451489},{"_id":"source/_posts/Session和Cookies.md","hash":"3d0b1adda8912408aaf24bc105a0ac8a4116df75","modified":1623727451487},{"_id":"source/_posts/docker的安装.md","hash":"e9a0ec277facfe58ae7f4252471d107d5fd0a545","modified":1623727451488},{"_id":"source/_posts/git常用命令.md","hash":"102c6c7f510e706d38dff6657467df081c3d348c","modified":1623727451488},{"_id":"source/_posts/python多线程基本原理.md","hash":"dcf4ec8fa3453d17d6ff8d8cb8d83c255e2074d1","modified":1623727451492},{"_id":"source/_posts/python多进程基本原理.md","hash":"9b5a5939766734cc95b7ff71b728e3aca964975c","modified":1623727451492},{"_id":"source/_posts/python的内置类型.md","hash":"5dc53375cd4cb0f0e38fe6c595fb4ea4bb1988f1","modified":1623727451493},{"_id":"source/_posts/requests库的基本使用.md","hash":"d1afb97e68860434273e1b94ba7858d02072c17d","modified":1623727451496},{"_id":"source/_posts/scrapy框架介绍.md","hash":"875fd4f20540b0d3fd9eb08f7ba8588be09d9bf1","modified":1623727451518},{"_id":"source/_posts/request、pyquest和pymongodb案例实战.md","hash":"3795f2051355c62ac045c4aa3799cf806d23d54f","modified":1623727451503},{"_id":"source/_posts/scrapy的基本使用.md","hash":"ee31cbc9eddf581855e560ca4f0099b25aeadb6d","modified":1623727451519},{"_id":"source/_posts/web网页基础.md","hash":"26a93872792c2840cc55a365f73813381ae9c580","modified":1623727451529},{"_id":"source/_posts/内篇（一）——逍遥游.md","hash":"aeaf61822d28221eecb7d053e03adbeba6709718","modified":1623727451542},{"_id":"source/_posts/在Hexo博客中嵌入外链视频.md","hash":"3cab8feaf710e34ed508ad8b1da1ef00844b61b9","modified":1623727451544},{"_id":"source/_posts/内篇（二）——齐物论.md","hash":"f1ca1912daf51f75e0f4ba26439000b06f92ed4c","modified":1623727451544},{"_id":"source/_posts/基于centos搭建个人网盘.md","hash":"fdf25cbdff219f2d942747904da5e3574d43ff54","modified":1623727451545},{"_id":"source/_posts/基于docker部署code-server.md","hash":"efe6de336152a8548d51e7dfd00251f6316ac0ba","modified":1623727451545},{"_id":"source/_posts/正则表达式.md","hash":"ed624e1154e9b813d742a7a327819f7e4ef3e477","modified":1623727451548},{"_id":"source/_posts/爬虫的基本原理.md","hash":"98a73788d56e55ff5c04b578e3f9c93043f2a35a","modified":1623727451551},{"_id":"source/_posts/腾讯云主机CPU占用百分百.md","hash":"d54ed3cdd0687dec15acbf2927e072c5efe2684f","modified":1623727451551},{"_id":"source/_posts/腾讯云配置ssl证书.md","hash":"272f5edbc3da736a58da9d6e90fa3d728aebc344","modified":1623727451557},{"_id":"source/about/index.md","hash":"3ac6ed3103034cb1a337d5014d325ba8d3bc068e","modified":1623727451558},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_4.webp","hash":"c2575022523ef6572d0c5325af42f8df21100be8","modified":1621929954000},{"_id":"source/_posts/HTTP基本原理/webp_0.webp","hash":"5cda1aef076a1f77cacb4ed2a194e2834394de31","modified":1620656894000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_2.webp","hash":"4deffbe63abf667eb7deab992e6fd5f5d8f19658","modified":1621848164000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_5.webp","hash":"c593a73651cc83f71afd2ec983070f834ab00bec","modified":1621848164000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_6.webp","hash":"74fe29c473536bc554b6f2f7e75f9f81f11f8ac4","modified":1621848460000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_3.webp","hash":"5714174e2273c7a9d85bc4d00a279f81d10f2d7b","modified":1621958980000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_8.webp","hash":"684d8530802e1ce1d5109860337382795a98b148","modified":1622259288000},{"_id":"source/_posts/go语言的下载和安装/Screenshot_1.webp","hash":"bb9781574494804cecbeaf411b9eab8e978b39a6","modified":1622004078000},{"_id":"source/_posts/go语言的下载和安装/Screenshot_2.webp","hash":"9ab82c434734f49b00fa9907ba03aa0c961ea67b","modified":1622008280000},{"_id":"source/_posts/python的内置类型/Screenshot_1.webp","hash":"61f8bfd7758ad8815e38fd4af73bbb51d02e5624","modified":1622259432000},{"_id":"source/_posts/requests库的基本使用/Screenshot_3.webp","hash":"c352952ce59a50999f2edd69707460e4ea0ef415","modified":1621597184000},{"_id":"source/_posts/requests库的基本使用/Screenshot_4.webp","hash":"9a8d44d9355d48fea9a16b85db6f94741b194ec7","modified":1621600584000},{"_id":"source/_posts/scrapy框架介绍/Screenshot_1.webp","hash":"b75a099cb7f90ef9be9f8079c762c5871b2910f5","modified":1622283948000},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_1.webp","hash":"6f8eb27774d4a5f4182842151beacc2819c15096","modified":1621929954000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_4.webp","hash":"d7e798aa6b3b6ad7a22298853c9f234137d38145","modified":1621848164000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_7.webp","hash":"e5d673561d5370a49d9f89e48a528f3786ef0f76","modified":1621848892000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_2.webp","hash":"1df3e2110351c6d598a414347d2d715b7ac4b3a9","modified":1621957862000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_5.webp","hash":"728868e8a29dd0a1dea0427c8d244e0de4e7aa70","modified":1621958056000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_1.webp","hash":"4c1dbd186f6472603d353c031b02181215d740e5","modified":1621957862000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_4.webp","hash":"6c9be21e922b1cb4099f8ed5a34707d7286005b3","modified":1621958980000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_7.webp","hash":"3d9f705648fa9375ae9143fc280082f493aa0f3c","modified":1622259288000},{"_id":"source/_posts/requests库的基本使用/Screenshot_2.webp","hash":"1a421421def18043cc6bb9583929f0c4c8813c73","modified":1621583494000},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_3.webp","hash":"bca12af16f5833c7f371dfc3c3eca274820bd8a5","modified":1621779668000},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_4.webp","hash":"bc77d73a8f74763fac132af7223e56986c3b5fb3","modified":1621779668000},{"_id":"source/_posts/scrapy的基本使用/Screenshot_2.webp","hash":"b92ca60213e79ed1efc641db00d2a4c0113074b7","modified":1622348002000},{"_id":"themes/Kratos-Rebirth-1.6.3/Kratos-Rebirth-Manual.md","hash":"f121d1cbaec49b0dbffbb6443c887d431f7ee841","modified":1623727451559},{"_id":"themes/Kratos-Rebirth-1.6.3/LICENSE","hash":"1eba7caf09a39110ad2f542e3ed8700d1a69c6d3","modified":1623727451560},{"_id":"themes/Kratos-Rebirth-1.6.3/ReadMe.md","hash":"56b024e036d5eb1b3411130bdc5b586c7042104b","modified":1623727451561},{"_id":"themes/Kratos-Rebirth-1.6.3/package.json","hash":"4a008c56af87b2c63d329b3872e17a44529556d5","modified":1623727451580},{"_id":"themes/Kratos-Rebirth-1.6.3/_config.yml","hash":"03e959bbc4a25b1912214300fa6a8b1520fd221c","modified":1621843798000},{"_id":"themes/Kratos-Rebirth-1.6.3/_config.yml.example","hash":"d1fc4d9403617602cacd268000fc3b8fff87f067","modified":1623727451562},{"_id":"themes/Kratos-Rebirth-1.6.3/gulpfile.js","hash":"711430d4be505a3674cc530540a48c112b3f42be","modified":1623727451563},{"_id":"themes/Kratos-Rebirth-1.6.3/languages/zh-CN.yml","hash":"08638ac462cbd495b612d4b131cb2a34180229cb","modified":1623727451564},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/archive.ejs","hash":"8de88e53b499322599025da6395b6b4a8c489bad","modified":1623727451577},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/404.js","hash":"c8c2775fb0afe8b5d010a36dd50eaf6b72a36f77","modified":1623727451581},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/index.ejs","hash":"554282c0cb749b397b12ab5855117015eb44e1dc","modified":1623727451578},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/layout.ejs","hash":"b5ee6bc72a4b0499f0044aabc20a7866d7304a2e","modified":1623727451578},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/cdn-optimize-helpers.js","hash":"063a81cb5d2888f52c8190aae25c29e6de41172b","modified":1623727451582},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/check-update.js","hash":"645a1f30fa21237b256d5fa7c0a0923032728901","modified":1623727451582},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/friends.js","hash":"2d9395526e74bfcdb46eaf3aac2dc0be748ff0b8","modified":1623727451583},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/genconfig.js","hash":"bc3a7d5dd918fe1e4da17098e2f60a34e9cbbe50","modified":1623727451584},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/search.js","hash":"e477a7e9a0ae009056120d4fd2040a296c28adad","modified":1623727451584},{"_id":"themes/Kratos-Rebirth-1.6.3/scripts/tag-widgets.js","hash":"0dda6634cbfb60594ba06b16d30532f9fe358339","modified":1623727451585},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/page.ejs","hash":"e7d5671d342ac7c594b493d30cddcc15206cd5e6","modified":1623727451579},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1621757054000},{"_id":"source/_posts/基于docker部署code-server/Screenshot_1.webp","hash":"b6358b7ac75a45bce36592548e5c732f41be2aa1","modified":1621937278000},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/post.ejs","hash":"7baed15e1fbce4585bc5e3bd940ec1edf114b5d2","modified":1623727451579},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_comments/disqus.ejs","hash":"e107a146259123fe3c1bdde4d6a33836efdcd36c","modified":1623727451565},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_comments/disqusjs.ejs","hash":"be784505c370fa683189a5220c51119e0afb57d5","modified":1623727451566},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_comments/twikoo.ejs","hash":"cf4659ba38d851c114c91e63f4e465538fe7b75a","modified":1623727451566},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_comments/valine.ejs","hash":"30942c85e9e8471e2885237b0589cf3ecf8cc0dc","modified":1623727451567},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_partial/after-footer.ejs","hash":"d7e2ebcd3763d233f8335caef6dc5e55d54ea952","modified":1623727451569},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_comments/waline.ejs","hash":"ed05efb5c1a13b23e3fc50a4061434e82b82bdaf","modified":1623727451567},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_partial/head.ejs","hash":"d8ae70df82dfa6948cd6a7be5405986713476bd6","modified":1623727451570},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_partial/footer.ejs","hash":"825a989ffe78fc18327a62801b6dccb580f9b2f6","modified":1623727451570},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_partial/header.ejs","hash":"f54adfdbd4341cd25d4b0941a97c225eed6f69e5","modified":1623727451571},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_pages/search-page.ejs","hash":"7a3fd8ceddd14dadf4e419b453bf799273430b75","modified":1623727451568},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_pages/404.ejs","hash":"0769195fc28d4153607bfd1ff78efdcd8f907710","modified":1623727451568},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_partial/sidebar.ejs","hash":"33395d7d7dcfdbf7d451b320ed778ddc9409cbc3","modified":1623727451571},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_plugins/mermaid.ejs","hash":"3f7ed41957dda08d4e185b177685f3201bb7af60","modified":1623727451572},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_tools/player.ejs","hash":"5c3ad00ab73158d9c2a5f94a637369ffba676131","modified":1623727451573},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_tools/share.ejs","hash":"0384875f82a28bc4ab3fa3383f9471da16e37c27","modified":1623727451573},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_widget/category.ejs","hash":"7141cc95eeb460f016d5cb16ce1121423a680f64","modified":1623727451575},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_widget/about.ejs","hash":"f355b8e8e1e9f2c912c77796ff616940cc34acba","modified":1623727451574},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/kr-dark.min.js","hash":"88c53d1b213f43e00f29007f0af8ceeba862a792","modified":1623727451619},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_widget/posts.ejs","hash":"a95e8afadec17d644d590769ccf6a82911a544f9","modified":1623727451575},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/kratosr.min.js","hash":"ab52ef5e952d6f011aff6cef0643f204eb5d8189","modified":1623727451620},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/snow.min.js","hash":"da76343827179b60fb0ff37f5e174e0d1a942715","modified":1623727451622},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/pjax.min.js","hash":"9e019ddcca0e5fad1728c577ea53d9df27ba3153","modified":1623727451622},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/candy.min.js","hash":"498e898190d24fc715c3ea9dd4daf671b88356c2","modified":1623727451619},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/kr-dark.min.css","hash":"f7b46640737a826b1a9e47f2e01cd594ea2d9bef","modified":1623727451589},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_widget/toc.ejs","hash":"3f605d61df121f80b101eaf6ff6031d3dad5320e","modified":1623727451576},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/kratosr.min.css","hash":"5e346823c3171f6c91d00de969801442e3429599","modified":1623727451589},{"_id":"themes/Kratos-Rebirth-1.6.3/layout/_widget/tagcloud.ejs","hash":"463a1e41aeaaff8b30fc4cff961181a73e007b60","modified":1623727451575},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/prismjs.min.css","hash":"897b51649b0557cf3c018b378b680897a76d991f","modified":1623727451590},{"_id":"themes/Kratos-Rebirth-1.6.3/source/js/local-search.min.js","hash":"b64846254b2ab9f4582d896f01803c20460425f6","modified":1623727451621},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/logo.webp","hash":"ad57efa7bf7cfe2b55857a5e1c917d67e268801d","modified":1621843670000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/candy.min.js.map","hash":"6665b21a65483d2344c471dc5c756c4d387d568b","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kr-dark.min.css.map","hash":"80ee66d1f262f9aa4a9b6960b0f8ff2fec14eb34","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kr-dark.min.js.map","hash":"d021646d1ea23cb79c169ce84799e85e7d19540e","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kratosr.min.js.map","hash":"b0d79ecf02c98ceecc14b9fa64160d186f20662c","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/light.min.css.map","hash":"b32142f58c42be8f25909a5c212364bb5c6fc804","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/local-search.min.js.map","hash":"b831de42d16beb1d8dd9a2d548422cbf1ee04314","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night-blue.min.css.map","hash":"311ec6106ef1523d8725b5e2b73203adefce0599","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night-bright.min.css.map","hash":"dd0d8c53d2794a7f64a48beaefc818ad37b74a76","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night-eighties.min.css.map","hash":"e283eba0a0ce4f94234d725b13d018898ecad8d7","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/night.min.css.map","hash":"98d68627b48700be8632f377bbe23adc2fa1c664","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/pjax.min.js.map","hash":"99e4cc9e361aeca9faf20a01b673e81d8fa4b895","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/prismjs.min.css.map","hash":"0c8ce3221dc6e6c95ae2a31f26d5c90bf090077c","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/src/js/candy.js","hash":"92f106471f1b446226da12e2f407cd9c71beb6d8","modified":1623727451633},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/snow.min.js.map","hash":"7c02278b2e50e5df0b19404baee1d31c2b6c0f76","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/src/js/kr-dark.js","hash":"2f5c290e7cce5dd8e4aa0c8492fc9111064bd7c3","modified":1623727451634},{"_id":"themes/Kratos-Rebirth-1.6.3/src/js/kratosr.js","hash":"a7e77063e17551aec088110a627a792cd3a08a85","modified":1623727451635},{"_id":"themes/Kratos-Rebirth-1.6.3/src/js/local-search.js","hash":"8e5f05a61c195f5e5ffcf0834ac83dc154eb34c7","modified":1623727451636},{"_id":"themes/Kratos-Rebirth-1.6.3/src/js/pjax.js","hash":"466805aedd764376d4bd94edfc05d38d9213f956","modified":1623727451636},{"_id":"source/_posts/正则表达式/Screenshot_1.webp","hash":"e1c8833a8026b1e8c0255be14f3cef05117f8611","modified":1621605760000},{"_id":"themes/Kratos-Rebirth-1.6.3/src/js/snow.js","hash":"f38cf6daf376da460d8bf58506dce37789500d68","modified":1623727451637},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/kr-dark.scss","hash":"d9056a938776f64f25b9ca47c7c30ff514c5768a","modified":1623727451641},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/kratosr.scss","hash":"bed24d526511014d8b15b983d2410e25b3a6b00e","modified":1623727451643},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/prismjs.scss","hash":"2575922312729ec354d5889e28f4860917a9cac6","modified":1623727451643},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/light.min.css","hash":"233726caed5966fd44bda443410a40e305c35b47","modified":1623727451586},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night-blue.min.css","hash":"b7163c860fe4becb4bb4c5804f0c43b8bd1f18b7","modified":1623727451587},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night-bright.min.css","hash":"a8f6dfe093e5f802fb531cc1177207ce8c6fce27","modified":1623727451587},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night-eighties.min.css","hash":"f39c1205e030454e5724ff98b1703a1fddfe91f2","modified":1623727451588},{"_id":"themes/Kratos-Rebirth-1.6.3/source/css/highlight/night.min.css","hash":"12b41d97f274bc1be0c487f0f6c1d443a4cf7d60","modified":1623727451588},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1621757054000},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/highlight/style.scss","hash":"6b9174d41d9d397e7498309eb16af5bb86ebb2ed","modified":1623727451638},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/highlight/theme/night-blue.scss","hash":"9d7b9690331b850e6b92da10e57254e2bd9d294d","modified":1623727451639},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/highlight/theme/light.scss","hash":"1fa05c806415127e3833315adb10443ca128b927","modified":1623727451639},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_2.webp","hash":"703e0f2823f2a8359bec3058626043ce79c90fac","modified":1621929954000},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/highlight/theme/night-bright.scss","hash":"8c1a12a963c0ff01d46f4e452b2c8ac7419465bd","modified":1623727451640},{"_id":"source/_posts/HTTP基本原理/1.png","hash":"c7b40fc10675514ee4a907cd6ed5b451b2c84491","modified":1620656792000},{"_id":"source/_posts/Nginx配置详解/1.jpg","hash":"9a45816cf19b79bf32997741a5411fff7f414714","modified":1621312366000},{"_id":"source/_posts/scrapy的基本使用/Screenshot_1.webp","hash":"e7b29693fcdb1ad13eb3f70c2c273913f282254f","modified":1622337232000},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/highlight/theme/night-eighties.scss","hash":"770bf47845991ce76ccb87e02ea63e1158b74b39","modified":1623727451640},{"_id":"themes/Kratos-Rebirth-1.6.3/src/scss/highlight/theme/night.scss","hash":"3bad0f8ac6be471a6d290f8b72a8ece8ca52f13e","modified":1623727451641},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_3.webp","hash":"0673e9e7afc64082d4ae24e1a2bb6a63ea40d89a","modified":1621929954000},{"_id":"source/_posts/HTTP基本原理/Screenshot_3.png","hash":"378fabca423cb07c62e41766928483465e65f9a2","modified":1620661064000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_1.webp","hash":"3b76c1cd462a5d790ee6ee6913a4fe0ea9939e4b","modified":1621848164000},{"_id":"source/_posts/HTTP基本原理/Screenshot_1.png","hash":"5adb41c8f84a13e121fc0f1c528dd40bbb856deb","modified":1620741928000},{"_id":"source/_posts/Selenium的基本使用/Screenshot_6.webp","hash":"222603f02ca72672ef9b37b58272aa7c40c319fc","modified":1621959370000},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_2.webp","hash":"bc928e85f843d46e64bfc84c71ec5e36f02e8a86","modified":1621779668000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_8.webp","hash":"75a2ce77a19e6b163c2721ac000f6b304c1d1a4e","modified":1621848892000},{"_id":"source/_posts/Nginx配置详解/2.jpg","hash":"b607fc3234184e21036463e44ed62842734a0854","modified":1621312790000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/maps/kratosr.min.css.map","hash":"79db71048315b161ee4bd150c02f74bcf2afa6cc","modified":1621757054000},{"_id":"source/_posts/HTTP基本原理/Screenshot_2.png","hash":"ace6846527b33bf22c4956655f0bd6e3c73ae24f","modified":1620660764000},{"_id":"source/_posts/requests库的基本使用/Screenshot_1.webp","hash":"467c01f42023d9f2a9aa0f6a2ff0ef6debc90862","modified":1621595382000},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_6.webp","hash":"d8e5dbb2beadb295313a5f276e03b78c500e7287","modified":1621834096000},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_5.webp","hash":"6ae5131d70f9c23ab81202483fc457b9b19c2142","modified":1621784082000},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_1.webp","hash":"6219480dd4f7f473bcdfaae8209a8d10766d9044","modified":1621779668000},{"_id":"source/_posts/腾讯云主机CPU占用百分百/Screenshot_1.webp","hash":"d5834d609c49df60661bd4c708b36ccd54cd272c","modified":1621937278000},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_3.webp","hash":"05806abf32ac862c1fc0bd6d951a52cec43bc402","modified":1621848164000},{"_id":"source/_posts/Nginx配置详解/3.jpg","hash":"5f1a30aceb878b36ec04bbe54d0bd5b821ebab9b","modified":1621312802000},{"_id":"themes/Kratos-Rebirth-1.6.3/source/images/my.webp","hash":"4ca18265439440b696893bbd8af9501511903a77","modified":1622263304000},{"_id":"source/_posts/scrapy的基本使用/Screenshot_3.webp","hash":"48195fa4642554448c4ffa0e3274ba28776ef1d1","modified":1622348002000},{"_id":"source/_posts/web网页基础/Screenshot_1.png","hash":"4466945441b85dc63432a583c23eec13419f8a5d","modified":1620747740000},{"_id":"public/config/main.json","hash":"65767c0374f3753e6c22ca74a99805eef7d7b163","modified":1622350900490},{"_id":"public/search.json","hash":"5f7238e8be6299b8eda6414593a11de885c8bd14","modified":1622350900490},{"_id":"public/404.html","hash":"b5aec8f5fd1b91038fd0f009693808e9687d0750","modified":1622350900490},{"_id":"public/about/index.html","hash":"71d7edd482cb255aef4e3af85bb949a3d41697fb","modified":1622350900490},{"_id":"public/2021/05/29/scrapy的基本使用/index.html","hash":"393005ea966e1c8bfd30e7730c54f4a781f224bc","modified":1622350900490},{"_id":"public/2021/05/29/scrapy框架介绍/index.html","hash":"8cf2c1ac0dce098115794dff9ff52973a948530f","modified":1622350900490},{"_id":"public/2021/05/29/内篇（二）——齐物论/index.html","hash":"34475489be485b3f14e6278cc12f1c2513c7b62f","modified":1622350900490},{"_id":"public/2021/05/29/内篇（一）——逍遥游/index.html","hash":"fd4299de978b90f11a77a39feffdad991cf782e3","modified":1622350900490},{"_id":"public/2021/05/28/python的内置类型/index.html","hash":"654f5fcdc641c61e9e3db69d29d46716e26cd3bd","modified":1622350900490},{"_id":"public/2021/05/26/go语言的下载和安装/index.html","hash":"d0580aa817a509fda1db1e3edbb1376b53002c95","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/index.html","hash":"ba6056e3887201f565fd9884e596dc7904d71ca1","modified":1622350900490},{"_id":"public/2021/05/25/基于docker部署code-server/index.html","hash":"814306e08f4484f39747109f24fa308600a6be56","modified":1622350900490},{"_id":"public/2021/05/25/腾讯云主机CPU占用百分百/index.html","hash":"752a49f6d63e19606ceb39da5a3fd49712a15aaf","modified":1622350900490},{"_id":"public/2021/05/24/Ajax爬取案例实战/index.html","hash":"d81b0ab857e607756f978830c32a596c495e6df7","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/index.html","hash":"cd373fe593b51e446a5f1fd9dca0600ed9a34797","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/index.html","hash":"c2f3ed638b22c05a2c9cbac555d545e8e8490cc3","modified":1622350900490},{"_id":"public/2021/05/23/MongoDB数据库的使用/index.html","hash":"9ec64f40a9d577620f508589b6036e4f9048c6c7","modified":1622350900490},{"_id":"public/2021/05/23/Pyquery的使用/index.html","hash":"02b01ffb634f7839cc314f60aee9a7983eecb537","modified":1622350900490},{"_id":"public/2021/05/21/正则表达式/index.html","hash":"fb35ab65cd3f3678230ac5cbf6e409ea96250f6e","modified":1622350900490},{"_id":"public/2021/05/20/docker的安装/index.html","hash":"e9ea3bed899377a68a5a720deb80a91ec6c43987","modified":1622350900490},{"_id":"public/2021/05/20/基于centos搭建个人网盘/index.html","hash":"8bf2cbfa10ed17e869ee2ba730d771b9254b41e6","modified":1622350900490},{"_id":"public/2021/05/18/requests库的基本使用/index.html","hash":"045ca7f4e259ac193d7137d3ea80da0ab0dee544","modified":1622350900490},{"_id":"public/2021/05/18/Nginx配置详解/index.html","hash":"a91117ce5aa8ff54601244ec21162b099a0b5be8","modified":1622350900490},{"_id":"public/2021/05/17/python多进程基本原理/index.html","hash":"d444809dea4648eeabe411dc104d12d50693c83d","modified":1622350900490},{"_id":"public/2021/05/12/python多线程基本原理/index.html","hash":"6b7d18d2cc94e88c7f28a537692d25d5eeaad55b","modified":1622350900490},{"_id":"public/2021/05/12/Session和Cookies/index.html","hash":"764ee6a9ac43daa720420caf54b7dc86de881593","modified":1622350900490},{"_id":"public/2021/05/12/爬虫的基本原理/index.html","hash":"2503efccf24381b03f3cd5cb93999544a2415ecb","modified":1622350900490},{"_id":"public/2021/05/11/web网页基础/index.html","hash":"e14a8e9604a8d5c304c56dbecb88fe86a7caba9c","modified":1622350900490},{"_id":"public/2021/05/11/在Hexo博客中嵌入外链视频/index.html","hash":"b4f4a5c8da74cffac9fbfd811e89eddc877815ba","modified":1622350900490},{"_id":"public/2021/05/10/腾讯云配置ssl证书/index.html","hash":"f892284e805f7c1be4bf090a38d1d3fead5aa3f2","modified":1622350900490},{"_id":"public/2021/05/10/Hexo在腾讯云的部署/index.html","hash":"3375b7a2ae5e0d92ae912275bfc187be762bac45","modified":1622350900490},{"_id":"public/2021/05/09/HTTP基本原理/index.html","hash":"fe91d8f32d240efc86cc7c2352c59fb5dd008418","modified":1622350900490},{"_id":"public/2021/05/08/git常用命令/index.html","hash":"0c165d99fdc06177e283cfbb0772850bd4f0bba1","modified":1622350900490},{"_id":"public/2021/05/08/Hexo创建博客/index.html","hash":"48cca9d2b4da6469ab840da88273c46567c71abc","modified":1622350900490},{"_id":"public/archives/index.html","hash":"1f95969b1913bec8bb549e70ac8a70e7cf4bcd80","modified":1622350900490},{"_id":"public/archives/page/2/index.html","hash":"db7d5a2ccfddd66a4181bc65d4452efb43d28dbb","modified":1622350900490},{"_id":"public/archives/page/3/index.html","hash":"3f6112b1fca2e0e01c6a25e768f4f2aa0dd6ee8c","modified":1622350900490},{"_id":"public/archives/2021/index.html","hash":"84cab83985210e545b0007116d0844d8741c4038","modified":1622350900490},{"_id":"public/archives/2021/page/2/index.html","hash":"e7456e1fd8e2bd6684d8d2e5946fc6cf0f1a4ee0","modified":1622350900490},{"_id":"public/archives/2021/page/3/index.html","hash":"9551746a140ab898e64c2868e2d9b8f906d609c3","modified":1622350900490},{"_id":"public/archives/2021/05/index.html","hash":"f35861e70bc2cbc0ac042ab3d7d75a3c5eafee03","modified":1622350900490},{"_id":"public/archives/2021/05/page/2/index.html","hash":"4852d539dfaa16d359ed3213ab2335e020aed177","modified":1622350900490},{"_id":"public/archives/2021/05/page/3/index.html","hash":"9ea314025f8b1f495ca6302259a094d354f5b171","modified":1622350900490},{"_id":"public/categories/爬虫/index.html","hash":"02439af381fe3466fa92c10d4110811804c4f7d4","modified":1622350900490},{"_id":"public/categories/爬虫/page/2/index.html","hash":"8098a67dbe17b224802ac9e004dc5b064691917e","modified":1622350900490},{"_id":"public/categories/博客教程/index.html","hash":"1212d9e4aa415337567bb0d2e7889e83e08a23d6","modified":1622350900490},{"_id":"public/categories/Nginx/index.html","hash":"e19b29096c3c792d0c3678cf3bafea76f489b762","modified":1622350900490},{"_id":"public/categories/Linux/index.html","hash":"15adeee4b211d85ecc6012a4461ef4354246e9c1","modified":1622350900490},{"_id":"public/categories/Git/index.html","hash":"4986986bc60572870c003c6ed4cecf340ed64ff5","modified":1622350900490},{"_id":"public/categories/Go/index.html","hash":"0fef6bb0be11776319c47af4c29a53bc3826241d","modified":1622350900490},{"_id":"public/categories/Python/index.html","hash":"f76f6627405208854245d5712a6e7448942dd4a0","modified":1622350900490},{"_id":"public/categories/庄子/index.html","hash":"e4f61baf201449be0183cdac51befc9b7f829438","modified":1622350900490},{"_id":"public/categories/Docker/index.html","hash":"7dd650da4882fda51546cd762af30a1a832834c1","modified":1622350900490},{"_id":"public/tags/ajax/index.html","hash":"0e130bcd873bf2a438dae3fff2cfb7882525c3f1","modified":1622350900490},{"_id":"public/tags/python/index.html","hash":"a464e16c57b7f5611ae4774c36914c5a9b88b479","modified":1622350900490},{"_id":"public/tags/javascript/index.html","hash":"cd9668f5a9df32e129877ce3ec9158f4336aaa6d","modified":1622350900490},{"_id":"public/tags/Hexo/index.html","hash":"73363f5094e22d25548b06cef2bcb85f631812a5","modified":1622350900490},{"_id":"public/tags/mongodb/index.html","hash":"d74d38d6842729dc8c93ecfed7f4a910b6b54fe7","modified":1622350900490},{"_id":"public/tags/Nginx/index.html","hash":"475cff28880c161802a1838634c5f32ecf4a359b","modified":1622350900490},{"_id":"public/tags/负载均衡/index.html","hash":"bdaf8585fbcfc666c925d111507b0d73f14dadf9","modified":1622350900490},{"_id":"public/tags/http/index.html","hash":"942564de30753f4c06f545c1513b067dfba9381a","modified":1622350900490},{"_id":"public/tags/web/index.html","hash":"70285b109732bbbfddbb46593c7a1b8e68d9c6b3","modified":1622350900490},{"_id":"public/tags/linux/index.html","hash":"0cdc912f6deab5c97107b85df2ffd576da169031","modified":1622350900490},{"_id":"public/tags/docker/index.html","hash":"c9eadbf7dfaf586b7d1c993135eda6c62a7e8e75","modified":1622350900490},{"_id":"public/tags/Git/index.html","hash":"2320955435b54e6c5d8a1d7362858c23b6f4343f","modified":1622350900490},{"_id":"public/tags/go/index.html","hash":"323d0fe049b6ca9e2e4b73640f3ffae2730a0723","modified":1622350900490},{"_id":"public/tags/多线程/index.html","hash":"4b7e753c4daf65f035299959dbb88014d77be5ac","modified":1622350900490},{"_id":"public/tags/threading/index.html","hash":"b30c72d7691089a913ce82d0d62db0715fb373a8","modified":1622350900490},{"_id":"public/tags/scrapy/index.html","hash":"7dd6ddeba73841897f4def222774df454a84f5a9","modified":1622350900490},{"_id":"public/tags/html/index.html","hash":"292acd07639182bbce8d5910bed7d3a3ba7b37ea","modified":1622350900490},{"_id":"public/tags/css/index.html","hash":"329c7bfc5a4e37943dce0b2dd7231a4326bfe15c","modified":1622350900490},{"_id":"public/tags/读书/index.html","hash":"589860dc05f8f64ca938fdecae39db54df0e0531","modified":1622350900490},{"_id":"public/tags/nextCloud/index.html","hash":"12d07e9ebdfd9d954b9bb076924bb60deb0a4763","modified":1622350900490},{"_id":"public/tags/vscode/index.html","hash":"5d9c0aca0eaec7afa121f7588446bcd9675fcf1c","modified":1622350900490},{"_id":"public/tags/re/index.html","hash":"0407822ac342e679e75b269d3d40509bca8736b0","modified":1622350900490},{"_id":"public/tags/爬虫/index.html","hash":"5a6ab20fa63113bc4d42f7862b2188f26eba093e","modified":1622350900490},{"_id":"public/tags/git/index.html","hash":"5a976fc4bb258c304e97e7ecb40fe1857520a74a","modified":1622350900490},{"_id":"public/tags/病毒/index.html","hash":"25cb5e4b68c4af83e89ccdc44ad5b91bd8ed676d","modified":1622350900490},{"_id":"public/tags/nginx/index.html","hash":"e1bfd3a05d69b7aa4f8ae896760c2a080f5dc911","modified":1622350900490},{"_id":"public/tags/https/index.html","hash":"d68d11f2d46762efcc2c12b950d57eb53ec14a1b","modified":1622350900490},{"_id":"public/tags/pyquery/index.html","hash":"978824f2f3f9a70f894b0d8665ccfbbfdf5f6f5d","modified":1622350900490},{"_id":"public/tags/selenium/index.html","hash":"bc7cbf2addc9c93342a40bf9d33f3316fba147c3","modified":1622350900490},{"_id":"public/tags/multiprocessing/index.html","hash":"29bb0d538a497f65556c0520a7fafc939c12441e","modified":1622350900490},{"_id":"public/tags/requests/index.html","hash":"f0a20ccd97c90c0160c89f40910ae6dc504a6031","modified":1622350900490},{"_id":"public/tags/request/index.html","hash":"5a4acb390a8e649f3d691dc1ad3ef22bf1fe9f13","modified":1622350900490},{"_id":"public/tags/pyquest/index.html","hash":"1903b56f627cbff0db7a1bcc7d39dda43adb4f1a","modified":1622350900490},{"_id":"public/tags/pymongodb/index.html","hash":"6b2eefce53018a32cae6fb56ba6d4bbcf71f8c7c","modified":1622350900490},{"_id":"public/index.html","hash":"35015dc4d16225a3a45b58c340ddd8ea44a3f594","modified":1622350900490},{"_id":"public/page/2/index.html","hash":"03bf427612cbb5e457781e77edf85069c044482e","modified":1622350900490},{"_id":"public/page/3/index.html","hash":"ab07c3375044643cf5ea17b969abb6ea39c1e456","modified":1622350900490},{"_id":"public/friends/index.html","hash":"a5234a44e295757f71f5b5396c88204d9a62ea5f","modified":1622350900490},{"_id":"public/search/index.html","hash":"31b3a5b4ea83e948eb212df1215abef6a3962204","modified":1622350900490},{"_id":"public/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1622350900490},{"_id":"public/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1622350900490},{"_id":"public/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1622350900490},{"_id":"public/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1622350900490},{"_id":"public/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1622350900490},{"_id":"public/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1622350900490},{"_id":"public/images/logo.webp","hash":"ad57efa7bf7cfe2b55857a5e1c917d67e268801d","modified":1622350900490},{"_id":"public/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1622350900490},{"_id":"public/maps/candy.min.js.map","hash":"6665b21a65483d2344c471dc5c756c4d387d568b","modified":1622350900490},{"_id":"public/maps/kr-dark.min.css.map","hash":"80ee66d1f262f9aa4a9b6960b0f8ff2fec14eb34","modified":1622350900490},{"_id":"public/maps/kr-dark.min.js.map","hash":"d021646d1ea23cb79c169ce84799e85e7d19540e","modified":1622350900490},{"_id":"public/maps/kratosr.min.js.map","hash":"b0d79ecf02c98ceecc14b9fa64160d186f20662c","modified":1622350900490},{"_id":"public/maps/light.min.css.map","hash":"b32142f58c42be8f25909a5c212364bb5c6fc804","modified":1622350900490},{"_id":"public/maps/night-blue.min.css.map","hash":"311ec6106ef1523d8725b5e2b73203adefce0599","modified":1622350900490},{"_id":"public/maps/local-search.min.js.map","hash":"b831de42d16beb1d8dd9a2d548422cbf1ee04314","modified":1622350900490},{"_id":"public/maps/night-bright.min.css.map","hash":"dd0d8c53d2794a7f64a48beaefc818ad37b74a76","modified":1622350900490},{"_id":"public/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1622350900490},{"_id":"public/maps/night-eighties.min.css.map","hash":"e283eba0a0ce4f94234d725b13d018898ecad8d7","modified":1622350900490},{"_id":"public/maps/night.min.css.map","hash":"98d68627b48700be8632f377bbe23adc2fa1c664","modified":1622350900490},{"_id":"public/maps/pjax.min.js.map","hash":"99e4cc9e361aeca9faf20a01b673e81d8fa4b895","modified":1622350900490},{"_id":"public/maps/prismjs.min.css.map","hash":"0c8ce3221dc6e6c95ae2a31f26d5c90bf090077c","modified":1622350900490},{"_id":"public/maps/snow.min.js.map","hash":"7c02278b2e50e5df0b19404baee1d31c2b6c0f76","modified":1622350900490},{"_id":"public/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1622350900490},{"_id":"public/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1622350900490},{"_id":"public/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1622350900490},{"_id":"public/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1622350900490},{"_id":"public/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1622350900490},{"_id":"public/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1622350900490},{"_id":"public/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1622350900490},{"_id":"public/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1622350900490},{"_id":"public/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1622350900490},{"_id":"public/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1622350900490},{"_id":"public/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1622350900490},{"_id":"public/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1622350900490},{"_id":"public/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1622350900490},{"_id":"public/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1622350900490},{"_id":"public/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1622350900490},{"_id":"public/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1622350900490},{"_id":"public/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1622350900490},{"_id":"public/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1622350900490},{"_id":"public/2021/05/24/Ajax爬取案例实战/Screenshot_4.webp","hash":"c2575022523ef6572d0c5325af42f8df21100be8","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_5.webp","hash":"c593a73651cc83f71afd2ec983070f834ab00bec","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_2.webp","hash":"4deffbe63abf667eb7deab992e6fd5f5d8f19658","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_6.webp","hash":"74fe29c473536bc554b6f2f7e75f9f81f11f8ac4","modified":1622350900490},{"_id":"public/2021/05/26/go语言的下载和安装/Screenshot_2.webp","hash":"9ab82c434734f49b00fa9907ba03aa0c961ea67b","modified":1622350900490},{"_id":"public/2021/05/29/scrapy框架介绍/Screenshot_1.webp","hash":"b75a099cb7f90ef9be9f8079c762c5871b2910f5","modified":1622350900490},{"_id":"public/2021/05/28/python的内置类型/Screenshot_1.webp","hash":"61f8bfd7758ad8815e38fd4af73bbb51d02e5624","modified":1622350900490},{"_id":"public/2021/05/09/HTTP基本原理/webp_0.webp","hash":"5cda1aef076a1f77cacb4ed2a194e2834394de31","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_3.webp","hash":"5714174e2273c7a9d85bc4d00a279f81d10f2d7b","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_8.webp","hash":"684d8530802e1ce1d5109860337382795a98b148","modified":1622350900490},{"_id":"public/2021/05/18/requests库的基本使用/Screenshot_3.webp","hash":"c352952ce59a50999f2edd69707460e4ea0ef415","modified":1622350900490},{"_id":"public/2021/05/18/requests库的基本使用/Screenshot_4.webp","hash":"9a8d44d9355d48fea9a16b85db6f94741b194ec7","modified":1622350900490},{"_id":"public/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1622350900490},{"_id":"public/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1622350900490},{"_id":"public/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1622350900490},{"_id":"public/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1622350900490},{"_id":"public/2021/05/24/Ajax爬取案例实战/Screenshot_1.webp","hash":"6f8eb27774d4a5f4182842151beacc2819c15096","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_4.webp","hash":"d7e798aa6b3b6ad7a22298853c9f234137d38145","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_7.webp","hash":"e5d673561d5370a49d9f89e48a528f3786ef0f76","modified":1622350900490},{"_id":"public/2021/05/26/go语言的下载和安装/Screenshot_1.webp","hash":"bb9781574494804cecbeaf411b9eab8e978b39a6","modified":1622350900490},{"_id":"public/2021/05/29/scrapy的基本使用/Screenshot_2.webp","hash":"b92ca60213e79ed1efc641db00d2a4c0113074b7","modified":1622350900490},{"_id":"public/2021/05/25/基于docker部署code-server/Screenshot_1.webp","hash":"b6358b7ac75a45bce36592548e5c732f41be2aa1","modified":1622350900490},{"_id":"public/2021/05/21/正则表达式/Screenshot_1.webp","hash":"e1c8833a8026b1e8c0255be14f3cef05117f8611","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_4.webp","hash":"6c9be21e922b1cb4099f8ed5a34707d7286005b3","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_2.webp","hash":"1df3e2110351c6d598a414347d2d715b7ac4b3a9","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_1.webp","hash":"4c1dbd186f6472603d353c031b02181215d740e5","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_5.webp","hash":"728868e8a29dd0a1dea0427c8d244e0de4e7aa70","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_7.webp","hash":"3d9f705648fa9375ae9143fc280082f493aa0f3c","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/Screenshot_4.webp","hash":"bc77d73a8f74763fac132af7223e56986c3b5fb3","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/Screenshot_3.webp","hash":"bca12af16f5833c7f371dfc3c3eca274820bd8a5","modified":1622350900490},{"_id":"public/maps/kratosr.min.css.map","hash":"79db71048315b161ee4bd150c02f74bcf2afa6cc","modified":1622350900490},{"_id":"public/js/kratosr.min.js","hash":"89656e74e417267f3d8fbaf8b6d369d0cdb84f1b","modified":1622350900490},{"_id":"public/js/kr-dark.min.js","hash":"b7d0488063224809bc9eac061627cc4ca96abfef","modified":1622350900490},{"_id":"public/js/local-search.min.js","hash":"9e60a349fe6bc9b0046f99f31aac125d0d66c1c3","modified":1622350900490},{"_id":"public/js/candy.min.js","hash":"68557657a90856086aaeaeeeeed768aa1e27d73e","modified":1622350900490},{"_id":"public/js/pjax.min.js","hash":"23fa40cb7ad123bb99e921d487447c195a6dadf3","modified":1622350900490},{"_id":"public/js/snow.min.js","hash":"c9f82a74501568aa42bada0becf766f45f309dbb","modified":1622350900490},{"_id":"public/css/kr-dark.min.css","hash":"f0c733d82a86863b20cf68ec2231bb7e8843c61b","modified":1622350900490},{"_id":"public/css/prismjs.min.css","hash":"94df0fe6c26d18a094c54c30283d65c3659ccf7a","modified":1622350900490},{"_id":"public/css/highlight/light.min.css","hash":"c42fa620f43eaafa550bc68a7e69e6e34ada0032","modified":1622350900490},{"_id":"public/css/highlight/night-blue.min.css","hash":"3a02ca54dd6a7ca6a8deb10012b5604653e398c6","modified":1622350900490},{"_id":"public/css/highlight/night-bright.min.css","hash":"9a3a66fa13f93d5196b67e8cac24b2aac4165a2c","modified":1622350900490},{"_id":"public/css/highlight/night-eighties.min.css","hash":"c3731f78911a97ed001500796a6e8d4ee9a78ab5","modified":1622350900490},{"_id":"public/css/highlight/night.min.css","hash":"6413d0664d104edd739554011c75b5a02b9f5fde","modified":1622350900490},{"_id":"public/2021/05/29/scrapy的基本使用/Screenshot_1.webp","hash":"e7b29693fcdb1ad13eb3f70c2c273913f282254f","modified":1622350900490},{"_id":"public/2021/05/09/HTTP基本原理/1.png","hash":"c7b40fc10675514ee4a907cd6ed5b451b2c84491","modified":1622350900490},{"_id":"public/2021/05/18/requests库的基本使用/Screenshot_2.webp","hash":"1a421421def18043cc6bb9583929f0c4c8813c73","modified":1622350900490},{"_id":"public/2021/05/24/Ajax爬取案例实战/Screenshot_2.webp","hash":"703e0f2823f2a8359bec3058626043ce79c90fac","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_1.webp","hash":"3b76c1cd462a5d790ee6ee6913a4fe0ea9939e4b","modified":1622350900490},{"_id":"public/2021/05/18/Nginx配置详解/1.jpg","hash":"9a45816cf19b79bf32997741a5411fff7f414714","modified":1622350900490},{"_id":"public/2021/05/18/Nginx配置详解/2.jpg","hash":"b607fc3234184e21036463e44ed62842734a0854","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/Screenshot_2.webp","hash":"bc928e85f843d46e64bfc84c71ec5e36f02e8a86","modified":1622350900490},{"_id":"public/2021/05/18/requests库的基本使用/Screenshot_1.webp","hash":"467c01f42023d9f2a9aa0f6a2ff0ef6debc90862","modified":1622350900490},{"_id":"public/css/kratosr.min.css","hash":"0d4d8e5d5c5f631b6b8dbb03ecbbb7adc7c5b00f","modified":1622350900490},{"_id":"public/images/my.webp","hash":"4ca18265439440b696893bbd8af9501511903a77","modified":1622350900490},{"_id":"public/2021/05/24/Ajax爬取案例实战/Screenshot_3.webp","hash":"0673e9e7afc64082d4ae24e1a2bb6a63ea40d89a","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_3.webp","hash":"05806abf32ac862c1fc0bd6d951a52cec43bc402","modified":1622350900490},{"_id":"public/2021/05/24/Ajax的原理和解析/Screenshot_8.webp","hash":"75a2ce77a19e6b163c2721ac000f6b304c1d1a4e","modified":1622350900490},{"_id":"public/2021/05/09/HTTP基本原理/Screenshot_2.png","hash":"ace6846527b33bf22c4956655f0bd6e3c73ae24f","modified":1622350900490},{"_id":"public/2021/05/09/HTTP基本原理/Screenshot_3.png","hash":"378fabca423cb07c62e41766928483465e65f9a2","modified":1622350900490},{"_id":"public/2021/05/25/Selenium的基本使用/Screenshot_6.webp","hash":"222603f02ca72672ef9b37b58272aa7c40c319fc","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/Screenshot_6.webp","hash":"d8e5dbb2beadb295313a5f276e03b78c500e7287","modified":1622350900490},{"_id":"public/2021/05/09/HTTP基本原理/Screenshot_1.png","hash":"5adb41c8f84a13e121fc0f1c528dd40bbb856deb","modified":1622350900490},{"_id":"public/2021/05/18/Nginx配置详解/3.jpg","hash":"5f1a30aceb878b36ec04bbe54d0bd5b821ebab9b","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/Screenshot_5.webp","hash":"6ae5131d70f9c23ab81202483fc457b9b19c2142","modified":1622350900490},{"_id":"public/2021/05/29/scrapy的基本使用/Screenshot_3.webp","hash":"48195fa4642554448c4ffa0e3274ba28776ef1d1","modified":1622350900490},{"_id":"public/2021/05/25/腾讯云主机CPU占用百分百/Screenshot_1.webp","hash":"d5834d609c49df60661bd4c708b36ccd54cd272c","modified":1622350900490},{"_id":"public/2021/05/23/request、pyquest和pymongodb案例实战/Screenshot_1.webp","hash":"6219480dd4f7f473bcdfaae8209a8d10766d9044","modified":1622350900490},{"_id":"public/2021/05/11/web网页基础/Screenshot_1.png","hash":"4466945441b85dc63432a583c23eec13419f8a5d","modified":1622350900490}],"Category":[{"name":"爬虫","_id":"ckpapu7h40003lcxu5fjnchf2"},{"name":"博客教程","_id":"ckpapu7hu000clcxu0h1j5vnp"},{"name":"Nginx","_id":"ckpapu7ia000qlcxuafed7h4f"},{"name":"Linux","_id":"ckpapu7if000ylcxu3qzcfuin"},{"name":"Git","_id":"ckpapu7il0015lcxu9ube7hpw"},{"name":"Go","_id":"ckpapu7is001flcxu20v54hoo"},{"name":"Python","_id":"ckpapu7ix001llcxu1mfk73vv"},{"name":"庄子","_id":"ckpapu7j1001ulcxu2azp5db3"},{"name":"Docker","_id":"ckpapu7j3001zlcxu1cxx0cf2"}],"Data":[],"Page":[{"title":"关于我","date":"2021-05-10T09:35:50.000Z","_content":"\n苦逼的工科生，学电子的却爱鼓捣计算机的东西。\n\n目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不太精通（╮(╯▽╰)╭）。\n\n工作之余专心学习`python`和`go`语言，想从事爬虫和数据可视化方向的工作。\n\n愿世界和平，大家都发财！\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2021-05-10 17:35:50\n---\n\n苦逼的工科生，学电子的却爱鼓捣计算机的东西。\n\n目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不太精通（╮(╯▽╰)╭）。\n\n工作之余专心学习`python`和`go`语言，想从事爬虫和数据可视化方向的工作。\n\n愿世界和平，大家都发财！\n","updated":"2021-06-15T03:24:11.558Z","path":"about/index.html","_id":"ckpapu7g90000lcxudzqcefy3","comments":1,"layout":"page","content":"<p>苦逼的工科生，学电子的却爱鼓捣计算机的东西。</p>\n<p>目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不太精通（╮(╯▽╰)╭）。</p>\n<p>工作之余专心学习<code>python</code>和<code>go</code>语言，想从事爬虫和数据可视化方向的工作。</p>\n<p>愿世界和平，大家都发财！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>苦逼的工科生，学电子的却爱鼓捣计算机的东西。</p>\n<p>目前从事城市轨道交通的自动化行业，和PLC和Modscan打交道比较多，还有各种奇怪的网络设备，服务器和软件。半个网络工程师、半个运维工程师，啥都会干啥都感觉不太精通（╮(╯▽╰)╭）。</p>\n<p>工作之余专心学习<code>python</code>和<code>go</code>语言，想从事爬虫和数据可视化方向的工作。</p>\n<p>愿世界和平，大家都发财！</p>\n"}],"Post":[{"title":"Ajax爬取案例实战","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-24T12:13:23.000Z","pic":null,"_content":"\n## 准备工作\n\n- 安装好`Python 3`（最低为 3.6 版本），并能成功运行`Python 3`程序。\n- 了解`PythonHTTP`请求库`requests`的基本用法。\n- 了解`Ajax`的基础知识和分析`Ajax`的基本方法。\n\n## 爬取目标\n\n其链接为：[https://dynamic1.scrape.cuiqingcai.com/](https://dynamic1.scrape.cuiqingcai.com/)，页面如图所示。\n\n![](Screenshot_1.webp)\n\n需要完成的目标有：\n\n- 分析页面数据的加载逻辑。\n- 用`requests`实现`Ajax`数据的爬取。\n- 将每部电影的数据保存成一个`JSON`数据文件。\n\n## 爬取列表页\n\n打开浏览器开发者工具，切换到`Network`面板，勾选上`「Preserve Log」`并切换到`「XHR」`选项卡，如图所示。\n\n![](Screenshot_2.webp)\n\n点开第`2`个结果，观察到其`Ajax`接口请求的`URL`地址为：`https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit=10&offset=10`，这里有两个参数，一个是`limit`，其值为`10`，一个是`offset`，它的值也是`10`。\n\n切换到`Preview`选项卡，结果如图所示。\n\n![](Screenshot_3.webp)\n\n可以看到结果是一些`JSON`数据，它有一个`results`字段，这是一个列表，列表的每一个元素都是一个字典。观察一下字典的内容，可以看到对应的电影数据的字段了，如`name`、`alias`、`cover`、 `categories`，对比下浏览器中的真实数据，各个内容是完全一致的，而且这个数据已经非常结构化了，完全就是我们想要爬取的数据。\n\n导入一些所需的库并定义一些配置，代码如下：\n\n```python\nimport requests\nimport logging\n\nlogging.basicConfig(level=logging.INFO,\n                    format='%(asctime)s-%(levelname)s:%(message)s')\n\nINDEX_URL = 'https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit={limit}&offset={offset}'\n```\n\n引入了`requests`和`logging`库，并定义了`logging`的基本配置，接着定义`INDEX_URL`，这里把`limit`和`offset`预留出来变成占位符，可以动态传入参数构造成一个完整的列表页`URL`。\n\n下面来实现一下列表页的爬取，先定义一个通用的爬取方法，代码如下：\n\n```python\ndef scrape_api(url):\n    logging.info('scraping %s...', url)\n    try:\n        response = requests.get(url, verify=False)\n        if response.status_code == 200:\n            return response.json()\n        logging.error('get invalid status code %s while scraping %s',\n                      response.status_code, url)\n    except requests.RequestException:\n        logging.error('error occurred while scraping %s', url, exc_info=True)\n```\n\n定义一个`scrape_api`方法，和之前不同的是，这个方法专门用来处理`JSON`接口，最后的`response`调用的是`json`方法，它可以解析响应的内容并将其转化成`JSON`字符串。\n\n在这个基础之上，定义一个爬取列表页的方法，代码如下：\n\n```python\nLIMIT = 10\n\ndef scrape_index(page):\n    url = INDEX_URL.format(limit=LIMIT, offset=LIMIT*(page-1))\n    return scrape_api(url)\n```\n\n定义了一个`scrape_index`方法，用来接收参数`page`，`page`代表列表页的页码。\n\n先构造了一个`URL`，通过字符串的`format`方法，传入`limit`和`offset`的值。这里的`limit`直接使用了全局变量`LIMIT`的值，`offset`则是动态计算的，计算方法是页码数减1再乘以`limit`，比如第1页的`offset`值就是`0`，第2页的`offset`值就是`10`，以此类推。构造好`URL`之后，直接调用`scrape_api`方法并返回结果即可。\n\n这样就完成了列表页的爬取，每次请求都会得到一页`10`部的电影数据。\n\n由于这时爬取到的数据已经是`JSON`类型了，所以不用像之前一样去解析`HTML`代码来提取数据，爬到的数据就是想要的结构化数据，因此解析这一步这里就可以直接省略。\n\n## 爬取详情页\n\n这时候已经可以拿到每一页的电影数据了，但是实际上这些数据还缺少一些想要的信息，如剧情简介等，所以需要进一步进入到详情页来获取这些内容。\n\n这时候点击任意一部电影，如《教父》，进入到其详情页面，这时候可以发现页面的`URL`已经变成了[](https://dynamic1.scrape.cuiqingcai.com/detail/40)，页面也成功展示了详情页的信息\n\n先定义一个详情页的爬取逻辑吧，代码如下：\n\n```python\nDETAIL_URL = 'https://dynamic1.scrape.cuiqingcai.com/api/movie/{id}'\n\ndef scrape_detail(id):\n    url = DETAIL_URL.format(id=id)\n    return scrape_api(url)\n```\n\n定义了一个`scrape_detail`方法，它接收参数`id`。这里的实现也非常简单，先根据定义好的`DETAIL_UR`L加上`id`，构造一个真实的详情页`Ajax`请求的`URL`，然后直接调用`scrape_api`方法传入这个`URL`即可。接着，定义一个总的调用方法，将以上的方法串联调用起来，代码如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_data = scrape_index(page)\n        for item in index_data.get('results'):\n            id = item.get('id')\n            print(id)\n            detail_data = scrape_detail(id)\n            logging.info('detail data %s', detail_data)\n```\n\n定义了一个`main`方法，首先遍历获取页码`page`，然后把`page`当成参数传递给`scrape_index`方法，得到列表页的数据。接着我遍历所有列表页的结果，获取每部电影的`id`，然后把`id`当作参数传递给`scrape_detail`方法，来爬取每部电影的详情数据，赋值为`detail_data`，输出即可。\n\n## 保存数据\n\n定义一个数据保存的方法，代码如下：\n\n```python\nimport json\nfrom os import makedirs\nfrom os.path import exists\n\nRESULT_DIR = 'results'\n\nexists(RESULT_DIR) or makedirs(RESULT_DIR)\n\ndef save_data(data):\n    name = data.get('name')\n    data_path = f'{RESULT_DIR}/{name}.json'\n    json.dump(data, open(data_path, 'w', encoding='utf-8'), ensure_ascii=False, indent=2)\n```\n\n首先定义了数据保存的文件夹`RESULTS_DIR`，注意，先要判断这个文件夹是否存在，如果不存在则需要创建。\n\n接着，定义了保存数据的方法`save_data`，首先获取数据的`name`字段，即电影的名称，把电影名称作为`JSON`文件的名称，接着构造`JSON`文件的路径，然后用`json`的`dump`方法将数据保存成文本格式。`dump`的方法设置了两个参数，一个是`ensure_ascii`，将其设置为`False`，它可以保证中文字符在文件中能以正常的中文文本呈现，而不是`unicode`字符；另一个是`indent`，它的数值为2，这代表生成的`JSON`数据结果有两个空格缩进，让它的格式显得更加美观。\n\n最后，`main`方法再调用下`save_data`方法即可，实现如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_data = scrape_index(page)\n        for item in index_data.get('results'):\n            id = item.get('id')\n            print(id)\n            detail_data = scrape_detail(id)\n            logging.info('detail data %s', detail_data)\n            save_data(detail_data)\n```\n\n本地`results`文件夹下出现了各个电影的`JSON`文件，如图所示。\n\n![](Screenshot_4.webp)\n","source":"_posts/Ajax爬取案例实战.md","raw":"---\ntitle: Ajax爬取案例实战\ntags:\n  - ajax\n  - python\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-24 20:13:23\ncategories: 爬虫\npic:\n---\n\n## 准备工作\n\n- 安装好`Python 3`（最低为 3.6 版本），并能成功运行`Python 3`程序。\n- 了解`PythonHTTP`请求库`requests`的基本用法。\n- 了解`Ajax`的基础知识和分析`Ajax`的基本方法。\n\n## 爬取目标\n\n其链接为：[https://dynamic1.scrape.cuiqingcai.com/](https://dynamic1.scrape.cuiqingcai.com/)，页面如图所示。\n\n![](Screenshot_1.webp)\n\n需要完成的目标有：\n\n- 分析页面数据的加载逻辑。\n- 用`requests`实现`Ajax`数据的爬取。\n- 将每部电影的数据保存成一个`JSON`数据文件。\n\n## 爬取列表页\n\n打开浏览器开发者工具，切换到`Network`面板，勾选上`「Preserve Log」`并切换到`「XHR」`选项卡，如图所示。\n\n![](Screenshot_2.webp)\n\n点开第`2`个结果，观察到其`Ajax`接口请求的`URL`地址为：`https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit=10&offset=10`，这里有两个参数，一个是`limit`，其值为`10`，一个是`offset`，它的值也是`10`。\n\n切换到`Preview`选项卡，结果如图所示。\n\n![](Screenshot_3.webp)\n\n可以看到结果是一些`JSON`数据，它有一个`results`字段，这是一个列表，列表的每一个元素都是一个字典。观察一下字典的内容，可以看到对应的电影数据的字段了，如`name`、`alias`、`cover`、 `categories`，对比下浏览器中的真实数据，各个内容是完全一致的，而且这个数据已经非常结构化了，完全就是我们想要爬取的数据。\n\n导入一些所需的库并定义一些配置，代码如下：\n\n```python\nimport requests\nimport logging\n\nlogging.basicConfig(level=logging.INFO,\n                    format='%(asctime)s-%(levelname)s:%(message)s')\n\nINDEX_URL = 'https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit={limit}&offset={offset}'\n```\n\n引入了`requests`和`logging`库，并定义了`logging`的基本配置，接着定义`INDEX_URL`，这里把`limit`和`offset`预留出来变成占位符，可以动态传入参数构造成一个完整的列表页`URL`。\n\n下面来实现一下列表页的爬取，先定义一个通用的爬取方法，代码如下：\n\n```python\ndef scrape_api(url):\n    logging.info('scraping %s...', url)\n    try:\n        response = requests.get(url, verify=False)\n        if response.status_code == 200:\n            return response.json()\n        logging.error('get invalid status code %s while scraping %s',\n                      response.status_code, url)\n    except requests.RequestException:\n        logging.error('error occurred while scraping %s', url, exc_info=True)\n```\n\n定义一个`scrape_api`方法，和之前不同的是，这个方法专门用来处理`JSON`接口，最后的`response`调用的是`json`方法，它可以解析响应的内容并将其转化成`JSON`字符串。\n\n在这个基础之上，定义一个爬取列表页的方法，代码如下：\n\n```python\nLIMIT = 10\n\ndef scrape_index(page):\n    url = INDEX_URL.format(limit=LIMIT, offset=LIMIT*(page-1))\n    return scrape_api(url)\n```\n\n定义了一个`scrape_index`方法，用来接收参数`page`，`page`代表列表页的页码。\n\n先构造了一个`URL`，通过字符串的`format`方法，传入`limit`和`offset`的值。这里的`limit`直接使用了全局变量`LIMIT`的值，`offset`则是动态计算的，计算方法是页码数减1再乘以`limit`，比如第1页的`offset`值就是`0`，第2页的`offset`值就是`10`，以此类推。构造好`URL`之后，直接调用`scrape_api`方法并返回结果即可。\n\n这样就完成了列表页的爬取，每次请求都会得到一页`10`部的电影数据。\n\n由于这时爬取到的数据已经是`JSON`类型了，所以不用像之前一样去解析`HTML`代码来提取数据，爬到的数据就是想要的结构化数据，因此解析这一步这里就可以直接省略。\n\n## 爬取详情页\n\n这时候已经可以拿到每一页的电影数据了，但是实际上这些数据还缺少一些想要的信息，如剧情简介等，所以需要进一步进入到详情页来获取这些内容。\n\n这时候点击任意一部电影，如《教父》，进入到其详情页面，这时候可以发现页面的`URL`已经变成了[](https://dynamic1.scrape.cuiqingcai.com/detail/40)，页面也成功展示了详情页的信息\n\n先定义一个详情页的爬取逻辑吧，代码如下：\n\n```python\nDETAIL_URL = 'https://dynamic1.scrape.cuiqingcai.com/api/movie/{id}'\n\ndef scrape_detail(id):\n    url = DETAIL_URL.format(id=id)\n    return scrape_api(url)\n```\n\n定义了一个`scrape_detail`方法，它接收参数`id`。这里的实现也非常简单，先根据定义好的`DETAIL_UR`L加上`id`，构造一个真实的详情页`Ajax`请求的`URL`，然后直接调用`scrape_api`方法传入这个`URL`即可。接着，定义一个总的调用方法，将以上的方法串联调用起来，代码如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_data = scrape_index(page)\n        for item in index_data.get('results'):\n            id = item.get('id')\n            print(id)\n            detail_data = scrape_detail(id)\n            logging.info('detail data %s', detail_data)\n```\n\n定义了一个`main`方法，首先遍历获取页码`page`，然后把`page`当成参数传递给`scrape_index`方法，得到列表页的数据。接着我遍历所有列表页的结果，获取每部电影的`id`，然后把`id`当作参数传递给`scrape_detail`方法，来爬取每部电影的详情数据，赋值为`detail_data`，输出即可。\n\n## 保存数据\n\n定义一个数据保存的方法，代码如下：\n\n```python\nimport json\nfrom os import makedirs\nfrom os.path import exists\n\nRESULT_DIR = 'results'\n\nexists(RESULT_DIR) or makedirs(RESULT_DIR)\n\ndef save_data(data):\n    name = data.get('name')\n    data_path = f'{RESULT_DIR}/{name}.json'\n    json.dump(data, open(data_path, 'w', encoding='utf-8'), ensure_ascii=False, indent=2)\n```\n\n首先定义了数据保存的文件夹`RESULTS_DIR`，注意，先要判断这个文件夹是否存在，如果不存在则需要创建。\n\n接着，定义了保存数据的方法`save_data`，首先获取数据的`name`字段，即电影的名称，把电影名称作为`JSON`文件的名称，接着构造`JSON`文件的路径，然后用`json`的`dump`方法将数据保存成文本格式。`dump`的方法设置了两个参数，一个是`ensure_ascii`，将其设置为`False`，它可以保证中文字符在文件中能以正常的中文文本呈现，而不是`unicode`字符；另一个是`indent`，它的数值为2，这代表生成的`JSON`数据结果有两个空格缩进，让它的格式显得更加美观。\n\n最后，`main`方法再调用下`save_data`方法即可，实现如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_data = scrape_index(page)\n        for item in index_data.get('results'):\n            id = item.get('id')\n            print(id)\n            detail_data = scrape_detail(id)\n            logging.info('detail data %s', detail_data)\n            save_data(detail_data)\n```\n\n本地`results`文件夹下出现了各个电影的`JSON`文件，如图所示。\n\n![](Screenshot_4.webp)\n","slug":"Ajax爬取案例实战","published":1,"updated":"2021-06-15T03:24:11.420Z","_id":"ckpapu7gj0001lcxuh91xh30t","layout":"post","photos":[],"link":"","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>安装好<code>Python 3</code>（最低为 3.6 版本），并能成功运行<code>Python 3</code>程序。</li>\n<li>了解<code>PythonHTTP</code>请求库<code>requests</code>的基本用法。</li>\n<li>了解<code>Ajax</code>的基础知识和分析<code>Ajax</code>的基本方法。</li>\n</ul>\n<h2 id=\"爬取目标\"><a href=\"#爬取目标\" class=\"headerlink\" title=\"爬取目标\"></a>爬取目标</h2><p>其链接为：<a href=\"https://dynamic1.scrape.cuiqingcai.com/\">https://dynamic1.scrape.cuiqingcai.com/</a>，页面如图所示。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>需要完成的目标有：</p>\n<ul>\n<li>分析页面数据的加载逻辑。</li>\n<li>用<code>requests</code>实现<code>Ajax</code>数据的爬取。</li>\n<li>将每部电影的数据保存成一个<code>JSON</code>数据文件。</li>\n</ul>\n<h2 id=\"爬取列表页\"><a href=\"#爬取列表页\" class=\"headerlink\" title=\"爬取列表页\"></a>爬取列表页</h2><p>打开浏览器开发者工具，切换到<code>Network</code>面板，勾选上<code>「Preserve Log」</code>并切换到<code>「XHR」</code>选项卡，如图所示。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>点开第<code>2</code>个结果，观察到其<code>Ajax</code>接口请求的<code>URL</code>地址为：<code>https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit=10&amp;offset=10</code>，这里有两个参数，一个是<code>limit</code>，其值为<code>10</code>，一个是<code>offset</code>，它的值也是<code>10</code>。</p>\n<p>切换到<code>Preview</code>选项卡，结果如图所示。</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p>可以看到结果是一些<code>JSON</code>数据，它有一个<code>results</code>字段，这是一个列表，列表的每一个元素都是一个字典。观察一下字典的内容，可以看到对应的电影数据的字段了，如<code>name</code>、<code>alias</code>、<code>cover</code>、 <code>categories</code>，对比下浏览器中的真实数据，各个内容是完全一致的，而且这个数据已经非常结构化了，完全就是我们想要爬取的数据。</p>\n<p>导入一些所需的库并定义一些配置，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(level=logging.INFO,</span><br><span class=\"line\">                    <span class=\"built_in\">format</span>=<span class=\"string\">&#x27;%(asctime)s-%(levelname)s:%(message)s&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">INDEX_URL = <span class=\"string\">&#x27;https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入了<code>requests</code>和<code>logging</code>库，并定义了<code>logging</code>的基本配置，接着定义<code>INDEX_URL</code>，这里把<code>limit</code>和<code>offset</code>预留出来变成占位符，可以动态传入参数构造成一个完整的列表页<code>URL</code>。</p>\n<p>下面来实现一下列表页的爬取，先定义一个通用的爬取方法，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_api</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    logging.info(<span class=\"string\">&#x27;scraping %s...&#x27;</span>, url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = requests.get(url, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> response.status_code == <span class=\"number\">200</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response.json()</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;get invalid status code %s while scraping %s&#x27;</span>,</span><br><span class=\"line\">                      response.status_code, url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.RequestException:</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>定义一个<code>scrape_api</code>方法，和之前不同的是，这个方法专门用来处理<code>JSON</code>接口，最后的<code>response</code>调用的是<code>json</code>方法，它可以解析响应的内容并将其转化成<code>JSON</code>字符串。</p>\n<p>在这个基础之上，定义一个爬取列表页的方法，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIMIT = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_index</span>(<span class=\"params\">page</span>):</span></span><br><span class=\"line\">    url = INDEX_URL.<span class=\"built_in\">format</span>(limit=LIMIT, offset=LIMIT*(page-<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_api(url)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>scrape_index</code>方法，用来接收参数<code>page</code>，<code>page</code>代表列表页的页码。</p>\n<p>先构造了一个<code>URL</code>，通过字符串的<code>format</code>方法，传入<code>limit</code>和<code>offset</code>的值。这里的<code>limit</code>直接使用了全局变量<code>LIMIT</code>的值，<code>offset</code>则是动态计算的，计算方法是页码数减1再乘以<code>limit</code>，比如第1页的<code>offset</code>值就是<code>0</code>，第2页的<code>offset</code>值就是<code>10</code>，以此类推。构造好<code>URL</code>之后，直接调用<code>scrape_api</code>方法并返回结果即可。</p>\n<p>这样就完成了列表页的爬取，每次请求都会得到一页<code>10</code>部的电影数据。</p>\n<p>由于这时爬取到的数据已经是<code>JSON</code>类型了，所以不用像之前一样去解析<code>HTML</code>代码来提取数据，爬到的数据就是想要的结构化数据，因此解析这一步这里就可以直接省略。</p>\n<h2 id=\"爬取详情页\"><a href=\"#爬取详情页\" class=\"headerlink\" title=\"爬取详情页\"></a>爬取详情页</h2><p>这时候已经可以拿到每一页的电影数据了，但是实际上这些数据还缺少一些想要的信息，如剧情简介等，所以需要进一步进入到详情页来获取这些内容。</p>\n<p>这时候点击任意一部电影，如《教父》，进入到其详情页面，这时候可以发现页面的<code>URL</code>已经变成了<a href=\"https://dynamic1.scrape.cuiqingcai.com/detail/40\"></a>，页面也成功展示了详情页的信息</p>\n<p>先定义一个详情页的爬取逻辑吧，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DETAIL_URL = <span class=\"string\">&#x27;https://dynamic1.scrape.cuiqingcai.com/api/movie/&#123;id&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_detail</span>(<span class=\"params\"><span class=\"built_in\">id</span></span>):</span></span><br><span class=\"line\">    url = DETAIL_URL.<span class=\"built_in\">format</span>(<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_api(url)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>scrape_detail</code>方法，它接收参数<code>id</code>。这里的实现也非常简单，先根据定义好的<code>DETAIL_UR</code>L加上<code>id</code>，构造一个真实的详情页<code>Ajax</code>请求的<code>URL</code>，然后直接调用<code>scrape_api</code>方法传入这个<code>URL</code>即可。接着，定义一个总的调用方法，将以上的方法串联调用起来，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_data = scrape_index(page)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> index_data.get(<span class=\"string\">&#x27;results&#x27;</span>):</span><br><span class=\"line\">            <span class=\"built_in\">id</span> = item.get(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            detail_data = scrape_detail(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;detail data %s&#x27;</span>, detail_data)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>main</code>方法，首先遍历获取页码<code>page</code>，然后把<code>page</code>当成参数传递给<code>scrape_index</code>方法，得到列表页的数据。接着我遍历所有列表页的结果，获取每部电影的<code>id</code>，然后把<code>id</code>当作参数传递给<code>scrape_detail</code>方法，来爬取每部电影的详情数据，赋值为<code>detail_data</code>，输出即可。</p>\n<h2 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h2><p>定义一个数据保存的方法，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">from</span> os <span class=\"keyword\">import</span> makedirs</span><br><span class=\"line\"><span class=\"keyword\">from</span> os.path <span class=\"keyword\">import</span> exists</span><br><span class=\"line\"></span><br><span class=\"line\">RESULT_DIR = <span class=\"string\">&#x27;results&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">exists(RESULT_DIR) <span class=\"keyword\">or</span> makedirs(RESULT_DIR)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_data</span>(<span class=\"params\">data</span>):</span></span><br><span class=\"line\">    name = data.get(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\">    data_path = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;RESULT_DIR&#125;</span>/<span class=\"subst\">&#123;name&#125;</span>.json&#x27;</span></span><br><span class=\"line\">    json.dump(data, <span class=\"built_in\">open</span>(data_path, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class=\"literal\">False</span>, indent=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>首先定义了数据保存的文件夹<code>RESULTS_DIR</code>，注意，先要判断这个文件夹是否存在，如果不存在则需要创建。</p>\n<p>接着，定义了保存数据的方法<code>save_data</code>，首先获取数据的<code>name</code>字段，即电影的名称，把电影名称作为<code>JSON</code>文件的名称，接着构造<code>JSON</code>文件的路径，然后用<code>json</code>的<code>dump</code>方法将数据保存成文本格式。<code>dump</code>的方法设置了两个参数，一个是<code>ensure_ascii</code>，将其设置为<code>False</code>，它可以保证中文字符在文件中能以正常的中文文本呈现，而不是<code>unicode</code>字符；另一个是<code>indent</code>，它的数值为2，这代表生成的<code>JSON</code>数据结果有两个空格缩进，让它的格式显得更加美观。</p>\n<p>最后，<code>main</code>方法再调用下<code>save_data</code>方法即可，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_data = scrape_index(page)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> index_data.get(<span class=\"string\">&#x27;results&#x27;</span>):</span><br><span class=\"line\">            <span class=\"built_in\">id</span> = item.get(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            detail_data = scrape_detail(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;detail data %s&#x27;</span>, detail_data)</span><br><span class=\"line\">            save_data(detail_data)</span><br></pre></td></tr></table></figure>\n\n<p>本地<code>results</code>文件夹下出现了各个电影的<code>JSON</code>文件，如图所示。</p>\n<p><img src=\"Screenshot_4.webp\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>安装好<code>Python 3</code>（最低为 3.6 版本），并能成功运行<code>Python 3</code>程序。</li>\n<li>了解<code>PythonHTTP</code>请求库<code>requests</code>的基本用法。</li>\n<li>了解<code>Ajax</code>的基础知识和分析<code>Ajax</code>的基本方法。</li>\n</ul>\n<h2 id=\"爬取目标\"><a href=\"#爬取目标\" class=\"headerlink\" title=\"爬取目标\"></a>爬取目标</h2><p>其链接为：<a href=\"https://dynamic1.scrape.cuiqingcai.com/\">https://dynamic1.scrape.cuiqingcai.com/</a>，页面如图所示。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>需要完成的目标有：</p>\n<ul>\n<li>分析页面数据的加载逻辑。</li>\n<li>用<code>requests</code>实现<code>Ajax</code>数据的爬取。</li>\n<li>将每部电影的数据保存成一个<code>JSON</code>数据文件。</li>\n</ul>\n<h2 id=\"爬取列表页\"><a href=\"#爬取列表页\" class=\"headerlink\" title=\"爬取列表页\"></a>爬取列表页</h2><p>打开浏览器开发者工具，切换到<code>Network</code>面板，勾选上<code>「Preserve Log」</code>并切换到<code>「XHR」</code>选项卡，如图所示。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>点开第<code>2</code>个结果，观察到其<code>Ajax</code>接口请求的<code>URL</code>地址为：<code>https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit=10&amp;offset=10</code>，这里有两个参数，一个是<code>limit</code>，其值为<code>10</code>，一个是<code>offset</code>，它的值也是<code>10</code>。</p>\n<p>切换到<code>Preview</code>选项卡，结果如图所示。</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p>可以看到结果是一些<code>JSON</code>数据，它有一个<code>results</code>字段，这是一个列表，列表的每一个元素都是一个字典。观察一下字典的内容，可以看到对应的电影数据的字段了，如<code>name</code>、<code>alias</code>、<code>cover</code>、 <code>categories</code>，对比下浏览器中的真实数据，各个内容是完全一致的，而且这个数据已经非常结构化了，完全就是我们想要爬取的数据。</p>\n<p>导入一些所需的库并定义一些配置，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(level=logging.INFO,</span><br><span class=\"line\">                    <span class=\"built_in\">format</span>=<span class=\"string\">&#x27;%(asctime)s-%(levelname)s:%(message)s&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">INDEX_URL = <span class=\"string\">&#x27;https://dynamic1.scrape.cuiqingcai.com/api/movie/?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入了<code>requests</code>和<code>logging</code>库，并定义了<code>logging</code>的基本配置，接着定义<code>INDEX_URL</code>，这里把<code>limit</code>和<code>offset</code>预留出来变成占位符，可以动态传入参数构造成一个完整的列表页<code>URL</code>。</p>\n<p>下面来实现一下列表页的爬取，先定义一个通用的爬取方法，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_api</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    logging.info(<span class=\"string\">&#x27;scraping %s...&#x27;</span>, url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = requests.get(url, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> response.status_code == <span class=\"number\">200</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response.json()</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;get invalid status code %s while scraping %s&#x27;</span>,</span><br><span class=\"line\">                      response.status_code, url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.RequestException:</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>定义一个<code>scrape_api</code>方法，和之前不同的是，这个方法专门用来处理<code>JSON</code>接口，最后的<code>response</code>调用的是<code>json</code>方法，它可以解析响应的内容并将其转化成<code>JSON</code>字符串。</p>\n<p>在这个基础之上，定义一个爬取列表页的方法，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIMIT = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_index</span>(<span class=\"params\">page</span>):</span></span><br><span class=\"line\">    url = INDEX_URL.<span class=\"built_in\">format</span>(limit=LIMIT, offset=LIMIT*(page-<span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_api(url)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>scrape_index</code>方法，用来接收参数<code>page</code>，<code>page</code>代表列表页的页码。</p>\n<p>先构造了一个<code>URL</code>，通过字符串的<code>format</code>方法，传入<code>limit</code>和<code>offset</code>的值。这里的<code>limit</code>直接使用了全局变量<code>LIMIT</code>的值，<code>offset</code>则是动态计算的，计算方法是页码数减1再乘以<code>limit</code>，比如第1页的<code>offset</code>值就是<code>0</code>，第2页的<code>offset</code>值就是<code>10</code>，以此类推。构造好<code>URL</code>之后，直接调用<code>scrape_api</code>方法并返回结果即可。</p>\n<p>这样就完成了列表页的爬取，每次请求都会得到一页<code>10</code>部的电影数据。</p>\n<p>由于这时爬取到的数据已经是<code>JSON</code>类型了，所以不用像之前一样去解析<code>HTML</code>代码来提取数据，爬到的数据就是想要的结构化数据，因此解析这一步这里就可以直接省略。</p>\n<h2 id=\"爬取详情页\"><a href=\"#爬取详情页\" class=\"headerlink\" title=\"爬取详情页\"></a>爬取详情页</h2><p>这时候已经可以拿到每一页的电影数据了，但是实际上这些数据还缺少一些想要的信息，如剧情简介等，所以需要进一步进入到详情页来获取这些内容。</p>\n<p>这时候点击任意一部电影，如《教父》，进入到其详情页面，这时候可以发现页面的<code>URL</code>已经变成了<a href=\"https://dynamic1.scrape.cuiqingcai.com/detail/40\"></a>，页面也成功展示了详情页的信息</p>\n<p>先定义一个详情页的爬取逻辑吧，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DETAIL_URL = <span class=\"string\">&#x27;https://dynamic1.scrape.cuiqingcai.com/api/movie/&#123;id&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_detail</span>(<span class=\"params\"><span class=\"built_in\">id</span></span>):</span></span><br><span class=\"line\">    url = DETAIL_URL.<span class=\"built_in\">format</span>(<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_api(url)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>scrape_detail</code>方法，它接收参数<code>id</code>。这里的实现也非常简单，先根据定义好的<code>DETAIL_UR</code>L加上<code>id</code>，构造一个真实的详情页<code>Ajax</code>请求的<code>URL</code>，然后直接调用<code>scrape_api</code>方法传入这个<code>URL</code>即可。接着，定义一个总的调用方法，将以上的方法串联调用起来，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_data = scrape_index(page)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> index_data.get(<span class=\"string\">&#x27;results&#x27;</span>):</span><br><span class=\"line\">            <span class=\"built_in\">id</span> = item.get(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            detail_data = scrape_detail(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;detail data %s&#x27;</span>, detail_data)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>main</code>方法，首先遍历获取页码<code>page</code>，然后把<code>page</code>当成参数传递给<code>scrape_index</code>方法，得到列表页的数据。接着我遍历所有列表页的结果，获取每部电影的<code>id</code>，然后把<code>id</code>当作参数传递给<code>scrape_detail</code>方法，来爬取每部电影的详情数据，赋值为<code>detail_data</code>，输出即可。</p>\n<h2 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h2><p>定义一个数据保存的方法，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">from</span> os <span class=\"keyword\">import</span> makedirs</span><br><span class=\"line\"><span class=\"keyword\">from</span> os.path <span class=\"keyword\">import</span> exists</span><br><span class=\"line\"></span><br><span class=\"line\">RESULT_DIR = <span class=\"string\">&#x27;results&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">exists(RESULT_DIR) <span class=\"keyword\">or</span> makedirs(RESULT_DIR)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_data</span>(<span class=\"params\">data</span>):</span></span><br><span class=\"line\">    name = data.get(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\">    data_path = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;RESULT_DIR&#125;</span>/<span class=\"subst\">&#123;name&#125;</span>.json&#x27;</span></span><br><span class=\"line\">    json.dump(data, <span class=\"built_in\">open</span>(data_path, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class=\"literal\">False</span>, indent=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>首先定义了数据保存的文件夹<code>RESULTS_DIR</code>，注意，先要判断这个文件夹是否存在，如果不存在则需要创建。</p>\n<p>接着，定义了保存数据的方法<code>save_data</code>，首先获取数据的<code>name</code>字段，即电影的名称，把电影名称作为<code>JSON</code>文件的名称，接着构造<code>JSON</code>文件的路径，然后用<code>json</code>的<code>dump</code>方法将数据保存成文本格式。<code>dump</code>的方法设置了两个参数，一个是<code>ensure_ascii</code>，将其设置为<code>False</code>，它可以保证中文字符在文件中能以正常的中文文本呈现，而不是<code>unicode</code>字符；另一个是<code>indent</code>，它的数值为2，这代表生成的<code>JSON</code>数据结果有两个空格缩进，让它的格式显得更加美观。</p>\n<p>最后，<code>main</code>方法再调用下<code>save_data</code>方法即可，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_data = scrape_index(page)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> index_data.get(<span class=\"string\">&#x27;results&#x27;</span>):</span><br><span class=\"line\">            <span class=\"built_in\">id</span> = item.get(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            detail_data = scrape_detail(<span class=\"built_in\">id</span>)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;detail data %s&#x27;</span>, detail_data)</span><br><span class=\"line\">            save_data(detail_data)</span><br></pre></td></tr></table></figure>\n\n<p>本地<code>results</code>文件夹下出现了各个电影的<code>JSON</code>文件，如图所示。</p>\n<p><img src=\"Screenshot_4.webp\"></p>\n"},{"title":"Ajax的原理和解析","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-24T08:33:38.000Z","pic":null,"_content":"\n## 什么是Ajax？\n\n`Ajax`，全称为`Asynchronous JavaScriptand XML`，即异步的`JavaScript`和`XML`。它不是一门编程语言，而是利用`JavaScript`在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。\n\n传统的网页，如果你想更新其内容，那么必须要刷新整个页面。有了`Ajax`，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上在后台与服务器进行了数据交互，获取到数据之后，再 利用`JavaScript`改变网页，这样网页内容就会更新了。\n\n到`W3School`上体验几个`Demo`来感受一下：[http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp](http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp)。\n\n## 基本原理\n\n初步了解了`Ajax`之后，来详细了解它的基本原理。发送`Ajax`请求到网页更新的过程可以简单分为以下3步：\n\n- 发送请求\n- 解析内容\n- 渲染网页\n\n### 发送请求\n\n`JavaScript`可以实现页面的各种交互功能，`Ajax`也不例外，它是由`JavaScript`实现的，实际上执行了如下代码：\n\n```javascript\nvar xmlhttp;\nif (window.XMLHttpRequest)\n  {// code for IE7+, Firefox, Chrome, Opera, Safari\n  xmlhttp=new XMLHttpRequest();\n  }\nelse\n  {// code for IE6, IE5\n  xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n  }\nxmlhttp.onreadystatechange=function()\n  {\n  if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n    document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n  }\nxmlhttp.open(\"GET\",\"/ajax/demo_get.asp\",true);\nxmlhttp.send();\n```\n\n这是`JavaScript`对`Ajax`最底层的实现，这个过程实际上是新建了`XMLHttpRequest`对象，然后调用`onreadystatechange`属性设置监听，最后调用`open()`和`send()`方法向某个链接（也就是服务器）发送请求。\n\n用`Python`实现请求发送之后，可以得到响应结果，但这里请求的发送由`JavaScript`来完成。由于设置了监听，所以当服务器返回响应时，`onreadystatechange`对应的方法便会被触发，在这个方法里面 解析响应内容即可。\n\n### 解析内容\n\n解得到响应之后，`onreadystatechange`属性对应的方法会被触发，此时利用`xmlhttp`的`responseText`属性便可取到响应内容。这类似于`Python`中利用`requests`向服务器发起请求，然后得到响应的过程。\n\n返回的内容可能是`HTML`，也可能是`JSON`，接下来只需要在方法中用`JavaScript`进一步处理即可。比如，如果返回的内容是`JSON`的话，可以对它进行解析和转化。\n\n### 渲染网页\n\n`JavaScript`有改变网页内容的能力，解析完响应内容之后，就可以调用`JavaScript`针对解析完的内容对网页进行下一步处理。比如，通过`document.getElementById().innerHTML`这样的操作，对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这种对`Document`网页文档进行如更改、删除等操作也被称作**`DOM`操作**。\n\n上例中，`document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText`这个操作便将`ID`为`myDiv`的节点内部的`HTML`代码更改为服务器返回的内容，这样`myDiv`元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。\n\n可以看到，**发送请求**、**解析内容**和**渲染网页**这3个步骤其实都是由`JavaScript`完成的。\n\n## Ajax分析\n\n用浏览器打开微博链接[https://weibo.com/u/5902654742](https://weibo.com/u/5902654742)，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择“检查”选项，此时便会弹出开发者工具，如图所示：\n\n![](Screenshot_1.webp)\n\n```python\n\n```\n\n`Ajax`有其特殊的请求类型，它叫作`xhr`。在图中我们可以发现一个以`getIndex`开头的请求，其`Type`为`xhr`，这就是一个`Ajax`请求。用鼠标点击这个请求，可以查看这个请求的详细信息。\n\n![](Screenshot_2.webp)\n\n在右侧可以观察到`Request Headers`、`URL`和`Response Headers`等信息。`Request Headers`中有一个信息为`X-Requested-With:XMLHttpRequest`，这就标记了此请求是`Ajax`请求，如图所示：\n\n![](Screenshot_3.webp)\n\n![](Screenshot_4.webp)\n\n点击`Preview`，即可看到响应的内容，它是`JSON`格式的。这里`Chrome`为我们自动做了解析，点击箭头即可展开和收起相应内容。\n\n可以观察到，返回结果是我的个人信息，包括昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。`JavaScript`接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。\n\n![](Screenshot_5.webp)\n\n切换到`Response`选项卡，从中观察到真实的返回数据，如图所示：\n\n![](Screenshot_6.webp)\n\n所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是在执行 JavaScript 后再次向后台发送 Ajax请求，浏览器拿到数据后进一步渲染出来的。\n\n## 过滤请求\n\n利用`Chrome`开发者工具的筛选功能筛选出所有的`Ajax`请求。在请求的上方有一层筛选栏，直接点击`XHR`，此时在下方显示的所有请求便都是`Ajax`请求了，如图所示：\n\n![](Screenshot_7.webp)\n\n接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也不断地出现`Ajax`请求，这样我们就可以捕获到所有的`Ajax`请求了。 随意点开一个条目，都可以清楚地看到其`Request URL、Request Headers、Response Headers、Response Body`等内容，此时想要模拟请求和提取就非常简单了。\n\n![](Screenshot_8.webp)\n\n","source":"_posts/Ajax的原理和解析.md","raw":"---\ntitle: Ajax的原理和解析\ntags:\n  - ajax\n  - javascript\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-24 16:33:38\ncategories: 爬虫\npic:\n---\n\n## 什么是Ajax？\n\n`Ajax`，全称为`Asynchronous JavaScriptand XML`，即异步的`JavaScript`和`XML`。它不是一门编程语言，而是利用`JavaScript`在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。\n\n传统的网页，如果你想更新其内容，那么必须要刷新整个页面。有了`Ajax`，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上在后台与服务器进行了数据交互，获取到数据之后，再 利用`JavaScript`改变网页，这样网页内容就会更新了。\n\n到`W3School`上体验几个`Demo`来感受一下：[http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp](http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp)。\n\n## 基本原理\n\n初步了解了`Ajax`之后，来详细了解它的基本原理。发送`Ajax`请求到网页更新的过程可以简单分为以下3步：\n\n- 发送请求\n- 解析内容\n- 渲染网页\n\n### 发送请求\n\n`JavaScript`可以实现页面的各种交互功能，`Ajax`也不例外，它是由`JavaScript`实现的，实际上执行了如下代码：\n\n```javascript\nvar xmlhttp;\nif (window.XMLHttpRequest)\n  {// code for IE7+, Firefox, Chrome, Opera, Safari\n  xmlhttp=new XMLHttpRequest();\n  }\nelse\n  {// code for IE6, IE5\n  xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n  }\nxmlhttp.onreadystatechange=function()\n  {\n  if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n    document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n  }\nxmlhttp.open(\"GET\",\"/ajax/demo_get.asp\",true);\nxmlhttp.send();\n```\n\n这是`JavaScript`对`Ajax`最底层的实现，这个过程实际上是新建了`XMLHttpRequest`对象，然后调用`onreadystatechange`属性设置监听，最后调用`open()`和`send()`方法向某个链接（也就是服务器）发送请求。\n\n用`Python`实现请求发送之后，可以得到响应结果，但这里请求的发送由`JavaScript`来完成。由于设置了监听，所以当服务器返回响应时，`onreadystatechange`对应的方法便会被触发，在这个方法里面 解析响应内容即可。\n\n### 解析内容\n\n解得到响应之后，`onreadystatechange`属性对应的方法会被触发，此时利用`xmlhttp`的`responseText`属性便可取到响应内容。这类似于`Python`中利用`requests`向服务器发起请求，然后得到响应的过程。\n\n返回的内容可能是`HTML`，也可能是`JSON`，接下来只需要在方法中用`JavaScript`进一步处理即可。比如，如果返回的内容是`JSON`的话，可以对它进行解析和转化。\n\n### 渲染网页\n\n`JavaScript`有改变网页内容的能力，解析完响应内容之后，就可以调用`JavaScript`针对解析完的内容对网页进行下一步处理。比如，通过`document.getElementById().innerHTML`这样的操作，对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这种对`Document`网页文档进行如更改、删除等操作也被称作**`DOM`操作**。\n\n上例中，`document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText`这个操作便将`ID`为`myDiv`的节点内部的`HTML`代码更改为服务器返回的内容，这样`myDiv`元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。\n\n可以看到，**发送请求**、**解析内容**和**渲染网页**这3个步骤其实都是由`JavaScript`完成的。\n\n## Ajax分析\n\n用浏览器打开微博链接[https://weibo.com/u/5902654742](https://weibo.com/u/5902654742)，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择“检查”选项，此时便会弹出开发者工具，如图所示：\n\n![](Screenshot_1.webp)\n\n```python\n\n```\n\n`Ajax`有其特殊的请求类型，它叫作`xhr`。在图中我们可以发现一个以`getIndex`开头的请求，其`Type`为`xhr`，这就是一个`Ajax`请求。用鼠标点击这个请求，可以查看这个请求的详细信息。\n\n![](Screenshot_2.webp)\n\n在右侧可以观察到`Request Headers`、`URL`和`Response Headers`等信息。`Request Headers`中有一个信息为`X-Requested-With:XMLHttpRequest`，这就标记了此请求是`Ajax`请求，如图所示：\n\n![](Screenshot_3.webp)\n\n![](Screenshot_4.webp)\n\n点击`Preview`，即可看到响应的内容，它是`JSON`格式的。这里`Chrome`为我们自动做了解析，点击箭头即可展开和收起相应内容。\n\n可以观察到，返回结果是我的个人信息，包括昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。`JavaScript`接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。\n\n![](Screenshot_5.webp)\n\n切换到`Response`选项卡，从中观察到真实的返回数据，如图所示：\n\n![](Screenshot_6.webp)\n\n所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是在执行 JavaScript 后再次向后台发送 Ajax请求，浏览器拿到数据后进一步渲染出来的。\n\n## 过滤请求\n\n利用`Chrome`开发者工具的筛选功能筛选出所有的`Ajax`请求。在请求的上方有一层筛选栏，直接点击`XHR`，此时在下方显示的所有请求便都是`Ajax`请求了，如图所示：\n\n![](Screenshot_7.webp)\n\n接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也不断地出现`Ajax`请求，这样我们就可以捕获到所有的`Ajax`请求了。 随意点开一个条目，都可以清楚地看到其`Request URL、Request Headers、Response Headers、Response Body`等内容，此时想要模拟请求和提取就非常简单了。\n\n![](Screenshot_8.webp)\n\n","slug":"Ajax的原理和解析","published":1,"updated":"2021-06-15T03:24:11.428Z","_id":"ckpapu7gx0002lcxu1mpp7axh","layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是Ajax？\"><a href=\"#什么是Ajax？\" class=\"headerlink\" title=\"什么是Ajax？\"></a>什么是Ajax？</h2><p><code>Ajax</code>，全称为<code>Asynchronous JavaScriptand XML</code>，即异步的<code>JavaScript</code>和<code>XML</code>。它不是一门编程语言，而是利用<code>JavaScript</code>在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p>\n<p>传统的网页，如果你想更新其内容，那么必须要刷新整个页面。有了<code>Ajax</code>，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上在后台与服务器进行了数据交互，获取到数据之后，再 利用<code>JavaScript</code>改变网页，这样网页内容就会更新了。</p>\n<p>到<code>W3School</code>上体验几个<code>Demo</code>来感受一下：<a href=\"http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp\">http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp</a>。</p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>初步了解了<code>Ajax</code>之后，来详细了解它的基本原理。发送<code>Ajax</code>请求到网页更新的过程可以简单分为以下3步：</p>\n<ul>\n<li>发送请求</li>\n<li>解析内容</li>\n<li>渲染网页</li>\n</ul>\n<h3 id=\"发送请求\"><a href=\"#发送请求\" class=\"headerlink\" title=\"发送请求\"></a>发送请求</h3><p><code>JavaScript</code>可以实现页面的各种交互功能，<code>Ajax</code>也不例外，它是由<code>JavaScript</code>实现的，实际上执行了如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest)</span><br><span class=\"line\">  &#123;<span class=\"comment\">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class=\"line\">  xmlhttp=<span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;<span class=\"comment\">// code for IE6, IE5</span></span><br><span class=\"line\">  xmlhttp=<span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">xmlhttp.onreadystatechange=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlhttp.readyState==<span class=\"number\">4</span> &amp;&amp; xmlhttp.status==<span class=\"number\">200</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&quot;GET&quot;</span>,<span class=\"string\">&quot;/ajax/demo_get.asp&quot;</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">xmlhttp.send();</span><br></pre></td></tr></table></figure>\n\n<p>这是<code>JavaScript</code>对<code>Ajax</code>最底层的实现，这个过程实际上是新建了<code>XMLHttpRequest</code>对象，然后调用<code>onreadystatechange</code>属性设置监听，最后调用<code>open()</code>和<code>send()</code>方法向某个链接（也就是服务器）发送请求。</p>\n<p>用<code>Python</code>实现请求发送之后，可以得到响应结果，但这里请求的发送由<code>JavaScript</code>来完成。由于设置了监听，所以当服务器返回响应时，<code>onreadystatechange</code>对应的方法便会被触发，在这个方法里面 解析响应内容即可。</p>\n<h3 id=\"解析内容\"><a href=\"#解析内容\" class=\"headerlink\" title=\"解析内容\"></a>解析内容</h3><p>解得到响应之后，<code>onreadystatechange</code>属性对应的方法会被触发，此时利用<code>xmlhttp</code>的<code>responseText</code>属性便可取到响应内容。这类似于<code>Python</code>中利用<code>requests</code>向服务器发起请求，然后得到响应的过程。</p>\n<p>返回的内容可能是<code>HTML</code>，也可能是<code>JSON</code>，接下来只需要在方法中用<code>JavaScript</code>进一步处理即可。比如，如果返回的内容是<code>JSON</code>的话，可以对它进行解析和转化。</p>\n<h3 id=\"渲染网页\"><a href=\"#渲染网页\" class=\"headerlink\" title=\"渲染网页\"></a>渲染网页</h3><p><code>JavaScript</code>有改变网页内容的能力，解析完响应内容之后，就可以调用<code>JavaScript</code>针对解析完的内容对网页进行下一步处理。比如，通过<code>document.getElementById().innerHTML</code>这样的操作，对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这种对<code>Document</code>网页文档进行如更改、删除等操作也被称作**<code>DOM</code>操作**。</p>\n<p>上例中，<code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText</code>这个操作便将<code>ID</code>为<code>myDiv</code>的节点内部的<code>HTML</code>代码更改为服务器返回的内容，这样<code>myDiv</code>元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。</p>\n<p>可以看到，<strong>发送请求</strong>、<strong>解析内容</strong>和<strong>渲染网页</strong>这3个步骤其实都是由<code>JavaScript</code>完成的。</p>\n<h2 id=\"Ajax分析\"><a href=\"#Ajax分析\" class=\"headerlink\" title=\"Ajax分析\"></a>Ajax分析</h2><p>用浏览器打开微博链接<a href=\"https://weibo.com/u/5902654742\">https://weibo.com/u/5902654742</a>，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择“检查”选项，此时便会弹出开发者工具，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>Ajax</code>有其特殊的请求类型，它叫作<code>xhr</code>。在图中我们可以发现一个以<code>getIndex</code>开头的请求，其<code>Type</code>为<code>xhr</code>，这就是一个<code>Ajax</code>请求。用鼠标点击这个请求，可以查看这个请求的详细信息。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>在右侧可以观察到<code>Request Headers</code>、<code>URL</code>和<code>Response Headers</code>等信息。<code>Request Headers</code>中有一个信息为<code>X-Requested-With:XMLHttpRequest</code>，这就标记了此请求是<code>Ajax</code>请求，如图所示：</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p><img src=\"Screenshot_4.webp\"></p>\n<p>点击<code>Preview</code>，即可看到响应的内容，它是<code>JSON</code>格式的。这里<code>Chrome</code>为我们自动做了解析，点击箭头即可展开和收起相应内容。</p>\n<p>可以观察到，返回结果是我的个人信息，包括昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。<code>JavaScript</code>接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。</p>\n<p><img src=\"Screenshot_5.webp\"></p>\n<p>切换到<code>Response</code>选项卡，从中观察到真实的返回数据，如图所示：</p>\n<p><img src=\"Screenshot_6.webp\"></p>\n<p>所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是在执行 JavaScript 后再次向后台发送 Ajax请求，浏览器拿到数据后进一步渲染出来的。</p>\n<h2 id=\"过滤请求\"><a href=\"#过滤请求\" class=\"headerlink\" title=\"过滤请求\"></a>过滤请求</h2><p>利用<code>Chrome</code>开发者工具的筛选功能筛选出所有的<code>Ajax</code>请求。在请求的上方有一层筛选栏，直接点击<code>XHR</code>，此时在下方显示的所有请求便都是<code>Ajax</code>请求了，如图所示：</p>\n<p><img src=\"Screenshot_7.webp\"></p>\n<p>接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也不断地出现<code>Ajax</code>请求，这样我们就可以捕获到所有的<code>Ajax</code>请求了。 随意点开一个条目，都可以清楚地看到其<code>Request URL、Request Headers、Response Headers、Response Body</code>等内容，此时想要模拟请求和提取就非常简单了。</p>\n<p><img src=\"Screenshot_8.webp\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Ajax？\"><a href=\"#什么是Ajax？\" class=\"headerlink\" title=\"什么是Ajax？\"></a>什么是Ajax？</h2><p><code>Ajax</code>，全称为<code>Asynchronous JavaScriptand XML</code>，即异步的<code>JavaScript</code>和<code>XML</code>。它不是一门编程语言，而是利用<code>JavaScript</code>在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p>\n<p>传统的网页，如果你想更新其内容，那么必须要刷新整个页面。有了<code>Ajax</code>，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上在后台与服务器进行了数据交互，获取到数据之后，再 利用<code>JavaScript</code>改变网页，这样网页内容就会更新了。</p>\n<p>到<code>W3School</code>上体验几个<code>Demo</code>来感受一下：<a href=\"http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp\">http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp</a>。</p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>初步了解了<code>Ajax</code>之后，来详细了解它的基本原理。发送<code>Ajax</code>请求到网页更新的过程可以简单分为以下3步：</p>\n<ul>\n<li>发送请求</li>\n<li>解析内容</li>\n<li>渲染网页</li>\n</ul>\n<h3 id=\"发送请求\"><a href=\"#发送请求\" class=\"headerlink\" title=\"发送请求\"></a>发送请求</h3><p><code>JavaScript</code>可以实现页面的各种交互功能，<code>Ajax</code>也不例外，它是由<code>JavaScript</code>实现的，实际上执行了如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest)</span><br><span class=\"line\">  &#123;<span class=\"comment\">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class=\"line\">  xmlhttp=<span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;<span class=\"comment\">// code for IE6, IE5</span></span><br><span class=\"line\">  xmlhttp=<span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">xmlhttp.onreadystatechange=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlhttp.readyState==<span class=\"number\">4</span> &amp;&amp; xmlhttp.status==<span class=\"number\">200</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&quot;GET&quot;</span>,<span class=\"string\">&quot;/ajax/demo_get.asp&quot;</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">xmlhttp.send();</span><br></pre></td></tr></table></figure>\n\n<p>这是<code>JavaScript</code>对<code>Ajax</code>最底层的实现，这个过程实际上是新建了<code>XMLHttpRequest</code>对象，然后调用<code>onreadystatechange</code>属性设置监听，最后调用<code>open()</code>和<code>send()</code>方法向某个链接（也就是服务器）发送请求。</p>\n<p>用<code>Python</code>实现请求发送之后，可以得到响应结果，但这里请求的发送由<code>JavaScript</code>来完成。由于设置了监听，所以当服务器返回响应时，<code>onreadystatechange</code>对应的方法便会被触发，在这个方法里面 解析响应内容即可。</p>\n<h3 id=\"解析内容\"><a href=\"#解析内容\" class=\"headerlink\" title=\"解析内容\"></a>解析内容</h3><p>解得到响应之后，<code>onreadystatechange</code>属性对应的方法会被触发，此时利用<code>xmlhttp</code>的<code>responseText</code>属性便可取到响应内容。这类似于<code>Python</code>中利用<code>requests</code>向服务器发起请求，然后得到响应的过程。</p>\n<p>返回的内容可能是<code>HTML</code>，也可能是<code>JSON</code>，接下来只需要在方法中用<code>JavaScript</code>进一步处理即可。比如，如果返回的内容是<code>JSON</code>的话，可以对它进行解析和转化。</p>\n<h3 id=\"渲染网页\"><a href=\"#渲染网页\" class=\"headerlink\" title=\"渲染网页\"></a>渲染网页</h3><p><code>JavaScript</code>有改变网页内容的能力，解析完响应内容之后，就可以调用<code>JavaScript</code>针对解析完的内容对网页进行下一步处理。比如，通过<code>document.getElementById().innerHTML</code>这样的操作，对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这种对<code>Document</code>网页文档进行如更改、删除等操作也被称作**<code>DOM</code>操作**。</p>\n<p>上例中，<code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText</code>这个操作便将<code>ID</code>为<code>myDiv</code>的节点内部的<code>HTML</code>代码更改为服务器返回的内容，这样<code>myDiv</code>元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。</p>\n<p>可以看到，<strong>发送请求</strong>、<strong>解析内容</strong>和<strong>渲染网页</strong>这3个步骤其实都是由<code>JavaScript</code>完成的。</p>\n<h2 id=\"Ajax分析\"><a href=\"#Ajax分析\" class=\"headerlink\" title=\"Ajax分析\"></a>Ajax分析</h2><p>用浏览器打开微博链接<a href=\"https://weibo.com/u/5902654742\">https://weibo.com/u/5902654742</a>，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择“检查”选项，此时便会弹出开发者工具，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>Ajax</code>有其特殊的请求类型，它叫作<code>xhr</code>。在图中我们可以发现一个以<code>getIndex</code>开头的请求，其<code>Type</code>为<code>xhr</code>，这就是一个<code>Ajax</code>请求。用鼠标点击这个请求，可以查看这个请求的详细信息。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>在右侧可以观察到<code>Request Headers</code>、<code>URL</code>和<code>Response Headers</code>等信息。<code>Request Headers</code>中有一个信息为<code>X-Requested-With:XMLHttpRequest</code>，这就标记了此请求是<code>Ajax</code>请求，如图所示：</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p><img src=\"Screenshot_4.webp\"></p>\n<p>点击<code>Preview</code>，即可看到响应的内容，它是<code>JSON</code>格式的。这里<code>Chrome</code>为我们自动做了解析，点击箭头即可展开和收起相应内容。</p>\n<p>可以观察到，返回结果是我的个人信息，包括昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。<code>JavaScript</code>接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。</p>\n<p><img src=\"Screenshot_5.webp\"></p>\n<p>切换到<code>Response</code>选项卡，从中观察到真实的返回数据，如图所示：</p>\n<p><img src=\"Screenshot_6.webp\"></p>\n<p>所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是在执行 JavaScript 后再次向后台发送 Ajax请求，浏览器拿到数据后进一步渲染出来的。</p>\n<h2 id=\"过滤请求\"><a href=\"#过滤请求\" class=\"headerlink\" title=\"过滤请求\"></a>过滤请求</h2><p>利用<code>Chrome</code>开发者工具的筛选功能筛选出所有的<code>Ajax</code>请求。在请求的上方有一层筛选栏，直接点击<code>XHR</code>，此时在下方显示的所有请求便都是<code>Ajax</code>请求了，如图所示：</p>\n<p><img src=\"Screenshot_7.webp\"></p>\n<p>接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也不断地出现<code>Ajax</code>请求，这样我们就可以捕获到所有的<code>Ajax</code>请求了。 随意点开一个条目，都可以清楚地看到其<code>Request URL、Request Headers、Response Headers、Response Body</code>等内容，此时想要模拟请求和提取就非常简单了。</p>\n<p><img src=\"Screenshot_8.webp\"></p>\n"},{"title":"Hexo搭建个人博客","date":"2021-05-08T07:39:22.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n\n# Hexo\n\n[Hexo](https://hexo.io/zh-cn/)是一个快速、简洁且高效的博客框架。\n\n## 安装\n\n### git安装\n\n```shell\n    Windows：下载并安装 git.\n    Mac：使用 Homebrew, MacPorts 或者下载 安装程序。\n    Linux (Ubuntu, Debian)：sudo apt-get install git-core\n    Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n```\n\n### 安装 Node.js\n\nNode.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。\n\n其它的安装方法：\n\n```shell\n    Windows：通过 nvs（推荐）或者nvm 安装。\n    Mac：使用 Homebrew 或 MacPorts 安装。\n    Linux（DEB/RPM-based）：从 NodeSource 安装。\n    其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导\n```\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n```shell\n    npm install -g hexo-cli\n```\n\n安装完成后，`win`+`R`输入`cmd`调出命令行，输入`hexo`提示如下，说明安装正确。\n\n```shell\n    C:\\Users\\espho>hexo\n    Usage: hexo <command>\n\n    Commands:\n    help     Get help on a command.\n    init     Create a new Hexo folder.\n    version  Display version information.\n\n    Global Options:\n    --config  Specify config file instead of using _config.yml\n    --cwd     Specify the CWD\n    --debug   Display all verbose messages in the terminal\n    --draft   Display draft posts\n    --safe    Disable all plugins and scripts\n    --silent  Hide output on console\n\n    For more help, you can use 'hexo help [command]' for the detailed information\n    or you can check the docs: http://hexo.io/docs/\n```\n\n## 建站\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```shell\n    hexo init <folder>\n    cd <folder>\n    npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```shell\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n### _config.yml\n\n网站的 配置 信息，您可以在此配置大部分的参数。\n\n### package.json\n\n应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。\n\n```shell\npackage.json\n{\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^3.8.0\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-server\": \"^0.3.3\"\n  }\n}\n```\n\n### scaffolds\n\n`模版`文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\n\nHexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\n\n### source\n\n资源文件夹是存放用户资源的地方。除 `_posts`文件夹之外，开头命名为 `_ (下划线)`的文件`/文件夹`和`隐藏的文件`将会被忽略。Markdown 和 HTML 文件会被解析并放到 `public`文件夹，而其他文件会被拷贝过去。\n\n### themes\n\n`主题`文件夹。Hexo 会根据主题来生成静态页面。\n\n## 配置\n\n相关配置可直接访问[官方文档](https://hexo.io/zh-cn/docs/configuration)查看，我们先从使用别人的主题开始，[官方](https://hexo.io/themes/)提供了335个主题下载使用，你也可以根据规范制定自己的主题。\n\n## 主题\n\n创建`Hexo`主题非常容易，您只要在`themes`文件夹内，新增一个任意名称的文件夹，并修改`_config.yml`内的`theme`设定，即可切换主题。一个主题可能会有以下的结构：\n\n```shell\n.\n├── _config.yml\n├── languages\n├── layout\n├── scripts\n└── source\n```\n\n### _config.yml\n\n主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启`Hexo Server`。\n\n## 获取主题\n\n选择相应的主题，从`github`上获取到`themes`目录下。\n\n修改主目录下`_config.yml`中的配置文件，将`theme`修改为获取主题的`文件夹名`。\n\n```shell\ntheme: Kratos-Rebirth\n```\n\n## 运行\n\n在主目录下调用`cmd`命令`hexo server`运行服务，访问`http://localhost:4000`进入博客。\n\n```shell\nespho@Holy-Surface MINGW64 /e/blog\n$ hexo server\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\nINFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2\nINFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。\nINFO  预祝您使用愉快。\n```\n\n## 添加文章\n\n","source":"_posts/Hexo创建博客.md","raw":"---\ntitle: Hexo搭建个人博客\ndate: 2021-05-08 15:39:22\ncategories: 博客教程\ntags:\n- Hexo\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n\n# Hexo\n\n[Hexo](https://hexo.io/zh-cn/)是一个快速、简洁且高效的博客框架。\n\n## 安装\n\n### git安装\n\n```shell\n    Windows：下载并安装 git.\n    Mac：使用 Homebrew, MacPorts 或者下载 安装程序。\n    Linux (Ubuntu, Debian)：sudo apt-get install git-core\n    Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n```\n\n### 安装 Node.js\n\nNode.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。\n\n其它的安装方法：\n\n```shell\n    Windows：通过 nvs（推荐）或者nvm 安装。\n    Mac：使用 Homebrew 或 MacPorts 安装。\n    Linux（DEB/RPM-based）：从 NodeSource 安装。\n    其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导\n```\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n```shell\n    npm install -g hexo-cli\n```\n\n安装完成后，`win`+`R`输入`cmd`调出命令行，输入`hexo`提示如下，说明安装正确。\n\n```shell\n    C:\\Users\\espho>hexo\n    Usage: hexo <command>\n\n    Commands:\n    help     Get help on a command.\n    init     Create a new Hexo folder.\n    version  Display version information.\n\n    Global Options:\n    --config  Specify config file instead of using _config.yml\n    --cwd     Specify the CWD\n    --debug   Display all verbose messages in the terminal\n    --draft   Display draft posts\n    --safe    Disable all plugins and scripts\n    --silent  Hide output on console\n\n    For more help, you can use 'hexo help [command]' for the detailed information\n    or you can check the docs: http://hexo.io/docs/\n```\n\n## 建站\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```shell\n    hexo init <folder>\n    cd <folder>\n    npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```shell\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n### _config.yml\n\n网站的 配置 信息，您可以在此配置大部分的参数。\n\n### package.json\n\n应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。\n\n```shell\npackage.json\n{\n  \"name\": \"hexo-site\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"hexo\": {\n    \"version\": \"\"\n  },\n  \"dependencies\": {\n    \"hexo\": \"^3.8.0\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-server\": \"^0.3.3\"\n  }\n}\n```\n\n### scaffolds\n\n`模版`文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\n\nHexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\n\n### source\n\n资源文件夹是存放用户资源的地方。除 `_posts`文件夹之外，开头命名为 `_ (下划线)`的文件`/文件夹`和`隐藏的文件`将会被忽略。Markdown 和 HTML 文件会被解析并放到 `public`文件夹，而其他文件会被拷贝过去。\n\n### themes\n\n`主题`文件夹。Hexo 会根据主题来生成静态页面。\n\n## 配置\n\n相关配置可直接访问[官方文档](https://hexo.io/zh-cn/docs/configuration)查看，我们先从使用别人的主题开始，[官方](https://hexo.io/themes/)提供了335个主题下载使用，你也可以根据规范制定自己的主题。\n\n## 主题\n\n创建`Hexo`主题非常容易，您只要在`themes`文件夹内，新增一个任意名称的文件夹，并修改`_config.yml`内的`theme`设定，即可切换主题。一个主题可能会有以下的结构：\n\n```shell\n.\n├── _config.yml\n├── languages\n├── layout\n├── scripts\n└── source\n```\n\n### _config.yml\n\n主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启`Hexo Server`。\n\n## 获取主题\n\n选择相应的主题，从`github`上获取到`themes`目录下。\n\n修改主目录下`_config.yml`中的配置文件，将`theme`修改为获取主题的`文件夹名`。\n\n```shell\ntheme: Kratos-Rebirth\n```\n\n## 运行\n\n在主目录下调用`cmd`命令`hexo server`运行服务，访问`http://localhost:4000`进入博客。\n\n```shell\nespho@Holy-Surface MINGW64 /e/blog\n$ hexo server\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\nINFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2\nINFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。\nINFO  预祝您使用愉快。\n```\n\n## 添加文章\n\n","slug":"Hexo创建博客","published":1,"updated":"2021-06-15T03:24:11.460Z","_id":"ckpapu7h90005lcxu7jc95deq","layout":"post","photos":[],"link":"","content":"<h1 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h1><p><a href=\"https://hexo.io/zh-cn/\">Hexo</a>是一个快速、简洁且高效的博客框架。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：下载并安装 git.</span><br><span class=\"line\">Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</span><br><span class=\"line\">Linux (Ubuntu, Debian)：sudo apt-get install git-core</span><br><span class=\"line\">Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p>\n<p>其它的安装方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：通过 nvs（推荐）或者nvm 安装。</span><br><span class=\"line\">Mac：使用 Homebrew 或 MacPorts 安装。</span><br><span class=\"line\">Linux（DEB/RPM-based）：从 NodeSource 安装。</span><br><span class=\"line\">其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，<code>win</code>+<code>R</code>输入<code>cmd</code>调出命令行，输入<code>hexo</code>提示如下，说明安装正确。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\espho&gt;hexo</span><br><span class=\"line\">Usage: hexo &lt;command&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">help     Get help on a command.</span><br><span class=\"line\">init     Create a new Hexo folder.</span><br><span class=\"line\">version  Display version information.</span><br><span class=\"line\"></span><br><span class=\"line\">Global Options:</span><br><span class=\"line\">--config  Specify config file instead of using _config.yml</span><br><span class=\"line\">--cwd     Specify the CWD</span><br><span class=\"line\">--debug   Display all verbose messages in the terminal</span><br><span class=\"line\">--draft   Display draft posts</span><br><span class=\"line\">--safe    Disable all plugins and scripts</span><br><span class=\"line\">--silent  Hide output on console</span><br><span class=\"line\"></span><br><span class=\"line\">For more help, you can use &#x27;hexo help [command]&#x27; for the detailed information</span><br><span class=\"line\">or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\">cd &lt;folder&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>\n<h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scaffolds\"><a href=\"#scaffolds\" class=\"headerlink\" title=\"scaffolds\"></a>scaffolds</h3><p><code>模版</code>文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>\n<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code>文件夹之外，开头命名为 <code>_ (下划线)</code>的文件<code>/文件夹</code>和<code>隐藏的文件</code>将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code>文件夹，而其他文件会被拷贝过去。</p>\n<h3 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h3><p><code>主题</code>文件夹。Hexo 会根据主题来生成静态页面。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>相关配置可直接访问<a href=\"https://hexo.io/zh-cn/docs/configuration\">官方文档</a>查看，我们先从使用别人的主题开始，<a href=\"https://hexo.io/themes/\">官方</a>提供了335个主题下载使用，你也可以根据规范制定自己的主题。</p>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><p>创建<code>Hexo</code>主题非常容易，您只要在<code>themes</code>文件夹内，新增一个任意名称的文件夹，并修改<code>_config.yml</code>内的<code>theme</code>设定，即可切换主题。一个主题可能会有以下的结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── languages</span><br><span class=\"line\">├── layout</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">└── source</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml-1\"><a href=\"#config-yml-1\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启<code>Hexo Server</code>。</p>\n<h2 id=\"获取主题\"><a href=\"#获取主题\" class=\"headerlink\" title=\"获取主题\"></a>获取主题</h2><p>选择相应的主题，从<code>github</code>上获取到<code>themes</code>目录下。</p>\n<p>修改主目录下<code>_config.yml</code>中的配置文件，将<code>theme</code>修改为获取主题的<code>文件夹名</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: Kratos-Rebirth</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在主目录下调用<code>cmd</code>命令<code>hexo server</code>运行服务，访问<code>http://localhost:4000</code>进入博客。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">espho@Holy-Surface MINGW64 /e/blog</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo server</span></span><br><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class=\"line\">INFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2</span><br><span class=\"line\">INFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。</span><br><span class=\"line\">INFO  预祝您使用愉快。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加文章\"><a href=\"#添加文章\" class=\"headerlink\" title=\"添加文章\"></a>添加文章</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h1><p><a href=\"https://hexo.io/zh-cn/\">Hexo</a>是一个快速、简洁且高效的博客框架。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：下载并安装 git.</span><br><span class=\"line\">Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</span><br><span class=\"line\">Linux (Ubuntu, Debian)：sudo apt-get install git-core</span><br><span class=\"line\">Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p>\n<p>其它的安装方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows：通过 nvs（推荐）或者nvm 安装。</span><br><span class=\"line\">Mac：使用 Homebrew 或 MacPorts 安装。</span><br><span class=\"line\">Linux（DEB/RPM-based）：从 NodeSource 安装。</span><br><span class=\"line\">其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，<code>win</code>+<code>R</code>输入<code>cmd</code>调出命令行，输入<code>hexo</code>提示如下，说明安装正确。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\espho&gt;hexo</span><br><span class=\"line\">Usage: hexo &lt;command&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">help     Get help on a command.</span><br><span class=\"line\">init     Create a new Hexo folder.</span><br><span class=\"line\">version  Display version information.</span><br><span class=\"line\"></span><br><span class=\"line\">Global Options:</span><br><span class=\"line\">--config  Specify config file instead of using _config.yml</span><br><span class=\"line\">--cwd     Specify the CWD</span><br><span class=\"line\">--debug   Display all verbose messages in the terminal</span><br><span class=\"line\">--draft   Display draft posts</span><br><span class=\"line\">--safe    Disable all plugins and scripts</span><br><span class=\"line\">--silent  Hide output on console</span><br><span class=\"line\"></span><br><span class=\"line\">For more help, you can use &#x27;hexo help [command]&#x27; for the detailed information</span><br><span class=\"line\">or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\">cd &lt;folder&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>\n<h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scaffolds\"><a href=\"#scaffolds\" class=\"headerlink\" title=\"scaffolds\"></a>scaffolds</h3><p><code>模版</code>文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>\n<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>\n<h3 id=\"source\"><a href=\"#source\" class=\"headerlink\" title=\"source\"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code>文件夹之外，开头命名为 <code>_ (下划线)</code>的文件<code>/文件夹</code>和<code>隐藏的文件</code>将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code>文件夹，而其他文件会被拷贝过去。</p>\n<h3 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h3><p><code>主题</code>文件夹。Hexo 会根据主题来生成静态页面。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>相关配置可直接访问<a href=\"https://hexo.io/zh-cn/docs/configuration\">官方文档</a>查看，我们先从使用别人的主题开始，<a href=\"https://hexo.io/themes/\">官方</a>提供了335个主题下载使用，你也可以根据规范制定自己的主题。</p>\n<h2 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h2><p>创建<code>Hexo</code>主题非常容易，您只要在<code>themes</code>文件夹内，新增一个任意名称的文件夹，并修改<code>_config.yml</code>内的<code>theme</code>设定，即可切换主题。一个主题可能会有以下的结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── languages</span><br><span class=\"line\">├── layout</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">└── source</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml-1\"><a href=\"#config-yml-1\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h3><p>主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启<code>Hexo Server</code>。</p>\n<h2 id=\"获取主题\"><a href=\"#获取主题\" class=\"headerlink\" title=\"获取主题\"></a>获取主题</h2><p>选择相应的主题，从<code>github</code>上获取到<code>themes</code>目录下。</p>\n<p>修改主目录下<code>_config.yml</code>中的配置文件，将<code>theme</code>修改为获取主题的<code>文件夹名</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: Kratos-Rebirth</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在主目录下调用<code>cmd</code>命令<code>hexo server</code>运行服务，访问<code>http://localhost:4000</code>进入博客。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">espho@Holy-Surface MINGW64 /e/blog</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> hexo server</span></span><br><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br><span class=\"line\">INFO  感谢使用 Kratos-Rebirth 主题，您的版本是 v1.6.2</span><br><span class=\"line\">INFO  如有任何疑问，您可以查阅文档，或是去 https://github.com/Candinya/Kratos-Rebirth/issues 提出对应的 issue 。</span><br><span class=\"line\">INFO  预祝您使用愉快。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加文章\"><a href=\"#添加文章\" class=\"headerlink\" title=\"添加文章\"></a>添加文章</h2>"},{"title":"Hexo在腾讯云的部署","date":"2021-05-10T04:51:56.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n## 简介\n\n`Hexo`在`GitHub pages`上的访问太慢了，迁移到腾讯云服务器上。\n\n## 部署环境\n\n腾讯云服务器（Centos 64位）。\n\n## 服务器配置\n\n### 安装git\n\n```shell\nyum install git\n```\n\n创建git用户并修改权限\n\n```shell\nadduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n\n找到一下内容\n\n```shell\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL\n```\n\n在该语句下添加\n\n```shell\ngit ALL=(ALL) ALL\n```\n\n退出（esc + :wq）并修改权限\n\n```shell\nchmod 400 /etc/sudoers\n```\n\n本地使用gitbash创建密钥\n\n```shell\nssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥\n```\n\n在腾讯云中创建`ssh`，并将本地的`id_rsa.pub`中的文件内容全部复制到`authorized_keys`中。\n\n```shell\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n```\n\n修改权限\n\n```shell\ncd ~\nchmod 600 .ssh/authorized_keys\nchmod 700 .ssh\n```\n\n本地测试\n\n```shell\nssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功\n```\n\n云服务器中创建网站目录并设置权限\n\n```shell\nsu root\nmkdir /home/hexo\nchown git:git -R /home/hexo\n```\n\n### 安装nginx\n\n```shell\nyum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务\n```\n\n以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。\n\n### 配置nginx\n\n```shell\nnginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。\nvim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo\n```\n\n重启服务\n\n```shell\nsystemctl restart nginx.service\n```\n\n## 建立git仓库并修改权限\n\n```shell\nsu root\ncd /home/git\ngit init --bare blog.git\nchown git:git -R blog.git\n```\n\n同步网站根目录\n\n```shell\nvim blog.git/hooks/post-receive\n```\n\n填入如下内容\n\n```shell\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\n```\n\n修改权限\n\n```shell\nchmod +x /home/git/blog.git/hooks/post-receive\n```\n\n在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：\n\n```shell\ngit@SERVER:/home/git/blog.git   //@后为你的服务器公网IP\n```\n\n以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。","source":"_posts/Hexo在腾讯云的部署.md","raw":"---\ntitle: Hexo在腾讯云的部署\ndate: 2021-05-10 12:51:56\ncategories: 博客教程\ntags:\n- Hexo\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n## 简介\n\n`Hexo`在`GitHub pages`上的访问太慢了，迁移到腾讯云服务器上。\n\n## 部署环境\n\n腾讯云服务器（Centos 64位）。\n\n## 服务器配置\n\n### 安装git\n\n```shell\nyum install git\n```\n\n创建git用户并修改权限\n\n```shell\nadduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n\n找到一下内容\n\n```shell\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL\n```\n\n在该语句下添加\n\n```shell\ngit ALL=(ALL) ALL\n```\n\n退出（esc + :wq）并修改权限\n\n```shell\nchmod 400 /etc/sudoers\n```\n\n本地使用gitbash创建密钥\n\n```shell\nssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥\n```\n\n在腾讯云中创建`ssh`，并将本地的`id_rsa.pub`中的文件内容全部复制到`authorized_keys`中。\n\n```shell\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n```\n\n修改权限\n\n```shell\ncd ~\nchmod 600 .ssh/authorized_keys\nchmod 700 .ssh\n```\n\n本地测试\n\n```shell\nssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功\n```\n\n云服务器中创建网站目录并设置权限\n\n```shell\nsu root\nmkdir /home/hexo\nchown git:git -R /home/hexo\n```\n\n### 安装nginx\n\n```shell\nyum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务\n```\n\n以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。\n\n### 配置nginx\n\n```shell\nnginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。\nvim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo\n```\n\n重启服务\n\n```shell\nsystemctl restart nginx.service\n```\n\n## 建立git仓库并修改权限\n\n```shell\nsu root\ncd /home/git\ngit init --bare blog.git\nchown git:git -R blog.git\n```\n\n同步网站根目录\n\n```shell\nvim blog.git/hooks/post-receive\n```\n\n填入如下内容\n\n```shell\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\n```\n\n修改权限\n\n```shell\nchmod +x /home/git/blog.git/hooks/post-receive\n```\n\n在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：\n\n```shell\ngit@SERVER:/home/git/blog.git   //@后为你的服务器公网IP\n```\n\n以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。","slug":"Hexo在腾讯云的部署","published":1,"updated":"2021-06-15T03:24:11.461Z","_id":"ckpapu7hb0006lcxu73sr3sdl","layout":"post","photos":[],"link":"","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>Hexo</code>在<code>GitHub pages</code>上的访问太慢了，迁移到腾讯云服务器上。</p>\n<h2 id=\"部署环境\"><a href=\"#部署环境\" class=\"headerlink\" title=\"部署环境\"></a>部署环境</h2><p>腾讯云服务器（Centos 64位）。</p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n\n<p>创建git用户并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser git</span><br><span class=\"line\">passwd git</span><br><span class=\"line\">chmod 740 /etc/sudoers</span><br><span class=\"line\">vim /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>找到一下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># Allow root to run any commands anywhere</span></span></span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>\n\n<p>在该语句下添加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>\n\n<p>退出（esc + :wq）并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>本地使用gitbash创建密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥</span><br></pre></td></tr></table></figure>\n\n<p>在腾讯云中创建<code>ssh</code>，并将本地的<code>id_rsa.pub</code>中的文件内容全部复制到<code>authorized_keys</code>中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su git</span><br><span class=\"line\">mkdir ~/.ssh</span><br><span class=\"line\">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">chmod 600 .ssh/authorized_keys</span><br><span class=\"line\">chmod 700 .ssh</span><br></pre></td></tr></table></figure>\n\n<p>本地测试</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功</span><br></pre></td></tr></table></figure>\n\n<p>云服务器中创建网站目录并设置权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">mkdir /home/hexo</span><br><span class=\"line\">chown git:git -R /home/hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y nginx    // 安装</span><br><span class=\"line\">systemctl start nginx.service     // 启动服务</span><br></pre></td></tr></table></figure>\n\n<p>以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。</p>\n<h3 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。</span><br><span class=\"line\">vim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建立git仓库并修改权限\"><a href=\"#建立git仓库并修改权限\" class=\"headerlink\" title=\"建立git仓库并修改权限\"></a>建立git仓库并修改权限</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">cd /home/git</span><br><span class=\"line\">git init --bare blog.git</span><br><span class=\"line\">chown git:git -R blog.git</span><br></pre></td></tr></table></figure>\n\n<p>同步网站根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>填入如下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\">git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@SERVER:/home/git/blog.git   //@后为你的服务器公网IP</span><br></pre></td></tr></table></figure>\n\n<p>以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>Hexo</code>在<code>GitHub pages</code>上的访问太慢了，迁移到腾讯云服务器上。</p>\n<h2 id=\"部署环境\"><a href=\"#部署环境\" class=\"headerlink\" title=\"部署环境\"></a>部署环境</h2><p>腾讯云服务器（Centos 64位）。</p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n\n<p>创建git用户并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser git</span><br><span class=\"line\">passwd git</span><br><span class=\"line\">chmod 740 /etc/sudoers</span><br><span class=\"line\">vim /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>找到一下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># Allow root to run any commands anywhere</span></span></span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>\n\n<p>在该语句下添加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ALL=(ALL) ALL</span><br></pre></td></tr></table></figure>\n\n<p>退出（esc + :wq）并修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>\n\n<p>本地使用gitbash创建密钥</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa //因为我在GitHub上部署博客时已经创建过密钥，这里可以直接跳过生成，用以前的密钥</span><br></pre></td></tr></table></figure>\n\n<p>在腾讯云中创建<code>ssh</code>，并将本地的<code>id_rsa.pub</code>中的文件内容全部复制到<code>authorized_keys</code>中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su git</span><br><span class=\"line\">mkdir ~/.ssh</span><br><span class=\"line\">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">chmod 600 .ssh/authorized_keys</span><br><span class=\"line\">chmod 700 .ssh</span><br></pre></td></tr></table></figure>\n\n<p>本地测试</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -v git@SERVER //@后是你自己的服务器公网IP，如果不出现failed字样，说明成功</span><br></pre></td></tr></table></figure>\n\n<p>云服务器中创建网站目录并设置权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">mkdir /home/hexo</span><br><span class=\"line\">chown git:git -R /home/hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y nginx    // 安装</span><br><span class=\"line\">systemctl start nginx.service     // 启动服务</span><br></pre></td></tr></table></figure>\n\n<p>以上执行完之后，在浏览器中输入你的公网IP如果可以进入CentOs界面，说明Nginx安装成功。</p>\n<h3 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t  // 命令查看位置，一般为 /etc/nginx/nginx.conf。</span><br><span class=\"line\">vim /etc/nginx/nginx.conf //修改配置文件，在server_name后添加自己的域名（要备案），root后添加/home/hexo</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建立git仓库并修改权限\"><a href=\"#建立git仓库并修改权限\" class=\"headerlink\" title=\"建立git仓库并修改权限\"></a>建立git仓库并修改权限</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su root</span><br><span class=\"line\">cd /home/git</span><br><span class=\"line\">git init --bare blog.git</span><br><span class=\"line\">chown git:git -R blog.git</span><br></pre></td></tr></table></figure>\n\n<p>同步网站根目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>填入如下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/sh</span></span><br><span class=\"line\">git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>修改权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>在本地Hexo目录下修改_config.yml文件中的deploy后的repo改为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git@SERVER:/home/git/blog.git   //@后为你的服务器公网IP</span><br></pre></td></tr></table></figure>\n\n<p>以上全部完成后，执行hexo的部署命令即可完成在腾讯云服务器上的博客部署。</p>\n"},{"title":"MongoDB数据库的使用","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-23T06:46:16.000Z","pic":null,"_content":"\n## 准备工作\n\n开始之前，请确保你已经安装好了`MongoDB`并启动了其服务，同时安装好了`Python`的`PyMongo`库。\n\n安装好之后，我们需要把`MongoDB`服务启动起来。启动完成之后，它会默认在本地`localhost`的`27017`端口上运行。\n\n接下来我们需要安装`PyMongo`这个库，它是`Python`用来操作`MongoDB`的第三方库，直接用`pip3`安装即可：\n\n```python\npip3 install pymongo\n```\n\n## 连接MongoDB\n\n连接`MongoDB`时，需要使用`PyMongo`库里面的`MongoClient`。一般来说，向其传入`MongoDB`的`IP`及端口即可，其中第一个参数为地址`host`，第二个参数为端口 `port`（如果不给它传递参数，则默认是`27017`）：\n\n```python\nimport pymongo\n\nclient = pymongo.MongoClient(host='localhost', port=27017)\n```\n\n另外，`MongoClient`的第一个参数`host`还可以直接传入`MongoDB`的连接字符串，它以`mongodb`开头，例如：\n\n```python\nclient = MongoClient('mongodb://localhost:27017/')\n```\n\n这样也可以达到同样的连接效果。\n\n### 指定数据库\n\n`MongoDB`中可以建立多个数据库，接下来指定操作其中一个数据库。这里以`test`数据库作为下一步需要在程序中指定使用的例子：\n\n```python\ndb = client.test\n```\n\n这里调用`client`的`test`属性即可返回`test`数据库。当然，也可以这样指定：\n\n```python\ndb = client['test']\n```\n\n这两种方式是等价的。\n\n### 指定集合\n\n`MongoDB`的每个数据库又包含许多集合`（collection）`，它们类似于关系型数据库中的表。\n\n下一步需要指定要操作的集合，这里指定一个名称为`students`的集合。与指定数据库类似，指定集合也有两种方式：\n\n```python\ncollection = db.students\n```\n\n或是\n\n```python\ncollection = db['students']\n```\n\n这样便声明了一个`Collection`对象。\n\n### 插入数据\n\n接下来，便可以插入数据了。对`students`这个集合新建一条学生数据，这条数据以字典形式表示：\n\n```python\nstudent = {\n    'id': '20170101',\n    'name': 'Jordan',\n    'age':'20',\n    'gender': 'male'\n}\n```\n\n新建的这条数据里指定了学生的学号、姓名、年龄和性别。直接调用`collection`的`insert`方法即可插入数据，代码如下：\n\n```python\nresult = collection.insert(student)\nprint(result)\n```\n\n在`MongoDB`中，每条数据其实都有一个`_id`属性来唯一标识。如果没有显式指明该属性，`MongoDB`会自动产生一个`ObjectId`类型的`_id`属性。`insert()`方法会在执行后返回`_id`值。\n\n运行结果如下：\n\n```python\n60aa06aca3aff156a9093404\n```\n\n当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：\n\n```python\nstudent1 = {\n    'id': '20170102',\n    'name': 'Jack',\n    'age':'23',\n    'gender': 'male'\n}\n\nstudent2 = {\n    'id': '201701013',\n    'name': 'Holy',\n    'age':'25',\n    'gender': 'male'\n}\nresult = collection.insert([student1, student2])\nprint(result)\n```\n\n返回结果是对应的`_id`的集合：\n\n```python\n[ObjectId('60aa07d11755f43c2a5becf3'), ObjectId('60aa07d11755f43c2a5becf4')]\n```\n\n在`PyMongo`中，官方已经不推荐使用`insert`方法了。但是如果你要继续使用也没有什么问题。目前，官方推荐使用`insert_one`和`insert_many`方法来分别插入单条记录和多条记录，示例如下：\n\n```python\nstudent = {\n    'id': '20170101',\n    'name': 'Jordan',\n    'age':'20',\n    'gender': 'male'\n}\n\nresult = collection.insert_one(student)\nprint(result)\nprint(result.inserted_id)\n```\n\n运行结果如下：\n\n```python\n<pymongo.results.InsertOneResult object at 0x00000267F7E9CD80>\n60aa0884c1479c83fc0e07a6\n```\n\n与`insert`方法不同，返回的是`InsertOneResult`对象，可以调用其`inserted_id`属性获取`_id`。 对于`insert_many`方法，可以将数据以列表形式传递，示例如下：\n\n```python\nstudent1 = {\n    'id': '20170102',\n    'name': 'Jack',\n    'age':'23',\n    'gender': 'male'\n}\n\nstudent2 = {\n    'id': '201701013',\n    'name': 'Holy',\n    'age':'25',\n    'gender': 'male'\n}\nresult = collection.insert_many([student1,student2])\nprint(result)\nprint(result.inserted_ids)\n```\n\n运行结果如下：\n\n```python\n<pymongo.results.InsertManyResult object at 0x0000021A0BA7A780>\n[ObjectId('60aa0908ba9556afc2c8ebec'), ObjectId('60aa0908ba9556afc2c8ebed')]\n```\n\n该方法返回的类型是`InsertManyResult`，调用`inserted_ids`属性可以获取插入数据的`_id`列表。\n\n### 查询数据\n\n插入数据后，可以利用`find_one`或`find`方法进行查询，其中`find_one`查询得到的是单个结果，`find`则返回一个生成器对象。示例如下：\n\n```python\nresult = collection.find_one({'name': 'Holy'})\nprint(result)\n```\n\n这里我们查询`name`为`Holy`的数据，它的返回结果是字典类型，运行结果如下：\n\n查询结果：\n\n```python\n{'_id': ObjectId('60aa07d11755f43c2a5becf4'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n```\n\n可以发现，它多了`_id`属性，这就是`MongoDB`在插入过程中自动添加的。此外，也可以根据`ObjectId`来查询，此时需要调用`bson`库里面的`objectid`：\n\n```python\nfrom bson.objectid import ObjectId\n\nresult = collection.find_one({'_id': ObjectId('60aa07d11755f43c2a5becf4')})\nprint(result)\n```\n\n查询结果：\n\n```python\n{'_id': ObjectId('60aa07d11755f43c2a5becf4'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n```\n\n对于多条数据的查询，可以使用`find`方法。例如，这里查找性别为`male`的数据，示例如下：\n\n```python\nresults = collection.find({'age': 20})\nprint(results)\nfor result in results:\n    print(result)\n```\n\n运行结果如下：\n\n```python\n{'_id': ObjectId('60aa065e109b00a7eee5447b'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa0686802c3967b97d7791'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa06aca3aff156a9093404'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa076374369a6a0801fb4a'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa077162e23647877e4213'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa07d11755f43c2a5becf3'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa07d11755f43c2a5becf4'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n{'_id': ObjectId('60aa0884c1479c83fc0e07a6'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa08f67cd6ac92cb505552'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa08f67cd6ac92cb505553'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n{'_id': ObjectId('60aa0908ba9556afc2c8ebec'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa0908ba9556afc2c8ebed'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n```\n\n返回结果是`Cursor`类型，它相当于一个生成器，需要遍历获取的所有结果，其中每个结果都是字典类型。\n\n如果要查询年龄大于`20`的数据，则写法如下：\n\n```python\nresults = collection.find({'age': {'$gt': 20}})\n```\n\n查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号`$gt`，意思是**大于**，键值为`20`。\n\n比较符号归纳如下：\n\n| 符号 | 含义 | 示例 |\n| :---: | :---: | :---: |\n| $lt | 小于 | {'age':{'$lt':20}} |\n| $gt | 大于 | {'age':{'$gt':20}} |\n| $lte | 小于或等于 | {'age':{'$lte':20}} |\n| $gte | 大于或等于 | {'age':{'$gte':20}} |\n| $ne | 不等于 | {'age':{'$ne':20}} |\n| $in | 在范围内 | {'age':{'$in':[20,23]}} |\n| $nin | 不在范围内 | {'age':{'$nin':[20, 23]}} |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n另外，还可以进行正则匹配查询。例如，查询名字以`H`开头的学生数据，示例如下：\n\n```python\nresults = collection.find({'name': {'$regex': '^H.*'}})\n```\n\n这里使用`$regex`来指定正则匹配，`^M.*`代表以`M`开头的正则表达式。\n\n一些功能符号归类为下表：\n\n| 符号 | 含义 | 示例 |\n| :---: | :---: | :---: |\n| $regrx | 匹配正则表达式 | {'name':{'$regex':'^M.*'}} |\n| $exists | 属性是否存在 | {'name':{'$exists':True}} |\n| $type | 类型判断 | {'age':{'$type':'int'}} |\n| $mod | 数字模操作 | {'age':{'$mod':[5,0]}} |\n| $text | 文本查询 | {'$text':{'$search':'Holy'}} |\n| $where | 高级条件查询 | {'$where':'obj.fans_count==obj.follows_count'} |\n\n### 计数\n\n要统计查询结果有多少条数据，可以调用`count`方法。以统计所有数据条数为例：\n\n```python\ncount = collection.find().count()\nprint(count)\n```\n\n我们还可以统计符合某个条件的数据：\n\n```python\ncount = collection.find({'age': 20}).count() \nprint(count)\n```\n\n运行结果是一个数值，即符合条件的数据条数。\n\n### 排序\n\n排序时，可以直接调用`sort`方法，并在其中传入排序的字段及升降序标志。示例如下：\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING)\nprint([result['name'] for result in results])\n```\n\n运行结果如下：\n\n```python\n['Holy', 'Holy', 'Holy', 'Holy', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jordan', 'Jordan', 'Jordan', 'Jordan']\n```\n\n调用`pymongo.ASCENDING`指定升序。如果要降序排列，可以传入`pymongo.DESCENDING`。\n\n### 偏移\n\n只需要取某几个元素，可以利用`skip`方法偏移几个位置，比如偏移2，就代表忽略前两个元素，得到第3个及以后的元素：\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING).skip(3)\nprint([result['name'] for result in results])\n```\n\n运行结果如下：\n\n```python\n['Holy', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jordan', 'Jordan', 'Jordan', 'Jordan']\n```\n\n还可以用`limit`方法指定要取的结果个数，示例如下：\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING).limit(1)\nprint([result['name'] for result in results])\n```\n\n运行结果如下：\n\n```python\n['Holy']\n```\n\n值得注意的是，在数据量非常庞大的时候，比如在查询千万、亿级别的数据库时，最好不要使用大的偏移量，因为这样很可能导致内存溢出。\n\n### 更新\n\n数据更新，可以使用`update`方法，指定更新的条件和更新后的数据即可。例如：\n\n```python\ncondition = {'name': 'Holy'}\nstudent = collection.find_one(condition)\nstudent['age'] = 30\nresult = collection.update(condition, student)\nprint(result)\n```\n\n更新`name`为`Holy`的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用`update`方法将原条件和修改后的数据传入。\n\n运行结果如下：\n\n```python\n{'n': 1, 'nModified': 0, 'ok': 1.0, 'updatedExisting': True}\n```\n\n返回结果是字典形式，`ok`代表执行成功，`nModified`代表影响的数据条数。\n\n也可以使用`$set`操作符对数据进行更新，代码如下：\n\n```python\nresult = collection.update(condition, {'$set': student})\n```\n\n这样可以只更新`student`字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用`$set`的话，则会把之前的数据全部用`student`字典替换；如果原本存在其他字段，则会被删除。\n\n`update`方法其实也是官方不推荐使用的方法。这里也分为`update_one`方法和`update_many`方法，用法更加严格，它们的第2个参数需要使用`$`类型操作符作为字典的键名，示例如下:\n\n```python\ncondition = {'name': 'Kevin'} \nstudent = collection.find_one(condition)\nstudent['age'] = 26\nresult = collection.update_one(condition, {'$set': student})\nprint(result) print(result.matched_count, result.modified_count)\n```\n\n上面的例子中调用了`update_one`方法，使得第2个参数不能再直接传入修改后的字典，而是需要使用`{'$set':student}`这样的形式，其返回结果是`UpdateResult`类型。然后分别调用`matched_count`和`modified_count`属性，可以获得匹配的数据条数和影响的数据条数。\n\n运行结果如下：\n\n```python\n<pymongo.results.UpdateResult object at 0x10d17b678>\n1 0\n```\n\n## 删除\n\n删除操作比较简单，直接调用`remove`方法指定删除的条件即可，此时符合条件的所有数据均会被删除。\n\n示例如下：\n\n```python\nresult = collection.remove({'name': 'Kevin'})\nprint(result)\n```\n\n运行结果如下：\n\n```python\n{'ok': 1, 'n': 1}\n```\n\n另外，这里依然存在两个新的推荐方法 ——`delete_one`和`delete_many`，示例如下：\n\n```python\nresult = collection.delete_one({'name': 'Kevin'})\nprint(result) \nprint(result.deleted_count)\nresult = collection.delete_many({'age': {'$lt': 25}})\nprint(result.deleted_count)\n```\n\n运行结果如下：\n\n```python\n<pymongo.results.DeleteResult object at 0x10e6ba4c8> \n14\n```\n\n`delete_one`删除第一条符合条件的数据，`delete_many`即删除所有符合条件的数据。它们的返回结果都是`DeleteResult`类型，可以调用`deleted_count`属性获取删除的数据条数。\n","source":"_posts/MongoDB数据库的使用.md","raw":"---\ntitle: MongoDB数据库的使用\ntags:\n  - python\n  - mongodb\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-23 14:46:16\ncategories: 爬虫\npic:\n---\n\n## 准备工作\n\n开始之前，请确保你已经安装好了`MongoDB`并启动了其服务，同时安装好了`Python`的`PyMongo`库。\n\n安装好之后，我们需要把`MongoDB`服务启动起来。启动完成之后，它会默认在本地`localhost`的`27017`端口上运行。\n\n接下来我们需要安装`PyMongo`这个库，它是`Python`用来操作`MongoDB`的第三方库，直接用`pip3`安装即可：\n\n```python\npip3 install pymongo\n```\n\n## 连接MongoDB\n\n连接`MongoDB`时，需要使用`PyMongo`库里面的`MongoClient`。一般来说，向其传入`MongoDB`的`IP`及端口即可，其中第一个参数为地址`host`，第二个参数为端口 `port`（如果不给它传递参数，则默认是`27017`）：\n\n```python\nimport pymongo\n\nclient = pymongo.MongoClient(host='localhost', port=27017)\n```\n\n另外，`MongoClient`的第一个参数`host`还可以直接传入`MongoDB`的连接字符串，它以`mongodb`开头，例如：\n\n```python\nclient = MongoClient('mongodb://localhost:27017/')\n```\n\n这样也可以达到同样的连接效果。\n\n### 指定数据库\n\n`MongoDB`中可以建立多个数据库，接下来指定操作其中一个数据库。这里以`test`数据库作为下一步需要在程序中指定使用的例子：\n\n```python\ndb = client.test\n```\n\n这里调用`client`的`test`属性即可返回`test`数据库。当然，也可以这样指定：\n\n```python\ndb = client['test']\n```\n\n这两种方式是等价的。\n\n### 指定集合\n\n`MongoDB`的每个数据库又包含许多集合`（collection）`，它们类似于关系型数据库中的表。\n\n下一步需要指定要操作的集合，这里指定一个名称为`students`的集合。与指定数据库类似，指定集合也有两种方式：\n\n```python\ncollection = db.students\n```\n\n或是\n\n```python\ncollection = db['students']\n```\n\n这样便声明了一个`Collection`对象。\n\n### 插入数据\n\n接下来，便可以插入数据了。对`students`这个集合新建一条学生数据，这条数据以字典形式表示：\n\n```python\nstudent = {\n    'id': '20170101',\n    'name': 'Jordan',\n    'age':'20',\n    'gender': 'male'\n}\n```\n\n新建的这条数据里指定了学生的学号、姓名、年龄和性别。直接调用`collection`的`insert`方法即可插入数据，代码如下：\n\n```python\nresult = collection.insert(student)\nprint(result)\n```\n\n在`MongoDB`中，每条数据其实都有一个`_id`属性来唯一标识。如果没有显式指明该属性，`MongoDB`会自动产生一个`ObjectId`类型的`_id`属性。`insert()`方法会在执行后返回`_id`值。\n\n运行结果如下：\n\n```python\n60aa06aca3aff156a9093404\n```\n\n当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：\n\n```python\nstudent1 = {\n    'id': '20170102',\n    'name': 'Jack',\n    'age':'23',\n    'gender': 'male'\n}\n\nstudent2 = {\n    'id': '201701013',\n    'name': 'Holy',\n    'age':'25',\n    'gender': 'male'\n}\nresult = collection.insert([student1, student2])\nprint(result)\n```\n\n返回结果是对应的`_id`的集合：\n\n```python\n[ObjectId('60aa07d11755f43c2a5becf3'), ObjectId('60aa07d11755f43c2a5becf4')]\n```\n\n在`PyMongo`中，官方已经不推荐使用`insert`方法了。但是如果你要继续使用也没有什么问题。目前，官方推荐使用`insert_one`和`insert_many`方法来分别插入单条记录和多条记录，示例如下：\n\n```python\nstudent = {\n    'id': '20170101',\n    'name': 'Jordan',\n    'age':'20',\n    'gender': 'male'\n}\n\nresult = collection.insert_one(student)\nprint(result)\nprint(result.inserted_id)\n```\n\n运行结果如下：\n\n```python\n<pymongo.results.InsertOneResult object at 0x00000267F7E9CD80>\n60aa0884c1479c83fc0e07a6\n```\n\n与`insert`方法不同，返回的是`InsertOneResult`对象，可以调用其`inserted_id`属性获取`_id`。 对于`insert_many`方法，可以将数据以列表形式传递，示例如下：\n\n```python\nstudent1 = {\n    'id': '20170102',\n    'name': 'Jack',\n    'age':'23',\n    'gender': 'male'\n}\n\nstudent2 = {\n    'id': '201701013',\n    'name': 'Holy',\n    'age':'25',\n    'gender': 'male'\n}\nresult = collection.insert_many([student1,student2])\nprint(result)\nprint(result.inserted_ids)\n```\n\n运行结果如下：\n\n```python\n<pymongo.results.InsertManyResult object at 0x0000021A0BA7A780>\n[ObjectId('60aa0908ba9556afc2c8ebec'), ObjectId('60aa0908ba9556afc2c8ebed')]\n```\n\n该方法返回的类型是`InsertManyResult`，调用`inserted_ids`属性可以获取插入数据的`_id`列表。\n\n### 查询数据\n\n插入数据后，可以利用`find_one`或`find`方法进行查询，其中`find_one`查询得到的是单个结果，`find`则返回一个生成器对象。示例如下：\n\n```python\nresult = collection.find_one({'name': 'Holy'})\nprint(result)\n```\n\n这里我们查询`name`为`Holy`的数据，它的返回结果是字典类型，运行结果如下：\n\n查询结果：\n\n```python\n{'_id': ObjectId('60aa07d11755f43c2a5becf4'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n```\n\n可以发现，它多了`_id`属性，这就是`MongoDB`在插入过程中自动添加的。此外，也可以根据`ObjectId`来查询，此时需要调用`bson`库里面的`objectid`：\n\n```python\nfrom bson.objectid import ObjectId\n\nresult = collection.find_one({'_id': ObjectId('60aa07d11755f43c2a5becf4')})\nprint(result)\n```\n\n查询结果：\n\n```python\n{'_id': ObjectId('60aa07d11755f43c2a5becf4'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n```\n\n对于多条数据的查询，可以使用`find`方法。例如，这里查找性别为`male`的数据，示例如下：\n\n```python\nresults = collection.find({'age': 20})\nprint(results)\nfor result in results:\n    print(result)\n```\n\n运行结果如下：\n\n```python\n{'_id': ObjectId('60aa065e109b00a7eee5447b'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa0686802c3967b97d7791'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa06aca3aff156a9093404'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa076374369a6a0801fb4a'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa077162e23647877e4213'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa07d11755f43c2a5becf3'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa07d11755f43c2a5becf4'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n{'_id': ObjectId('60aa0884c1479c83fc0e07a6'), 'id': '20170101', 'name': 'Jordan', 'age': '20', 'gender': 'male'}\n{'_id': ObjectId('60aa08f67cd6ac92cb505552'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa08f67cd6ac92cb505553'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n{'_id': ObjectId('60aa0908ba9556afc2c8ebec'), 'id': '20170102', 'name': 'Jack', 'age': '23', 'gender': 'male'}\n{'_id': ObjectId('60aa0908ba9556afc2c8ebed'), 'id': '201701013', 'name': 'Holy', 'age': '25', 'gender': 'male'}\n```\n\n返回结果是`Cursor`类型，它相当于一个生成器，需要遍历获取的所有结果，其中每个结果都是字典类型。\n\n如果要查询年龄大于`20`的数据，则写法如下：\n\n```python\nresults = collection.find({'age': {'$gt': 20}})\n```\n\n查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号`$gt`，意思是**大于**，键值为`20`。\n\n比较符号归纳如下：\n\n| 符号 | 含义 | 示例 |\n| :---: | :---: | :---: |\n| $lt | 小于 | {'age':{'$lt':20}} |\n| $gt | 大于 | {'age':{'$gt':20}} |\n| $lte | 小于或等于 | {'age':{'$lte':20}} |\n| $gte | 大于或等于 | {'age':{'$gte':20}} |\n| $ne | 不等于 | {'age':{'$ne':20}} |\n| $in | 在范围内 | {'age':{'$in':[20,23]}} |\n| $nin | 不在范围内 | {'age':{'$nin':[20, 23]}} |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n另外，还可以进行正则匹配查询。例如，查询名字以`H`开头的学生数据，示例如下：\n\n```python\nresults = collection.find({'name': {'$regex': '^H.*'}})\n```\n\n这里使用`$regex`来指定正则匹配，`^M.*`代表以`M`开头的正则表达式。\n\n一些功能符号归类为下表：\n\n| 符号 | 含义 | 示例 |\n| :---: | :---: | :---: |\n| $regrx | 匹配正则表达式 | {'name':{'$regex':'^M.*'}} |\n| $exists | 属性是否存在 | {'name':{'$exists':True}} |\n| $type | 类型判断 | {'age':{'$type':'int'}} |\n| $mod | 数字模操作 | {'age':{'$mod':[5,0]}} |\n| $text | 文本查询 | {'$text':{'$search':'Holy'}} |\n| $where | 高级条件查询 | {'$where':'obj.fans_count==obj.follows_count'} |\n\n### 计数\n\n要统计查询结果有多少条数据，可以调用`count`方法。以统计所有数据条数为例：\n\n```python\ncount = collection.find().count()\nprint(count)\n```\n\n我们还可以统计符合某个条件的数据：\n\n```python\ncount = collection.find({'age': 20}).count() \nprint(count)\n```\n\n运行结果是一个数值，即符合条件的数据条数。\n\n### 排序\n\n排序时，可以直接调用`sort`方法，并在其中传入排序的字段及升降序标志。示例如下：\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING)\nprint([result['name'] for result in results])\n```\n\n运行结果如下：\n\n```python\n['Holy', 'Holy', 'Holy', 'Holy', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jordan', 'Jordan', 'Jordan', 'Jordan']\n```\n\n调用`pymongo.ASCENDING`指定升序。如果要降序排列，可以传入`pymongo.DESCENDING`。\n\n### 偏移\n\n只需要取某几个元素，可以利用`skip`方法偏移几个位置，比如偏移2，就代表忽略前两个元素，得到第3个及以后的元素：\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING).skip(3)\nprint([result['name'] for result in results])\n```\n\n运行结果如下：\n\n```python\n['Holy', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jack', 'Jordan', 'Jordan', 'Jordan', 'Jordan']\n```\n\n还可以用`limit`方法指定要取的结果个数，示例如下：\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING).limit(1)\nprint([result['name'] for result in results])\n```\n\n运行结果如下：\n\n```python\n['Holy']\n```\n\n值得注意的是，在数据量非常庞大的时候，比如在查询千万、亿级别的数据库时，最好不要使用大的偏移量，因为这样很可能导致内存溢出。\n\n### 更新\n\n数据更新，可以使用`update`方法，指定更新的条件和更新后的数据即可。例如：\n\n```python\ncondition = {'name': 'Holy'}\nstudent = collection.find_one(condition)\nstudent['age'] = 30\nresult = collection.update(condition, student)\nprint(result)\n```\n\n更新`name`为`Holy`的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用`update`方法将原条件和修改后的数据传入。\n\n运行结果如下：\n\n```python\n{'n': 1, 'nModified': 0, 'ok': 1.0, 'updatedExisting': True}\n```\n\n返回结果是字典形式，`ok`代表执行成功，`nModified`代表影响的数据条数。\n\n也可以使用`$set`操作符对数据进行更新，代码如下：\n\n```python\nresult = collection.update(condition, {'$set': student})\n```\n\n这样可以只更新`student`字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用`$set`的话，则会把之前的数据全部用`student`字典替换；如果原本存在其他字段，则会被删除。\n\n`update`方法其实也是官方不推荐使用的方法。这里也分为`update_one`方法和`update_many`方法，用法更加严格，它们的第2个参数需要使用`$`类型操作符作为字典的键名，示例如下:\n\n```python\ncondition = {'name': 'Kevin'} \nstudent = collection.find_one(condition)\nstudent['age'] = 26\nresult = collection.update_one(condition, {'$set': student})\nprint(result) print(result.matched_count, result.modified_count)\n```\n\n上面的例子中调用了`update_one`方法，使得第2个参数不能再直接传入修改后的字典，而是需要使用`{'$set':student}`这样的形式，其返回结果是`UpdateResult`类型。然后分别调用`matched_count`和`modified_count`属性，可以获得匹配的数据条数和影响的数据条数。\n\n运行结果如下：\n\n```python\n<pymongo.results.UpdateResult object at 0x10d17b678>\n1 0\n```\n\n## 删除\n\n删除操作比较简单，直接调用`remove`方法指定删除的条件即可，此时符合条件的所有数据均会被删除。\n\n示例如下：\n\n```python\nresult = collection.remove({'name': 'Kevin'})\nprint(result)\n```\n\n运行结果如下：\n\n```python\n{'ok': 1, 'n': 1}\n```\n\n另外，这里依然存在两个新的推荐方法 ——`delete_one`和`delete_many`，示例如下：\n\n```python\nresult = collection.delete_one({'name': 'Kevin'})\nprint(result) \nprint(result.deleted_count)\nresult = collection.delete_many({'age': {'$lt': 25}})\nprint(result.deleted_count)\n```\n\n运行结果如下：\n\n```python\n<pymongo.results.DeleteResult object at 0x10e6ba4c8> \n14\n```\n\n`delete_one`删除第一条符合条件的数据，`delete_many`即删除所有符合条件的数据。它们的返回结果都是`DeleteResult`类型，可以调用`deleted_count`属性获取删除的数据条数。\n","slug":"MongoDB数据库的使用","published":1,"updated":"2021-06-15T03:24:11.461Z","_id":"ckpapu7hd0007lcxubbf9023a","layout":"post","photos":[],"link":"","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>开始之前，请确保你已经安装好了<code>MongoDB</code>并启动了其服务，同时安装好了<code>Python</code>的<code>PyMongo</code>库。</p>\n<p>安装好之后，我们需要把<code>MongoDB</code>服务启动起来。启动完成之后，它会默认在本地<code>localhost</code>的<code>27017</code>端口上运行。</p>\n<p>接下来我们需要安装<code>PyMongo</code>这个库，它是<code>Python</code>用来操作<code>MongoDB</code>的第三方库，直接用<code>pip3</code>安装即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install pymongo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接MongoDB\"><a href=\"#连接MongoDB\" class=\"headerlink\" title=\"连接MongoDB\"></a>连接MongoDB</h2><p>连接<code>MongoDB</code>时，需要使用<code>PyMongo</code>库里面的<code>MongoClient</code>。一般来说，向其传入<code>MongoDB</code>的<code>IP</code>及端口即可，其中第一个参数为地址<code>host</code>，第二个参数为端口 <code>port</code>（如果不给它传递参数，则默认是<code>27017</code>）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymongo</span><br><span class=\"line\"></span><br><span class=\"line\">client = pymongo.MongoClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">27017</span>)</span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>MongoClient</code>的第一个参数<code>host</code>还可以直接传入<code>MongoDB</code>的连接字符串，它以<code>mongodb</code>开头，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client = MongoClient(<span class=\"string\">&#x27;mongodb://localhost:27017/&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这样也可以达到同样的连接效果。</p>\n<h3 id=\"指定数据库\"><a href=\"#指定数据库\" class=\"headerlink\" title=\"指定数据库\"></a>指定数据库</h3><p><code>MongoDB</code>中可以建立多个数据库，接下来指定操作其中一个数据库。这里以<code>test</code>数据库作为下一步需要在程序中指定使用的例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db = client.test</span><br></pre></td></tr></table></figure>\n\n<p>这里调用<code>client</code>的<code>test</code>属性即可返回<code>test</code>数据库。当然，也可以这样指定：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db = client[<span class=\"string\">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这两种方式是等价的。</p>\n<h3 id=\"指定集合\"><a href=\"#指定集合\" class=\"headerlink\" title=\"指定集合\"></a>指定集合</h3><p><code>MongoDB</code>的每个数据库又包含许多集合<code>（collection）</code>，它们类似于关系型数据库中的表。</p>\n<p>下一步需要指定要操作的集合，这里指定一个名称为<code>students</code>的集合。与指定数据库类似，指定集合也有两种方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection = db.students</span><br></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection = db[<span class=\"string\">&#x27;students&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这样便声明了一个<code>Collection</code>对象。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><p>接下来，便可以插入数据了。对<code>students</code>这个集合新建一条学生数据，这条数据以字典形式表示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;20&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建的这条数据里指定了学生的学号、姓名、年龄和性别。直接调用<code>collection</code>的<code>insert</code>方法即可插入数据，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.insert(student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>MongoDB</code>中，每条数据其实都有一个<code>_id</code>属性来唯一标识。如果没有显式指明该属性，<code>MongoDB</code>会自动产生一个<code>ObjectId</code>类型的<code>_id</code>属性。<code>insert()</code>方法会在执行后返回<code>_id</code>值。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">60aa06aca3aff156a9093404</span><br></pre></td></tr></table></figure>\n\n<p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student1 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;23&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">student2 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;25&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result = collection.insert([student1, student2])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>返回结果是对应的<code>_id</code>的集合：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf3&#x27;</span>), ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>在<code>PyMongo</code>中，官方已经不推荐使用<code>insert</code>方法了。但是如果你要继续使用也没有什么问题。目前，官方推荐使用<code>insert_one</code>和<code>insert_many</code>方法来分别插入单条记录和多条记录，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;20&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">result = collection.insert_one(student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.inserted_id)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.InsertOneResult <span class=\"built_in\">object</span> at <span class=\"number\">0x00000267F7E9CD80</span>&gt;</span><br><span class=\"line\">60aa0884c1479c83fc0e07a6</span><br></pre></td></tr></table></figure>\n\n<p>与<code>insert</code>方法不同，返回的是<code>InsertOneResult</code>对象，可以调用其<code>inserted_id</code>属性获取<code>_id</code>。 对于<code>insert_many</code>方法，可以将数据以列表形式传递，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student1 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;23&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">student2 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;25&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result = collection.insert_many([student1,student2])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.inserted_ids)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.InsertManyResult <span class=\"built_in\">object</span> at <span class=\"number\">0x0000021A0BA7A780</span>&gt;</span><br><span class=\"line\">[ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebec&#x27;</span>), ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebed&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>该方法返回的类型是<code>InsertManyResult</code>，调用<code>inserted_ids</code>属性可以获取插入数据的<code>_id</code>列表。</p>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>插入数据后，可以利用<code>find_one</code>或<code>find</code>方法进行查询，其中<code>find_one</code>查询得到的是单个结果，<code>find</code>则返回一个生成器对象。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.find_one(&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>这里我们查询<code>name</code>为<code>Holy</code>的数据，它的返回结果是字典类型，运行结果如下：</p>\n<p>查询结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，它多了<code>_id</code>属性，这就是<code>MongoDB</code>在插入过程中自动添加的。此外，也可以根据<code>ObjectId</code>来查询，此时需要调用<code>bson</code>库里面的<code>objectid</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> bson.objectid <span class=\"keyword\">import</span> ObjectId</span><br><span class=\"line\"></span><br><span class=\"line\">result = collection.find_one(&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>)&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>查询结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于多条数据的查询，可以使用<code>find</code>方法。例如，这里查找性别为<code>male</code>的数据，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find(&#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(results)</span><br><span class=\"line\"><span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa065e109b00a7eee5447b&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0686802c3967b97d7791&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa06aca3aff156a9093404&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa076374369a6a0801fb4a&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa077162e23647877e4213&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf3&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0884c1479c83fc0e07a6&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa08f67cd6ac92cb505552&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa08f67cd6ac92cb505553&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebec&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebed&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回结果是<code>Cursor</code>类型，它相当于一个生成器，需要遍历获取的所有结果，其中每个结果都是字典类型。</p>\n<p>如果要查询年龄大于<code>20</code>的数据，则写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find(&#123;<span class=\"string\">&#x27;age&#x27;</span>: &#123;<span class=\"string\">&#x27;$gt&#x27;</span>: <span class=\"number\">20</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号<code>$gt</code>，意思是<strong>大于</strong>，键值为<code>20</code>。</p>\n<p>比较符号归纳如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$lt</td>\n<td align=\"center\">小于</td>\n<td align=\"center\">{‘age’:{‘$lt’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$gt</td>\n<td align=\"center\">大于</td>\n<td align=\"center\">{‘age’:{‘$gt’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$lte</td>\n<td align=\"center\">小于或等于</td>\n<td align=\"center\">{‘age’:{‘$lte’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$gte</td>\n<td align=\"center\">大于或等于</td>\n<td align=\"center\">{‘age’:{‘$gte’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$ne</td>\n<td align=\"center\">不等于</td>\n<td align=\"center\">{‘age’:{‘$ne’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$in</td>\n<td align=\"center\">在范围内</td>\n<td align=\"center\">{‘age’:{‘$in’:[20,23]}}</td>\n</tr>\n<tr>\n<td align=\"center\">$nin</td>\n<td align=\"center\">不在范围内</td>\n<td align=\"center\">{‘age’:{‘$nin’:[20, 23]}}</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n<p>另外，还可以进行正则匹配查询。例如，查询名字以<code>H</code>开头的学生数据，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find(&#123;<span class=\"string\">&#x27;name&#x27;</span>: &#123;<span class=\"string\">&#x27;$regex&#x27;</span>: <span class=\"string\">&#x27;^H.*&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里使用<code>$regex</code>来指定正则匹配，<code>^M.*</code>代表以<code>M</code>开头的正则表达式。</p>\n<p>一些功能符号归类为下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$regrx</td>\n<td align=\"center\">匹配正则表达式</td>\n<td align=\"center\">{‘name’:{‘$regex’:’^M.*’}}</td>\n</tr>\n<tr>\n<td align=\"center\">$exists</td>\n<td align=\"center\">属性是否存在</td>\n<td align=\"center\">{‘name’:{‘$exists’:True}}</td>\n</tr>\n<tr>\n<td align=\"center\">$type</td>\n<td align=\"center\">类型判断</td>\n<td align=\"center\">{‘age’:{‘$type’:’int’}}</td>\n</tr>\n<tr>\n<td align=\"center\">$mod</td>\n<td align=\"center\">数字模操作</td>\n<td align=\"center\">{‘age’:{‘$mod’:[5,0]}}</td>\n</tr>\n<tr>\n<td align=\"center\">$text</td>\n<td align=\"center\">文本查询</td>\n<td align=\"center\">{‘$text’:{‘$search’:’Holy’}}</td>\n</tr>\n<tr>\n<td align=\"center\">$where</td>\n<td align=\"center\">高级条件查询</td>\n<td align=\"center\">{‘$where’:’obj.fans_count==obj.follows_count’}</td>\n</tr>\n</tbody></table>\n<h3 id=\"计数\"><a href=\"#计数\" class=\"headerlink\" title=\"计数\"></a>计数</h3><p>要统计查询结果有多少条数据，可以调用<code>count</code>方法。以统计所有数据条数为例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = collection.find().count()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(count)</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以统计符合某个条件的数据：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = collection.find(&#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">20</span>&#125;).count() </span><br><span class=\"line\"><span class=\"built_in\">print</span>(count)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果是一个数值，即符合条件的数据条数。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>排序时，可以直接调用<code>sort</code>方法，并在其中传入排序的字段及升降序标志。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find().sort(<span class=\"string\">&#x27;name&#x27;</span>, pymongo.ASCENDING)</span><br><span class=\"line\"><span class=\"built_in\">print</span>([result[<span class=\"string\">&#x27;name&#x27;</span>] <span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results])</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>pymongo.ASCENDING</code>指定升序。如果要降序排列，可以传入<code>pymongo.DESCENDING</code>。</p>\n<h3 id=\"偏移\"><a href=\"#偏移\" class=\"headerlink\" title=\"偏移\"></a>偏移</h3><p>只需要取某几个元素，可以利用<code>skip</code>方法偏移几个位置，比如偏移2，就代表忽略前两个元素，得到第3个及以后的元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find().sort(<span class=\"string\">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>([result[<span class=\"string\">&#x27;name&#x27;</span>] <span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results])</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>还可以用<code>limit</code>方法指定要取的结果个数，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find().sort(<span class=\"string\">&#x27;name&#x27;</span>, pymongo.ASCENDING).limit(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>([result[<span class=\"string\">&#x27;name&#x27;</span>] <span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results])</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;Holy&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，在数据量非常庞大的时候，比如在查询千万、亿级别的数据库时，最好不要使用大的偏移量，因为这样很可能导致内存溢出。</p>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><p>数据更新，可以使用<code>update</code>方法，指定更新的条件和更新后的数据即可。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>&#125;</span><br><span class=\"line\">student = collection.find_one(condition)</span><br><span class=\"line\">student[<span class=\"string\">&#x27;age&#x27;</span>] = <span class=\"number\">30</span></span><br><span class=\"line\">result = collection.update(condition, student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>更新<code>name</code>为<code>Holy</code>的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用<code>update</code>方法将原条件和修改后的数据传入。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;n&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;nModified&#x27;</span>: <span class=\"number\">0</span>, <span class=\"string\">&#x27;ok&#x27;</span>: <span class=\"number\">1.0</span>, <span class=\"string\">&#x27;updatedExisting&#x27;</span>: <span class=\"literal\">True</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回结果是字典形式，<code>ok</code>代表执行成功，<code>nModified</code>代表影响的数据条数。</p>\n<p>也可以使用<code>$set</code>操作符对数据进行更新，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.update(condition, &#123;<span class=\"string\">&#x27;$set&#x27;</span>: student&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样可以只更新<code>student</code>字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用<code>$set</code>的话，则会把之前的数据全部用<code>student</code>字典替换；如果原本存在其他字段，则会被删除。</p>\n<p><code>update</code>方法其实也是官方不推荐使用的方法。这里也分为<code>update_one</code>方法和<code>update_many</code>方法，用法更加严格，它们的第2个参数需要使用<code>$</code>类型操作符作为字典的键名，示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Kevin&#x27;</span>&#125; </span><br><span class=\"line\">student = collection.find_one(condition)</span><br><span class=\"line\">student[<span class=\"string\">&#x27;age&#x27;</span>] = <span class=\"number\">26</span></span><br><span class=\"line\">result = collection.update_one(condition, &#123;<span class=\"string\">&#x27;$set&#x27;</span>: student&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result) <span class=\"built_in\">print</span>(result.matched_count, result.modified_count)</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中调用了<code>update_one</code>方法，使得第2个参数不能再直接传入修改后的字典，而是需要使用<code>&#123;&#39;$set&#39;:student&#125;</code>这样的形式，其返回结果是<code>UpdateResult</code>类型。然后分别调用<code>matched_count</code>和<code>modified_count</code>属性，可以获得匹配的数据条数和影响的数据条数。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.UpdateResult <span class=\"built_in\">object</span> at <span class=\"number\">0x10d17b678</span>&gt;</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>删除操作比较简单，直接调用<code>remove</code>方法指定删除的条件即可，此时符合条件的所有数据均会被删除。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.remove(&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Kevin&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;ok&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;n&#x27;</span>: <span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，这里依然存在两个新的推荐方法 ——<code>delete_one</code>和<code>delete_many</code>，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.delete_one(&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Kevin&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.deleted_count)</span><br><span class=\"line\">result = collection.delete_many(&#123;<span class=\"string\">&#x27;age&#x27;</span>: &#123;<span class=\"string\">&#x27;$lt&#x27;</span>: <span class=\"number\">25</span>&#125;&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.deleted_count)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.DeleteResult <span class=\"built_in\">object</span> at <span class=\"number\">0x10e6ba4c8</span>&gt; </span><br><span class=\"line\"><span class=\"number\">14</span></span><br></pre></td></tr></table></figure>\n\n<p><code>delete_one</code>删除第一条符合条件的数据，<code>delete_many</code>即删除所有符合条件的数据。它们的返回结果都是<code>DeleteResult</code>类型，可以调用<code>deleted_count</code>属性获取删除的数据条数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>开始之前，请确保你已经安装好了<code>MongoDB</code>并启动了其服务，同时安装好了<code>Python</code>的<code>PyMongo</code>库。</p>\n<p>安装好之后，我们需要把<code>MongoDB</code>服务启动起来。启动完成之后，它会默认在本地<code>localhost</code>的<code>27017</code>端口上运行。</p>\n<p>接下来我们需要安装<code>PyMongo</code>这个库，它是<code>Python</code>用来操作<code>MongoDB</code>的第三方库，直接用<code>pip3</code>安装即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install pymongo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接MongoDB\"><a href=\"#连接MongoDB\" class=\"headerlink\" title=\"连接MongoDB\"></a>连接MongoDB</h2><p>连接<code>MongoDB</code>时，需要使用<code>PyMongo</code>库里面的<code>MongoClient</code>。一般来说，向其传入<code>MongoDB</code>的<code>IP</code>及端口即可，其中第一个参数为地址<code>host</code>，第二个参数为端口 <code>port</code>（如果不给它传递参数，则默认是<code>27017</code>）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymongo</span><br><span class=\"line\"></span><br><span class=\"line\">client = pymongo.MongoClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">27017</span>)</span><br></pre></td></tr></table></figure>\n\n<p>另外，<code>MongoClient</code>的第一个参数<code>host</code>还可以直接传入<code>MongoDB</code>的连接字符串，它以<code>mongodb</code>开头，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client = MongoClient(<span class=\"string\">&#x27;mongodb://localhost:27017/&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这样也可以达到同样的连接效果。</p>\n<h3 id=\"指定数据库\"><a href=\"#指定数据库\" class=\"headerlink\" title=\"指定数据库\"></a>指定数据库</h3><p><code>MongoDB</code>中可以建立多个数据库，接下来指定操作其中一个数据库。这里以<code>test</code>数据库作为下一步需要在程序中指定使用的例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db = client.test</span><br></pre></td></tr></table></figure>\n\n<p>这里调用<code>client</code>的<code>test</code>属性即可返回<code>test</code>数据库。当然，也可以这样指定：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db = client[<span class=\"string\">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这两种方式是等价的。</p>\n<h3 id=\"指定集合\"><a href=\"#指定集合\" class=\"headerlink\" title=\"指定集合\"></a>指定集合</h3><p><code>MongoDB</code>的每个数据库又包含许多集合<code>（collection）</code>，它们类似于关系型数据库中的表。</p>\n<p>下一步需要指定要操作的集合，这里指定一个名称为<code>students</code>的集合。与指定数据库类似，指定集合也有两种方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection = db.students</span><br></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection = db[<span class=\"string\">&#x27;students&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这样便声明了一个<code>Collection</code>对象。</p>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><p>接下来，便可以插入数据了。对<code>students</code>这个集合新建一条学生数据，这条数据以字典形式表示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;20&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建的这条数据里指定了学生的学号、姓名、年龄和性别。直接调用<code>collection</code>的<code>insert</code>方法即可插入数据，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.insert(student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>MongoDB</code>中，每条数据其实都有一个<code>_id</code>属性来唯一标识。如果没有显式指明该属性，<code>MongoDB</code>会自动产生一个<code>ObjectId</code>类型的<code>_id</code>属性。<code>insert()</code>方法会在执行后返回<code>_id</code>值。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">60aa06aca3aff156a9093404</span><br></pre></td></tr></table></figure>\n\n<p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student1 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;23&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">student2 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;25&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result = collection.insert([student1, student2])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>返回结果是对应的<code>_id</code>的集合：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf3&#x27;</span>), ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>在<code>PyMongo</code>中，官方已经不推荐使用<code>insert</code>方法了。但是如果你要继续使用也没有什么问题。目前，官方推荐使用<code>insert_one</code>和<code>insert_many</code>方法来分别插入单条记录和多条记录，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;20&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">result = collection.insert_one(student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.inserted_id)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.InsertOneResult <span class=\"built_in\">object</span> at <span class=\"number\">0x00000267F7E9CD80</span>&gt;</span><br><span class=\"line\">60aa0884c1479c83fc0e07a6</span><br></pre></td></tr></table></figure>\n\n<p>与<code>insert</code>方法不同，返回的是<code>InsertOneResult</code>对象，可以调用其<code>inserted_id</code>属性获取<code>_id</code>。 对于<code>insert_many</code>方法，可以将数据以列表形式传递，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">student1 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;23&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">student2 = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;25&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result = collection.insert_many([student1,student2])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.inserted_ids)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.InsertManyResult <span class=\"built_in\">object</span> at <span class=\"number\">0x0000021A0BA7A780</span>&gt;</span><br><span class=\"line\">[ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebec&#x27;</span>), ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebed&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>该方法返回的类型是<code>InsertManyResult</code>，调用<code>inserted_ids</code>属性可以获取插入数据的<code>_id</code>列表。</p>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>插入数据后，可以利用<code>find_one</code>或<code>find</code>方法进行查询，其中<code>find_one</code>查询得到的是单个结果，<code>find</code>则返回一个生成器对象。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.find_one(&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>这里我们查询<code>name</code>为<code>Holy</code>的数据，它的返回结果是字典类型，运行结果如下：</p>\n<p>查询结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，它多了<code>_id</code>属性，这就是<code>MongoDB</code>在插入过程中自动添加的。此外，也可以根据<code>ObjectId</code>来查询，此时需要调用<code>bson</code>库里面的<code>objectid</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> bson.objectid <span class=\"keyword\">import</span> ObjectId</span><br><span class=\"line\"></span><br><span class=\"line\">result = collection.find_one(&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>)&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>查询结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于多条数据的查询，可以使用<code>find</code>方法。例如，这里查找性别为<code>male</code>的数据，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find(&#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(results)</span><br><span class=\"line\"><span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa065e109b00a7eee5447b&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0686802c3967b97d7791&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa06aca3aff156a9093404&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa076374369a6a0801fb4a&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa077162e23647877e4213&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf3&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa07d11755f43c2a5becf4&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0884c1479c83fc0e07a6&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170101&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;20&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa08f67cd6ac92cb505552&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa08f67cd6ac92cb505553&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebec&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;20170102&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;23&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;_id&#x27;</span>: ObjectId(<span class=\"string\">&#x27;60aa0908ba9556afc2c8ebed&#x27;</span>), <span class=\"string\">&#x27;id&#x27;</span>: <span class=\"string\">&#x27;201701013&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"string\">&#x27;25&#x27;</span>, <span class=\"string\">&#x27;gender&#x27;</span>: <span class=\"string\">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回结果是<code>Cursor</code>类型，它相当于一个生成器，需要遍历获取的所有结果，其中每个结果都是字典类型。</p>\n<p>如果要查询年龄大于<code>20</code>的数据，则写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find(&#123;<span class=\"string\">&#x27;age&#x27;</span>: &#123;<span class=\"string\">&#x27;$gt&#x27;</span>: <span class=\"number\">20</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号<code>$gt</code>，意思是<strong>大于</strong>，键值为<code>20</code>。</p>\n<p>比较符号归纳如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$lt</td>\n<td align=\"center\">小于</td>\n<td align=\"center\">{‘age’:{‘$lt’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$gt</td>\n<td align=\"center\">大于</td>\n<td align=\"center\">{‘age’:{‘$gt’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$lte</td>\n<td align=\"center\">小于或等于</td>\n<td align=\"center\">{‘age’:{‘$lte’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$gte</td>\n<td align=\"center\">大于或等于</td>\n<td align=\"center\">{‘age’:{‘$gte’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$ne</td>\n<td align=\"center\">不等于</td>\n<td align=\"center\">{‘age’:{‘$ne’:20}}</td>\n</tr>\n<tr>\n<td align=\"center\">$in</td>\n<td align=\"center\">在范围内</td>\n<td align=\"center\">{‘age’:{‘$in’:[20,23]}}</td>\n</tr>\n<tr>\n<td align=\"center\">$nin</td>\n<td align=\"center\">不在范围内</td>\n<td align=\"center\">{‘age’:{‘$nin’:[20, 23]}}</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n<p>另外，还可以进行正则匹配查询。例如，查询名字以<code>H</code>开头的学生数据，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find(&#123;<span class=\"string\">&#x27;name&#x27;</span>: &#123;<span class=\"string\">&#x27;$regex&#x27;</span>: <span class=\"string\">&#x27;^H.*&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里使用<code>$regex</code>来指定正则匹配，<code>^M.*</code>代表以<code>M</code>开头的正则表达式。</p>\n<p>一些功能符号归类为下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$regrx</td>\n<td align=\"center\">匹配正则表达式</td>\n<td align=\"center\">{‘name’:{‘$regex’:’^M.*’}}</td>\n</tr>\n<tr>\n<td align=\"center\">$exists</td>\n<td align=\"center\">属性是否存在</td>\n<td align=\"center\">{‘name’:{‘$exists’:True}}</td>\n</tr>\n<tr>\n<td align=\"center\">$type</td>\n<td align=\"center\">类型判断</td>\n<td align=\"center\">{‘age’:{‘$type’:’int’}}</td>\n</tr>\n<tr>\n<td align=\"center\">$mod</td>\n<td align=\"center\">数字模操作</td>\n<td align=\"center\">{‘age’:{‘$mod’:[5,0]}}</td>\n</tr>\n<tr>\n<td align=\"center\">$text</td>\n<td align=\"center\">文本查询</td>\n<td align=\"center\">{‘$text’:{‘$search’:’Holy’}}</td>\n</tr>\n<tr>\n<td align=\"center\">$where</td>\n<td align=\"center\">高级条件查询</td>\n<td align=\"center\">{‘$where’:’obj.fans_count==obj.follows_count’}</td>\n</tr>\n</tbody></table>\n<h3 id=\"计数\"><a href=\"#计数\" class=\"headerlink\" title=\"计数\"></a>计数</h3><p>要统计查询结果有多少条数据，可以调用<code>count</code>方法。以统计所有数据条数为例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = collection.find().count()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(count)</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以统计符合某个条件的数据：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = collection.find(&#123;<span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">20</span>&#125;).count() </span><br><span class=\"line\"><span class=\"built_in\">print</span>(count)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果是一个数值，即符合条件的数据条数。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>排序时，可以直接调用<code>sort</code>方法，并在其中传入排序的字段及升降序标志。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find().sort(<span class=\"string\">&#x27;name&#x27;</span>, pymongo.ASCENDING)</span><br><span class=\"line\"><span class=\"built_in\">print</span>([result[<span class=\"string\">&#x27;name&#x27;</span>] <span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results])</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>pymongo.ASCENDING</code>指定升序。如果要降序排列，可以传入<code>pymongo.DESCENDING</code>。</p>\n<h3 id=\"偏移\"><a href=\"#偏移\" class=\"headerlink\" title=\"偏移\"></a>偏移</h3><p>只需要取某几个元素，可以利用<code>skip</code>方法偏移几个位置，比如偏移2，就代表忽略前两个元素，得到第3个及以后的元素：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find().sort(<span class=\"string\">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>([result[<span class=\"string\">&#x27;name&#x27;</span>] <span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results])</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;Holy&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jack&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>, <span class=\"string\">&#x27;Jordan&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>还可以用<code>limit</code>方法指定要取的结果个数，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">results = collection.find().sort(<span class=\"string\">&#x27;name&#x27;</span>, pymongo.ASCENDING).limit(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>([result[<span class=\"string\">&#x27;name&#x27;</span>] <span class=\"keyword\">for</span> result <span class=\"keyword\">in</span> results])</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;Holy&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，在数据量非常庞大的时候，比如在查询千万、亿级别的数据库时，最好不要使用大的偏移量，因为这样很可能导致内存溢出。</p>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><p>数据更新，可以使用<code>update</code>方法，指定更新的条件和更新后的数据即可。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Holy&#x27;</span>&#125;</span><br><span class=\"line\">student = collection.find_one(condition)</span><br><span class=\"line\">student[<span class=\"string\">&#x27;age&#x27;</span>] = <span class=\"number\">30</span></span><br><span class=\"line\">result = collection.update(condition, student)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>更新<code>name</code>为<code>Holy</code>的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用<code>update</code>方法将原条件和修改后的数据传入。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;n&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;nModified&#x27;</span>: <span class=\"number\">0</span>, <span class=\"string\">&#x27;ok&#x27;</span>: <span class=\"number\">1.0</span>, <span class=\"string\">&#x27;updatedExisting&#x27;</span>: <span class=\"literal\">True</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回结果是字典形式，<code>ok</code>代表执行成功，<code>nModified</code>代表影响的数据条数。</p>\n<p>也可以使用<code>$set</code>操作符对数据进行更新，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.update(condition, &#123;<span class=\"string\">&#x27;$set&#x27;</span>: student&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样可以只更新<code>student</code>字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用<code>$set</code>的话，则会把之前的数据全部用<code>student</code>字典替换；如果原本存在其他字段，则会被删除。</p>\n<p><code>update</code>方法其实也是官方不推荐使用的方法。这里也分为<code>update_one</code>方法和<code>update_many</code>方法，用法更加严格，它们的第2个参数需要使用<code>$</code>类型操作符作为字典的键名，示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Kevin&#x27;</span>&#125; </span><br><span class=\"line\">student = collection.find_one(condition)</span><br><span class=\"line\">student[<span class=\"string\">&#x27;age&#x27;</span>] = <span class=\"number\">26</span></span><br><span class=\"line\">result = collection.update_one(condition, &#123;<span class=\"string\">&#x27;$set&#x27;</span>: student&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result) <span class=\"built_in\">print</span>(result.matched_count, result.modified_count)</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中调用了<code>update_one</code>方法，使得第2个参数不能再直接传入修改后的字典，而是需要使用<code>&#123;&#39;$set&#39;:student&#125;</code>这样的形式，其返回结果是<code>UpdateResult</code>类型。然后分别调用<code>matched_count</code>和<code>modified_count</code>属性，可以获得匹配的数据条数和影响的数据条数。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.UpdateResult <span class=\"built_in\">object</span> at <span class=\"number\">0x10d17b678</span>&gt;</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>删除操作比较简单，直接调用<code>remove</code>方法指定删除的条件即可，此时符合条件的所有数据均会被删除。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.remove(&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Kevin&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;ok&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;n&#x27;</span>: <span class=\"number\">1</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，这里依然存在两个新的推荐方法 ——<code>delete_one</code>和<code>delete_many</code>，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = collection.delete_one(&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Kevin&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.deleted_count)</span><br><span class=\"line\">result = collection.delete_many(&#123;<span class=\"string\">&#x27;age&#x27;</span>: &#123;<span class=\"string\">&#x27;$lt&#x27;</span>: <span class=\"number\">25</span>&#125;&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.deleted_count)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;pymongo.results.DeleteResult <span class=\"built_in\">object</span> at <span class=\"number\">0x10e6ba4c8</span>&gt; </span><br><span class=\"line\"><span class=\"number\">14</span></span><br></pre></td></tr></table></figure>\n\n<p><code>delete_one</code>删除第一条符合条件的数据，<code>delete_many</code>即删除所有符合条件的数据。它们的返回结果都是<code>DeleteResult</code>类型，可以调用<code>deleted_count</code>属性获取删除的数据条数。</p>\n"},{"title":"Nginx配置详解","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-18T03:16:57.000Z","pic":null,"_content":"\n## 简介\n\n`Nginx`是`lgor Sysoev`为俄罗斯访问量第二的`rambler.ru`站点设计开发的。从`2004`年发布至今，凭借开源的力量，已经接近成熟与完善。\n\n`Nginx`功能丰富，可作为`HTTP服务器`，也可作为反向代理服务器，邮件服务器。支持`FastCGI`、`SSL`、`Virtual Host`、`URL Rewrite`、`Gzip`等功能。并且支持很多第三方的模块扩展。\n\n`Nginx`的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有`12.18%`的使用比率，大约为`2220`万个网站。\n\n## Nginx常用功能\n\n### 1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\n\n正向代理和反向代理：\n\n![正向代理和反向代理](1.jpg)\n\n`Nginx`在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。`Nginx`可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的文件服务器，动态页面`web`服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且`Nginx`对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。\n\n### 2、负载均衡\n\n`Nginx`提供的负载均衡策略有2种：`内置策略`和`扩展策略`。内置策略为轮询，加权轮询，`Ip hash`。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。\n\n上3个图，理解这三种负载均衡算法的实现\n\n![负载均衡](2.jpg)\n\nIp hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。\n\n![负载均衡](3.jpg)\n\n### 3、web缓存\n\n`Nginx`可以对不同的文件做不同的缓存处理，配置灵活，并且支持`FastCGI_Cache`，主要用于对`FastCGI`的动态程序进行缓存。配合着第三方的`ngx_cache_purge`，对制定的`URL`缓存内容可以的进行增删管理。\n\n### 4、Nginx相关地址\n\n源码：https://trac.nginx.org/nginx/browser\n\n官网：http://www.nginx.org/\n\n## Nginx配置文件结构\n\n如果你下载好啦，你的安装文件，不妨打开`conf`文件夹的`nginx.conf`文件，`Nginx`服务器的基础配置，默认的配置也存放在此。\n\n在`nginx.conf`的注释符号为：`#`\n\n默认的`nginx`配置文件`nginx.conf`内容如下：\n\n```shell\n#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n```\n\n## nginx 文件结构\n\n```shell\n...              #全局块\n\nevents {         #events块\n   ...\n}\n\nhttp      #http块\n{\n    ...   #http全局块\n    server        #server块\n    { \n        ...       #server全局块\n        location [PATTERN]   #location块\n        {\n            ...\n        }\n        location [PATTERN] \n        {\n            ...\n        }\n    }\n    server\n    {\n      ...\n    }\n    ...     #http全局块\n}\n```\n\n- 1、**全局块**：配置影响`nginx`全局的指令。一般有运行`nginx`服务器的用户组，`nginx`进程`pid`存放路径，日志存放路径，配置文件引入，允许生成`worker process数`等。\n- 2、**events块**：配置影响`nginx`服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。\n- 3、**http块**：可以嵌套多个`server`，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，`mime-type`定义，日志自定义，是否使用`sendfile`传输文件，连接超时时间，单连接请求数等。\n- 4、**server块**：配置虚拟主机的相关参数，一个`http`中可以有多个`server`。\n- 5、**location块**：配置请求的路由，以及各种页面的处理情况。\n\n下面给大家上一个配置文件，作为理解。\n\n```shell\n########### 每个指令必须有分号结束。#################\n#user administrator administrators;  #配置用户或者组，默认为nobody nobody。\n#worker_processes 2;  #允许生成的进程数，默认为1\n#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址\nerror_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg\nevents {\n    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on\n    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off\n    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport\n    worker_connections  1024;    #最大连接数，默认为512\n}\nhttp {\n    include       mime.types;   #文件扩展名与文件类型映射表\n    default_type  application/octet-stream; #默认文件类型，默认为text/plain\n    #access_log off; #取消服务日志    \n    log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式\n    access_log log/access.log myFormat;  #combined为日志格式的默认值\n    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。\n    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。\n    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。\n\n    upstream mysvr {   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  #热备\n    }\n    error_page 404 https://www.baidu.com; #错误页\n    server {\n        keepalive_requests 120; #单连接请求上限次数。\n        listen       4545;   #监听端口\n        server_name  127.0.0.1;   #监听地址       \n        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。\n           #root path;  #根目录\n           #index vv.txt;  #设置默认页\n           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表\n           deny 127.0.0.1;  #拒绝的ip\n           allow 172.18.5.54; #允许的ip           \n        } \n    }\n}\n```\n\n上面是nginx的基本配置，需要注意的有以下几点：\n\n- 1、几个常见配置项\n\n```shell\n1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；\n2.$remote_user ：用来记录客户端用户名称；\n3.$time_local ： 用来记录访问时间与时区；\n4.$request ： 用来记录请求的url与http协议；\n5.$status ： 用来记录请求状态；成功是200；\n6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；\n7.$http_referer ：用来记录从那个页面链接访问过来的；\n8.$http_user_agent ：记录客户端浏览器的相关信息；\n```\n\n- 2、惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。\n\n- 3、每个指令必须有分号结束。\n\n> 原文地址：[https://www.runoob.com/w3cnote/nginx-setup-intro.html](https://www.runoob.com/w3cnote/nginx-setup-intro.html)","source":"_posts/Nginx配置详解.md","raw":"---\ntitle: Nginx配置详解\ntags:\n  - Nginx\n  - 负载均衡\n  - http\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-18 11:16:57\ncategories: Nginx\npic:\n---\n\n## 简介\n\n`Nginx`是`lgor Sysoev`为俄罗斯访问量第二的`rambler.ru`站点设计开发的。从`2004`年发布至今，凭借开源的力量，已经接近成熟与完善。\n\n`Nginx`功能丰富，可作为`HTTP服务器`，也可作为反向代理服务器，邮件服务器。支持`FastCGI`、`SSL`、`Virtual Host`、`URL Rewrite`、`Gzip`等功能。并且支持很多第三方的模块扩展。\n\n`Nginx`的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有`12.18%`的使用比率，大约为`2220`万个网站。\n\n## Nginx常用功能\n\n### 1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\n\n正向代理和反向代理：\n\n![正向代理和反向代理](1.jpg)\n\n`Nginx`在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。`Nginx`可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的文件服务器，动态页面`web`服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且`Nginx`对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。\n\n### 2、负载均衡\n\n`Nginx`提供的负载均衡策略有2种：`内置策略`和`扩展策略`。内置策略为轮询，加权轮询，`Ip hash`。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。\n\n上3个图，理解这三种负载均衡算法的实现\n\n![负载均衡](2.jpg)\n\nIp hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。\n\n![负载均衡](3.jpg)\n\n### 3、web缓存\n\n`Nginx`可以对不同的文件做不同的缓存处理，配置灵活，并且支持`FastCGI_Cache`，主要用于对`FastCGI`的动态程序进行缓存。配合着第三方的`ngx_cache_purge`，对制定的`URL`缓存内容可以的进行增删管理。\n\n### 4、Nginx相关地址\n\n源码：https://trac.nginx.org/nginx/browser\n\n官网：http://www.nginx.org/\n\n## Nginx配置文件结构\n\n如果你下载好啦，你的安装文件，不妨打开`conf`文件夹的`nginx.conf`文件，`Nginx`服务器的基础配置，默认的配置也存放在此。\n\n在`nginx.conf`的注释符号为：`#`\n\n默认的`nginx`配置文件`nginx.conf`内容如下：\n\n```shell\n#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n```\n\n## nginx 文件结构\n\n```shell\n...              #全局块\n\nevents {         #events块\n   ...\n}\n\nhttp      #http块\n{\n    ...   #http全局块\n    server        #server块\n    { \n        ...       #server全局块\n        location [PATTERN]   #location块\n        {\n            ...\n        }\n        location [PATTERN] \n        {\n            ...\n        }\n    }\n    server\n    {\n      ...\n    }\n    ...     #http全局块\n}\n```\n\n- 1、**全局块**：配置影响`nginx`全局的指令。一般有运行`nginx`服务器的用户组，`nginx`进程`pid`存放路径，日志存放路径，配置文件引入，允许生成`worker process数`等。\n- 2、**events块**：配置影响`nginx`服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。\n- 3、**http块**：可以嵌套多个`server`，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，`mime-type`定义，日志自定义，是否使用`sendfile`传输文件，连接超时时间，单连接请求数等。\n- 4、**server块**：配置虚拟主机的相关参数，一个`http`中可以有多个`server`。\n- 5、**location块**：配置请求的路由，以及各种页面的处理情况。\n\n下面给大家上一个配置文件，作为理解。\n\n```shell\n########### 每个指令必须有分号结束。#################\n#user administrator administrators;  #配置用户或者组，默认为nobody nobody。\n#worker_processes 2;  #允许生成的进程数，默认为1\n#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址\nerror_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg\nevents {\n    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on\n    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off\n    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport\n    worker_connections  1024;    #最大连接数，默认为512\n}\nhttp {\n    include       mime.types;   #文件扩展名与文件类型映射表\n    default_type  application/octet-stream; #默认文件类型，默认为text/plain\n    #access_log off; #取消服务日志    \n    log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式\n    access_log log/access.log myFormat;  #combined为日志格式的默认值\n    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。\n    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。\n    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。\n\n    upstream mysvr {   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  #热备\n    }\n    error_page 404 https://www.baidu.com; #错误页\n    server {\n        keepalive_requests 120; #单连接请求上限次数。\n        listen       4545;   #监听端口\n        server_name  127.0.0.1;   #监听地址       \n        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。\n           #root path;  #根目录\n           #index vv.txt;  #设置默认页\n           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表\n           deny 127.0.0.1;  #拒绝的ip\n           allow 172.18.5.54; #允许的ip           \n        } \n    }\n}\n```\n\n上面是nginx的基本配置，需要注意的有以下几点：\n\n- 1、几个常见配置项\n\n```shell\n1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；\n2.$remote_user ：用来记录客户端用户名称；\n3.$time_local ： 用来记录访问时间与时区；\n4.$request ： 用来记录请求的url与http协议；\n5.$status ： 用来记录请求状态；成功是200；\n6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；\n7.$http_referer ：用来记录从那个页面链接访问过来的；\n8.$http_user_agent ：记录客户端浏览器的相关信息；\n```\n\n- 2、惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。\n\n- 3、每个指令必须有分号结束。\n\n> 原文地址：[https://www.runoob.com/w3cnote/nginx-setup-intro.html](https://www.runoob.com/w3cnote/nginx-setup-intro.html)","slug":"Nginx配置详解","published":1,"updated":"2021-06-15T03:24:11.462Z","_id":"ckpapu7ho000alcxu8syz94h2","layout":"post","photos":[],"link":"","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>Nginx</code>是<code>lgor Sysoev</code>为俄罗斯访问量第二的<code>rambler.ru</code>站点设计开发的。从<code>2004</code>年发布至今，凭借开源的力量，已经接近成熟与完善。</p>\n<p><code>Nginx</code>功能丰富，可作为<code>HTTP服务器</code>，也可作为反向代理服务器，邮件服务器。支持<code>FastCGI</code>、<code>SSL</code>、<code>Virtual Host</code>、<code>URL Rewrite</code>、<code>Gzip</code>等功能。并且支持很多第三方的模块扩展。</p>\n<p><code>Nginx</code>的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有<code>12.18%</code>的使用比率，大约为<code>2220</code>万个网站。</p>\n<h2 id=\"Nginx常用功能\"><a href=\"#Nginx常用功能\" class=\"headerlink\" title=\"Nginx常用功能\"></a>Nginx常用功能</h2><h3 id=\"1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\"><a href=\"#1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\" class=\"headerlink\" title=\"1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\"></a>1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理</h3><p>正向代理和反向代理：</p>\n<p><img src=\"1.jpg\" alt=\"正向代理和反向代理\"></p>\n<p><code>Nginx</code>在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。<code>Nginx</code>可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的文件服务器，动态页面<code>web</code>服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且<code>Nginx</code>对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。</p>\n<h3 id=\"2、负载均衡\"><a href=\"#2、负载均衡\" class=\"headerlink\" title=\"2、负载均衡\"></a>2、负载均衡</h3><p><code>Nginx</code>提供的负载均衡策略有2种：<code>内置策略</code>和<code>扩展策略</code>。内置策略为轮询，加权轮询，<code>Ip hash</code>。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。</p>\n<p>上3个图，理解这三种负载均衡算法的实现</p>\n<p><img src=\"2.jpg\" alt=\"负载均衡\"></p>\n<p>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p>\n<p><img src=\"3.jpg\" alt=\"负载均衡\"></p>\n<h3 id=\"3、web缓存\"><a href=\"#3、web缓存\" class=\"headerlink\" title=\"3、web缓存\"></a>3、web缓存</h3><p><code>Nginx</code>可以对不同的文件做不同的缓存处理，配置灵活，并且支持<code>FastCGI_Cache</code>，主要用于对<code>FastCGI</code>的动态程序进行缓存。配合着第三方的<code>ngx_cache_purge</code>，对制定的<code>URL</code>缓存内容可以的进行增删管理。</p>\n<h3 id=\"4、Nginx相关地址\"><a href=\"#4、Nginx相关地址\" class=\"headerlink\" title=\"4、Nginx相关地址\"></a>4、Nginx相关地址</h3><p>源码：<a href=\"https://trac.nginx.org/nginx/browser\">https://trac.nginx.org/nginx/browser</a></p>\n<p>官网：<a href=\"http://www.nginx.org/\">http://www.nginx.org/</a></p>\n<h2 id=\"Nginx配置文件结构\"><a href=\"#Nginx配置文件结构\" class=\"headerlink\" title=\"Nginx配置文件结构\"></a>Nginx配置文件结构</h2><p>如果你下载好啦，你的安装文件，不妨打开<code>conf</code>文件夹的<code>nginx.conf</code>文件，<code>Nginx</code>服务器的基础配置，默认的配置也存放在此。</p>\n<p>在<code>nginx.conf</code>的注释符号为：<code>#</code></p>\n<p>默认的<code>nginx</code>配置文件<code>nginx.conf</code>内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">user  nobody;</span></span><br><span class=\"line\">worker_processes  1;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log  notice;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log  info;</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">pid        logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">    #access_log  logs/access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    #keepalive_timeout  0;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        #error_page  404              /404.html;</span><br><span class=\"line\"></span><br><span class=\"line\">        # redirect server error pages to the static page /50x.html</span><br><span class=\"line\">        #</span><br><span class=\"line\">        error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #location ~ \\.php$ &#123;</span><br><span class=\"line\">        #    proxy_pass   http://127.0.0.1;</span><br><span class=\"line\">        #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #location ~ \\.php$ &#123;</span><br><span class=\"line\">        #    root           html;</span><br><span class=\"line\">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">        #    fastcgi_index  index.php;</span><br><span class=\"line\">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">        #    include        fastcgi_params;</span><br><span class=\"line\">        #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class=\"line\">        # concurs with nginx&#x27;s one</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #location ~ /\\.ht &#123;</span><br><span class=\"line\">        #    deny  all;</span><br><span class=\"line\">        #&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class=\"line\">    #</span><br><span class=\"line\">    #server &#123;</span><br><span class=\"line\">    #    listen       8000;</span><br><span class=\"line\">    #    listen       somename:8080;</span><br><span class=\"line\">    #    server_name  somename  alias  another.alias;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    location / &#123;</span><br><span class=\"line\">    #        root   html;</span><br><span class=\"line\">    #        index  index.html index.htm;</span><br><span class=\"line\">    #    &#125;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # HTTPS server</span><br><span class=\"line\">    #</span><br><span class=\"line\">    #server &#123;</span><br><span class=\"line\">    #    listen       443 ssl;</span><br><span class=\"line\">    #    server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    ssl_certificate      cert.pem;</span><br><span class=\"line\">    #    ssl_certificate_key  cert.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class=\"line\">    #    ssl_session_timeout  5m;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class=\"line\">    #    ssl_prefer_server_ciphers  on;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    location / &#123;</span><br><span class=\"line\">    #        root   html;</span><br><span class=\"line\">    #        index  index.html index.htm;</span><br><span class=\"line\">    #    &#125;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"nginx-文件结构\"><a href=\"#nginx-文件结构\" class=\"headerlink\" title=\"nginx 文件结构\"></a>nginx 文件结构</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...              #全局块</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;         #events块</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http      #http块</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...   #http全局块</span><br><span class=\"line\">    server        #server块</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        ...       #server全局块</span><br><span class=\"line\">        location [PATTERN]   #location块</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location [PATTERN] </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...     #http全局块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1、<strong>全局块</strong>：配置影响<code>nginx</code>全局的指令。一般有运行<code>nginx</code>服务器的用户组，<code>nginx</code>进程<code>pid</code>存放路径，日志存放路径，配置文件引入，允许生成<code>worker process数</code>等。</li>\n<li>2、<strong>events块</strong>：配置影响<code>nginx</code>服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>\n<li>3、<strong>http块</strong>：可以嵌套多个<code>server</code>，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，<code>mime-type</code>定义，日志自定义，是否使用<code>sendfile</code>传输文件，连接超时时间，单连接请求数等。</li>\n<li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个<code>http</code>中可以有多个<code>server</code>。</li>\n<li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li>\n</ul>\n<p>下面给大家上一个配置文件，作为理解。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">########## 每个指令必须有分号结束。#################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">user administrator administrators;  <span class=\"comment\">#配置用户或者组，默认为nobody nobody。</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">worker_processes 2;  <span class=\"comment\">#允许生成的进程数，默认为1</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">pid /nginx/pid/nginx.pid;   <span class=\"comment\">#指定nginx进程运行文件存放地址</span></span></span><br><span class=\"line\">error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class=\"line\">    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class=\"line\">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class=\"line\">    worker_connections  1024;    #最大连接数，默认为512</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class=\"line\">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class=\"line\">    #access_log off; #取消服务日志    </span><br><span class=\"line\">    log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #自定义格式</span><br><span class=\"line\">    access_log log/access.log myFormat;  #combined为日志格式的默认值</span><br><span class=\"line\">    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class=\"line\">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class=\"line\">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream mysvr &#123;   </span><br><span class=\"line\">      server 127.0.0.1:7878;</span><br><span class=\"line\">      server 192.168.10.121:3333 backup;  #热备</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    error_page 404 https://www.baidu.com; #错误页</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class=\"line\">        listen       4545;   #监听端口</span><br><span class=\"line\">        server_name  127.0.0.1;   #监听地址       </span><br><span class=\"line\">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class=\"line\">           #root path;  #根目录</span><br><span class=\"line\">           #index vv.txt;  #设置默认页</span><br><span class=\"line\">           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表</span><br><span class=\"line\">           deny 127.0.0.1;  #拒绝的ip</span><br><span class=\"line\">           allow 172.18.5.54; #允许的ip           </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面是nginx的基本配置，需要注意的有以下几点：</p>\n<ul>\n<li>1、几个常见配置项</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</span><br><span class=\"line\">2.$remote_user ：用来记录客户端用户名称；</span><br><span class=\"line\">3.$time_local ： 用来记录访问时间与时区；</span><br><span class=\"line\">4.$request ： 用来记录请求的url与http协议；</span><br><span class=\"line\">5.$status ： 用来记录请求状态；成功是200；</span><br><span class=\"line\">6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</span><br><span class=\"line\">7.$http_referer ：用来记录从那个页面链接访问过来的；</span><br><span class=\"line\">8.$http_user_agent ：记录客户端浏览器的相关信息；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>2、惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。</p>\n</li>\n<li><p>3、每个指令必须有分号结束。</p>\n</li>\n</ul>\n<blockquote>\n<p>原文地址：<a href=\"https://www.runoob.com/w3cnote/nginx-setup-intro.html\">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><code>Nginx</code>是<code>lgor Sysoev</code>为俄罗斯访问量第二的<code>rambler.ru</code>站点设计开发的。从<code>2004</code>年发布至今，凭借开源的力量，已经接近成熟与完善。</p>\n<p><code>Nginx</code>功能丰富，可作为<code>HTTP服务器</code>，也可作为反向代理服务器，邮件服务器。支持<code>FastCGI</code>、<code>SSL</code>、<code>Virtual Host</code>、<code>URL Rewrite</code>、<code>Gzip</code>等功能。并且支持很多第三方的模块扩展。</p>\n<p><code>Nginx</code>的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有<code>12.18%</code>的使用比率，大约为<code>2220</code>万个网站。</p>\n<h2 id=\"Nginx常用功能\"><a href=\"#Nginx常用功能\" class=\"headerlink\" title=\"Nginx常用功能\"></a>Nginx常用功能</h2><h3 id=\"1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\"><a href=\"#1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\" class=\"headerlink\" title=\"1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理\"></a>1、Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理</h3><p>正向代理和反向代理：</p>\n<p><img src=\"1.jpg\" alt=\"正向代理和反向代理\"></p>\n<p><code>Nginx</code>在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。<code>Nginx</code>可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的文件服务器，动态页面<code>web</code>服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且<code>Nginx</code>对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。</p>\n<h3 id=\"2、负载均衡\"><a href=\"#2、负载均衡\" class=\"headerlink\" title=\"2、负载均衡\"></a>2、负载均衡</h3><p><code>Nginx</code>提供的负载均衡策略有2种：<code>内置策略</code>和<code>扩展策略</code>。内置策略为轮询，加权轮询，<code>Ip hash</code>。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。</p>\n<p>上3个图，理解这三种负载均衡算法的实现</p>\n<p><img src=\"2.jpg\" alt=\"负载均衡\"></p>\n<p>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</p>\n<p><img src=\"3.jpg\" alt=\"负载均衡\"></p>\n<h3 id=\"3、web缓存\"><a href=\"#3、web缓存\" class=\"headerlink\" title=\"3、web缓存\"></a>3、web缓存</h3><p><code>Nginx</code>可以对不同的文件做不同的缓存处理，配置灵活，并且支持<code>FastCGI_Cache</code>，主要用于对<code>FastCGI</code>的动态程序进行缓存。配合着第三方的<code>ngx_cache_purge</code>，对制定的<code>URL</code>缓存内容可以的进行增删管理。</p>\n<h3 id=\"4、Nginx相关地址\"><a href=\"#4、Nginx相关地址\" class=\"headerlink\" title=\"4、Nginx相关地址\"></a>4、Nginx相关地址</h3><p>源码：<a href=\"https://trac.nginx.org/nginx/browser\">https://trac.nginx.org/nginx/browser</a></p>\n<p>官网：<a href=\"http://www.nginx.org/\">http://www.nginx.org/</a></p>\n<h2 id=\"Nginx配置文件结构\"><a href=\"#Nginx配置文件结构\" class=\"headerlink\" title=\"Nginx配置文件结构\"></a>Nginx配置文件结构</h2><p>如果你下载好啦，你的安装文件，不妨打开<code>conf</code>文件夹的<code>nginx.conf</code>文件，<code>Nginx</code>服务器的基础配置，默认的配置也存放在此。</p>\n<p>在<code>nginx.conf</code>的注释符号为：<code>#</code></p>\n<p>默认的<code>nginx</code>配置文件<code>nginx.conf</code>内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">user  nobody;</span></span><br><span class=\"line\">worker_processes  1;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log  notice;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">error_log  logs/error.log  info;</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">pid        logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">    #access_log  logs/access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    #keepalive_timeout  0;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        #error_page  404              /404.html;</span><br><span class=\"line\"></span><br><span class=\"line\">        # redirect server error pages to the static page /50x.html</span><br><span class=\"line\">        #</span><br><span class=\"line\">        error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">        location = /50x.html &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #location ~ \\.php$ &#123;</span><br><span class=\"line\">        #    proxy_pass   http://127.0.0.1;</span><br><span class=\"line\">        #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #location ~ \\.php$ &#123;</span><br><span class=\"line\">        #    root           html;</span><br><span class=\"line\">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">        #    fastcgi_index  index.php;</span><br><span class=\"line\">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">        #    include        fastcgi_params;</span><br><span class=\"line\">        #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class=\"line\">        # concurs with nginx&#x27;s one</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #location ~ /\\.ht &#123;</span><br><span class=\"line\">        #    deny  all;</span><br><span class=\"line\">        #&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class=\"line\">    #</span><br><span class=\"line\">    #server &#123;</span><br><span class=\"line\">    #    listen       8000;</span><br><span class=\"line\">    #    listen       somename:8080;</span><br><span class=\"line\">    #    server_name  somename  alias  another.alias;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    location / &#123;</span><br><span class=\"line\">    #        root   html;</span><br><span class=\"line\">    #        index  index.html index.htm;</span><br><span class=\"line\">    #    &#125;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # HTTPS server</span><br><span class=\"line\">    #</span><br><span class=\"line\">    #server &#123;</span><br><span class=\"line\">    #    listen       443 ssl;</span><br><span class=\"line\">    #    server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    ssl_certificate      cert.pem;</span><br><span class=\"line\">    #    ssl_certificate_key  cert.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class=\"line\">    #    ssl_session_timeout  5m;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class=\"line\">    #    ssl_prefer_server_ciphers  on;</span><br><span class=\"line\"></span><br><span class=\"line\">    #    location / &#123;</span><br><span class=\"line\">    #        root   html;</span><br><span class=\"line\">    #        index  index.html index.htm;</span><br><span class=\"line\">    #    &#125;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"nginx-文件结构\"><a href=\"#nginx-文件结构\" class=\"headerlink\" title=\"nginx 文件结构\"></a>nginx 文件结构</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...              #全局块</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;         #events块</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http      #http块</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...   #http全局块</span><br><span class=\"line\">    server        #server块</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        ...       #server全局块</span><br><span class=\"line\">        location [PATTERN]   #location块</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location [PATTERN] </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...     #http全局块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1、<strong>全局块</strong>：配置影响<code>nginx</code>全局的指令。一般有运行<code>nginx</code>服务器的用户组，<code>nginx</code>进程<code>pid</code>存放路径，日志存放路径，配置文件引入，允许生成<code>worker process数</code>等。</li>\n<li>2、<strong>events块</strong>：配置影响<code>nginx</code>服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>\n<li>3、<strong>http块</strong>：可以嵌套多个<code>server</code>，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，<code>mime-type</code>定义，日志自定义，是否使用<code>sendfile</code>传输文件，连接超时时间，单连接请求数等。</li>\n<li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个<code>http</code>中可以有多个<code>server</code>。</li>\n<li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li>\n</ul>\n<p>下面给大家上一个配置文件，作为理解。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">########## 每个指令必须有分号结束。#################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">user administrator administrators;  <span class=\"comment\">#配置用户或者组，默认为nobody nobody。</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">worker_processes 2;  <span class=\"comment\">#允许生成的进程数，默认为1</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">pid /nginx/pid/nginx.pid;   <span class=\"comment\">#指定nginx进程运行文件存放地址</span></span></span><br><span class=\"line\">error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class=\"line\">    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class=\"line\">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class=\"line\">    worker_connections  1024;    #最大连接数，默认为512</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class=\"line\">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class=\"line\">    #access_log off; #取消服务日志    </span><br><span class=\"line\">    log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #自定义格式</span><br><span class=\"line\">    access_log log/access.log myFormat;  #combined为日志格式的默认值</span><br><span class=\"line\">    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class=\"line\">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class=\"line\">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream mysvr &#123;   </span><br><span class=\"line\">      server 127.0.0.1:7878;</span><br><span class=\"line\">      server 192.168.10.121:3333 backup;  #热备</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    error_page 404 https://www.baidu.com; #错误页</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class=\"line\">        listen       4545;   #监听端口</span><br><span class=\"line\">        server_name  127.0.0.1;   #监听地址       </span><br><span class=\"line\">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class=\"line\">           #root path;  #根目录</span><br><span class=\"line\">           #index vv.txt;  #设置默认页</span><br><span class=\"line\">           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表</span><br><span class=\"line\">           deny 127.0.0.1;  #拒绝的ip</span><br><span class=\"line\">           allow 172.18.5.54; #允许的ip           </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面是nginx的基本配置，需要注意的有以下几点：</p>\n<ul>\n<li>1、几个常见配置项</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</span><br><span class=\"line\">2.$remote_user ：用来记录客户端用户名称；</span><br><span class=\"line\">3.$time_local ： 用来记录访问时间与时区；</span><br><span class=\"line\">4.$request ： 用来记录请求的url与http协议；</span><br><span class=\"line\">5.$status ： 用来记录请求状态；成功是200；</span><br><span class=\"line\">6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</span><br><span class=\"line\">7.$http_referer ：用来记录从那个页面链接访问过来的；</span><br><span class=\"line\">8.$http_user_agent ：记录客户端浏览器的相关信息；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>2、惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。</p>\n</li>\n<li><p>3、每个指令必须有分号结束。</p>\n</li>\n</ul>\n<blockquote>\n<p>原文地址：<a href=\"https://www.runoob.com/w3cnote/nginx-setup-intro.html\">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>\n</blockquote>\n"},{"title":"Session和Cookies","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-12T02:51:36.000Z","pic":null,"_content":"\n## 静态网页和动态网页\n\n示例代码：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>This is a Demo</title> \n  </head>\n  <body> \n    <div id=\"container\">\n      <div class=\"wrapper\"> \n        <h2 class=\"title\">Hello World</h2> \n        <p class=\"text\">Hello, this is a paragraph.</p> \n        </div> \n      </div> \n    </body> \n</html>\n```\n\n这是最基本的HTML代码，保存为一个`.html`文件，然后把它放在某台具有固定公网`IP`的主机上，主机上装上`Apache`或`Nginx`等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。\n\n这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据`URL`灵活多变地显示内容等。例如，想要给这个网页的`URL`传入一个`name`参数，让其在网页中显示出来，是无法做到的。\n\n因此，动态网页应运而生，它可以动态解析`URL`中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的`HTML`，而是可能由`JSP`、`PHP`、`Python`等语言编写的，其功能比静态网页强大和丰富太多了。\n\n此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。\n\n那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。\n\n## 无状态HTTP\n\n在了解`Session`和`Cookies`之前，还需要了解`HTTP`的一个特点，叫作无状态。\n\n`HTTP`的无状态是指`HTTP`协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。\n\n当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。\n\n这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。\n\n这时两个用于保持`HTTP`连接状态的技术就出现了，它们分别是`Session`和`Cookies`。`Session`在服务端，也就是网站的服务器，用来保存用户的`Session信息`；`Cookies`在客户端，也可以理解为**浏览器端**，有了`Cookies`，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别`Cookies`并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。\n\n可以理解为`Cookies`里面保存了登录的凭证，有了它，只需要在下次请求携带`Cookies`发送请求而不必重新输入用户名、密码等信息重新登录了。\n\n因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的`Cookies`放在请求头里面直接请求，而不必重新模拟登录。\n\n## Cookies\n\n`Cookies`指某些网站为了辨别用户身份、进行`Session`跟踪而存储在用户本地终端上的数据。\n\n## Session\n\n`Session`，中文称之为**会话**，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 `Session`。\n\n而在`Web`中，`Session对象`用来存储特定用户`Session`所需的属性及配置信息。这样，当用户在应用程序的`Web`页之间跳转时，存储在`Session`对象中的变量将不会丢失，而是在整个用户`Session`中一直存在下去。当用户请求来自应用程序的`Web`页时，如果该用户还没有`Session`，则`Web`服务器将自动创建一个 `Session`对象。当`Session`过期或被放弃后，服务器将终止该`Session`。\n\n## Session维持\n\n那么，怎样利用`Cookies`保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有`Set-Cookie`字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把`Cookies`保存起来。当浏览器下一次再请求该网站时，浏览器会把此`Cookies`放到请求头一起提交给服务器，`Cookies`携带了`SessionID` 信息，服务器检查该`Cookies`即可找到对应的`Session`是什么，然后再判断`Session`来以此来辨认用户状态。\n\n在成功登录某个网站时，服务器会告诉客户端设置哪些`Cookies`信息，在后续访问页面时客户端会把`Cookies`发送给服务器，服务器再找到对应的`Session`加以判断。如果`Session`中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。\n\n反之，如果传给服务器的`Cookies`是无效的，或者`Session`已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，`Cookies`和`Session`需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录`Session`控制。\n\n## Cookies属性结构\n\n`Cookie`有如下几个属性。\n\n- `Name`，即该`Cookie`的名称。\n- `Cookie`一旦创建，名称便不可更改。\n- `Value`，即该`Cookie`的值。如果值为`Unicode`字符，需要为字符编码。如果值为二进制数据，则需要使用`BASE64`编码。\n- `MaxAge`，即该`Cookie`失效的时间，单位秒，也常和`Expires`一起使用，通过它可以计算出其有效时间。\n- `MaxAge` 如果为正数，则该`Cookie`在`MaxAge`秒之后失效。如果为负数，则关闭浏览器时`Cookie`即失效，浏览器也不会以任何形式保存该`Cookie`。\n- `Path`，即该`Cookie`的使用路径。如果设置为`/path/`，则只有路径为`/path/`的页面可以访问该`Cookie`。如果设置为`/`，则本域名下的所有页面都可以访问该`Cookie`。\n- `Domain`，即可以访问该`Cookie`的域名。例如如果设置为`.zhihu.com`，则所有以`zhihu.com`，结尾的域名都可以访问该`Cookie`。\n- `Size`字段，即此`Cookie`的大小。\n- `Http`字段，即`Cookie`的`httponly`属性。若此属性为`true`，则只有在`HTTP Headers`中会带有此`Cookie`的信息，而不能通过`document.cookie`来访问此`Cookie`。\n- `Secure`，即该`Cookie`是否仅被使用安全协议传输。安全协议。安全协议有`HTTPS、SSL`等，在网络上传输数据之前先将数据加密。默认为`false`。\n\n## 会话会`Cookie`和持久和`Cookie`\n\n从表面意思来说，会话`Cookie`就是把`Cookie`放在浏览器内存里，浏览器在关闭之后该`Cookie`即失效；持久`Cookie`则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。\n\n严格来说，没有会话`Cookie`和持久`Cookie`之分，只是由`Cookie`的`MaxAge`或`Expires`字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把`Cookie`的有效时间和`Session`有效期设置得比较长，下次再访问页面时仍然携带之前的`Cookie`，就可以直接保持登录状态。\n\n## 常见误区\n\n在谈论`Session`机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，`Session`就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对`Session`来说，也是一样，除非程序通知服务器删除一个`Session`，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除`Session`。\n\n但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话`Cookie`来保存`Session ID`信息，而关闭浏览器后`Cookies`就消失了，再次连接服务器时，也就无法找到原来的`Session`了。如果服务器设置的`Cookies`保存到硬盘上，或者使用某种手段改写浏览器发出的`HTTP`请求头，把原来的`Cookies`发送给服务器，则再次打开浏览器，仍然能够找到原来的`Session ID`，依旧还是可以保持登录状态的。\n\n而且恰恰是由于关闭浏览器不会导致`Session`被删除，这就需要服务器为`Session`设置一个失效时间，当距离客户端上一次使用`Session`的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把`Session`删除以节省存储空间。\n","source":"_posts/Session和Cookies.md","raw":"---\ntitle: Session和Cookies\ntags:\n  - http\n  - web\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-12 10:51:36\ncategories: 爬虫\npic:\n---\n\n## 静态网页和动态网页\n\n示例代码：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>This is a Demo</title> \n  </head>\n  <body> \n    <div id=\"container\">\n      <div class=\"wrapper\"> \n        <h2 class=\"title\">Hello World</h2> \n        <p class=\"text\">Hello, this is a paragraph.</p> \n        </div> \n      </div> \n    </body> \n</html>\n```\n\n这是最基本的HTML代码，保存为一个`.html`文件，然后把它放在某台具有固定公网`IP`的主机上，主机上装上`Apache`或`Nginx`等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。\n\n这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据`URL`灵活多变地显示内容等。例如，想要给这个网页的`URL`传入一个`name`参数，让其在网页中显示出来，是无法做到的。\n\n因此，动态网页应运而生，它可以动态解析`URL`中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的`HTML`，而是可能由`JSP`、`PHP`、`Python`等语言编写的，其功能比静态网页强大和丰富太多了。\n\n此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。\n\n那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。\n\n## 无状态HTTP\n\n在了解`Session`和`Cookies`之前，还需要了解`HTTP`的一个特点，叫作无状态。\n\n`HTTP`的无状态是指`HTTP`协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。\n\n当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。\n\n这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。\n\n这时两个用于保持`HTTP`连接状态的技术就出现了，它们分别是`Session`和`Cookies`。`Session`在服务端，也就是网站的服务器，用来保存用户的`Session信息`；`Cookies`在客户端，也可以理解为**浏览器端**，有了`Cookies`，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别`Cookies`并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。\n\n可以理解为`Cookies`里面保存了登录的凭证，有了它，只需要在下次请求携带`Cookies`发送请求而不必重新输入用户名、密码等信息重新登录了。\n\n因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的`Cookies`放在请求头里面直接请求，而不必重新模拟登录。\n\n## Cookies\n\n`Cookies`指某些网站为了辨别用户身份、进行`Session`跟踪而存储在用户本地终端上的数据。\n\n## Session\n\n`Session`，中文称之为**会话**，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 `Session`。\n\n而在`Web`中，`Session对象`用来存储特定用户`Session`所需的属性及配置信息。这样，当用户在应用程序的`Web`页之间跳转时，存储在`Session`对象中的变量将不会丢失，而是在整个用户`Session`中一直存在下去。当用户请求来自应用程序的`Web`页时，如果该用户还没有`Session`，则`Web`服务器将自动创建一个 `Session`对象。当`Session`过期或被放弃后，服务器将终止该`Session`。\n\n## Session维持\n\n那么，怎样利用`Cookies`保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有`Set-Cookie`字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把`Cookies`保存起来。当浏览器下一次再请求该网站时，浏览器会把此`Cookies`放到请求头一起提交给服务器，`Cookies`携带了`SessionID` 信息，服务器检查该`Cookies`即可找到对应的`Session`是什么，然后再判断`Session`来以此来辨认用户状态。\n\n在成功登录某个网站时，服务器会告诉客户端设置哪些`Cookies`信息，在后续访问页面时客户端会把`Cookies`发送给服务器，服务器再找到对应的`Session`加以判断。如果`Session`中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。\n\n反之，如果传给服务器的`Cookies`是无效的，或者`Session`已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，`Cookies`和`Session`需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录`Session`控制。\n\n## Cookies属性结构\n\n`Cookie`有如下几个属性。\n\n- `Name`，即该`Cookie`的名称。\n- `Cookie`一旦创建，名称便不可更改。\n- `Value`，即该`Cookie`的值。如果值为`Unicode`字符，需要为字符编码。如果值为二进制数据，则需要使用`BASE64`编码。\n- `MaxAge`，即该`Cookie`失效的时间，单位秒，也常和`Expires`一起使用，通过它可以计算出其有效时间。\n- `MaxAge` 如果为正数，则该`Cookie`在`MaxAge`秒之后失效。如果为负数，则关闭浏览器时`Cookie`即失效，浏览器也不会以任何形式保存该`Cookie`。\n- `Path`，即该`Cookie`的使用路径。如果设置为`/path/`，则只有路径为`/path/`的页面可以访问该`Cookie`。如果设置为`/`，则本域名下的所有页面都可以访问该`Cookie`。\n- `Domain`，即可以访问该`Cookie`的域名。例如如果设置为`.zhihu.com`，则所有以`zhihu.com`，结尾的域名都可以访问该`Cookie`。\n- `Size`字段，即此`Cookie`的大小。\n- `Http`字段，即`Cookie`的`httponly`属性。若此属性为`true`，则只有在`HTTP Headers`中会带有此`Cookie`的信息，而不能通过`document.cookie`来访问此`Cookie`。\n- `Secure`，即该`Cookie`是否仅被使用安全协议传输。安全协议。安全协议有`HTTPS、SSL`等，在网络上传输数据之前先将数据加密。默认为`false`。\n\n## 会话会`Cookie`和持久和`Cookie`\n\n从表面意思来说，会话`Cookie`就是把`Cookie`放在浏览器内存里，浏览器在关闭之后该`Cookie`即失效；持久`Cookie`则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。\n\n严格来说，没有会话`Cookie`和持久`Cookie`之分，只是由`Cookie`的`MaxAge`或`Expires`字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把`Cookie`的有效时间和`Session`有效期设置得比较长，下次再访问页面时仍然携带之前的`Cookie`，就可以直接保持登录状态。\n\n## 常见误区\n\n在谈论`Session`机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，`Session`就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对`Session`来说，也是一样，除非程序通知服务器删除一个`Session`，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除`Session`。\n\n但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话`Cookie`来保存`Session ID`信息，而关闭浏览器后`Cookies`就消失了，再次连接服务器时，也就无法找到原来的`Session`了。如果服务器设置的`Cookies`保存到硬盘上，或者使用某种手段改写浏览器发出的`HTTP`请求头，把原来的`Cookies`发送给服务器，则再次打开浏览器，仍然能够找到原来的`Session ID`，依旧还是可以保持登录状态的。\n\n而且恰恰是由于关闭浏览器不会导致`Session`被删除，这就需要服务器为`Session`设置一个失效时间，当距离客户端上一次使用`Session`的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把`Session`删除以节省存储空间。\n","slug":"Session和Cookies","published":1,"updated":"2021-06-15T03:24:11.487Z","_id":"ckpapu7hq000blcxu198iganf","layout":"post","photos":[],"link":"","content":"<h2 id=\"静态网页和动态网页\"><a href=\"#静态网页和动态网页\" class=\"headerlink\" title=\"静态网页和动态网页\"></a>静态网页和动态网页</h2><p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;title&quot;</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>Hello, this is a paragraph.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是最基本的HTML代码，保存为一个<code>.html</code>文件，然后把它放在某台具有固定公网<code>IP</code>的主机上，主机上装上<code>Apache</code>或<code>Nginx</code>等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。</p>\n<p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据<code>URL</code>灵活多变地显示内容等。例如，想要给这个网页的<code>URL</code>传入一个<code>name</code>参数，让其在网页中显示出来，是无法做到的。</p>\n<p>因此，动态网页应运而生，它可以动态解析<code>URL</code>中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的<code>HTML</code>，而是可能由<code>JSP</code>、<code>PHP</code>、<code>Python</code>等语言编写的，其功能比静态网页强大和丰富太多了。</p>\n<p>此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。</p>\n<p>那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。</p>\n<h2 id=\"无状态HTTP\"><a href=\"#无状态HTTP\" class=\"headerlink\" title=\"无状态HTTP\"></a>无状态HTTP</h2><p>在了解<code>Session</code>和<code>Cookies</code>之前，还需要了解<code>HTTP</code>的一个特点，叫作无状态。</p>\n<p><code>HTTP</code>的无状态是指<code>HTTP</code>协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。</p>\n<p>当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p>\n<p>这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。</p>\n<p>这时两个用于保持<code>HTTP</code>连接状态的技术就出现了，它们分别是<code>Session</code>和<code>Cookies</code>。<code>Session</code>在服务端，也就是网站的服务器，用来保存用户的<code>Session信息</code>；<code>Cookies</code>在客户端，也可以理解为<strong>浏览器端</strong>，有了<code>Cookies</code>，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别<code>Cookies</code>并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。</p>\n<p>可以理解为<code>Cookies</code>里面保存了登录的凭证，有了它，只需要在下次请求携带<code>Cookies</code>发送请求而不必重新输入用户名、密码等信息重新登录了。</p>\n<p>因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的<code>Cookies</code>放在请求头里面直接请求，而不必重新模拟登录。</p>\n<h2 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h2><p><code>Cookies</code>指某些网站为了辨别用户身份、进行<code>Session</code>跟踪而存储在用户本地终端上的数据。</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p><code>Session</code>，中文称之为<strong>会话</strong>，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 <code>Session</code>。</p>\n<p>而在<code>Web</code>中，<code>Session对象</code>用来存储特定用户<code>Session</code>所需的属性及配置信息。这样，当用户在应用程序的<code>Web</code>页之间跳转时，存储在<code>Session</code>对象中的变量将不会丢失，而是在整个用户<code>Session</code>中一直存在下去。当用户请求来自应用程序的<code>Web</code>页时，如果该用户还没有<code>Session</code>，则<code>Web</code>服务器将自动创建一个 <code>Session</code>对象。当<code>Session</code>过期或被放弃后，服务器将终止该<code>Session</code>。</p>\n<h2 id=\"Session维持\"><a href=\"#Session维持\" class=\"headerlink\" title=\"Session维持\"></a>Session维持</h2><p>那么，怎样利用<code>Cookies</code>保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有<code>Set-Cookie</code>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把<code>Cookies</code>保存起来。当浏览器下一次再请求该网站时，浏览器会把此<code>Cookies</code>放到请求头一起提交给服务器，<code>Cookies</code>携带了<code>SessionID</code> 信息，服务器检查该<code>Cookies</code>即可找到对应的<code>Session</code>是什么，然后再判断<code>Session</code>来以此来辨认用户状态。</p>\n<p>在成功登录某个网站时，服务器会告诉客户端设置哪些<code>Cookies</code>信息，在后续访问页面时客户端会把<code>Cookies</code>发送给服务器，服务器再找到对应的<code>Session</code>加以判断。如果<code>Session</code>中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p>\n<p>反之，如果传给服务器的<code>Cookies</code>是无效的，或者<code>Session</code>已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，<code>Cookies</code>和<code>Session</code>需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录<code>Session</code>控制。</p>\n<h2 id=\"Cookies属性结构\"><a href=\"#Cookies属性结构\" class=\"headerlink\" title=\"Cookies属性结构\"></a>Cookies属性结构</h2><p><code>Cookie</code>有如下几个属性。</p>\n<ul>\n<li><code>Name</code>，即该<code>Cookie</code>的名称。</li>\n<li><code>Cookie</code>一旦创建，名称便不可更改。</li>\n<li><code>Value</code>，即该<code>Cookie</code>的值。如果值为<code>Unicode</code>字符，需要为字符编码。如果值为二进制数据，则需要使用<code>BASE64</code>编码。</li>\n<li><code>MaxAge</code>，即该<code>Cookie</code>失效的时间，单位秒，也常和<code>Expires</code>一起使用，通过它可以计算出其有效时间。</li>\n<li><code>MaxAge</code> 如果为正数，则该<code>Cookie</code>在<code>MaxAge</code>秒之后失效。如果为负数，则关闭浏览器时<code>Cookie</code>即失效，浏览器也不会以任何形式保存该<code>Cookie</code>。</li>\n<li><code>Path</code>，即该<code>Cookie</code>的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该<code>Cookie</code>。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该<code>Cookie</code>。</li>\n<li><code>Domain</code>，即可以访问该<code>Cookie</code>的域名。例如如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>，结尾的域名都可以访问该<code>Cookie</code>。</li>\n<li><code>Size</code>字段，即此<code>Cookie</code>的大小。</li>\n<li><code>Http</code>字段，即<code>Cookie</code>的<code>httponly</code>属性。若此属性为<code>true</code>，则只有在<code>HTTP Headers</code>中会带有此<code>Cookie</code>的信息，而不能通过<code>document.cookie</code>来访问此<code>Cookie</code>。</li>\n<li><code>Secure</code>，即该<code>Cookie</code>是否仅被使用安全协议传输。安全协议。安全协议有<code>HTTPS、SSL</code>等，在网络上传输数据之前先将数据加密。默认为<code>false</code>。</li>\n</ul>\n<h2 id=\"会话会Cookie和持久和Cookie\"><a href=\"#会话会Cookie和持久和Cookie\" class=\"headerlink\" title=\"会话会Cookie和持久和Cookie\"></a>会话会<code>Cookie</code>和持久和<code>Cookie</code></h2><p>从表面意思来说，会话<code>Cookie</code>就是把<code>Cookie</code>放在浏览器内存里，浏览器在关闭之后该<code>Cookie</code>即失效；持久<code>Cookie</code>则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p>\n<p>严格来说，没有会话<code>Cookie</code>和持久<code>Cookie</code>之分，只是由<code>Cookie</code>的<code>MaxAge</code>或<code>Expires</code>字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把<code>Cookie</code>的有效时间和<code>Session</code>有效期设置得比较长，下次再访问页面时仍然携带之前的<code>Cookie</code>，就可以直接保持登录状态。</p>\n<h2 id=\"常见误区\"><a href=\"#常见误区\" class=\"headerlink\" title=\"常见误区\"></a>常见误区</h2><p>在谈论<code>Session</code>机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，<code>Session</code>就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对<code>Session</code>来说，也是一样，除非程序通知服务器删除一个<code>Session</code>，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除<code>Session</code>。</p>\n<p>但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话<code>Cookie</code>来保存<code>Session ID</code>信息，而关闭浏览器后<code>Cookies</code>就消失了，再次连接服务器时，也就无法找到原来的<code>Session</code>了。如果服务器设置的<code>Cookies</code>保存到硬盘上，或者使用某种手段改写浏览器发出的<code>HTTP</code>请求头，把原来的<code>Cookies</code>发送给服务器，则再次打开浏览器，仍然能够找到原来的<code>Session ID</code>，依旧还是可以保持登录状态的。</p>\n<p>而且恰恰是由于关闭浏览器不会导致<code>Session</code>被删除，这就需要服务器为<code>Session</code>设置一个失效时间，当距离客户端上一次使用<code>Session</code>的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把<code>Session</code>删除以节省存储空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"静态网页和动态网页\"><a href=\"#静态网页和动态网页\" class=\"headerlink\" title=\"静态网页和动态网页\"></a>静态网页和动态网页</h2><p>示例代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;title&quot;</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span>Hello, this is a paragraph.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是最基本的HTML代码，保存为一个<code>.html</code>文件，然后把它放在某台具有固定公网<code>IP</code>的主机上，主机上装上<code>Apache</code>或<code>Nginx</code>等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。</p>\n<p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据<code>URL</code>灵活多变地显示内容等。例如，想要给这个网页的<code>URL</code>传入一个<code>name</code>参数，让其在网页中显示出来，是无法做到的。</p>\n<p>因此，动态网页应运而生，它可以动态解析<code>URL</code>中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。现在遇到的大多数网站都是动态网站，它们不再是一个简单的<code>HTML</code>，而是可能由<code>JSP</code>、<code>PHP</code>、<code>Python</code>等语言编写的，其功能比静态网页强大和丰富太多了。</p>\n<p>此外，动态网站还可以实现用户登录和注册的功能。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，才能保持登录状态，才能访问登录之后才能看到的页面。</p>\n<p>那么，这种神秘的凭证到底是什么呢？其实它就是 Session和Cookies 共同产生的结果。</p>\n<h2 id=\"无状态HTTP\"><a href=\"#无状态HTTP\" class=\"headerlink\" title=\"无状态HTTP\"></a>无状态HTTP</h2><p>在了解<code>Session</code>和<code>Cookies</code>之前，还需要了解<code>HTTP</code>的一个特点，叫作无状态。</p>\n<p><code>HTTP</code>的无状态是指<code>HTTP</code>协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。</p>\n<p>当向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p>\n<p>这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，这种效果显然不是想要的。为了保持前后状态，肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。</p>\n<p>这时两个用于保持<code>HTTP</code>连接状态的技术就出现了，它们分别是<code>Session</code>和<code>Cookies</code>。<code>Session</code>在服务端，也就是网站的服务器，用来保存用户的<code>Session信息</code>；<code>Cookies</code>在客户端，也可以理解为<strong>浏览器端</strong>，有了<code>Cookies</code>，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别<code>Cookies</code>并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。</p>\n<p>可以理解为<code>Cookies</code>里面保存了登录的凭证，有了它，只需要在下次请求携带<code>Cookies</code>发送请求而不必重新输入用户名、密码等信息重新登录了。</p>\n<p>因此在爬虫中，有时候处理需要登录才能访问的页面时，一般会直接将登录成功后获取的<code>Cookies</code>放在请求头里面直接请求，而不必重新模拟登录。</p>\n<h2 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h2><p><code>Cookies</code>指某些网站为了辨别用户身份、进行<code>Session</code>跟踪而存储在用户本地终端上的数据。</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p><code>Session</code>，中文称之为<strong>会话</strong>，其本身的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 <code>Session</code>。</p>\n<p>而在<code>Web</code>中，<code>Session对象</code>用来存储特定用户<code>Session</code>所需的属性及配置信息。这样，当用户在应用程序的<code>Web</code>页之间跳转时，存储在<code>Session</code>对象中的变量将不会丢失，而是在整个用户<code>Session</code>中一直存在下去。当用户请求来自应用程序的<code>Web</code>页时，如果该用户还没有<code>Session</code>，则<code>Web</code>服务器将自动创建一个 <code>Session</code>对象。当<code>Session</code>过期或被放弃后，服务器将终止该<code>Session</code>。</p>\n<h2 id=\"Session维持\"><a href=\"#Session维持\" class=\"headerlink\" title=\"Session维持\"></a>Session维持</h2><p>那么，怎样利用<code>Cookies</code>保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有<code>Set-Cookie</code>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把<code>Cookies</code>保存起来。当浏览器下一次再请求该网站时，浏览器会把此<code>Cookies</code>放到请求头一起提交给服务器，<code>Cookies</code>携带了<code>SessionID</code> 信息，服务器检查该<code>Cookies</code>即可找到对应的<code>Session</code>是什么，然后再判断<code>Session</code>来以此来辨认用户状态。</p>\n<p>在成功登录某个网站时，服务器会告诉客户端设置哪些<code>Cookies</code>信息，在后续访问页面时客户端会把<code>Cookies</code>发送给服务器，服务器再找到对应的<code>Session</code>加以判断。如果<code>Session</code>中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p>\n<p>反之，如果传给服务器的<code>Cookies</code>是无效的，或者<code>Session</code>已经过期了，将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，<code>Cookies</code>和<code>Session</code>需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录<code>Session</code>控制。</p>\n<h2 id=\"Cookies属性结构\"><a href=\"#Cookies属性结构\" class=\"headerlink\" title=\"Cookies属性结构\"></a>Cookies属性结构</h2><p><code>Cookie</code>有如下几个属性。</p>\n<ul>\n<li><code>Name</code>，即该<code>Cookie</code>的名称。</li>\n<li><code>Cookie</code>一旦创建，名称便不可更改。</li>\n<li><code>Value</code>，即该<code>Cookie</code>的值。如果值为<code>Unicode</code>字符，需要为字符编码。如果值为二进制数据，则需要使用<code>BASE64</code>编码。</li>\n<li><code>MaxAge</code>，即该<code>Cookie</code>失效的时间，单位秒，也常和<code>Expires</code>一起使用，通过它可以计算出其有效时间。</li>\n<li><code>MaxAge</code> 如果为正数，则该<code>Cookie</code>在<code>MaxAge</code>秒之后失效。如果为负数，则关闭浏览器时<code>Cookie</code>即失效，浏览器也不会以任何形式保存该<code>Cookie</code>。</li>\n<li><code>Path</code>，即该<code>Cookie</code>的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该<code>Cookie</code>。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该<code>Cookie</code>。</li>\n<li><code>Domain</code>，即可以访问该<code>Cookie</code>的域名。例如如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>，结尾的域名都可以访问该<code>Cookie</code>。</li>\n<li><code>Size</code>字段，即此<code>Cookie</code>的大小。</li>\n<li><code>Http</code>字段，即<code>Cookie</code>的<code>httponly</code>属性。若此属性为<code>true</code>，则只有在<code>HTTP Headers</code>中会带有此<code>Cookie</code>的信息，而不能通过<code>document.cookie</code>来访问此<code>Cookie</code>。</li>\n<li><code>Secure</code>，即该<code>Cookie</code>是否仅被使用安全协议传输。安全协议。安全协议有<code>HTTPS、SSL</code>等，在网络上传输数据之前先将数据加密。默认为<code>false</code>。</li>\n</ul>\n<h2 id=\"会话会Cookie和持久和Cookie\"><a href=\"#会话会Cookie和持久和Cookie\" class=\"headerlink\" title=\"会话会Cookie和持久和Cookie\"></a>会话会<code>Cookie</code>和持久和<code>Cookie</code></h2><p>从表面意思来说，会话<code>Cookie</code>就是把<code>Cookie</code>放在浏览器内存里，浏览器在关闭之后该<code>Cookie</code>即失效；持久<code>Cookie</code>则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p>\n<p>严格来说，没有会话<code>Cookie</code>和持久<code>Cookie</code>之分，只是由<code>Cookie</code>的<code>MaxAge</code>或<code>Expires</code>字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把<code>Cookie</code>的有效时间和<code>Session</code>有效期设置得比较长，下次再访问页面时仍然携带之前的<code>Cookie</code>，就可以直接保持登录状态。</p>\n<h2 id=\"常见误区\"><a href=\"#常见误区\" class=\"headerlink\" title=\"常见误区\"></a>常见误区</h2><p>在谈论<code>Session</code>机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，<code>Session</code>就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对<code>Session</code>来说，也是一样，除非程序通知服务器删除一个<code>Session</code>，否则服务器会一直保留。比如，程序一般都是在做注销操作时才去删除<code>Session</code>。</p>\n<p>但是当关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话<code>Cookie</code>来保存<code>Session ID</code>信息，而关闭浏览器后<code>Cookies</code>就消失了，再次连接服务器时，也就无法找到原来的<code>Session</code>了。如果服务器设置的<code>Cookies</code>保存到硬盘上，或者使用某种手段改写浏览器发出的<code>HTTP</code>请求头，把原来的<code>Cookies</code>发送给服务器，则再次打开浏览器，仍然能够找到原来的<code>Session ID</code>，依旧还是可以保持登录状态的。</p>\n<p>而且恰恰是由于关闭浏览器不会导致<code>Session</code>被删除，这就需要服务器为<code>Session</code>设置一个失效时间，当距离客户端上一次使用<code>Session</code>的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把<code>Session</code>删除以节省存储空间。</p>\n"},{"title":"docker的安装","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-20T08:45:41.000Z","pic":null,"_content":"\n\n## 安装环境\n\n安装环境是Centos环境，要求版本是` CentOS 7 or 8`以上。\n\n## 卸载旧版本的docker\n\n```shell\n sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n## 使用yum仓库安装\n\n安装方式有很多种，可以参考官方文档。\n\n### 设置仓库源\n\n下载`yum-utils`工具包和稳固的安装源。\n\n```shell\nsudo yum install -y yum-utils\n\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n### 安装docker引擎\n\n- 1.安装最新版本\n\n```shell\nsudo yum install docker-ce docker-ce-cli containerd.io\n```\n\n- 2.安装特定版本\n\n列出可安装的版本。\n\n```python\nyum list docker-ce --showduplicates | sort -r\n```\n\n选择安装版本。\n\n```python\nsudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n```\n\n### 启动docker\n\n运行下列命令启动`docker`。\n\n```shell\nsudo systemctl start docker\n```\n\n测试`docker`安装正确。\n\n```python\nsudo docker run hello-world\n```\n\n## 卸载docker\n\n卸载docker和下载的容器及包：\n\n```shell\nsudo yum remove docker-ce docker-ce-cli containerd.io\n\n ```\n\n镜像等配置文件不会自动移除，需要手动删除。\n\n```shell\nsudo rm -rf /var/lib/docker\nsudo rm -rf /var/lib/containerd\n```\n","source":"_posts/docker的安装.md","raw":"---\ntitle: docker的安装\ntags:\n  - linux\n  - docker\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-20 16:45:41\ncategories: Linux\npic:\n---\n\n\n## 安装环境\n\n安装环境是Centos环境，要求版本是` CentOS 7 or 8`以上。\n\n## 卸载旧版本的docker\n\n```shell\n sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n## 使用yum仓库安装\n\n安装方式有很多种，可以参考官方文档。\n\n### 设置仓库源\n\n下载`yum-utils`工具包和稳固的安装源。\n\n```shell\nsudo yum install -y yum-utils\n\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n### 安装docker引擎\n\n- 1.安装最新版本\n\n```shell\nsudo yum install docker-ce docker-ce-cli containerd.io\n```\n\n- 2.安装特定版本\n\n列出可安装的版本。\n\n```python\nyum list docker-ce --showduplicates | sort -r\n```\n\n选择安装版本。\n\n```python\nsudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n```\n\n### 启动docker\n\n运行下列命令启动`docker`。\n\n```shell\nsudo systemctl start docker\n```\n\n测试`docker`安装正确。\n\n```python\nsudo docker run hello-world\n```\n\n## 卸载docker\n\n卸载docker和下载的容器及包：\n\n```shell\nsudo yum remove docker-ce docker-ce-cli containerd.io\n\n ```\n\n镜像等配置文件不会自动移除，需要手动删除。\n\n```shell\nsudo rm -rf /var/lib/docker\nsudo rm -rf /var/lib/containerd\n```\n","slug":"docker的安装","published":1,"updated":"2021-06-15T03:24:11.488Z","_id":"ckpapu7hw000flcxug2m161kh","layout":"post","photos":[],"link":"","content":"<h2 id=\"安装环境\"><a href=\"#安装环境\" class=\"headerlink\" title=\"安装环境\"></a>安装环境</h2><p>安装环境是Centos环境，要求版本是<code> CentOS 7 or 8</code>以上。</p>\n<h2 id=\"卸载旧版本的docker\"><a href=\"#卸载旧版本的docker\" class=\"headerlink\" title=\"卸载旧版本的docker\"></a>卸载旧版本的docker</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                 docker-client \\</span><br><span class=\"line\">                 docker-client-latest \\</span><br><span class=\"line\">                 docker-common \\</span><br><span class=\"line\">                 docker-latest \\</span><br><span class=\"line\">                 docker-latest-logrotate \\</span><br><span class=\"line\">                 docker-logrotate \\</span><br><span class=\"line\">                 docker-engine</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用yum仓库安装\"><a href=\"#使用yum仓库安装\" class=\"headerlink\" title=\"使用yum仓库安装\"></a>使用yum仓库安装</h2><p>安装方式有很多种，可以参考官方文档。</p>\n<h3 id=\"设置仓库源\"><a href=\"#设置仓库源\" class=\"headerlink\" title=\"设置仓库源\"></a>设置仓库源</h3><p>下载<code>yum-utils</code>工具包和稳固的安装源。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum-config-manager \\</span><br><span class=\"line\">    --add-repo \\</span><br><span class=\"line\">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装docker引擎\"><a href=\"#安装docker引擎\" class=\"headerlink\" title=\"安装docker引擎\"></a>安装docker引擎</h3><ul>\n<li>1.安装最新版本</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2.安装特定版本</li>\n</ul>\n<p>列出可安装的版本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum <span class=\"built_in\">list</span> docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>\n\n<p>选择安装版本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动docker\"><a href=\"#启动docker\" class=\"headerlink\" title=\"启动docker\"></a>启动docker</h3><p>运行下列命令启动<code>docker</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<p>测试<code>docker</code>安装正确。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"卸载docker\"><a href=\"#卸载docker\" class=\"headerlink\" title=\"卸载docker\"></a>卸载docker</h2><p>卸载docker和下载的容器及包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>镜像等配置文件不会自动移除，需要手动删除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf /var/lib/docker</span><br><span class=\"line\">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装环境\"><a href=\"#安装环境\" class=\"headerlink\" title=\"安装环境\"></a>安装环境</h2><p>安装环境是Centos环境，要求版本是<code> CentOS 7 or 8</code>以上。</p>\n<h2 id=\"卸载旧版本的docker\"><a href=\"#卸载旧版本的docker\" class=\"headerlink\" title=\"卸载旧版本的docker\"></a>卸载旧版本的docker</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                 docker-client \\</span><br><span class=\"line\">                 docker-client-latest \\</span><br><span class=\"line\">                 docker-common \\</span><br><span class=\"line\">                 docker-latest \\</span><br><span class=\"line\">                 docker-latest-logrotate \\</span><br><span class=\"line\">                 docker-logrotate \\</span><br><span class=\"line\">                 docker-engine</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用yum仓库安装\"><a href=\"#使用yum仓库安装\" class=\"headerlink\" title=\"使用yum仓库安装\"></a>使用yum仓库安装</h2><p>安装方式有很多种，可以参考官方文档。</p>\n<h3 id=\"设置仓库源\"><a href=\"#设置仓库源\" class=\"headerlink\" title=\"设置仓库源\"></a>设置仓库源</h3><p>下载<code>yum-utils</code>工具包和稳固的安装源。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum-config-manager \\</span><br><span class=\"line\">    --add-repo \\</span><br><span class=\"line\">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装docker引擎\"><a href=\"#安装docker引擎\" class=\"headerlink\" title=\"安装docker引擎\"></a>安装docker引擎</h3><ul>\n<li>1.安装最新版本</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2.安装特定版本</li>\n</ul>\n<p>列出可安装的版本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum <span class=\"built_in\">list</span> docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>\n\n<p>选择安装版本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动docker\"><a href=\"#启动docker\" class=\"headerlink\" title=\"启动docker\"></a>启动docker</h3><p>运行下列命令启动<code>docker</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<p>测试<code>docker</code>安装正确。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"卸载docker\"><a href=\"#卸载docker\" class=\"headerlink\" title=\"卸载docker\"></a>卸载docker</h2><p>卸载docker和下载的容器及包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>镜像等配置文件不会自动移除，需要手动删除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf /var/lib/docker</span><br><span class=\"line\">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>\n"},{"title":"Git常用命令","date":"2021-05-08T10:03:19.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n# Git常用命令\n\n## 仓库\n\n在当前目录新建一个Git代码库\n\n```shell\ngit init\n```\n\n新建一个目录，将其初始化为Git代码库\n\n```shell\ngit init [project-name]\n```\n\n下载一个项目和它的整个代码历史\n\n```shell\ngit clone [url]\n```\n\n## 配置\n\n显示当前的Git配置\n\n```shell\ngit config --list\n```\n\n编辑Git配置文件\n\n```shell\ngit config -e [--global]\n```\n\n设置提交代码时的用户信息\n\n```shell\ngit config [--global] user.name \"[name]\"\ngit config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n\n添加指定文件到暂存区\n\n```shell\ngit add [file1] [file2] ...\n```\n\n添加指定目录到暂存区，包括子目录\n\n```shell\ngit add [dir]\n```\n\n添加当前目录的所有文件到暂存区\n\n```shell\ngit add .\n```\n\n## 添加每个变化前，都会要求确认\n\n对于同一个文件的多处变化，可以实现分次提交\n\n```shell\ngit add -p\n````\n\n删除工作区文件，并且将这次删除放入暂存区\n\n```shell\ngit rm [file1] [file2] ...\n```\n\n停止追踪指定文件，但该文件会保留在工作区\n\n```shell\ngit rm --cached [file]\n```\n\n改名文件，并且将这个改名放入暂存区\n\n```shell\ngit mv [file-original] [file-renamed]\n```\n\n## 代码提交\n\n提交暂存区到仓库区\n\n```shell\ngit commit -m [message]\n```\n\n提交暂存区的指定文件到仓库区\n\n```shell\ngit commit [file1] [file2] ... -m [message]\n```\n\n提交工作区自上次commit之后的变化，直接到仓库区\n\n```shell\ngit commit -a\n```\n\n提交时显示所有diff信息\n\n```shell\ngit commit -v\n```\n\n使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息\n\n```shell\ngit commit --amend -m [message]\n```\n\n重做上一次commit，并包括指定文件的新变化\n\n```shell\ngit commit --amend [file1] [file2] ...\n```\n\n## 分支\n\n列出所有本地分支\n\n```shell\ngit branch\n```\n\n列出所有远程分支\n\n```shell\ngit branch -r\n```\n\n列出所有本地分支和远程分支\n\n```shell\ngit branch -a\n```\n\n新建一个分支，但依然停留在当前分支\n\n```shell\ngit branch [branch-name]\n```\n\n新建一个分支，并切换到该分支\n\n```shell\ngit checkout -b [branch]\n```\n\n新建一个分支，指向指定commit\n\n```shell\ngit branch [branch] [commit]\n```\n\n新建一个分支，与指定的远程分支建立追踪关系\n\n```shell\ngit branch --track [branch] [remote-branch]\n```\n\n切换到指定分支，并更新工作区\n\n```shell\ngit checkout [branch-name]\n```\n\n切换到上一个分支\n\n```shell\ngit checkout -\n```\n\n建立追踪关系，在现有分支与指定的远程分支之间\n\n```shell\ngit branch --set-upstream [branch] [remote-branch]\n```\n\n合并指定分支到当前分支\n\n```shell\ngit merge [branch]\n```\n\n选择一个commit，合并进当前分支\n\n```shell\ngit cherry-pick [commit]\n```\n\n删除分支\n\n```shell\ngit branch -d [branch-name]\n```\n\n删除远程分支\n\n```shell\ngit push origin --delete [branch-name]\ngit branch -dr [remote/branch]\n```\n\n## 标签\n\n列出所有tag\n\n```shell\ngit tag\n```\n\n新建一个tag在当前commit\n\n```shell\ngit tag [tag]\n```\n\n新建一个tag在指定commit\n\n```shell\ngit tag [tag] [commit]\n```\n\n删除本地tag\n\n```shell\ngit tag -d [tag]\n```\n\n删除远程tag\n\n```shell\ngit push origin :refs/tags/[tagName]\n```\n\n查看tag信息\n\n```shell\ngit show [tag]\n```\n\n提交指定tag\n\n```shell\ngit push [remote] [tag]\n```\n\n提交所有tag\n\n```shell\ngit push [remote] --tags\n```\n\n新建一个分支，指向某个tag\n\n```shell\ngit checkout -b [branch] [tag]\n```\n\n## 查看信息\n\n显示有变更的文件\n\n```shell\ngit status\n```\n\n显示当前分支的版本历史\n\n```shell\ngit log\n```\n\n显示commit历史，以及每次commit发生变更的文件\n\n```shell\ngit log --stat\n```\n\n搜索提交历史，根据关键词\n\n```shell\ngit log -S [keyword]\n```\n\n显示某个commit之后的所有变动，每个commit占据一行\n\n```shell\ngit log [tag] HEAD --pretty=format:%s\n```\n\n显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n```shell\ngit log [tag] HEAD --grep feature\n```\n\n显示某个文件的版本历史，包括文件改名\n\n```shell\ngit log --follow [file]\ngit whatchanged [file]\n```\n\n显示指定文件相关的每一次diff\n\n```shell\ngit log -p [file]\n```\n\n显示过去5次提交\n\n```shell\ngit log -5 --pretty --oneline\n```\n\n显示所有提交过的用户，按提交次数排序\n\n```shell\ngit shortlog -sn\n```\n\n显示指定文件是什么人在什么时间修改过\n\n```shell\ngit blame [file]\n```\n\n显示暂存区和工作区的差异\n\n```shell\ngit diff\n```\n\n显示暂存区和上一个commit的差异\n\n```shell\ngit diff --cached [file]\n```\n\n显示工作区与当前分支最新commit之间的差异\n\n```shell\ngit diff HEAD\n```\n\n显示两次提交之间的差异\n\n```shell\ngit diff [first-branch]...[second-branch]\n```\n\n显示今天你写了多少行代码\n\n```shell\ngit diff --shortstat \"@{0 day ago}\"\n```\n\n显示某次提交的元数据和内容变化\n\n```shell\ngit show [commit]\n```\n\n显示某次提交发生变化的文件\n\n```shell\ngit show --name-only [commit]\n```\n\n显示某次提交时，某个文件的内容\n\n```shell\ngit show [commit]:[filename]\n```\n\n显示当前分支的最近几次提交\n\n```shell\ngit reflog\n```\n\n## 远程同步\n\n下载远程仓库的所有变动\n\n```shell\ngit fetch [remote]\n```\n\n显示所有远程仓库\n\n```shell\ngit remote -v\n```\n\n显示某个远程仓库的信息\n\n```shell\ngit remote show [remote]\n```\n\n增加一个新的远程仓库，并命名\n\n```shell\ngit remote add [shortname] [url]\n```\n\n取回远程仓库的变化，并与本地分支合并\n\n```shell\ngit pull [remote] [branch]\n```\n\n上传本地指定分支到远程仓库\n\n```shell\ngit push [remote] [branch]\n```\n\n强行推送当前分支到远程仓库，即使有冲突\n\n```shell\ngit push [remote] --force\n```\n\n推送所有分支到远程仓库\n\n```shell\ngit push [remote] --all\n```\n\n## 撤销\n\n恢复暂存区的指定文件到工作区\n\n```shell\ngit checkout [file]\n```\n\n恢复某个commit的指定文件到暂存区和工作区\n\n```shell\ngit checkout [commit] [file]\n```\n\n恢复暂存区的所有文件到工作区\n\n```shell\ngit checkout .\n```\n\n重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n```shell\ngit reset [file]\n```\n\n重置暂存区与工作区，与上一次commit保持一致\n\n```shell\ngit reset --hard\n```\n\n重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n\n```shell\ngit reset [commit]\n```\n\n重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n\n```shell\ngit reset --hard [commit]\n```\n\n重置当前HEAD为指定commit，但保持暂存区和工作区不变\n\n```shell\ngit reset --keep [commit]\n```\n\n新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支\n\n```shell\ngit revert [commit]\n```\n\n暂时将未提交的变化移除，稍后再移入\n\n```shell\ngit stash\ngit stash pop\n```\n\n## 其他\n\n生成一个可供发布的压缩包\n\n```shell\ngit archive\n```\n","source":"_posts/git常用命令.md","raw":"---\ntitle: Git常用命令\ndate: 2021-05-08 18:03:19\ncategories: Git\ntags:\n- Git\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n# Git常用命令\n\n## 仓库\n\n在当前目录新建一个Git代码库\n\n```shell\ngit init\n```\n\n新建一个目录，将其初始化为Git代码库\n\n```shell\ngit init [project-name]\n```\n\n下载一个项目和它的整个代码历史\n\n```shell\ngit clone [url]\n```\n\n## 配置\n\n显示当前的Git配置\n\n```shell\ngit config --list\n```\n\n编辑Git配置文件\n\n```shell\ngit config -e [--global]\n```\n\n设置提交代码时的用户信息\n\n```shell\ngit config [--global] user.name \"[name]\"\ngit config [--global] user.email \"[email address]\"\n```\n\n## 增加/删除文件\n\n添加指定文件到暂存区\n\n```shell\ngit add [file1] [file2] ...\n```\n\n添加指定目录到暂存区，包括子目录\n\n```shell\ngit add [dir]\n```\n\n添加当前目录的所有文件到暂存区\n\n```shell\ngit add .\n```\n\n## 添加每个变化前，都会要求确认\n\n对于同一个文件的多处变化，可以实现分次提交\n\n```shell\ngit add -p\n````\n\n删除工作区文件，并且将这次删除放入暂存区\n\n```shell\ngit rm [file1] [file2] ...\n```\n\n停止追踪指定文件，但该文件会保留在工作区\n\n```shell\ngit rm --cached [file]\n```\n\n改名文件，并且将这个改名放入暂存区\n\n```shell\ngit mv [file-original] [file-renamed]\n```\n\n## 代码提交\n\n提交暂存区到仓库区\n\n```shell\ngit commit -m [message]\n```\n\n提交暂存区的指定文件到仓库区\n\n```shell\ngit commit [file1] [file2] ... -m [message]\n```\n\n提交工作区自上次commit之后的变化，直接到仓库区\n\n```shell\ngit commit -a\n```\n\n提交时显示所有diff信息\n\n```shell\ngit commit -v\n```\n\n使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息\n\n```shell\ngit commit --amend -m [message]\n```\n\n重做上一次commit，并包括指定文件的新变化\n\n```shell\ngit commit --amend [file1] [file2] ...\n```\n\n## 分支\n\n列出所有本地分支\n\n```shell\ngit branch\n```\n\n列出所有远程分支\n\n```shell\ngit branch -r\n```\n\n列出所有本地分支和远程分支\n\n```shell\ngit branch -a\n```\n\n新建一个分支，但依然停留在当前分支\n\n```shell\ngit branch [branch-name]\n```\n\n新建一个分支，并切换到该分支\n\n```shell\ngit checkout -b [branch]\n```\n\n新建一个分支，指向指定commit\n\n```shell\ngit branch [branch] [commit]\n```\n\n新建一个分支，与指定的远程分支建立追踪关系\n\n```shell\ngit branch --track [branch] [remote-branch]\n```\n\n切换到指定分支，并更新工作区\n\n```shell\ngit checkout [branch-name]\n```\n\n切换到上一个分支\n\n```shell\ngit checkout -\n```\n\n建立追踪关系，在现有分支与指定的远程分支之间\n\n```shell\ngit branch --set-upstream [branch] [remote-branch]\n```\n\n合并指定分支到当前分支\n\n```shell\ngit merge [branch]\n```\n\n选择一个commit，合并进当前分支\n\n```shell\ngit cherry-pick [commit]\n```\n\n删除分支\n\n```shell\ngit branch -d [branch-name]\n```\n\n删除远程分支\n\n```shell\ngit push origin --delete [branch-name]\ngit branch -dr [remote/branch]\n```\n\n## 标签\n\n列出所有tag\n\n```shell\ngit tag\n```\n\n新建一个tag在当前commit\n\n```shell\ngit tag [tag]\n```\n\n新建一个tag在指定commit\n\n```shell\ngit tag [tag] [commit]\n```\n\n删除本地tag\n\n```shell\ngit tag -d [tag]\n```\n\n删除远程tag\n\n```shell\ngit push origin :refs/tags/[tagName]\n```\n\n查看tag信息\n\n```shell\ngit show [tag]\n```\n\n提交指定tag\n\n```shell\ngit push [remote] [tag]\n```\n\n提交所有tag\n\n```shell\ngit push [remote] --tags\n```\n\n新建一个分支，指向某个tag\n\n```shell\ngit checkout -b [branch] [tag]\n```\n\n## 查看信息\n\n显示有变更的文件\n\n```shell\ngit status\n```\n\n显示当前分支的版本历史\n\n```shell\ngit log\n```\n\n显示commit历史，以及每次commit发生变更的文件\n\n```shell\ngit log --stat\n```\n\n搜索提交历史，根据关键词\n\n```shell\ngit log -S [keyword]\n```\n\n显示某个commit之后的所有变动，每个commit占据一行\n\n```shell\ngit log [tag] HEAD --pretty=format:%s\n```\n\n显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n```shell\ngit log [tag] HEAD --grep feature\n```\n\n显示某个文件的版本历史，包括文件改名\n\n```shell\ngit log --follow [file]\ngit whatchanged [file]\n```\n\n显示指定文件相关的每一次diff\n\n```shell\ngit log -p [file]\n```\n\n显示过去5次提交\n\n```shell\ngit log -5 --pretty --oneline\n```\n\n显示所有提交过的用户，按提交次数排序\n\n```shell\ngit shortlog -sn\n```\n\n显示指定文件是什么人在什么时间修改过\n\n```shell\ngit blame [file]\n```\n\n显示暂存区和工作区的差异\n\n```shell\ngit diff\n```\n\n显示暂存区和上一个commit的差异\n\n```shell\ngit diff --cached [file]\n```\n\n显示工作区与当前分支最新commit之间的差异\n\n```shell\ngit diff HEAD\n```\n\n显示两次提交之间的差异\n\n```shell\ngit diff [first-branch]...[second-branch]\n```\n\n显示今天你写了多少行代码\n\n```shell\ngit diff --shortstat \"@{0 day ago}\"\n```\n\n显示某次提交的元数据和内容变化\n\n```shell\ngit show [commit]\n```\n\n显示某次提交发生变化的文件\n\n```shell\ngit show --name-only [commit]\n```\n\n显示某次提交时，某个文件的内容\n\n```shell\ngit show [commit]:[filename]\n```\n\n显示当前分支的最近几次提交\n\n```shell\ngit reflog\n```\n\n## 远程同步\n\n下载远程仓库的所有变动\n\n```shell\ngit fetch [remote]\n```\n\n显示所有远程仓库\n\n```shell\ngit remote -v\n```\n\n显示某个远程仓库的信息\n\n```shell\ngit remote show [remote]\n```\n\n增加一个新的远程仓库，并命名\n\n```shell\ngit remote add [shortname] [url]\n```\n\n取回远程仓库的变化，并与本地分支合并\n\n```shell\ngit pull [remote] [branch]\n```\n\n上传本地指定分支到远程仓库\n\n```shell\ngit push [remote] [branch]\n```\n\n强行推送当前分支到远程仓库，即使有冲突\n\n```shell\ngit push [remote] --force\n```\n\n推送所有分支到远程仓库\n\n```shell\ngit push [remote] --all\n```\n\n## 撤销\n\n恢复暂存区的指定文件到工作区\n\n```shell\ngit checkout [file]\n```\n\n恢复某个commit的指定文件到暂存区和工作区\n\n```shell\ngit checkout [commit] [file]\n```\n\n恢复暂存区的所有文件到工作区\n\n```shell\ngit checkout .\n```\n\n重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n```shell\ngit reset [file]\n```\n\n重置暂存区与工作区，与上一次commit保持一致\n\n```shell\ngit reset --hard\n```\n\n重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n\n```shell\ngit reset [commit]\n```\n\n重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n\n```shell\ngit reset --hard [commit]\n```\n\n重置当前HEAD为指定commit，但保持暂存区和工作区不变\n\n```shell\ngit reset --keep [commit]\n```\n\n新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支\n\n```shell\ngit revert [commit]\n```\n\n暂时将未提交的变化移除，稍后再移入\n\n```shell\ngit stash\ngit stash pop\n```\n\n## 其他\n\n生成一个可供发布的压缩包\n\n```shell\ngit archive\n```\n","slug":"git常用命令","published":1,"updated":"2021-06-15T03:24:11.488Z","_id":"ckpapu7hz000ilcxu66p23in4","layout":"post","photos":[],"link":"","content":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>在当前目录新建一个Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>新建一个目录，将其初始化为Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init [project-name]</span><br></pre></td></tr></table></figure>\n\n<p>下载一个项目和它的整个代码历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone [url]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>显示当前的Git配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --list</span><br></pre></td></tr></table></figure>\n\n<p>编辑Git配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -e [--global]</span><br></pre></td></tr></table></figure>\n\n<p>设置提交代码时的用户信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h2><p>添加指定文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>添加指定目录到暂存区，包括子目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [dir]</span><br></pre></td></tr></table></figure>\n\n<p>添加当前目录的所有文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加每个变化前，都会要求确认\"><a href=\"#添加每个变化前，都会要求确认\" class=\"headerlink\" title=\"添加每个变化前，都会要求确认\"></a>添加每个变化前，都会要求确认</h2><p>对于同一个文件的多处变化，可以实现分次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -p</span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\">删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\"></span><br><span class=\"line\">```shell</span><br><span class=\"line\">git rm [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>停止追踪指定文件，但该文件会保留在工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>改名文件，并且将这个改名放入暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h2><p>提交暂存区到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交暂存区的指定文件到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交工作区自上次commit之后的变化，直接到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -a</span><br></pre></td></tr></table></figure>\n\n<p>提交时显示所有diff信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -v</span><br></pre></td></tr></table></figure>\n\n<p>使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>重做上一次commit，并包括指定文件的新变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>列出所有本地分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<p>列出所有远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n\n<p>列出所有本地分支和远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，但依然停留在当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，并切换到该分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，与指定的远程分支建立追踪关系</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>切换到指定分支，并更新工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>切换到上一个分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n\n<p>建立追踪关系，在现有分支与指定的远程分支之间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>合并指定分支到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge [branch]</span><br></pre></td></tr></table></figure>\n\n<p>选择一个commit，合并进当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete [branch-name]</span><br><span class=\"line\">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>列出所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在当前commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除本地tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d [tag]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure>\n\n<p>查看tag信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交指定tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --tags</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向某个tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h2><p>显示有变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的版本历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br></pre></td></tr></table></figure>\n\n<p>显示commit历史，以及每次commit发生变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --stat</span><br></pre></td></tr></table></figure>\n\n<p>搜索提交历史，根据关键词</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -S [keyword]</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，每个commit占据一行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure>\n\n<p>显示某个文件的版本历史，包括文件改名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --follow [file]</span><br><span class=\"line\">git whatchanged [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件相关的每一次diff</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -p [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示过去5次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -5 --pretty --oneline</span><br></pre></td></tr></table></figure>\n\n<p>显示所有提交过的用户，按提交次数排序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git shortlog -sn</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件是什么人在什么时间修改过</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git blame [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和工作区的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和上一个commit的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示工作区与当前分支最新commit之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff HEAD</span><br></pre></td></tr></table></figure>\n\n<p>显示两次提交之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>\n\n<p>显示今天你写了多少行代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交的元数据和内容变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交发生变化的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show --name-only [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交时，某个文件的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的最近几次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h2><p>下载远程仓库的所有变动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch [remote]</span><br></pre></td></tr></table></figure>\n\n<p>显示所有远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<p>显示某个远程仓库的信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show [remote]</span><br></pre></td></tr></table></figure>\n\n<p>增加一个新的远程仓库，并命名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>\n\n<p>取回远程仓库的变化，并与本地分支合并</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>上传本地指定分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>强行推送当前分支到远程仓库，即使有冲突</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --force</span><br></pre></td></tr></table></figure>\n\n<p>推送所有分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>恢复暂存区的指定文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复某个commit的指定文件到暂存区和工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [commit] [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复暂存区的所有文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [file]</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区与工作区，与上一次commit保持一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --keep [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert [commit]</span><br></pre></td></tr></table></figure>\n\n<p>暂时将未提交的变化移除，稍后再移入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>生成一个可供发布的压缩包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git archive</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>在当前目录新建一个Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>新建一个目录，将其初始化为Git代码库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init [project-name]</span><br></pre></td></tr></table></figure>\n\n<p>下载一个项目和它的整个代码历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone [url]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>显示当前的Git配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --list</span><br></pre></td></tr></table></figure>\n\n<p>编辑Git配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -e [--global]</span><br></pre></td></tr></table></figure>\n\n<p>设置提交代码时的用户信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config [--global] user.name &quot;[name]&quot;</span><br><span class=\"line\">git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h2><p>添加指定文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>添加指定目录到暂存区，包括子目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add [dir]</span><br></pre></td></tr></table></figure>\n\n<p>添加当前目录的所有文件到暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加每个变化前，都会要求确认\"><a href=\"#添加每个变化前，都会要求确认\" class=\"headerlink\" title=\"添加每个变化前，都会要求确认\"></a>添加每个变化前，都会要求确认</h2><p>对于同一个文件的多处变化，可以实现分次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -p</span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\">删除工作区文件，并且将这次删除放入暂存区</span><br><span class=\"line\"></span><br><span class=\"line\">```shell</span><br><span class=\"line\">git rm [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>停止追踪指定文件，但该文件会保留在工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>改名文件，并且将这个改名放入暂存区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h2><p>提交暂存区到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交暂存区的指定文件到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>提交工作区自上次commit之后的变化，直接到仓库区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -a</span><br></pre></td></tr></table></figure>\n\n<p>提交时显示所有diff信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -v</span><br></pre></td></tr></table></figure>\n\n<p>使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend -m [message]</span><br></pre></td></tr></table></figure>\n\n<p>重做上一次commit，并包括指定文件的新变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><p>列出所有本地分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<p>列出所有远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n\n<p>列出所有本地分支和远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，但依然停留在当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，并切换到该分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch [branch] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，与指定的远程分支建立追踪关系</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>切换到指定分支，并更新工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>切换到上一个分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n\n<p>建立追踪关系，在现有分支与指定的远程分支之间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>\n\n<p>合并指定分支到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge [branch]</span><br></pre></td></tr></table></figure>\n\n<p>选择一个commit，合并进当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d [branch-name]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete [branch-name]</span><br><span class=\"line\">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>列出所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在当前commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个tag在指定commit</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag [tag] [commit]</span><br></pre></td></tr></table></figure>\n\n<p>删除本地tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d [tag]</span><br></pre></td></tr></table></figure>\n\n<p>删除远程tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure>\n\n<p>查看tag信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交指定tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [tag]</span><br></pre></td></tr></table></figure>\n\n<p>提交所有tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --tags</span><br></pre></td></tr></table></figure>\n\n<p>新建一个分支，指向某个tag</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h2><p>显示有变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的版本历史</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br></pre></td></tr></table></figure>\n\n<p>显示commit历史，以及每次commit发生变更的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --stat</span><br></pre></td></tr></table></figure>\n\n<p>搜索提交历史，根据关键词</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -S [keyword]</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，每个commit占据一行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>\n\n<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure>\n\n<p>显示某个文件的版本历史，包括文件改名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --follow [file]</span><br><span class=\"line\">git whatchanged [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件相关的每一次diff</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -p [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示过去5次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log -5 --pretty --oneline</span><br></pre></td></tr></table></figure>\n\n<p>显示所有提交过的用户，按提交次数排序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git shortlog -sn</span><br></pre></td></tr></table></figure>\n\n<p>显示指定文件是什么人在什么时间修改过</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git blame [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和工作区的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n\n<p>显示暂存区和上一个commit的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached [file]</span><br></pre></td></tr></table></figure>\n\n<p>显示工作区与当前分支最新commit之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff HEAD</span><br></pre></td></tr></table></figure>\n\n<p>显示两次提交之间的差异</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>\n\n<p>显示今天你写了多少行代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交的元数据和内容变化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交发生变化的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show --name-only [commit]</span><br></pre></td></tr></table></figure>\n\n<p>显示某次提交时，某个文件的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>\n\n<p>显示当前分支的最近几次提交</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h2><p>下载远程仓库的所有变动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch [remote]</span><br></pre></td></tr></table></figure>\n\n<p>显示所有远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<p>显示某个远程仓库的信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show [remote]</span><br></pre></td></tr></table></figure>\n\n<p>增加一个新的远程仓库，并命名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>\n\n<p>取回远程仓库的变化，并与本地分支合并</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>上传本地指定分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] [branch]</span><br></pre></td></tr></table></figure>\n\n<p>强行推送当前分支到远程仓库，即使有冲突</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --force</span><br></pre></td></tr></table></figure>\n\n<p>推送所有分支到远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [remote] --all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h2><p>恢复暂存区的指定文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复某个commit的指定文件到暂存区和工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [commit] [file]</span><br></pre></td></tr></table></figure>\n\n<p>恢复暂存区的所有文件到工作区</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [file]</span><br></pre></td></tr></table></figure>\n\n<p>重置暂存区与工作区，与上一次commit保持一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard [commit]</span><br></pre></td></tr></table></figure>\n\n<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --keep [commit]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert [commit]</span><br></pre></td></tr></table></figure>\n\n<p>暂时将未提交的变化移除，稍后再移入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>生成一个可供发布的压缩包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git archive</span><br></pre></td></tr></table></figure>\n"},{"title":"go语言的下载和安装","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-26T02:37:38.000Z","pic":null,"_content":"\n\n## 下载安装包\n\n访问[https://studygolang.com/dl](https://studygolang.com/dl)下载对应系统的安装包，这里以`windows`平台为例。\n\n![](Screenshot_1.webp)\n\n## 安装\n\n安装下载后的安装文件。\n\n![](Screenshot_2.webp)\n\n使用推荐的默认设置就可以了。\n\n## 增加环境变量\n\n在系统环境变量`PATH`中添加`go`的安装路径，比如`C:\\Program Files\\Go\\bin`。\n\n添加完成后调出`cmd`输入`go version`有下面的显示说明安装成功了。\n\n```cmd\nC:\\Users\\espho>go version\ngo version go1.16.4 windows/amd64\n```\n\n## 设置代理\n\n设置为国内代理，方便下载`go`模块：\n\n```shell\n阿里云\nhttps://mirrors.aliyun.com/goproxy/\n七牛云\nhttps://goproxy.cn\n```\n\n设置方式：\n\n```shell\ngo env -w GO111MODULE=on\ngo env -w GOPROXY=https://mirrors.aliyun.com/goproxy/\n```\n\n运行`go env`查看设置是否成功。\n","source":"_posts/go语言的下载和安装.md","raw":"---\ntitle: go语言的下载和安装\ntags:\n  - go\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-26 10:37:38\ncategories: Go\npic:\n---\n\n\n## 下载安装包\n\n访问[https://studygolang.com/dl](https://studygolang.com/dl)下载对应系统的安装包，这里以`windows`平台为例。\n\n![](Screenshot_1.webp)\n\n## 安装\n\n安装下载后的安装文件。\n\n![](Screenshot_2.webp)\n\n使用推荐的默认设置就可以了。\n\n## 增加环境变量\n\n在系统环境变量`PATH`中添加`go`的安装路径，比如`C:\\Program Files\\Go\\bin`。\n\n添加完成后调出`cmd`输入`go version`有下面的显示说明安装成功了。\n\n```cmd\nC:\\Users\\espho>go version\ngo version go1.16.4 windows/amd64\n```\n\n## 设置代理\n\n设置为国内代理，方便下载`go`模块：\n\n```shell\n阿里云\nhttps://mirrors.aliyun.com/goproxy/\n七牛云\nhttps://goproxy.cn\n```\n\n设置方式：\n\n```shell\ngo env -w GO111MODULE=on\ngo env -w GOPROXY=https://mirrors.aliyun.com/goproxy/\n```\n\n运行`go env`查看设置是否成功。\n","slug":"go语言的下载和安装","published":1,"updated":"2021-06-15T03:24:11.489Z","_id":"ckpapu7i3000nlcxuh7paf5fa","layout":"post","photos":[],"link":"","content":"<h2 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h2><p>访问<a href=\"https://studygolang.com/dl\">https://studygolang.com/dl</a>下载对应系统的安装包，这里以<code>windows</code>平台为例。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装下载后的安装文件。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>使用推荐的默认设置就可以了。</p>\n<h2 id=\"增加环境变量\"><a href=\"#增加环境变量\" class=\"headerlink\" title=\"增加环境变量\"></a>增加环境变量</h2><p>在系统环境变量<code>PATH</code>中添加<code>go</code>的安装路径，比如<code>C:\\Program Files\\Go\\bin</code>。</p>\n<p>添加完成后调出<code>cmd</code>输入<code>go version</code>有下面的显示说明安装成功了。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Users</span>\\<span class=\"title\">espho</span>&gt;<span class=\"title\">go</span> <span class=\"title\">version</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">go</span> <span class=\"title\">version</span> <span class=\"title\">go1</span>.16.4 <span class=\"title\">windows</span>/<span class=\"title\">amd64</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置代理\"><a href=\"#设置代理\" class=\"headerlink\" title=\"设置代理\"></a>设置代理</h2><p>设置为国内代理，方便下载<code>go</code>模块：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阿里云</span><br><span class=\"line\">https://mirrors.aliyun.com/goproxy/</span><br><span class=\"line\">七牛云</span><br><span class=\"line\">https://goproxy.cn</span><br></pre></td></tr></table></figure>\n\n<p>设置方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go env -w GO111MODULE=on</span><br><span class=\"line\">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/</span><br></pre></td></tr></table></figure>\n\n<p>运行<code>go env</code>查看设置是否成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h2><p>访问<a href=\"https://studygolang.com/dl\">https://studygolang.com/dl</a>下载对应系统的安装包，这里以<code>windows</code>平台为例。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装下载后的安装文件。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>使用推荐的默认设置就可以了。</p>\n<h2 id=\"增加环境变量\"><a href=\"#增加环境变量\" class=\"headerlink\" title=\"增加环境变量\"></a>增加环境变量</h2><p>在系统环境变量<code>PATH</code>中添加<code>go</code>的安装路径，比如<code>C:\\Program Files\\Go\\bin</code>。</p>\n<p>添加完成后调出<code>cmd</code>输入<code>go version</code>有下面的显示说明安装成功了。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Users</span>\\<span class=\"title\">espho</span>&gt;<span class=\"title\">go</span> <span class=\"title\">version</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">go</span> <span class=\"title\">version</span> <span class=\"title\">go1</span>.16.4 <span class=\"title\">windows</span>/<span class=\"title\">amd64</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置代理\"><a href=\"#设置代理\" class=\"headerlink\" title=\"设置代理\"></a>设置代理</h2><p>设置为国内代理，方便下载<code>go</code>模块：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阿里云</span><br><span class=\"line\">https://mirrors.aliyun.com/goproxy/</span><br><span class=\"line\">七牛云</span><br><span class=\"line\">https://goproxy.cn</span><br></pre></td></tr></table></figure>\n\n<p>设置方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go env -w GO111MODULE=on</span><br><span class=\"line\">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/</span><br></pre></td></tr></table></figure>\n\n<p>运行<code>go env</code>查看设置是否成功。</p>\n"},{"title":"python多线程基本原理","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-06-15T03:24:11.491Z","pic":null,"_content":"\n\n## 多线程的含义\n\n说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。\n\n进程可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。\n\n而进程呢？它就是**线程的集合**，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。\n\n了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。\n\n## 并发和并行\n\n并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。\n\n并发，英文叫作`concurrency`。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程`A`的指令一段时间，再执行线程`B`的指令一段时间，再切回到线程`A`执行一段时间。\n\n由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。\n\n并行，英文叫作`parallel`。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。\n\n并行只能在多处理器系统中存在，如果的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。\n\n举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。\n\n## 多线程适用场景\n\n多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。\n\n像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于`IO`密集型任务。对于这种任务，如果启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。\n\n但并不是所有的任务都是`IO`密集型任务，还有一种任务叫作计算密集型任务，也可以称之为`CPU`密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。\n\n所以，如果任务不全是计算密集型任务，可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种IO密集型任务来说，使用多线程会大大提高程序整体的爬取效率。\n\n## Python实现多线程\n\n实在`Python`中，实现多线程的模块叫作`threading`，是`Python`自带的模块。使用`threading`实现多线程的方法。\n\n###Thread直接创建子线程\n\n首先，可以使用`Thread`类来创建一个线程，创建时需要指定`target`参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过`Thread`的`args`参数来指定。示例如下：\n\n```python\nimport threading\nimport time\n\ndef target(second):\n    print(f'Threading {threading.currentThread().name} id runing')\n    print(f'Threading {threading.current_thread().name} sleep {second}s')\n    time.sleep(second)\n    print(f'Threading {threading.currentThread().name} is ended')\n\nprint(f'Threading {threading.currentThread().name} id runing')\nfor i in [1, 5]:\n    thread = threading.Thread(target=target, args=[i])\n    thread.start()\nprint(f'Threading {threading.currentThread().name} is ended')\n```\n\n运行结果如下：\n\n```python\nThreading MainThread id runing\nThreading Thread-1 id runing\nThreading Thread-1 sleep 1s\nThreading Thread-2 id runingThreading MainThread is ended\n\nThreading Thread-2 sleep 5s\nThreading Thread-1 is ended\nThreading Thread-2 is ended\n```\n\n在这里首先声明了一个方法，叫作`target`，它接收一个参数为`second`，通过方法的实现可以发现，这个方法其实就是执行了一个`time.sleep`休眠操作，`second`参数就是休眠秒数，其前后都`print`了一些内容，其中线程的名字通过`threading.current_thread().name`来获取出来，如果是主线程的话，其值就是`MainThread`，如果是子线程的话，其值就是`Thread-*`。\n\n然后通过`Thead`类新建了两个线程，`target`参数就是刚才所定义的方法名，`args`以列表的形式传递。两次循环中，这里`i`分别就是`1`和`5`，这样两个线程就分别休眠`1`秒·和5秒，声明完成之后，调用`start`方法即可开始线程的运行。\n\n观察结果可以发现，这里一共产生了三个线程，分别是主线程`MainThread`和两个子线程`Thread-1`、`Thread-2`。另外观察到，主线程首先运行结束，紧接着`Thread-1`、`Thread-2`才接连运行结束，分别间隔了`1`秒和`4`秒。这说明主线程并没有等待子线程运行完毕才结束运行，而是直接退出了，有点不符合常理。如果想要主线程等待子线程运行完毕之后才退出，可以让每个子线程对象都调用下`join`方法，实现如下：\n\n```python\nthreads = []\nfor i in [1, 5]:\n    thread = threading.Thread(target=target, args=[i])\n    threads.append(thread)\n    thread.start()\nfor thread in threads:\n    thread.join()\n```\n\n运行结果如下：\n\n```python\nThreading MainThread id runing\nThreading Thread-1 id runing\nThreading Thread-1 sleep 1s\nThreading Thread-2 id runing\nThreading Thread-2 sleep 5s\nThreading Thread-1 is ended\nThreading Thread-2 is ended\nThreading MainThread is ended\n```\n\n主线程必须等待子线程都运行结束，主线程才继续运行并结束。\n\n## 继承Thread类创建子线程\n\n另外，也可以通过继承`Thread`类的方式创建一个线程，该线程需要执行的方法写在类的`run`方法里面即可。上面的例子的等价改写为：\n\n```python\nimport time\nimport threading\n\nclass MyThread(threading.Thread):\n    def __init__(self, second):\n        threading.Thread.__init__(self)\n        self.second = second\n\n    def run(self):\n        print(f'Threading {threading.current_thread().name} is runing')\n        print(f'Threding {threading.current_thread().name} sleep {self.second}s')\n        time.sleep(self.second)\n        print(f'Threading {threading.current_thread().name} is ended')\n\nprint(f'Threading {threading.current_thread().name} is running')\nthreads = []\nfor i in [1, 5]:\n    thread = MyThread(i)\n    threads.append(thread)\n    thread.start()\nfor thread in threads:\n    thread.join()\nprint(f'Threading {threading.current_thread().name} is ended')\n```\n\n运行结果如下：\n\n```python\nThreading MainThread id runing\nThreading Thread-1 id runing\nThreading Thread-1 sleep 1s\nThreading Thread-2 id runing\nThreading Thread-2 sleep 5s\nThreading Thread-1 is ended\nThreading Thread-2 is ended\nThreading MainThread is ended\n```\n\n可以看到，两种实现方式，其运行效果是相同的。\n\n## 守护进程\n\n在线程中有一个叫作守护线程的概念，如果一个线程被设置为守护线程，那么意味着这个线程是“不重要”的，这意味着，如果主线程结束了而该守护线程还没有运行完，那么它将会被强制结束。在`Python`中可以通过`setDaemon`方法来将某个线程设置为守护线程。\n\n示例如下：\n\n```python\nThreding MainThread is running\nThreading Thread-1 is running\nThreding Thread-1 sleep 2s\nThreading Thread-2 is running\nThreding Thread-2 sleep 5s\nThreading MainThread is ended\nThreading Thread-1 is ended\n```\n\n在这里通过 setDaemon方法将 t2 设置为了守护线程，这样主线程在运行完毕时，t2 线程会随着线程的结束而结束。\n\n运行结果如下：\n\n```python\nThreding MainThread is running\nThreading Thread-1 is running\nThreding Thread-1 sleep 2s\nThreading Thread-2 is running\nThreding Thread-2 sleep 5s\nThreading MainThread is ended\nThreading Thread-1 is ended\n```\n\n可以看到，没有`Thread-2`打印退出的消息，`Thread-2`随着主线程的退出而退出了。\n\n这里并没有调用`join`方法，如果让`t1`和`t2`都调用`join`方法，主线程就会仍然等待各个子线程执行完毕再退出，不论其是否是守护线程。\n\n## 互斥锁\n\n互在一个进程中的多个线程是共享资源的，比如在一个进程中，有一个全局变量`count`用来计数，声明多个线程，每个线程运行时都给`count`加`1`，代码实现如下：\n\n在这里，声明了`1000`个线程，每个线程都是现取到当前的全局变量`count`值，然后休眠一小段时间，然后对`count`赋予新的值。\n\n按照常理来说，最终的`count`值应该为`1000`。但其实不然。运行结果如下：\n\n```python\nFinal count: 15\n```\n\n最后的结果居然只有`15`，而且多次运行或者换个环境运行结果是不同的.这是为什么呢？因为`count`这个值是共享的，每个线程都可以在执行`temp = count`这行代码时拿到当前`count`的值，但是这些线程中的一些线程可能是并发或者并行执行的，这就导致不同的线程拿到的可能是同一个`count`值，最后导致有些线程的`count`的加`1`操作并没有生效，导致最后的结果偏小。\n\n所以，如果多个线程同时对某个数据进行读取或修改，就会出现不可预料的结果。为了避免这种情况，我们需要对多个线程进行同步，要实现同步，我们可以对需要操作的数据进行**加锁保护**，这里就需要用到`threading.Lock`了。\n\n加锁保护是什么意思呢？就是说，某个线程在对数据进行操作前，需要先加锁，这样其他的线程发现被加锁了之后，就无法继续向下执行，会一直等待锁被释放，只有加锁的线程把锁释放了，其他的线程才能 继续加锁并对数据做修改，修改完了再释放锁。这样可以确保同一时间只有一个线程操作数据，多个线程不会再同时读取和修改同一个数据，这样最后的运行结果就是对的了。\n\n将代码修改为如下内容：\n\n```python\nimport time\nimport threading\n\ncount = 0\n\nclass MyThread(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n\n    def run(self):\n        global count\n        lock.acquire()  # 加锁\n        temp = count + 1\n        time.sleep(0.001)\n        count = temp\n        lock.release() # 解锁\n\nthreads = []\nlock = threading.Lock() # 创建一把锁\nfor _ in range(1000):\n    thread = MyThread()\n    thread.start()\n    threads.append(thread)\n\nfor thread in threads:\n    thread.join()\nprint(f'Final count: {count}')\n\n```\n\n运行结果如下：\n\n```python\nFinal count: 1000\n```\n\n## Python多线程的问题\n\n由于`Python`中`GIL`的限制，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致`Python`多线程无法发挥多核并行的优势。\n\n`GIL`全称为`GlobalInterpreter Lock`，中文翻译为全局解释器锁，其最初设计是出于数据安全而考虑的。\n\n在`Python`多线程下，每个线程的执行方式如下：\n\n- 获取`GIL`执行对应线程的代码\n- 释放`GIL`可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL看作是通行证，并且在一个 Python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。这样就会导致，即使是多核条件下，一个 Python 进程下的多个线程，同一时刻也只能执行一个线程。 不过对于爬虫这种 IO 密集型任务来说，这个问题影响并不大。而对于计算密集型任务来说，由于 GIL的存在，多线程总体的运行效率相比可能反而比单线程更低","source":"_posts/python多线程基本原理.md","raw":"---\ntitle: python多线程基本原理\ntags: \n- python\n- 多线程\n- threading\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\ndate: 2021-05-1303:42:12\ncategories: Python\npic:\n---\n\n\n## 多线程的含义\n\n说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。\n\n进程可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。\n\n而进程呢？它就是**线程的集合**，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。\n\n了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。\n\n## 并发和并行\n\n并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。\n\n并发，英文叫作`concurrency`。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程`A`的指令一段时间，再执行线程`B`的指令一段时间，再切回到线程`A`执行一段时间。\n\n由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。\n\n并行，英文叫作`parallel`。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。\n\n并行只能在多处理器系统中存在，如果的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。\n\n举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。\n\n## 多线程适用场景\n\n多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。\n\n像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于`IO`密集型任务。对于这种任务，如果启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。\n\n但并不是所有的任务都是`IO`密集型任务，还有一种任务叫作计算密集型任务，也可以称之为`CPU`密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。\n\n所以，如果任务不全是计算密集型任务，可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种IO密集型任务来说，使用多线程会大大提高程序整体的爬取效率。\n\n## Python实现多线程\n\n实在`Python`中，实现多线程的模块叫作`threading`，是`Python`自带的模块。使用`threading`实现多线程的方法。\n\n###Thread直接创建子线程\n\n首先，可以使用`Thread`类来创建一个线程，创建时需要指定`target`参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过`Thread`的`args`参数来指定。示例如下：\n\n```python\nimport threading\nimport time\n\ndef target(second):\n    print(f'Threading {threading.currentThread().name} id runing')\n    print(f'Threading {threading.current_thread().name} sleep {second}s')\n    time.sleep(second)\n    print(f'Threading {threading.currentThread().name} is ended')\n\nprint(f'Threading {threading.currentThread().name} id runing')\nfor i in [1, 5]:\n    thread = threading.Thread(target=target, args=[i])\n    thread.start()\nprint(f'Threading {threading.currentThread().name} is ended')\n```\n\n运行结果如下：\n\n```python\nThreading MainThread id runing\nThreading Thread-1 id runing\nThreading Thread-1 sleep 1s\nThreading Thread-2 id runingThreading MainThread is ended\n\nThreading Thread-2 sleep 5s\nThreading Thread-1 is ended\nThreading Thread-2 is ended\n```\n\n在这里首先声明了一个方法，叫作`target`，它接收一个参数为`second`，通过方法的实现可以发现，这个方法其实就是执行了一个`time.sleep`休眠操作，`second`参数就是休眠秒数，其前后都`print`了一些内容，其中线程的名字通过`threading.current_thread().name`来获取出来，如果是主线程的话，其值就是`MainThread`，如果是子线程的话，其值就是`Thread-*`。\n\n然后通过`Thead`类新建了两个线程，`target`参数就是刚才所定义的方法名，`args`以列表的形式传递。两次循环中，这里`i`分别就是`1`和`5`，这样两个线程就分别休眠`1`秒·和5秒，声明完成之后，调用`start`方法即可开始线程的运行。\n\n观察结果可以发现，这里一共产生了三个线程，分别是主线程`MainThread`和两个子线程`Thread-1`、`Thread-2`。另外观察到，主线程首先运行结束，紧接着`Thread-1`、`Thread-2`才接连运行结束，分别间隔了`1`秒和`4`秒。这说明主线程并没有等待子线程运行完毕才结束运行，而是直接退出了，有点不符合常理。如果想要主线程等待子线程运行完毕之后才退出，可以让每个子线程对象都调用下`join`方法，实现如下：\n\n```python\nthreads = []\nfor i in [1, 5]:\n    thread = threading.Thread(target=target, args=[i])\n    threads.append(thread)\n    thread.start()\nfor thread in threads:\n    thread.join()\n```\n\n运行结果如下：\n\n```python\nThreading MainThread id runing\nThreading Thread-1 id runing\nThreading Thread-1 sleep 1s\nThreading Thread-2 id runing\nThreading Thread-2 sleep 5s\nThreading Thread-1 is ended\nThreading Thread-2 is ended\nThreading MainThread is ended\n```\n\n主线程必须等待子线程都运行结束，主线程才继续运行并结束。\n\n## 继承Thread类创建子线程\n\n另外，也可以通过继承`Thread`类的方式创建一个线程，该线程需要执行的方法写在类的`run`方法里面即可。上面的例子的等价改写为：\n\n```python\nimport time\nimport threading\n\nclass MyThread(threading.Thread):\n    def __init__(self, second):\n        threading.Thread.__init__(self)\n        self.second = second\n\n    def run(self):\n        print(f'Threading {threading.current_thread().name} is runing')\n        print(f'Threding {threading.current_thread().name} sleep {self.second}s')\n        time.sleep(self.second)\n        print(f'Threading {threading.current_thread().name} is ended')\n\nprint(f'Threading {threading.current_thread().name} is running')\nthreads = []\nfor i in [1, 5]:\n    thread = MyThread(i)\n    threads.append(thread)\n    thread.start()\nfor thread in threads:\n    thread.join()\nprint(f'Threading {threading.current_thread().name} is ended')\n```\n\n运行结果如下：\n\n```python\nThreading MainThread id runing\nThreading Thread-1 id runing\nThreading Thread-1 sleep 1s\nThreading Thread-2 id runing\nThreading Thread-2 sleep 5s\nThreading Thread-1 is ended\nThreading Thread-2 is ended\nThreading MainThread is ended\n```\n\n可以看到，两种实现方式，其运行效果是相同的。\n\n## 守护进程\n\n在线程中有一个叫作守护线程的概念，如果一个线程被设置为守护线程，那么意味着这个线程是“不重要”的，这意味着，如果主线程结束了而该守护线程还没有运行完，那么它将会被强制结束。在`Python`中可以通过`setDaemon`方法来将某个线程设置为守护线程。\n\n示例如下：\n\n```python\nThreding MainThread is running\nThreading Thread-1 is running\nThreding Thread-1 sleep 2s\nThreading Thread-2 is running\nThreding Thread-2 sleep 5s\nThreading MainThread is ended\nThreading Thread-1 is ended\n```\n\n在这里通过 setDaemon方法将 t2 设置为了守护线程，这样主线程在运行完毕时，t2 线程会随着线程的结束而结束。\n\n运行结果如下：\n\n```python\nThreding MainThread is running\nThreading Thread-1 is running\nThreding Thread-1 sleep 2s\nThreading Thread-2 is running\nThreding Thread-2 sleep 5s\nThreading MainThread is ended\nThreading Thread-1 is ended\n```\n\n可以看到，没有`Thread-2`打印退出的消息，`Thread-2`随着主线程的退出而退出了。\n\n这里并没有调用`join`方法，如果让`t1`和`t2`都调用`join`方法，主线程就会仍然等待各个子线程执行完毕再退出，不论其是否是守护线程。\n\n## 互斥锁\n\n互在一个进程中的多个线程是共享资源的，比如在一个进程中，有一个全局变量`count`用来计数，声明多个线程，每个线程运行时都给`count`加`1`，代码实现如下：\n\n在这里，声明了`1000`个线程，每个线程都是现取到当前的全局变量`count`值，然后休眠一小段时间，然后对`count`赋予新的值。\n\n按照常理来说，最终的`count`值应该为`1000`。但其实不然。运行结果如下：\n\n```python\nFinal count: 15\n```\n\n最后的结果居然只有`15`，而且多次运行或者换个环境运行结果是不同的.这是为什么呢？因为`count`这个值是共享的，每个线程都可以在执行`temp = count`这行代码时拿到当前`count`的值，但是这些线程中的一些线程可能是并发或者并行执行的，这就导致不同的线程拿到的可能是同一个`count`值，最后导致有些线程的`count`的加`1`操作并没有生效，导致最后的结果偏小。\n\n所以，如果多个线程同时对某个数据进行读取或修改，就会出现不可预料的结果。为了避免这种情况，我们需要对多个线程进行同步，要实现同步，我们可以对需要操作的数据进行**加锁保护**，这里就需要用到`threading.Lock`了。\n\n加锁保护是什么意思呢？就是说，某个线程在对数据进行操作前，需要先加锁，这样其他的线程发现被加锁了之后，就无法继续向下执行，会一直等待锁被释放，只有加锁的线程把锁释放了，其他的线程才能 继续加锁并对数据做修改，修改完了再释放锁。这样可以确保同一时间只有一个线程操作数据，多个线程不会再同时读取和修改同一个数据，这样最后的运行结果就是对的了。\n\n将代码修改为如下内容：\n\n```python\nimport time\nimport threading\n\ncount = 0\n\nclass MyThread(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n\n    def run(self):\n        global count\n        lock.acquire()  # 加锁\n        temp = count + 1\n        time.sleep(0.001)\n        count = temp\n        lock.release() # 解锁\n\nthreads = []\nlock = threading.Lock() # 创建一把锁\nfor _ in range(1000):\n    thread = MyThread()\n    thread.start()\n    threads.append(thread)\n\nfor thread in threads:\n    thread.join()\nprint(f'Final count: {count}')\n\n```\n\n运行结果如下：\n\n```python\nFinal count: 1000\n```\n\n## Python多线程的问题\n\n由于`Python`中`GIL`的限制，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致`Python`多线程无法发挥多核并行的优势。\n\n`GIL`全称为`GlobalInterpreter Lock`，中文翻译为全局解释器锁，其最初设计是出于数据安全而考虑的。\n\n在`Python`多线程下，每个线程的执行方式如下：\n\n- 获取`GIL`执行对应线程的代码\n- 释放`GIL`可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL看作是通行证，并且在一个 Python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。这样就会导致，即使是多核条件下，一个 Python 进程下的多个线程，同一时刻也只能执行一个线程。 不过对于爬虫这种 IO 密集型任务来说，这个问题影响并不大。而对于计算密集型任务来说，由于 GIL的存在，多线程总体的运行效率相比可能反而比单线程更低","slug":"python多线程基本原理","published":1,"updated":"2021-06-15T03:24:11.492Z","_id":"ckpapu7i7000plcxuftjv4i42","layout":"post","photos":[],"link":"","content":"<h2 id=\"多线程的含义\"><a href=\"#多线程的含义\" class=\"headerlink\" title=\"多线程的含义\"></a>多线程的含义</h2><p>说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。</p>\n<p>进程可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。</p>\n<p>而进程呢？它就是<strong>线程的集合</strong>，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。</p>\n<p>了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。</p>\n<h2 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h2><p>并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。</p>\n<p>并发，英文叫作<code>concurrency</code>。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程<code>A</code>的指令一段时间，再执行线程<code>B</code>的指令一段时间，再切回到线程<code>A</code>执行一段时间。</p>\n<p>由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。</p>\n<p>并行，英文叫作<code>parallel</code>。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。</p>\n<p>并行只能在多处理器系统中存在，如果的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。</p>\n<p>举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p>\n<h2 id=\"多线程适用场景\"><a href=\"#多线程适用场景\" class=\"headerlink\" title=\"多线程适用场景\"></a>多线程适用场景</h2><p>多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。</p>\n<p>像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于<code>IO</code>密集型任务。对于这种任务，如果启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。</p>\n<p>但并不是所有的任务都是<code>IO</code>密集型任务，还有一种任务叫作计算密集型任务，也可以称之为<code>CPU</code>密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p>\n<p>所以，如果任务不全是计算密集型任务，可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种IO密集型任务来说，使用多线程会大大提高程序整体的爬取效率。</p>\n<h2 id=\"Python实现多线程\"><a href=\"#Python实现多线程\" class=\"headerlink\" title=\"Python实现多线程\"></a>Python实现多线程</h2><p>实在<code>Python</code>中，实现多线程的模块叫作<code>threading</code>，是<code>Python</code>自带的模块。使用<code>threading</code>实现多线程的方法。</p>\n<p>###Thread直接创建子线程</p>\n<p>首先，可以使用<code>Thread</code>类来创建一个线程，创建时需要指定<code>target</code>参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过<code>Thread</code>的<code>args</code>参数来指定。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">target</span>(<span class=\"params\">second</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> id runing&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> sleep <span class=\"subst\">&#123;second&#125;</span>s&#x27;</span>)</span><br><span class=\"line\">    time.sleep(second)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> is ended&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> id runing&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">5</span>]:</span><br><span class=\"line\">    thread = threading.Thread(target=target, args=[i])</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> is ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threading MainThread <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> sleep 1s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"built_in\">id</span> runingThreading MainThread <span class=\"keyword\">is</span> ended</span><br><span class=\"line\"></span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>在这里首先声明了一个方法，叫作<code>target</code>，它接收一个参数为<code>second</code>，通过方法的实现可以发现，这个方法其实就是执行了一个<code>time.sleep</code>休眠操作，<code>second</code>参数就是休眠秒数，其前后都<code>print</code>了一些内容，其中线程的名字通过<code>threading.current_thread().name</code>来获取出来，如果是主线程的话，其值就是<code>MainThread</code>，如果是子线程的话，其值就是<code>Thread-*</code>。</p>\n<p>然后通过<code>Thead</code>类新建了两个线程，<code>target</code>参数就是刚才所定义的方法名，<code>args</code>以列表的形式传递。两次循环中，这里<code>i</code>分别就是<code>1</code>和<code>5</code>，这样两个线程就分别休眠<code>1</code>秒·和5秒，声明完成之后，调用<code>start</code>方法即可开始线程的运行。</p>\n<p>观察结果可以发现，这里一共产生了三个线程，分别是主线程<code>MainThread</code>和两个子线程<code>Thread-1</code>、<code>Thread-2</code>。另外观察到，主线程首先运行结束，紧接着<code>Thread-1</code>、<code>Thread-2</code>才接连运行结束，分别间隔了<code>1</code>秒和<code>4</code>秒。这说明主线程并没有等待子线程运行完毕才结束运行，而是直接退出了，有点不符合常理。如果想要主线程等待子线程运行完毕之后才退出，可以让每个子线程对象都调用下<code>join</code>方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threads = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">5</span>]:</span><br><span class=\"line\">    thread = threading.Thread(target=target, args=[i])</span><br><span class=\"line\">    threads.append(thread)</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    thread.join()</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threading MainThread <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> sleep 1s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>主线程必须等待子线程都运行结束，主线程才继续运行并结束。</p>\n<h2 id=\"继承Thread类创建子线程\"><a href=\"#继承Thread类创建子线程\" class=\"headerlink\" title=\"继承Thread类创建子线程\"></a>继承Thread类创建子线程</h2><p>另外，也可以通过继承<code>Thread</code>类的方式创建一个线程，该线程需要执行的方法写在类的<code>run</code>方法里面即可。上面的例子的等价改写为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span>(<span class=\"params\">threading.Thread</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, second</span>):</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self.second = second</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is runing&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threding <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> sleep <span class=\"subst\">&#123;self.second&#125;</span>s&#x27;</span>)</span><br><span class=\"line\">        time.sleep(self.second)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is ended&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is running&#x27;</span>)</span><br><span class=\"line\">threads = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">5</span>]:</span><br><span class=\"line\">    thread = MyThread(i)</span><br><span class=\"line\">    threads.append(thread)</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    thread.join()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threading MainThread <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> sleep 1s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，两种实现方式，其运行效果是相同的。</p>\n<h2 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h2><p>在线程中有一个叫作守护线程的概念，如果一个线程被设置为守护线程，那么意味着这个线程是“不重要”的，这意味着，如果主线程结束了而该守护线程还没有运行完，那么它将会被强制结束。在<code>Python</code>中可以通过<code>setDaemon</code>方法来将某个线程设置为守护线程。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threding MainThread <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">1</span> sleep 2s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>在这里通过 setDaemon方法将 t2 设置为了守护线程，这样主线程在运行完毕时，t2 线程会随着线程的结束而结束。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threding MainThread <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">1</span> sleep 2s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，没有<code>Thread-2</code>打印退出的消息，<code>Thread-2</code>随着主线程的退出而退出了。</p>\n<p>这里并没有调用<code>join</code>方法，如果让<code>t1</code>和<code>t2</code>都调用<code>join</code>方法，主线程就会仍然等待各个子线程执行完毕再退出，不论其是否是守护线程。</p>\n<h2 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h2><p>互在一个进程中的多个线程是共享资源的，比如在一个进程中，有一个全局变量<code>count</code>用来计数，声明多个线程，每个线程运行时都给<code>count</code>加<code>1</code>，代码实现如下：</p>\n<p>在这里，声明了<code>1000</code>个线程，每个线程都是现取到当前的全局变量<code>count</code>值，然后休眠一小段时间，然后对<code>count</code>赋予新的值。</p>\n<p>按照常理来说，最终的<code>count</code>值应该为<code>1000</code>。但其实不然。运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Final count: <span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>最后的结果居然只有<code>15</code>，而且多次运行或者换个环境运行结果是不同的.这是为什么呢？因为<code>count</code>这个值是共享的，每个线程都可以在执行<code>temp = count</code>这行代码时拿到当前<code>count</code>的值，但是这些线程中的一些线程可能是并发或者并行执行的，这就导致不同的线程拿到的可能是同一个<code>count</code>值，最后导致有些线程的<code>count</code>的加<code>1</code>操作并没有生效，导致最后的结果偏小。</p>\n<p>所以，如果多个线程同时对某个数据进行读取或修改，就会出现不可预料的结果。为了避免这种情况，我们需要对多个线程进行同步，要实现同步，我们可以对需要操作的数据进行<strong>加锁保护</strong>，这里就需要用到<code>threading.Lock</code>了。</p>\n<p>加锁保护是什么意思呢？就是说，某个线程在对数据进行操作前，需要先加锁，这样其他的线程发现被加锁了之后，就无法继续向下执行，会一直等待锁被释放，只有加锁的线程把锁释放了，其他的线程才能 继续加锁并对数据做修改，修改完了再释放锁。这样可以确保同一时间只有一个线程操作数据，多个线程不会再同时读取和修改同一个数据，这样最后的运行结果就是对的了。</p>\n<p>将代码修改为如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span>(<span class=\"params\">threading.Thread</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">global</span> count</span><br><span class=\"line\">        lock.acquire()  <span class=\"comment\"># 加锁</span></span><br><span class=\"line\">        temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.001</span>)</span><br><span class=\"line\">        count = temp</span><br><span class=\"line\">        lock.release() <span class=\"comment\"># 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">threads = []</span><br><span class=\"line\">lock = threading.Lock() <span class=\"comment\"># 创建一把锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000</span>):</span><br><span class=\"line\">    thread = MyThread()</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\">    threads.append(thread)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    thread.join()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Final count: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Final count: <span class=\"number\">1000</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Python多线程的问题\"><a href=\"#Python多线程的问题\" class=\"headerlink\" title=\"Python多线程的问题\"></a>Python多线程的问题</h2><p>由于<code>Python</code>中<code>GIL</code>的限制，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致<code>Python</code>多线程无法发挥多核并行的优势。</p>\n<p><code>GIL</code>全称为<code>GlobalInterpreter Lock</code>，中文翻译为全局解释器锁，其最初设计是出于数据安全而考虑的。</p>\n<p>在<code>Python</code>多线程下，每个线程的执行方式如下：</p>\n<ul>\n<li>获取<code>GIL</code>执行对应线程的代码</li>\n<li>释放<code>GIL</code>可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL看作是通行证，并且在一个 Python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。这样就会导致，即使是多核条件下，一个 Python 进程下的多个线程，同一时刻也只能执行一个线程。 不过对于爬虫这种 IO 密集型任务来说，这个问题影响并不大。而对于计算密集型任务来说，由于 GIL的存在，多线程总体的运行效率相比可能反而比单线程更低</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"多线程的含义\"><a href=\"#多线程的含义\" class=\"headerlink\" title=\"多线程的含义\"></a>多线程的含义</h2><p>说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。</p>\n<p>进程可以理解为是一个可以独立运行的程序单位，比如打开一个浏览器，这就开启了一个浏览器进程；打开一个文本编辑器，这就开启了一个文本编辑器进程。但一个进程中是可以同时处理很多事情的，比如在浏览器中，可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画，它们可以同时运行，互不干扰。为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。</p>\n<p>而进程呢？它就是<strong>线程的集合</strong>，进程就是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。</p>\n<p>了解了线程的概念，多线程就很容易理解了，多线程就是一个进程中同时执行多个线程，前面所说的浏览器的情景就是典型的多线程执行。</p>\n<h2 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h2><p>并说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。</p>\n<p>并发，英文叫作<code>concurrency</code>。它是指同一时刻只能有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。比如一个处理器，它先执行线程<code>A</code>的指令一段时间，再执行线程<code>B</code>的指令一段时间，再切回到线程<code>A</code>执行一段时间。</p>\n<p>由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但微观上只是这个处理器在连续不断地在多个线程之间切换和执行，每个线程的执行一定会占用这个处理器一个时间片段，同一时刻，其实只有一个线程在执行。</p>\n<p>并行，英文叫作<code>parallel</code>。它是指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。</p>\n<p>并行只能在多处理器系统中存在，如果的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。</p>\n<p>举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p>\n<h2 id=\"多线程适用场景\"><a href=\"#多线程适用场景\" class=\"headerlink\" title=\"多线程适用场景\"></a>多线程适用场景</h2><p>多在一个程序进程中，有一些操作是比较耗时或者需要等待的，比如等待数据库的查询结果的返回，等待网页结果的响应。如果使用单线程，处理器必须要等到这些操作完成之后才能继续往下执行其他操作，而这个线程在等待的过程中，处理器明显是可以来执行其他的操作的。如果使用多线程，处理器就可以在某个线程等待的时候，去执行其他的线程，从而从整体上提高执行效率。</p>\n<p>像上述场景，线程在执行过程中很多情况下是需要等待的。比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于<code>IO</code>密集型任务。对于这种任务，如果启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。</p>\n<p>但并不是所有的任务都是<code>IO</code>密集型任务，还有一种任务叫作计算密集型任务，也可以称之为<code>CPU</code>密集型任务。顾名思义，就是任务的运行一直需要处理器的参与。此时如果开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p>\n<p>所以，如果任务不全是计算密集型任务，可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种IO密集型任务来说，使用多线程会大大提高程序整体的爬取效率。</p>\n<h2 id=\"Python实现多线程\"><a href=\"#Python实现多线程\" class=\"headerlink\" title=\"Python实现多线程\"></a>Python实现多线程</h2><p>实在<code>Python</code>中，实现多线程的模块叫作<code>threading</code>，是<code>Python</code>自带的模块。使用<code>threading</code>实现多线程的方法。</p>\n<p>###Thread直接创建子线程</p>\n<p>首先，可以使用<code>Thread</code>类来创建一个线程，创建时需要指定<code>target</code>参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过<code>Thread</code>的<code>args</code>参数来指定。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">target</span>(<span class=\"params\">second</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> id runing&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> sleep <span class=\"subst\">&#123;second&#125;</span>s&#x27;</span>)</span><br><span class=\"line\">    time.sleep(second)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> is ended&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> id runing&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">5</span>]:</span><br><span class=\"line\">    thread = threading.Thread(target=target, args=[i])</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.currentThread().name&#125;</span> is ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threading MainThread <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> sleep 1s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"built_in\">id</span> runingThreading MainThread <span class=\"keyword\">is</span> ended</span><br><span class=\"line\"></span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>在这里首先声明了一个方法，叫作<code>target</code>，它接收一个参数为<code>second</code>，通过方法的实现可以发现，这个方法其实就是执行了一个<code>time.sleep</code>休眠操作，<code>second</code>参数就是休眠秒数，其前后都<code>print</code>了一些内容，其中线程的名字通过<code>threading.current_thread().name</code>来获取出来，如果是主线程的话，其值就是<code>MainThread</code>，如果是子线程的话，其值就是<code>Thread-*</code>。</p>\n<p>然后通过<code>Thead</code>类新建了两个线程，<code>target</code>参数就是刚才所定义的方法名，<code>args</code>以列表的形式传递。两次循环中，这里<code>i</code>分别就是<code>1</code>和<code>5</code>，这样两个线程就分别休眠<code>1</code>秒·和5秒，声明完成之后，调用<code>start</code>方法即可开始线程的运行。</p>\n<p>观察结果可以发现，这里一共产生了三个线程，分别是主线程<code>MainThread</code>和两个子线程<code>Thread-1</code>、<code>Thread-2</code>。另外观察到，主线程首先运行结束，紧接着<code>Thread-1</code>、<code>Thread-2</code>才接连运行结束，分别间隔了<code>1</code>秒和<code>4</code>秒。这说明主线程并没有等待子线程运行完毕才结束运行，而是直接退出了，有点不符合常理。如果想要主线程等待子线程运行完毕之后才退出，可以让每个子线程对象都调用下<code>join</code>方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threads = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">5</span>]:</span><br><span class=\"line\">    thread = threading.Thread(target=target, args=[i])</span><br><span class=\"line\">    threads.append(thread)</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    thread.join()</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threading MainThread <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> sleep 1s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>主线程必须等待子线程都运行结束，主线程才继续运行并结束。</p>\n<h2 id=\"继承Thread类创建子线程\"><a href=\"#继承Thread类创建子线程\" class=\"headerlink\" title=\"继承Thread类创建子线程\"></a>继承Thread类创建子线程</h2><p>另外，也可以通过继承<code>Thread</code>类的方式创建一个线程，该线程需要执行的方法写在类的<code>run</code>方法里面即可。上面的例子的等价改写为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span>(<span class=\"params\">threading.Thread</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, second</span>):</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self.second = second</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is runing&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threding <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> sleep <span class=\"subst\">&#123;self.second&#125;</span>s&#x27;</span>)</span><br><span class=\"line\">        time.sleep(self.second)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is ended&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is running&#x27;</span>)</span><br><span class=\"line\">threads = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">1</span>, <span class=\"number\">5</span>]:</span><br><span class=\"line\">    thread = MyThread(i)</span><br><span class=\"line\">    threads.append(thread)</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    thread.join()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Threading <span class=\"subst\">&#123;threading.current_thread().name&#125;</span> is ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threading MainThread <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> sleep 1s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"built_in\">id</span> runing</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，两种实现方式，其运行效果是相同的。</p>\n<h2 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h2><p>在线程中有一个叫作守护线程的概念，如果一个线程被设置为守护线程，那么意味着这个线程是“不重要”的，这意味着，如果主线程结束了而该守护线程还没有运行完，那么它将会被强制结束。在<code>Python</code>中可以通过<code>setDaemon</code>方法来将某个线程设置为守护线程。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threding MainThread <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">1</span> sleep 2s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>在这里通过 setDaemon方法将 t2 设置为了守护线程，这样主线程在运行完毕时，t2 线程会随着线程的结束而结束。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Threding MainThread <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">1</span> sleep 2s</span><br><span class=\"line\">Threading Thread-<span class=\"number\">2</span> <span class=\"keyword\">is</span> running</span><br><span class=\"line\">Threding Thread-<span class=\"number\">2</span> sleep 5s</span><br><span class=\"line\">Threading MainThread <span class=\"keyword\">is</span> ended</span><br><span class=\"line\">Threading Thread-<span class=\"number\">1</span> <span class=\"keyword\">is</span> ended</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，没有<code>Thread-2</code>打印退出的消息，<code>Thread-2</code>随着主线程的退出而退出了。</p>\n<p>这里并没有调用<code>join</code>方法，如果让<code>t1</code>和<code>t2</code>都调用<code>join</code>方法，主线程就会仍然等待各个子线程执行完毕再退出，不论其是否是守护线程。</p>\n<h2 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h2><p>互在一个进程中的多个线程是共享资源的，比如在一个进程中，有一个全局变量<code>count</code>用来计数，声明多个线程，每个线程运行时都给<code>count</code>加<code>1</code>，代码实现如下：</p>\n<p>在这里，声明了<code>1000</code>个线程，每个线程都是现取到当前的全局变量<code>count</code>值，然后休眠一小段时间，然后对<code>count</code>赋予新的值。</p>\n<p>按照常理来说，最终的<code>count</code>值应该为<code>1000</code>。但其实不然。运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Final count: <span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>最后的结果居然只有<code>15</code>，而且多次运行或者换个环境运行结果是不同的.这是为什么呢？因为<code>count</code>这个值是共享的，每个线程都可以在执行<code>temp = count</code>这行代码时拿到当前<code>count</code>的值，但是这些线程中的一些线程可能是并发或者并行执行的，这就导致不同的线程拿到的可能是同一个<code>count</code>值，最后导致有些线程的<code>count</code>的加<code>1</code>操作并没有生效，导致最后的结果偏小。</p>\n<p>所以，如果多个线程同时对某个数据进行读取或修改，就会出现不可预料的结果。为了避免这种情况，我们需要对多个线程进行同步，要实现同步，我们可以对需要操作的数据进行<strong>加锁保护</strong>，这里就需要用到<code>threading.Lock</code>了。</p>\n<p>加锁保护是什么意思呢？就是说，某个线程在对数据进行操作前，需要先加锁，这样其他的线程发现被加锁了之后，就无法继续向下执行，会一直等待锁被释放，只有加锁的线程把锁释放了，其他的线程才能 继续加锁并对数据做修改，修改完了再释放锁。这样可以确保同一时间只有一个线程操作数据，多个线程不会再同时读取和修改同一个数据，这样最后的运行结果就是对的了。</p>\n<p>将代码修改为如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\">count = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span>(<span class=\"params\">threading.Thread</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">global</span> count</span><br><span class=\"line\">        lock.acquire()  <span class=\"comment\"># 加锁</span></span><br><span class=\"line\">        temp = count + <span class=\"number\">1</span></span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.001</span>)</span><br><span class=\"line\">        count = temp</span><br><span class=\"line\">        lock.release() <span class=\"comment\"># 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">threads = []</span><br><span class=\"line\">lock = threading.Lock() <span class=\"comment\"># 创建一把锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000</span>):</span><br><span class=\"line\">    thread = MyThread()</span><br><span class=\"line\">    thread.start()</span><br><span class=\"line\">    threads.append(thread)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> threads:</span><br><span class=\"line\">    thread.join()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Final count: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Final count: <span class=\"number\">1000</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Python多线程的问题\"><a href=\"#Python多线程的问题\" class=\"headerlink\" title=\"Python多线程的问题\"></a>Python多线程的问题</h2><p>由于<code>Python</code>中<code>GIL</code>的限制，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致<code>Python</code>多线程无法发挥多核并行的优势。</p>\n<p><code>GIL</code>全称为<code>GlobalInterpreter Lock</code>，中文翻译为全局解释器锁，其最初设计是出于数据安全而考虑的。</p>\n<p>在<code>Python</code>多线程下，每个线程的执行方式如下：</p>\n<ul>\n<li>获取<code>GIL</code>执行对应线程的代码</li>\n<li>释放<code>GIL</code>可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL看作是通行证，并且在一个 Python进程中，GIL只有一个。拿不到通行证的线程，就不允许执行。这样就会导致，即使是多核条件下，一个 Python 进程下的多个线程，同一时刻也只能执行一个线程。 不过对于爬虫这种 IO 密集型任务来说，这个问题影响并不大。而对于计算密集型任务来说，由于 GIL的存在，多线程总体的运行效率相比可能反而比单线程更低</li>\n</ul>\n"},{"title":"python的内置类型","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-28T15:52:16.000Z","pic":null,"_content":"\n## 字符串与字节\n\n`Python3`中只有一种能够保存文本信息的数据类型，就是`str`(`string`，字符串)。它是不可变的序列，保存的`Unicode`码位(`code point`)。\n\n字符串可以保存的数据类型有非常明确的限制，就是`Unicode`文本。\n\n`bytes`以及可变的`bytearray`与`str`不同，只能用字节作为序列值，即`0<=x<256`范围内的整数。\n\n```python\n>>> bytes([102,111,111])\nb'foo'\n```\n\n对于`bytes`和`bytearray`，在转换为另一种序列类型（例如`list`或`tuple`）时可以显示出其本来面目：\n\n```python\n>>> list(b'foo bar')\n[102, 111, 111, 32, 98, 97, 114]\n>>> tuple(b'foo bar')\n(102, 111, 111, 32, 98, 97, 114)\n```\n\n从`Python3.0`开始，所有没有前缀的字符串都是`Unicode`。因此，所有用单引号（'）、双引号（\"）或成组的3个引号（单引号或双引号）包围且没有前缀的值都表示`str`数据类型：\n\n```python\n>>> type(\"some string\")\n<class 'str'>\n```\n\n字节也被单引号、双引号或三引号包围，但必须有一个`b`或`B`前缀：\n\n```python\n>>> type(b\"some bytes\")\n<class 'bytes'>\n```\n\n`Python`字符串是不可变的。字节序列也是如此。`bytearray`是`bytes`的可变版本，不存在这样的问题。字节数组可以通过元素赋值来进行原处修改（无需创建新对象），其大小也可以像列表一样动态地变化（利用`append`、`pop`、`inseer`等方法）。\n\n### 字符串拼接\n\n用`str.join()`方法。它接受可迭代的字符串作为参数，返回合并后的字符串。\n\n```python\n>>> ','.join(['some','one','like','you','forever'])\n'some,one,like,you,forever'\n```\n\n因为`join()`方法速度更快（对于大型列表来说更是如此），并不意味着在所有需要拼接两个字符串的情况下都应该使用这一方法。虽然这是一种广为认可的做法，但并不会提高代码的可读性。可读性是很重要的！在某些情况下，`join()`的性能可能还不如利用加法的普通拼接。\n\n## 集合类型\n\n### 列表和元组\n\n列表是动态的，其大小可以改变；而元组是不可变的，一旦创建就不能修改。\n\n`tuple是`不可变的（immutable），因此也是可哈希的（hashable）\n\n从细节上来看，`Python`中的列表是由对其他对象的引用组成的的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要改变大小（重新分配）。幸运的是，`Python`在创建这些数组时采用了指数过分配（exponential over-allocation），所以并不是每次操作都需要改变数组大小。这也是添加或取出元素的平摊复杂度较低的原因。不幸的是，在普通链表中“代价很小”的其他一些操作在`Python`中的计算复杂度却相对较高：\n\n- 利用`list.insert`方法在任意位置插入一个元素——复杂度为`O(n)`。\n- 利用`list.delete`或`del`删除一个元素——复杂度为`O(n)`。\n\n![](Screenshot_1.webp)\n\n#### 列表推导\n\n```python\n>>> evens = []\n>>> for i in range(10):\n...     if i%2 == 0:\n...             evens.append(i)\n...\n>>> evens\n[0, 2, 4, 6, 8]\n```\n\n这种写法可能适用于`C`语言，但在`Python`中的实际运行速度很慢，原因如下。\n\n- 解释器在每次循环中都需要判断序列中的哪一部分需要修改。\n- 需要用一个计数器来跟踪需要处理的元素。\n- 由于`append()`是一个列表方法，所以每次遍历时还需要额外执行一个查询函数。\n\n列表推导正是解决这个问题的正确方法。它使用编排好的功能对上述语法的一部分做了自动化处理：\n\n```python\n>>> [i for i in range(10) if i % 2 == 0]\n[0, 2, 4, 6, 8]\n```\n\n这种写法除了更加高效之外，也更加简短，涉及的语法元素也更少。在大型程序中，这意味着更少的错误，代码也更容易阅读和理解。\n\n#### 其他习语\n\n`Python`习语的另一个典型例子是使用`enumerate`（枚举）。在循环中使用序列时，这个内置函数可以很方便地获取其索引。以下面这段代码为例：\n\n```python\n>>> for element in ['one','two','three']:\n...     print(i, element)\n...     i += 1\n...\n0 one\n1 two\n2 three\n```\n\n它可以替换为下面这段更短的代码：\n\n```python\n>>> for i, element in enumerate(['one','two','three']):\n...     print(i, element)\n...\n0 one\n1 two\n2 three\n```\n\n#### 序列解包（sequence unpacking）\n\n这种方法并不限于列表和元组，而是适用于任意序列类型（甚至包括字符串和字节序列）。只要赋值运算符左边的变量数目与序列中的元素数目相等，你都可以用这种方法将元素序列解包到另一组变量中：\n\n```python\n>>> first, second, third = \"holy\", \"chan\", 100\n>>> first\n'holy'\n>>> second\n'chan'\n>>> third\n100\n```\n\n解包还可以利用带星号的表达式获取单个变量中的多个元素，只要它的解释没有歧义即可。还可以对嵌套序列进行解包。特别是在遍历由序列构成的复杂数据结构时，这种方法非常实用。下面是一些更复杂的解包示例\n\n```python\n>>> # 带星号的表达式可以获取序列的剩余部分\n>>> first, second, *rest = 0, 1, 2, 3\n>>> first\n0\n>>> second\n1\n>>> rest\n[2, 3]\n\n>>> # 带星号的表达式可以获取序列的中间部分\n>>> first, *inner, last = 0, 1, 2, 3\n>>> first\n0\n>>> inner\n[1, 2]\n>>> last\n3\n\n>>> # 嵌套解包\n>>> (a,b), (c,d) = (1,2), (3,4)\n>>> a, b, c, d\n(1, 2, 3, 4)\n```\n\n### 字典\n\n字典是`Python`中最通用的数据结构之一。`dict`可以将一组唯一键映射到对应的值，如下所示：\n\n```python\n{\n  1: 'one',\n  2: 'two',\n  3: 'three',\n}\n```\n\n可以用和前面列表推导类似的推导来创建一个新的字典。这里有一个非常简单的例子如下所示：\n\n```python\n>>> squares = {number: number ** 2 for number in range(10)}\n>>> squares\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n```\n\n在许多情况下，字典推导要更加高效、更加简短、更加整洁。对于更复杂的代码而言，需要用到许多`if`语句或函数调用来创建一个字典，这时最好使用简单的`for`循环，尤其是它还提高了可读性。\n\n对于`python3`，字典的`keys()`、`values()`和`items()`3个方法的返回值类型不再是列表。此外，与之对应的`iterkeys()`、`itervalues()`和`iteritems()`本来返回的是迭代器，而`Python3`中并没有这3个方法。现在`keys()`、`values()`和`items()`返回的是视图对象（`viewobjects`）。\n\n- keys()：返回dict_keys对象，可以查看字典的所有键。\n- values()：返回dict_values对象，可以查看字典的所有值。\n- items()：返回dict_items对象，可以查看字典所有的(key, value)二元元组。\n\n视图对象可以动态查看字典的内容，因此每次字典发生变化时，视图都会相应改变，见下面这个例子：\n\n```python\n>>> words = {'foo1':'bar', 'fizz':'bazz'}\n>>> items = words.items()\n>>> words['spam'] = 'eggs'\n>>> items\ndict_items([('foo1', 'bar'), ('fizz', 'bazz'), ('spam', 'eggs')])\n```\n\n视图对象既有旧的`keys()`、`values()`和`items()`方法返回的列表的特性，也有旧的`iterkeys()`、`itervalues()`和`iteritems()`方法返回的迭代器的特性。视图无需冗余地将所有值都保存在内存里（像列表那样），但你仍然可以获取其长度（使用`len`），也可以测试元素是否包含其中（使用`in`子句）。当然，视图是可迭代的。最后一件重要的事情是，在`keys()`和`values()`方法返回的视图中，键和值的顺序是完全对应的。\n\n### 集合\n\n集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构是很有用的。它与数学上的集合概念非常类似。`Python`的内置集合类型有两种。\n\n- set()：一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。\n- frozenset()：一种不可变的、可哈希的、无序的集合，其元素是唯一的、不可变的（可哈希的）对象。\n\n由于`frozenset()`具有不变性，它可以用作字典的键，也可以作为其他`set()`和`frozenset()`的元素。在一个`set()`或`frozenset()`中不能包含另一个普通的可变`set()`，因为这会引发`TypeError`：\n\n```python\n>>> set([set([1,2,3]),set([2,3,4])])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'set'\n```\n\n下面这种集合初始化的方法是完全正确的：\n\n```python\n>>> set([frozenset([1,2,3]),frozenset([2,3,4])])\n{frozenset({1, 2, 3}), frozenset({2, 3, 4})}\n```\n\n创建可变集合方法有以下3种，如下所示。\n\n- 调用set()，选择性地接受可迭代对象作为初始化参数，例如set([0, 1, 2])。\n- 使用集合推导，例如{element for element in range(3)}。\n- 使用集合字面值，例如{1, 2, 3}。\n\n使用集合的字面值和推导要格外小心，因为它们在形式上与字典的字面值和推导非常相似。此外，空的集合对象是没有字面值的。空的花括号{}表示的是空的字典字面值。\n","source":"_posts/python的内置类型.md","raw":"---\ntitle: python的内置类型\ntags:\n  - python\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-28 23:52:16\ncategories: Python\npic:\n---\n\n## 字符串与字节\n\n`Python3`中只有一种能够保存文本信息的数据类型，就是`str`(`string`，字符串)。它是不可变的序列，保存的`Unicode`码位(`code point`)。\n\n字符串可以保存的数据类型有非常明确的限制，就是`Unicode`文本。\n\n`bytes`以及可变的`bytearray`与`str`不同，只能用字节作为序列值，即`0<=x<256`范围内的整数。\n\n```python\n>>> bytes([102,111,111])\nb'foo'\n```\n\n对于`bytes`和`bytearray`，在转换为另一种序列类型（例如`list`或`tuple`）时可以显示出其本来面目：\n\n```python\n>>> list(b'foo bar')\n[102, 111, 111, 32, 98, 97, 114]\n>>> tuple(b'foo bar')\n(102, 111, 111, 32, 98, 97, 114)\n```\n\n从`Python3.0`开始，所有没有前缀的字符串都是`Unicode`。因此，所有用单引号（'）、双引号（\"）或成组的3个引号（单引号或双引号）包围且没有前缀的值都表示`str`数据类型：\n\n```python\n>>> type(\"some string\")\n<class 'str'>\n```\n\n字节也被单引号、双引号或三引号包围，但必须有一个`b`或`B`前缀：\n\n```python\n>>> type(b\"some bytes\")\n<class 'bytes'>\n```\n\n`Python`字符串是不可变的。字节序列也是如此。`bytearray`是`bytes`的可变版本，不存在这样的问题。字节数组可以通过元素赋值来进行原处修改（无需创建新对象），其大小也可以像列表一样动态地变化（利用`append`、`pop`、`inseer`等方法）。\n\n### 字符串拼接\n\n用`str.join()`方法。它接受可迭代的字符串作为参数，返回合并后的字符串。\n\n```python\n>>> ','.join(['some','one','like','you','forever'])\n'some,one,like,you,forever'\n```\n\n因为`join()`方法速度更快（对于大型列表来说更是如此），并不意味着在所有需要拼接两个字符串的情况下都应该使用这一方法。虽然这是一种广为认可的做法，但并不会提高代码的可读性。可读性是很重要的！在某些情况下，`join()`的性能可能还不如利用加法的普通拼接。\n\n## 集合类型\n\n### 列表和元组\n\n列表是动态的，其大小可以改变；而元组是不可变的，一旦创建就不能修改。\n\n`tuple是`不可变的（immutable），因此也是可哈希的（hashable）\n\n从细节上来看，`Python`中的列表是由对其他对象的引用组成的的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要改变大小（重新分配）。幸运的是，`Python`在创建这些数组时采用了指数过分配（exponential over-allocation），所以并不是每次操作都需要改变数组大小。这也是添加或取出元素的平摊复杂度较低的原因。不幸的是，在普通链表中“代价很小”的其他一些操作在`Python`中的计算复杂度却相对较高：\n\n- 利用`list.insert`方法在任意位置插入一个元素——复杂度为`O(n)`。\n- 利用`list.delete`或`del`删除一个元素——复杂度为`O(n)`。\n\n![](Screenshot_1.webp)\n\n#### 列表推导\n\n```python\n>>> evens = []\n>>> for i in range(10):\n...     if i%2 == 0:\n...             evens.append(i)\n...\n>>> evens\n[0, 2, 4, 6, 8]\n```\n\n这种写法可能适用于`C`语言，但在`Python`中的实际运行速度很慢，原因如下。\n\n- 解释器在每次循环中都需要判断序列中的哪一部分需要修改。\n- 需要用一个计数器来跟踪需要处理的元素。\n- 由于`append()`是一个列表方法，所以每次遍历时还需要额外执行一个查询函数。\n\n列表推导正是解决这个问题的正确方法。它使用编排好的功能对上述语法的一部分做了自动化处理：\n\n```python\n>>> [i for i in range(10) if i % 2 == 0]\n[0, 2, 4, 6, 8]\n```\n\n这种写法除了更加高效之外，也更加简短，涉及的语法元素也更少。在大型程序中，这意味着更少的错误，代码也更容易阅读和理解。\n\n#### 其他习语\n\n`Python`习语的另一个典型例子是使用`enumerate`（枚举）。在循环中使用序列时，这个内置函数可以很方便地获取其索引。以下面这段代码为例：\n\n```python\n>>> for element in ['one','two','three']:\n...     print(i, element)\n...     i += 1\n...\n0 one\n1 two\n2 three\n```\n\n它可以替换为下面这段更短的代码：\n\n```python\n>>> for i, element in enumerate(['one','two','three']):\n...     print(i, element)\n...\n0 one\n1 two\n2 three\n```\n\n#### 序列解包（sequence unpacking）\n\n这种方法并不限于列表和元组，而是适用于任意序列类型（甚至包括字符串和字节序列）。只要赋值运算符左边的变量数目与序列中的元素数目相等，你都可以用这种方法将元素序列解包到另一组变量中：\n\n```python\n>>> first, second, third = \"holy\", \"chan\", 100\n>>> first\n'holy'\n>>> second\n'chan'\n>>> third\n100\n```\n\n解包还可以利用带星号的表达式获取单个变量中的多个元素，只要它的解释没有歧义即可。还可以对嵌套序列进行解包。特别是在遍历由序列构成的复杂数据结构时，这种方法非常实用。下面是一些更复杂的解包示例\n\n```python\n>>> # 带星号的表达式可以获取序列的剩余部分\n>>> first, second, *rest = 0, 1, 2, 3\n>>> first\n0\n>>> second\n1\n>>> rest\n[2, 3]\n\n>>> # 带星号的表达式可以获取序列的中间部分\n>>> first, *inner, last = 0, 1, 2, 3\n>>> first\n0\n>>> inner\n[1, 2]\n>>> last\n3\n\n>>> # 嵌套解包\n>>> (a,b), (c,d) = (1,2), (3,4)\n>>> a, b, c, d\n(1, 2, 3, 4)\n```\n\n### 字典\n\n字典是`Python`中最通用的数据结构之一。`dict`可以将一组唯一键映射到对应的值，如下所示：\n\n```python\n{\n  1: 'one',\n  2: 'two',\n  3: 'three',\n}\n```\n\n可以用和前面列表推导类似的推导来创建一个新的字典。这里有一个非常简单的例子如下所示：\n\n```python\n>>> squares = {number: number ** 2 for number in range(10)}\n>>> squares\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n```\n\n在许多情况下，字典推导要更加高效、更加简短、更加整洁。对于更复杂的代码而言，需要用到许多`if`语句或函数调用来创建一个字典，这时最好使用简单的`for`循环，尤其是它还提高了可读性。\n\n对于`python3`，字典的`keys()`、`values()`和`items()`3个方法的返回值类型不再是列表。此外，与之对应的`iterkeys()`、`itervalues()`和`iteritems()`本来返回的是迭代器，而`Python3`中并没有这3个方法。现在`keys()`、`values()`和`items()`返回的是视图对象（`viewobjects`）。\n\n- keys()：返回dict_keys对象，可以查看字典的所有键。\n- values()：返回dict_values对象，可以查看字典的所有值。\n- items()：返回dict_items对象，可以查看字典所有的(key, value)二元元组。\n\n视图对象可以动态查看字典的内容，因此每次字典发生变化时，视图都会相应改变，见下面这个例子：\n\n```python\n>>> words = {'foo1':'bar', 'fizz':'bazz'}\n>>> items = words.items()\n>>> words['spam'] = 'eggs'\n>>> items\ndict_items([('foo1', 'bar'), ('fizz', 'bazz'), ('spam', 'eggs')])\n```\n\n视图对象既有旧的`keys()`、`values()`和`items()`方法返回的列表的特性，也有旧的`iterkeys()`、`itervalues()`和`iteritems()`方法返回的迭代器的特性。视图无需冗余地将所有值都保存在内存里（像列表那样），但你仍然可以获取其长度（使用`len`），也可以测试元素是否包含其中（使用`in`子句）。当然，视图是可迭代的。最后一件重要的事情是，在`keys()`和`values()`方法返回的视图中，键和值的顺序是完全对应的。\n\n### 集合\n\n集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构是很有用的。它与数学上的集合概念非常类似。`Python`的内置集合类型有两种。\n\n- set()：一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。\n- frozenset()：一种不可变的、可哈希的、无序的集合，其元素是唯一的、不可变的（可哈希的）对象。\n\n由于`frozenset()`具有不变性，它可以用作字典的键，也可以作为其他`set()`和`frozenset()`的元素。在一个`set()`或`frozenset()`中不能包含另一个普通的可变`set()`，因为这会引发`TypeError`：\n\n```python\n>>> set([set([1,2,3]),set([2,3,4])])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'set'\n```\n\n下面这种集合初始化的方法是完全正确的：\n\n```python\n>>> set([frozenset([1,2,3]),frozenset([2,3,4])])\n{frozenset({1, 2, 3}), frozenset({2, 3, 4})}\n```\n\n创建可变集合方法有以下3种，如下所示。\n\n- 调用set()，选择性地接受可迭代对象作为初始化参数，例如set([0, 1, 2])。\n- 使用集合推导，例如{element for element in range(3)}。\n- 使用集合字面值，例如{1, 2, 3}。\n\n使用集合的字面值和推导要格外小心，因为它们在形式上与字典的字面值和推导非常相似。此外，空的集合对象是没有字面值的。空的花括号{}表示的是空的字典字面值。\n","slug":"python的内置类型","published":1,"updated":"2021-06-15T03:24:11.493Z","_id":"ckpapu7ib000tlcxu6xpk0zpe","layout":"post","photos":[],"link":"","content":"<h2 id=\"字符串与字节\"><a href=\"#字符串与字节\" class=\"headerlink\" title=\"字符串与字节\"></a>字符串与字节</h2><p><code>Python3</code>中只有一种能够保存文本信息的数据类型，就是<code>str</code>(<code>string</code>，字符串)。它是不可变的序列，保存的<code>Unicode</code>码位(<code>code point</code>)。</p>\n<p>字符串可以保存的数据类型有非常明确的限制，就是<code>Unicode</code>文本。</p>\n<p><code>bytes</code>以及可变的<code>bytearray</code>与<code>str</code>不同，只能用字节作为序列值，即<code>0&lt;=x&lt;256</code>范围内的整数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">bytes</span>([<span class=\"number\">102</span>,<span class=\"number\">111</span>,<span class=\"number\">111</span>])</span><br><span class=\"line\"><span class=\"string\">b&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于<code>bytes</code>和<code>bytearray</code>，在转换为另一种序列类型（例如<code>list</code>或<code>tuple</code>）时可以显示出其本来面目：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(<span class=\"string\">b&#x27;foo bar&#x27;</span>)</span><br><span class=\"line\">[<span class=\"number\">102</span>, <span class=\"number\">111</span>, <span class=\"number\">111</span>, <span class=\"number\">32</span>, <span class=\"number\">98</span>, <span class=\"number\">97</span>, <span class=\"number\">114</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">tuple</span>(<span class=\"string\">b&#x27;foo bar&#x27;</span>)</span><br><span class=\"line\">(<span class=\"number\">102</span>, <span class=\"number\">111</span>, <span class=\"number\">111</span>, <span class=\"number\">32</span>, <span class=\"number\">98</span>, <span class=\"number\">97</span>, <span class=\"number\">114</span>)</span><br></pre></td></tr></table></figure>\n\n<p>从<code>Python3.0</code>开始，所有没有前缀的字符串都是<code>Unicode</code>。因此，所有用单引号（’）、双引号（”）或成组的3个引号（单引号或双引号）包围且没有前缀的值都表示<code>str</code>数据类型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(<span class=\"string\">&quot;some string&quot;</span>)</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>字节也被单引号、双引号或三引号包围，但必须有一个<code>b</code>或<code>B</code>前缀：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(<span class=\"string\">b&quot;some bytes&quot;</span>)</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">bytes</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Python</code>字符串是不可变的。字节序列也是如此。<code>bytearray</code>是<code>bytes</code>的可变版本，不存在这样的问题。字节数组可以通过元素赋值来进行原处修改（无需创建新对象），其大小也可以像列表一样动态地变化（利用<code>append</code>、<code>pop</code>、<code>inseer</code>等方法）。</p>\n<h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><p>用<code>str.join()</code>方法。它接受可迭代的字符串作为参数，返回合并后的字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&#x27;,&#x27;</span>.join([<span class=\"string\">&#x27;some&#x27;</span>,<span class=\"string\">&#x27;one&#x27;</span>,<span class=\"string\">&#x27;like&#x27;</span>,<span class=\"string\">&#x27;you&#x27;</span>,<span class=\"string\">&#x27;forever&#x27;</span>])</span><br><span class=\"line\"><span class=\"string\">&#x27;some,one,like,you,forever&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为<code>join()</code>方法速度更快（对于大型列表来说更是如此），并不意味着在所有需要拼接两个字符串的情况下都应该使用这一方法。虽然这是一种广为认可的做法，但并不会提高代码的可读性。可读性是很重要的！在某些情况下，<code>join()</code>的性能可能还不如利用加法的普通拼接。</p>\n<h2 id=\"集合类型\"><a href=\"#集合类型\" class=\"headerlink\" title=\"集合类型\"></a>集合类型</h2><h3 id=\"列表和元组\"><a href=\"#列表和元组\" class=\"headerlink\" title=\"列表和元组\"></a>列表和元组</h3><p>列表是动态的，其大小可以改变；而元组是不可变的，一旦创建就不能修改。</p>\n<p><code>tuple是</code>不可变的（immutable），因此也是可哈希的（hashable）</p>\n<p>从细节上来看，<code>Python</code>中的列表是由对其他对象的引用组成的的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要改变大小（重新分配）。幸运的是，<code>Python</code>在创建这些数组时采用了指数过分配（exponential over-allocation），所以并不是每次操作都需要改变数组大小。这也是添加或取出元素的平摊复杂度较低的原因。不幸的是，在普通链表中“代价很小”的其他一些操作在<code>Python</code>中的计算复杂度却相对较高：</p>\n<ul>\n<li>利用<code>list.insert</code>方法在任意位置插入一个元素——复杂度为<code>O(n)</code>。</li>\n<li>利用<code>list.delete</code>或<code>del</code>删除一个元素——复杂度为<code>O(n)</code>。</li>\n</ul>\n<p><img src=\"Screenshot_1.webp\"></p>\n<h4 id=\"列表推导\"><a href=\"#列表推导\" class=\"headerlink\" title=\"列表推导\"></a>列表推导</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>evens = []</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>            evens.append(i)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>evens</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这种写法可能适用于<code>C</code>语言，但在<code>Python</code>中的实际运行速度很慢，原因如下。</p>\n<ul>\n<li>解释器在每次循环中都需要判断序列中的哪一部分需要修改。</li>\n<li>需要用一个计数器来跟踪需要处理的元素。</li>\n<li>由于<code>append()</code>是一个列表方法，所以每次遍历时还需要额外执行一个查询函数。</li>\n</ul>\n<p>列表推导正是解决这个问题的正确方法。它使用编排好的功能对上述语法的一部分做了自动化处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>) <span class=\"keyword\">if</span> i % <span class=\"number\">2</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这种写法除了更加高效之外，也更加简短，涉及的语法元素也更少。在大型程序中，这意味着更少的错误，代码也更容易阅读和理解。</p>\n<h4 id=\"其他习语\"><a href=\"#其他习语\" class=\"headerlink\" title=\"其他习语\"></a>其他习语</h4><p><code>Python</code>习语的另一个典型例子是使用<code>enumerate</code>（枚举）。在循环中使用序列时，这个内置函数可以很方便地获取其索引。以下面这段代码为例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;one&#x27;</span>,<span class=\"string\">&#x27;two&#x27;</span>,<span class=\"string\">&#x27;three&#x27;</span>]:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(i, element)</span><br><span class=\"line\"><span class=\"meta\">... </span>    i += <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span> one</span><br><span class=\"line\"><span class=\"number\">1</span> two</span><br><span class=\"line\"><span class=\"number\">2</span> three</span><br></pre></td></tr></table></figure>\n\n<p>它可以替换为下面这段更短的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i, element <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>([<span class=\"string\">&#x27;one&#x27;</span>,<span class=\"string\">&#x27;two&#x27;</span>,<span class=\"string\">&#x27;three&#x27;</span>]):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(i, element)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span> one</span><br><span class=\"line\"><span class=\"number\">1</span> two</span><br><span class=\"line\"><span class=\"number\">2</span> three</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"序列解包（sequence-unpacking）\"><a href=\"#序列解包（sequence-unpacking）\" class=\"headerlink\" title=\"序列解包（sequence unpacking）\"></a>序列解包（sequence unpacking）</h4><p>这种方法并不限于列表和元组，而是适用于任意序列类型（甚至包括字符串和字节序列）。只要赋值运算符左边的变量数目与序列中的元素数目相等，你都可以用这种方法将元素序列解包到另一组变量中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first, second, third = <span class=\"string\">&quot;holy&quot;</span>, <span class=\"string\">&quot;chan&quot;</span>, <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first</span><br><span class=\"line\"><span class=\"string\">&#x27;holy&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>second</span><br><span class=\"line\"><span class=\"string\">&#x27;chan&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>third</span><br><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<p>解包还可以利用带星号的表达式获取单个变量中的多个元素，只要它的解释没有歧义即可。还可以对嵌套序列进行解包。特别是在遍历由序列构成的复杂数据结构时，这种方法非常实用。下面是一些更复杂的解包示例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 带星号的表达式可以获取序列的剩余部分</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first, second, *rest = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>second</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>rest</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 带星号的表达式可以获取序列的中间部分</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first, *inner, last = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>inner</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>last</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 嵌套解包</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(a,b), (c,d) = (<span class=\"number\">1</span>,<span class=\"number\">2</span>), (<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c, d</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>字典是<code>Python</code>中最通用的数据结构之一。<code>dict</code>可以将一组唯一键映射到对应的值，如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&#x27;one&#x27;</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">&#x27;two&#x27;</span>,</span><br><span class=\"line\">  <span class=\"number\">3</span>: <span class=\"string\">&#x27;three&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以用和前面列表推导类似的推导来创建一个新的字典。这里有一个非常简单的例子如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>squares = &#123;number: number ** <span class=\"number\">2</span> <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>)&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>squares</span><br><span class=\"line\">&#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>, <span class=\"number\">1</span>: <span class=\"number\">1</span>, <span class=\"number\">2</span>: <span class=\"number\">4</span>, <span class=\"number\">3</span>: <span class=\"number\">9</span>, <span class=\"number\">4</span>: <span class=\"number\">16</span>, <span class=\"number\">5</span>: <span class=\"number\">25</span>, <span class=\"number\">6</span>: <span class=\"number\">36</span>, <span class=\"number\">7</span>: <span class=\"number\">49</span>, <span class=\"number\">8</span>: <span class=\"number\">64</span>, <span class=\"number\">9</span>: <span class=\"number\">81</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在许多情况下，字典推导要更加高效、更加简短、更加整洁。对于更复杂的代码而言，需要用到许多<code>if</code>语句或函数调用来创建一个字典，这时最好使用简单的<code>for</code>循环，尤其是它还提高了可读性。</p>\n<p>对于<code>python3</code>，字典的<code>keys()</code>、<code>values()</code>和<code>items()</code>3个方法的返回值类型不再是列表。此外，与之对应的<code>iterkeys()</code>、<code>itervalues()</code>和<code>iteritems()</code>本来返回的是迭代器，而<code>Python3</code>中并没有这3个方法。现在<code>keys()</code>、<code>values()</code>和<code>items()</code>返回的是视图对象（<code>viewobjects</code>）。</p>\n<ul>\n<li>keys()：返回dict_keys对象，可以查看字典的所有键。</li>\n<li>values()：返回dict_values对象，可以查看字典的所有值。</li>\n<li>items()：返回dict_items对象，可以查看字典所有的(key, value)二元元组。</li>\n</ul>\n<p>视图对象可以动态查看字典的内容，因此每次字典发生变化时，视图都会相应改变，见下面这个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>words = &#123;<span class=\"string\">&#x27;foo1&#x27;</span>:<span class=\"string\">&#x27;bar&#x27;</span>, <span class=\"string\">&#x27;fizz&#x27;</span>:<span class=\"string\">&#x27;bazz&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>items = words.items()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>words[<span class=\"string\">&#x27;spam&#x27;</span>] = <span class=\"string\">&#x27;eggs&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>items</span><br><span class=\"line\">dict_items([(<span class=\"string\">&#x27;foo1&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>), (<span class=\"string\">&#x27;fizz&#x27;</span>, <span class=\"string\">&#x27;bazz&#x27;</span>), (<span class=\"string\">&#x27;spam&#x27;</span>, <span class=\"string\">&#x27;eggs&#x27;</span>)])</span><br></pre></td></tr></table></figure>\n\n<p>视图对象既有旧的<code>keys()</code>、<code>values()</code>和<code>items()</code>方法返回的列表的特性，也有旧的<code>iterkeys()</code>、<code>itervalues()</code>和<code>iteritems()</code>方法返回的迭代器的特性。视图无需冗余地将所有值都保存在内存里（像列表那样），但你仍然可以获取其长度（使用<code>len</code>），也可以测试元素是否包含其中（使用<code>in</code>子句）。当然，视图是可迭代的。最后一件重要的事情是，在<code>keys()</code>和<code>values()</code>方法返回的视图中，键和值的顺序是完全对应的。</p>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构是很有用的。它与数学上的集合概念非常类似。<code>Python</code>的内置集合类型有两种。</p>\n<ul>\n<li>set()：一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。</li>\n<li>frozenset()：一种不可变的、可哈希的、无序的集合，其元素是唯一的、不可变的（可哈希的）对象。</li>\n</ul>\n<p>由于<code>frozenset()</code>具有不变性，它可以用作字典的键，也可以作为其他<code>set()</code>和<code>frozenset()</code>的元素。在一个<code>set()</code>或<code>frozenset()</code>中不能包含另一个普通的可变<code>set()</code>，因为这会引发<code>TypeError</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">set</span>([<span class=\"built_in\">set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]),<span class=\"built_in\">set</span>([<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])])</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">TypeError: unhashable <span class=\"built_in\">type</span>: <span class=\"string\">&#x27;set&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面这种集合初始化的方法是完全正确的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">set</span>([<span class=\"built_in\">frozenset</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]),<span class=\"built_in\">frozenset</span>([<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])])</span><br><span class=\"line\">&#123;<span class=\"built_in\">frozenset</span>(&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;), <span class=\"built_in\">frozenset</span>(&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建可变集合方法有以下3种，如下所示。</p>\n<ul>\n<li>调用set()，选择性地接受可迭代对象作为初始化参数，例如set([0, 1, 2])。</li>\n<li>使用集合推导，例如{element for element in range(3)}。</li>\n<li>使用集合字面值，例如{1, 2, 3}。</li>\n</ul>\n<p>使用集合的字面值和推导要格外小心，因为它们在形式上与字典的字面值和推导非常相似。此外，空的集合对象是没有字面值的。空的花括号{}表示的是空的字典字面值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"字符串与字节\"><a href=\"#字符串与字节\" class=\"headerlink\" title=\"字符串与字节\"></a>字符串与字节</h2><p><code>Python3</code>中只有一种能够保存文本信息的数据类型，就是<code>str</code>(<code>string</code>，字符串)。它是不可变的序列，保存的<code>Unicode</code>码位(<code>code point</code>)。</p>\n<p>字符串可以保存的数据类型有非常明确的限制，就是<code>Unicode</code>文本。</p>\n<p><code>bytes</code>以及可变的<code>bytearray</code>与<code>str</code>不同，只能用字节作为序列值，即<code>0&lt;=x&lt;256</code>范围内的整数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">bytes</span>([<span class=\"number\">102</span>,<span class=\"number\">111</span>,<span class=\"number\">111</span>])</span><br><span class=\"line\"><span class=\"string\">b&#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于<code>bytes</code>和<code>bytearray</code>，在转换为另一种序列类型（例如<code>list</code>或<code>tuple</code>）时可以显示出其本来面目：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(<span class=\"string\">b&#x27;foo bar&#x27;</span>)</span><br><span class=\"line\">[<span class=\"number\">102</span>, <span class=\"number\">111</span>, <span class=\"number\">111</span>, <span class=\"number\">32</span>, <span class=\"number\">98</span>, <span class=\"number\">97</span>, <span class=\"number\">114</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">tuple</span>(<span class=\"string\">b&#x27;foo bar&#x27;</span>)</span><br><span class=\"line\">(<span class=\"number\">102</span>, <span class=\"number\">111</span>, <span class=\"number\">111</span>, <span class=\"number\">32</span>, <span class=\"number\">98</span>, <span class=\"number\">97</span>, <span class=\"number\">114</span>)</span><br></pre></td></tr></table></figure>\n\n<p>从<code>Python3.0</code>开始，所有没有前缀的字符串都是<code>Unicode</code>。因此，所有用单引号（’）、双引号（”）或成组的3个引号（单引号或双引号）包围且没有前缀的值都表示<code>str</code>数据类型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(<span class=\"string\">&quot;some string&quot;</span>)</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>字节也被单引号、双引号或三引号包围，但必须有一个<code>b</code>或<code>B</code>前缀：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(<span class=\"string\">b&quot;some bytes&quot;</span>)</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">bytes</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Python</code>字符串是不可变的。字节序列也是如此。<code>bytearray</code>是<code>bytes</code>的可变版本，不存在这样的问题。字节数组可以通过元素赋值来进行原处修改（无需创建新对象），其大小也可以像列表一样动态地变化（利用<code>append</code>、<code>pop</code>、<code>inseer</code>等方法）。</p>\n<h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><p>用<code>str.join()</code>方法。它接受可迭代的字符串作为参数，返回合并后的字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&#x27;,&#x27;</span>.join([<span class=\"string\">&#x27;some&#x27;</span>,<span class=\"string\">&#x27;one&#x27;</span>,<span class=\"string\">&#x27;like&#x27;</span>,<span class=\"string\">&#x27;you&#x27;</span>,<span class=\"string\">&#x27;forever&#x27;</span>])</span><br><span class=\"line\"><span class=\"string\">&#x27;some,one,like,you,forever&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为<code>join()</code>方法速度更快（对于大型列表来说更是如此），并不意味着在所有需要拼接两个字符串的情况下都应该使用这一方法。虽然这是一种广为认可的做法，但并不会提高代码的可读性。可读性是很重要的！在某些情况下，<code>join()</code>的性能可能还不如利用加法的普通拼接。</p>\n<h2 id=\"集合类型\"><a href=\"#集合类型\" class=\"headerlink\" title=\"集合类型\"></a>集合类型</h2><h3 id=\"列表和元组\"><a href=\"#列表和元组\" class=\"headerlink\" title=\"列表和元组\"></a>列表和元组</h3><p>列表是动态的，其大小可以改变；而元组是不可变的，一旦创建就不能修改。</p>\n<p><code>tuple是</code>不可变的（immutable），因此也是可哈希的（hashable）</p>\n<p>从细节上来看，<code>Python</code>中的列表是由对其他对象的引用组成的的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要改变大小（重新分配）。幸运的是，<code>Python</code>在创建这些数组时采用了指数过分配（exponential over-allocation），所以并不是每次操作都需要改变数组大小。这也是添加或取出元素的平摊复杂度较低的原因。不幸的是，在普通链表中“代价很小”的其他一些操作在<code>Python</code>中的计算复杂度却相对较高：</p>\n<ul>\n<li>利用<code>list.insert</code>方法在任意位置插入一个元素——复杂度为<code>O(n)</code>。</li>\n<li>利用<code>list.delete</code>或<code>del</code>删除一个元素——复杂度为<code>O(n)</code>。</li>\n</ul>\n<p><img src=\"Screenshot_1.webp\"></p>\n<h4 id=\"列表推导\"><a href=\"#列表推导\" class=\"headerlink\" title=\"列表推导\"></a>列表推导</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>evens = []</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>            evens.append(i)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>evens</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这种写法可能适用于<code>C</code>语言，但在<code>Python</code>中的实际运行速度很慢，原因如下。</p>\n<ul>\n<li>解释器在每次循环中都需要判断序列中的哪一部分需要修改。</li>\n<li>需要用一个计数器来跟踪需要处理的元素。</li>\n<li>由于<code>append()</code>是一个列表方法，所以每次遍历时还需要额外执行一个查询函数。</li>\n</ul>\n<p>列表推导正是解决这个问题的正确方法。它使用编排好的功能对上述语法的一部分做了自动化处理：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>) <span class=\"keyword\">if</span> i % <span class=\"number\">2</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这种写法除了更加高效之外，也更加简短，涉及的语法元素也更少。在大型程序中，这意味着更少的错误，代码也更容易阅读和理解。</p>\n<h4 id=\"其他习语\"><a href=\"#其他习语\" class=\"headerlink\" title=\"其他习语\"></a>其他习语</h4><p><code>Python</code>习语的另一个典型例子是使用<code>enumerate</code>（枚举）。在循环中使用序列时，这个内置函数可以很方便地获取其索引。以下面这段代码为例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;one&#x27;</span>,<span class=\"string\">&#x27;two&#x27;</span>,<span class=\"string\">&#x27;three&#x27;</span>]:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(i, element)</span><br><span class=\"line\"><span class=\"meta\">... </span>    i += <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span> one</span><br><span class=\"line\"><span class=\"number\">1</span> two</span><br><span class=\"line\"><span class=\"number\">2</span> three</span><br></pre></td></tr></table></figure>\n\n<p>它可以替换为下面这段更短的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i, element <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>([<span class=\"string\">&#x27;one&#x27;</span>,<span class=\"string\">&#x27;two&#x27;</span>,<span class=\"string\">&#x27;three&#x27;</span>]):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(i, element)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span> one</span><br><span class=\"line\"><span class=\"number\">1</span> two</span><br><span class=\"line\"><span class=\"number\">2</span> three</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"序列解包（sequence-unpacking）\"><a href=\"#序列解包（sequence-unpacking）\" class=\"headerlink\" title=\"序列解包（sequence unpacking）\"></a>序列解包（sequence unpacking）</h4><p>这种方法并不限于列表和元组，而是适用于任意序列类型（甚至包括字符串和字节序列）。只要赋值运算符左边的变量数目与序列中的元素数目相等，你都可以用这种方法将元素序列解包到另一组变量中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first, second, third = <span class=\"string\">&quot;holy&quot;</span>, <span class=\"string\">&quot;chan&quot;</span>, <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first</span><br><span class=\"line\"><span class=\"string\">&#x27;holy&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>second</span><br><span class=\"line\"><span class=\"string\">&#x27;chan&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>third</span><br><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<p>解包还可以利用带星号的表达式获取单个变量中的多个元素，只要它的解释没有歧义即可。还可以对嵌套序列进行解包。特别是在遍历由序列构成的复杂数据结构时，这种方法非常实用。下面是一些更复杂的解包示例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 带星号的表达式可以获取序列的剩余部分</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first, second, *rest = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>second</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>rest</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 带星号的表达式可以获取序列的中间部分</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first, *inner, last = <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>inner</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>last</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"comment\"># 嵌套解包</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(a,b), (c,d) = (<span class=\"number\">1</span>,<span class=\"number\">2</span>), (<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c, d</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>字典是<code>Python</code>中最通用的数据结构之一。<code>dict</code>可以将一组唯一键映射到对应的值，如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&#x27;one&#x27;</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">&#x27;two&#x27;</span>,</span><br><span class=\"line\">  <span class=\"number\">3</span>: <span class=\"string\">&#x27;three&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以用和前面列表推导类似的推导来创建一个新的字典。这里有一个非常简单的例子如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>squares = &#123;number: number ** <span class=\"number\">2</span> <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>)&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>squares</span><br><span class=\"line\">&#123;<span class=\"number\">0</span>: <span class=\"number\">0</span>, <span class=\"number\">1</span>: <span class=\"number\">1</span>, <span class=\"number\">2</span>: <span class=\"number\">4</span>, <span class=\"number\">3</span>: <span class=\"number\">9</span>, <span class=\"number\">4</span>: <span class=\"number\">16</span>, <span class=\"number\">5</span>: <span class=\"number\">25</span>, <span class=\"number\">6</span>: <span class=\"number\">36</span>, <span class=\"number\">7</span>: <span class=\"number\">49</span>, <span class=\"number\">8</span>: <span class=\"number\">64</span>, <span class=\"number\">9</span>: <span class=\"number\">81</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在许多情况下，字典推导要更加高效、更加简短、更加整洁。对于更复杂的代码而言，需要用到许多<code>if</code>语句或函数调用来创建一个字典，这时最好使用简单的<code>for</code>循环，尤其是它还提高了可读性。</p>\n<p>对于<code>python3</code>，字典的<code>keys()</code>、<code>values()</code>和<code>items()</code>3个方法的返回值类型不再是列表。此外，与之对应的<code>iterkeys()</code>、<code>itervalues()</code>和<code>iteritems()</code>本来返回的是迭代器，而<code>Python3</code>中并没有这3个方法。现在<code>keys()</code>、<code>values()</code>和<code>items()</code>返回的是视图对象（<code>viewobjects</code>）。</p>\n<ul>\n<li>keys()：返回dict_keys对象，可以查看字典的所有键。</li>\n<li>values()：返回dict_values对象，可以查看字典的所有值。</li>\n<li>items()：返回dict_items对象，可以查看字典所有的(key, value)二元元组。</li>\n</ul>\n<p>视图对象可以动态查看字典的内容，因此每次字典发生变化时，视图都会相应改变，见下面这个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>words = &#123;<span class=\"string\">&#x27;foo1&#x27;</span>:<span class=\"string\">&#x27;bar&#x27;</span>, <span class=\"string\">&#x27;fizz&#x27;</span>:<span class=\"string\">&#x27;bazz&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>items = words.items()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>words[<span class=\"string\">&#x27;spam&#x27;</span>] = <span class=\"string\">&#x27;eggs&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>items</span><br><span class=\"line\">dict_items([(<span class=\"string\">&#x27;foo1&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>), (<span class=\"string\">&#x27;fizz&#x27;</span>, <span class=\"string\">&#x27;bazz&#x27;</span>), (<span class=\"string\">&#x27;spam&#x27;</span>, <span class=\"string\">&#x27;eggs&#x27;</span>)])</span><br></pre></td></tr></table></figure>\n\n<p>视图对象既有旧的<code>keys()</code>、<code>values()</code>和<code>items()</code>方法返回的列表的特性，也有旧的<code>iterkeys()</code>、<code>itervalues()</code>和<code>iteritems()</code>方法返回的迭代器的特性。视图无需冗余地将所有值都保存在内存里（像列表那样），但你仍然可以获取其长度（使用<code>len</code>），也可以测试元素是否包含其中（使用<code>in</code>子句）。当然，视图是可迭代的。最后一件重要的事情是，在<code>keys()</code>和<code>values()</code>方法返回的视图中，键和值的顺序是完全对应的。</p>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构是很有用的。它与数学上的集合概念非常类似。<code>Python</code>的内置集合类型有两种。</p>\n<ul>\n<li>set()：一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。</li>\n<li>frozenset()：一种不可变的、可哈希的、无序的集合，其元素是唯一的、不可变的（可哈希的）对象。</li>\n</ul>\n<p>由于<code>frozenset()</code>具有不变性，它可以用作字典的键，也可以作为其他<code>set()</code>和<code>frozenset()</code>的元素。在一个<code>set()</code>或<code>frozenset()</code>中不能包含另一个普通的可变<code>set()</code>，因为这会引发<code>TypeError</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">set</span>([<span class=\"built_in\">set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]),<span class=\"built_in\">set</span>([<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])])</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">TypeError: unhashable <span class=\"built_in\">type</span>: <span class=\"string\">&#x27;set&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面这种集合初始化的方法是完全正确的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">set</span>([<span class=\"built_in\">frozenset</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]),<span class=\"built_in\">frozenset</span>([<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])])</span><br><span class=\"line\">&#123;<span class=\"built_in\">frozenset</span>(&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;), <span class=\"built_in\">frozenset</span>(&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建可变集合方法有以下3种，如下所示。</p>\n<ul>\n<li>调用set()，选择性地接受可迭代对象作为初始化参数，例如set([0, 1, 2])。</li>\n<li>使用集合推导，例如{element for element in range(3)}。</li>\n<li>使用集合字面值，例如{1, 2, 3}。</li>\n</ul>\n<p>使用集合的字面值和推导要格外小心，因为它们在形式上与字典的字面值和推导非常相似。此外，空的集合对象是没有字面值的。空的花括号{}表示的是空的字典字面值。</p>\n"},{"title":"scrapy框架介绍","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-29T10:13:04.000Z","pic":null,"_content":"\n## Scrapy介绍\n\n`Scrapy`是一个基于`Twisted`的异步处理框架，是纯`Python`实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。只需要定制开发几个模块就可以轻松实现一个爬虫。\n\n首先来看下`Scrapy`框架的架构，如图所示：\n\n![](Screenshot_1.webp)\n\n它可以分为如下的几个部分。\n\n- `Engine（引擎）`：用来处理整个系统的数据流处理、触发事务，是整个框架的核心。\n- `Item（项目）`：定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。\n- `Scheduler（调度器）`：用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。\n- `Downloader（下载器）`：用于下载网页内容，并将网页内容返回给蜘蛛。\n- `Spiders（蜘蛛）`：其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。\n- `ItemPipeline（项目管道）`：负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。\n- `Downloader Middlewares（下载器中间件）`：位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。\n- `Spider Middlewares（蜘蛛中间件）`：位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。\n\n## 数据流\n\n了解了架构，就是要了解它是怎么进行数据爬取和处理的，所以接下来介绍`Scrapy`的数据流机制。\n\n`Scrapy`中的数据流由引擎控制，其过程如下：\n\n- `Engine`首先打开一个网站，找到处理该网站的`Spider`并向该`Spider`请求第一个要爬虫的`URL`。\n- `Engine`从`Spider`中获取到第一个要爬取的`URL`并通过`Scheduler`以`Request`的形式调度。\n- `Engine`向`Scheduler`请求下一个要爬取的`URL`。\n- `Scheduler`返回下一个要爬取的`URL`给`Engine`，`Engine`将`URL`通过`Downloader Middlewares`转发给`Downloader`下载。\n- 一旦页面下载完毕， `Downloader`生成一个该页面的`Response`，并将其通过`Downloader Middlewares`发送给`Engine`。\n- `Engine`从下载器中接收到`Response`并通过`Spider Middlewares`发送给`Spider`处理。\n- `Spider`处理`Response`并返回爬取到的`Item`及新的`Request`给`Engine`。\n- `Engine`将`Spider`返回的`Item`给`ItemPipeline`，将新的`Request`给`Scheduler`。\n- 重复第二步到最后一步，直到`Scheduler`中没有更多的`Request`，`Engine`关闭该网站，爬取结束。\n\n通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，`Scrapy`最大限度地利用了网络带宽，大大提高了 数据爬取和处理的效率。\n\n## 安装\n\n使用官方文档推荐的方式安装就可以了：\n\n```python\npip install scrapy\n```\n\n## 项目结构\n\n安装完成后，就可以使用`Scrapy`预先配置好的很多可用的组件和编写爬虫时所用的脚手架。\n\n创建项目的命令如下：\n\n```python\nscrapy startproject demo\n```\n\n执行完成之后，在当前运行目录下便会出现一个文件夹，叫作`demo`，这就是一个`Scrapy`项目框架，可以基于这个项目框架来编写爬虫。\n\n项目文件结构如下所示：\n\n```python\nscrapy.cfg \nproject/ \n  __init__.py\n  items.py \n  pipelines.py \n  settings.py \n  middlewares.py \n  spiders/\n    __init__.py\n    spider1.py\n    spider2.py\n    ...\n```\n\n在此要将各个文件的功能描述如下：\n\n- `scrapy.cfg`：它是`Scrapy`项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。\n- `items.py`：它定义`Item`数据结构，所有的`Item`的定义都可以放这里。\n- `pipelines.py`：它定义`ItemPipeline`的实现，所有的`ItemPipeline`的实现都可以放这里。\n- `settings.py`：它定义项目的全局配置。\n- `middlewares.py`：它定义`Spider Middlewares`和`Downloader Middlewares`的实现。\n- `spiders`：其内包含一个个`Spider`的实现，每个`Spider`都有一个文件。\n\n","source":"_posts/scrapy框架介绍.md","raw":"---\ntitle: scrapy框架介绍\ntags:\n  - scrapy\n  - python\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-29 18:13:04\ncategories: 爬虫\npic:\n---\n\n## Scrapy介绍\n\n`Scrapy`是一个基于`Twisted`的异步处理框架，是纯`Python`实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。只需要定制开发几个模块就可以轻松实现一个爬虫。\n\n首先来看下`Scrapy`框架的架构，如图所示：\n\n![](Screenshot_1.webp)\n\n它可以分为如下的几个部分。\n\n- `Engine（引擎）`：用来处理整个系统的数据流处理、触发事务，是整个框架的核心。\n- `Item（项目）`：定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。\n- `Scheduler（调度器）`：用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。\n- `Downloader（下载器）`：用于下载网页内容，并将网页内容返回给蜘蛛。\n- `Spiders（蜘蛛）`：其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。\n- `ItemPipeline（项目管道）`：负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。\n- `Downloader Middlewares（下载器中间件）`：位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。\n- `Spider Middlewares（蜘蛛中间件）`：位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。\n\n## 数据流\n\n了解了架构，就是要了解它是怎么进行数据爬取和处理的，所以接下来介绍`Scrapy`的数据流机制。\n\n`Scrapy`中的数据流由引擎控制，其过程如下：\n\n- `Engine`首先打开一个网站，找到处理该网站的`Spider`并向该`Spider`请求第一个要爬虫的`URL`。\n- `Engine`从`Spider`中获取到第一个要爬取的`URL`并通过`Scheduler`以`Request`的形式调度。\n- `Engine`向`Scheduler`请求下一个要爬取的`URL`。\n- `Scheduler`返回下一个要爬取的`URL`给`Engine`，`Engine`将`URL`通过`Downloader Middlewares`转发给`Downloader`下载。\n- 一旦页面下载完毕， `Downloader`生成一个该页面的`Response`，并将其通过`Downloader Middlewares`发送给`Engine`。\n- `Engine`从下载器中接收到`Response`并通过`Spider Middlewares`发送给`Spider`处理。\n- `Spider`处理`Response`并返回爬取到的`Item`及新的`Request`给`Engine`。\n- `Engine`将`Spider`返回的`Item`给`ItemPipeline`，将新的`Request`给`Scheduler`。\n- 重复第二步到最后一步，直到`Scheduler`中没有更多的`Request`，`Engine`关闭该网站，爬取结束。\n\n通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，`Scrapy`最大限度地利用了网络带宽，大大提高了 数据爬取和处理的效率。\n\n## 安装\n\n使用官方文档推荐的方式安装就可以了：\n\n```python\npip install scrapy\n```\n\n## 项目结构\n\n安装完成后，就可以使用`Scrapy`预先配置好的很多可用的组件和编写爬虫时所用的脚手架。\n\n创建项目的命令如下：\n\n```python\nscrapy startproject demo\n```\n\n执行完成之后，在当前运行目录下便会出现一个文件夹，叫作`demo`，这就是一个`Scrapy`项目框架，可以基于这个项目框架来编写爬虫。\n\n项目文件结构如下所示：\n\n```python\nscrapy.cfg \nproject/ \n  __init__.py\n  items.py \n  pipelines.py \n  settings.py \n  middlewares.py \n  spiders/\n    __init__.py\n    spider1.py\n    spider2.py\n    ...\n```\n\n在此要将各个文件的功能描述如下：\n\n- `scrapy.cfg`：它是`Scrapy`项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。\n- `items.py`：它定义`Item`数据结构，所有的`Item`的定义都可以放这里。\n- `pipelines.py`：它定义`ItemPipeline`的实现，所有的`ItemPipeline`的实现都可以放这里。\n- `settings.py`：它定义项目的全局配置。\n- `middlewares.py`：它定义`Spider Middlewares`和`Downloader Middlewares`的实现。\n- `spiders`：其内包含一个个`Spider`的实现，每个`Spider`都有一个文件。\n\n","slug":"scrapy框架介绍","published":1,"updated":"2021-06-15T03:24:11.518Z","_id":"ckpapu7id000vlcxudaqy38uj","layout":"post","photos":[],"link":"","content":"<h2 id=\"Scrapy介绍\"><a href=\"#Scrapy介绍\" class=\"headerlink\" title=\"Scrapy介绍\"></a>Scrapy介绍</h2><p><code>Scrapy</code>是一个基于<code>Twisted</code>的异步处理框架，是纯<code>Python</code>实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。只需要定制开发几个模块就可以轻松实现一个爬虫。</p>\n<p>首先来看下<code>Scrapy</code>框架的架构，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>它可以分为如下的几个部分。</p>\n<ul>\n<li><code>Engine（引擎）</code>：用来处理整个系统的数据流处理、触发事务，是整个框架的核心。</li>\n<li><code>Item（项目）</code>：定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。</li>\n<li><code>Scheduler（调度器）</code>：用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。</li>\n<li><code>Downloader（下载器）</code>：用于下载网页内容，并将网页内容返回给蜘蛛。</li>\n<li><code>Spiders（蜘蛛）</code>：其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。</li>\n<li><code>ItemPipeline（项目管道）</code>：负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。</li>\n<li><code>Downloader Middlewares（下载器中间件）</code>：位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。</li>\n<li><code>Spider Middlewares（蜘蛛中间件）</code>：位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。</li>\n</ul>\n<h2 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h2><p>了解了架构，就是要了解它是怎么进行数据爬取和处理的，所以接下来介绍<code>Scrapy</code>的数据流机制。</p>\n<p><code>Scrapy</code>中的数据流由引擎控制，其过程如下：</p>\n<ul>\n<li><code>Engine</code>首先打开一个网站，找到处理该网站的<code>Spider</code>并向该<code>Spider</code>请求第一个要爬虫的<code>URL</code>。</li>\n<li><code>Engine</code>从<code>Spider</code>中获取到第一个要爬取的<code>URL</code>并通过<code>Scheduler</code>以<code>Request</code>的形式调度。</li>\n<li><code>Engine</code>向<code>Scheduler</code>请求下一个要爬取的<code>URL</code>。</li>\n<li><code>Scheduler</code>返回下一个要爬取的<code>URL</code>给<code>Engine</code>，<code>Engine</code>将<code>URL</code>通过<code>Downloader Middlewares</code>转发给<code>Downloader</code>下载。</li>\n<li>一旦页面下载完毕， <code>Downloader</code>生成一个该页面的<code>Response</code>，并将其通过<code>Downloader Middlewares</code>发送给<code>Engine</code>。</li>\n<li><code>Engine</code>从下载器中接收到<code>Response</code>并通过<code>Spider Middlewares</code>发送给<code>Spider</code>处理。</li>\n<li><code>Spider</code>处理<code>Response</code>并返回爬取到的<code>Item</code>及新的<code>Request</code>给<code>Engine</code>。</li>\n<li><code>Engine</code>将<code>Spider</code>返回的<code>Item</code>给<code>ItemPipeline</code>，将新的<code>Request</code>给<code>Scheduler</code>。</li>\n<li>重复第二步到最后一步，直到<code>Scheduler</code>中没有更多的<code>Request</code>，<code>Engine</code>关闭该网站，爬取结束。</li>\n</ul>\n<p>通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，<code>Scrapy</code>最大限度地利用了网络带宽，大大提高了 数据爬取和处理的效率。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用官方文档推荐的方式安装就可以了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scrapy</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>安装完成后，就可以使用<code>Scrapy</code>预先配置好的很多可用的组件和编写爬虫时所用的脚手架。</p>\n<p>创建项目的命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject demo</span><br></pre></td></tr></table></figure>\n\n<p>执行完成之后，在当前运行目录下便会出现一个文件夹，叫作<code>demo</code>，这就是一个<code>Scrapy</code>项目框架，可以基于这个项目框架来编写爬虫。</p>\n<p>项目文件结构如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy.cfg </span><br><span class=\"line\">project/ </span><br><span class=\"line\">  __init__.py</span><br><span class=\"line\">  items.py </span><br><span class=\"line\">  pipelines.py </span><br><span class=\"line\">  settings.py </span><br><span class=\"line\">  middlewares.py </span><br><span class=\"line\">  spiders/</span><br><span class=\"line\">    __init__.py</span><br><span class=\"line\">    spider1.py</span><br><span class=\"line\">    spider2.py</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>在此要将各个文件的功能描述如下：</p>\n<ul>\n<li><code>scrapy.cfg</code>：它是<code>Scrapy</code>项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。</li>\n<li><code>items.py</code>：它定义<code>Item</code>数据结构，所有的<code>Item</code>的定义都可以放这里。</li>\n<li><code>pipelines.py</code>：它定义<code>ItemPipeline</code>的实现，所有的<code>ItemPipeline</code>的实现都可以放这里。</li>\n<li><code>settings.py</code>：它定义项目的全局配置。</li>\n<li><code>middlewares.py</code>：它定义<code>Spider Middlewares</code>和<code>Downloader Middlewares</code>的实现。</li>\n<li><code>spiders</code>：其内包含一个个<code>Spider</code>的实现，每个<code>Spider</code>都有一个文件。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Scrapy介绍\"><a href=\"#Scrapy介绍\" class=\"headerlink\" title=\"Scrapy介绍\"></a>Scrapy介绍</h2><p><code>Scrapy</code>是一个基于<code>Twisted</code>的异步处理框架，是纯<code>Python</code>实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。只需要定制开发几个模块就可以轻松实现一个爬虫。</p>\n<p>首先来看下<code>Scrapy</code>框架的架构，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>它可以分为如下的几个部分。</p>\n<ul>\n<li><code>Engine（引擎）</code>：用来处理整个系统的数据流处理、触发事务，是整个框架的核心。</li>\n<li><code>Item（项目）</code>：定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。</li>\n<li><code>Scheduler（调度器）</code>：用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。</li>\n<li><code>Downloader（下载器）</code>：用于下载网页内容，并将网页内容返回给蜘蛛。</li>\n<li><code>Spiders（蜘蛛）</code>：其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。</li>\n<li><code>ItemPipeline（项目管道）</code>：负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。</li>\n<li><code>Downloader Middlewares（下载器中间件）</code>：位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。</li>\n<li><code>Spider Middlewares（蜘蛛中间件）</code>：位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。</li>\n</ul>\n<h2 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h2><p>了解了架构，就是要了解它是怎么进行数据爬取和处理的，所以接下来介绍<code>Scrapy</code>的数据流机制。</p>\n<p><code>Scrapy</code>中的数据流由引擎控制，其过程如下：</p>\n<ul>\n<li><code>Engine</code>首先打开一个网站，找到处理该网站的<code>Spider</code>并向该<code>Spider</code>请求第一个要爬虫的<code>URL</code>。</li>\n<li><code>Engine</code>从<code>Spider</code>中获取到第一个要爬取的<code>URL</code>并通过<code>Scheduler</code>以<code>Request</code>的形式调度。</li>\n<li><code>Engine</code>向<code>Scheduler</code>请求下一个要爬取的<code>URL</code>。</li>\n<li><code>Scheduler</code>返回下一个要爬取的<code>URL</code>给<code>Engine</code>，<code>Engine</code>将<code>URL</code>通过<code>Downloader Middlewares</code>转发给<code>Downloader</code>下载。</li>\n<li>一旦页面下载完毕， <code>Downloader</code>生成一个该页面的<code>Response</code>，并将其通过<code>Downloader Middlewares</code>发送给<code>Engine</code>。</li>\n<li><code>Engine</code>从下载器中接收到<code>Response</code>并通过<code>Spider Middlewares</code>发送给<code>Spider</code>处理。</li>\n<li><code>Spider</code>处理<code>Response</code>并返回爬取到的<code>Item</code>及新的<code>Request</code>给<code>Engine</code>。</li>\n<li><code>Engine</code>将<code>Spider</code>返回的<code>Item</code>给<code>ItemPipeline</code>，将新的<code>Request</code>给<code>Scheduler</code>。</li>\n<li>重复第二步到最后一步，直到<code>Scheduler</code>中没有更多的<code>Request</code>，<code>Engine</code>关闭该网站，爬取结束。</li>\n</ul>\n<p>通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，<code>Scrapy</code>最大限度地利用了网络带宽，大大提高了 数据爬取和处理的效率。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用官方文档推荐的方式安装就可以了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install scrapy</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>安装完成后，就可以使用<code>Scrapy</code>预先配置好的很多可用的组件和编写爬虫时所用的脚手架。</p>\n<p>创建项目的命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject demo</span><br></pre></td></tr></table></figure>\n\n<p>执行完成之后，在当前运行目录下便会出现一个文件夹，叫作<code>demo</code>，这就是一个<code>Scrapy</code>项目框架，可以基于这个项目框架来编写爬虫。</p>\n<p>项目文件结构如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy.cfg </span><br><span class=\"line\">project/ </span><br><span class=\"line\">  __init__.py</span><br><span class=\"line\">  items.py </span><br><span class=\"line\">  pipelines.py </span><br><span class=\"line\">  settings.py </span><br><span class=\"line\">  middlewares.py </span><br><span class=\"line\">  spiders/</span><br><span class=\"line\">    __init__.py</span><br><span class=\"line\">    spider1.py</span><br><span class=\"line\">    spider2.py</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>在此要将各个文件的功能描述如下：</p>\n<ul>\n<li><code>scrapy.cfg</code>：它是<code>Scrapy</code>项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。</li>\n<li><code>items.py</code>：它定义<code>Item</code>数据结构，所有的<code>Item</code>的定义都可以放这里。</li>\n<li><code>pipelines.py</code>：它定义<code>ItemPipeline</code>的实现，所有的<code>ItemPipeline</code>的实现都可以放这里。</li>\n<li><code>settings.py</code>：它定义项目的全局配置。</li>\n<li><code>middlewares.py</code>：它定义<code>Spider Middlewares</code>和<code>Downloader Middlewares</code>的实现。</li>\n<li><code>spiders</code>：其内包含一个个<code>Spider</code>的实现，每个<code>Spider</code>都有一个文件。</li>\n</ul>\n"},{"title":"scrapy的基本使用","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-29T14:49:55.000Z","pic":null,"_content":"\n## 抓取目标\n\n要完成的任务如下。\n\n- 创建一个`Scrapy`项目。\n- 创建一个`Spider`来抓取站点和处理数据。\n- 通过命令行将抓取的内容导出。\n- 将抓取的内容保存到`MongoDB`数据库。\n\n抓取的目标站点为[](http://quotes.toscrape.com/)。\n\n## 准备工作\n\n安装好`scrapy`框架、`MongoDB`和`PyMongo`库。\n\n## 创建项目\n\n创建一个`Scrapy`项目，项目文件可以直接用`Scrapy`命令生成，命令如下所示：\n\n```python\nscrapy startproject tutorial\n```\n\n这个命令将会创建一个名为`tutorial`的文件夹，文件夹结构如下所示：\n\n```python\nscrapy.cfg    # Scrapy 部署时的配置文件 \ntutorial    # 项目的模块，引入的时候需要从这里引入 \n  __init__.py \n  items.py    # Items 的定义，定义爬取的数据结构 \n  middlewares.py     # Middlewares 的定义，定义爬取时的中间件 \n  pipelines.py    # Pipelines 的定义，定义数据管道 \n  settings.py     # 配置文件 \n  spiders     # 放置 Spiders 的文件夹 \n    __init__.py\n```\n\n## 创建Spider\n\n`Spider`是自己定义的类，`Scrapy`用它从网页里抓取内容，并解析抓取的结果。不过这个类必须继承`Scrapy`提供的`Spider`类`scrapy.Spider`，还要定义`Spider`的名称和起始请求，以及怎样处理爬取后的结果的方法。\n\n也可以使用命令行创建一个`Spider`。比如要生成`Quotes`这个`Spider`，可以执行如下命令：\n\n```python\n>>> scrapy genspider quotes quotes.toscrape.com     \nCreated spider 'quotes' using template 'basic' in module:\n  tutorial.spiders.quotes\n```\n\n进入刚才创建的`tutorial`文件夹，然后执行`genspider`命令。第一个参数是`Spider`的名称，第二个参数是`网站域名`。执行完毕之后，`spiders`文件夹中多了一个`quotes.py`，它就是刚刚创建的`Spider`，内容如下所示：\n\n```python\nimport scrapy\n\nclass QuotesSpider(scrapy.Spider):\n    name = 'quotes'\n    allowed_domains = ['quotes.toscrape.com']\n    start_urls = ['http://quotes.toscrape.com/']\n\n    def parse(self, response):\n        pass\n```\n\n这里有三个属性——`name`、`allowed_domains`和`start_urls`，还有一个方法`parse`。\n\n- `name`：它是每个项目唯一的名字，用来区分不同的`Spider`。\n- `allowed_domains`：它是允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，则请求链接会被过滤掉。\n- `start_urls`：它包含了`Spider`在启动时爬取的`url`列表，初始请求是由它来定义的。\n- `parse`：它是`Spider`的一个方法。默认情况下，被调用时`start_urls`里面的链接构成的请求完成下载执行后，返回的响应就会作为唯一的参数传递给这个函数。该方法负责解析返回的响应、提取数据或者进一 步生成要处理的请求。\n\n## 创建Item\n\n`Item`是保存爬虫数据的容器，它的使用方法和字典类似，不过相比字典，`Item`多了额外的保护机制，可以避免拼写错误或者定义字段错误。\n\n创建`Item`需要继承`scrapy.Item`类，并且定义类型为`scrapy.Field`的字段。观察目标网站，可以获取到的内容有`text`、`author`、`tags`。\n\n定义`Item`，此时将`items.py`修改如下：\n\n```python\nimport scrapy\n\nclass QuoteItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    text = scrapy.Field()\n    author = scrapy.Field()\n    tags = scrapy.Field()\n```\n\n这里定义了三个字段，将类的名称修改为`QuoteItem`，接下来爬取时会使用到这个`Item`。\n\n## 解析Response\n\n`parse`方法的参数`response`是`start_urls`里面的链接爬取后的结果。所以在`parse`方法中，可以直接对`response`变量包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求。\n\n首先看看网页结构，如图所示。每一页都有多个`class`为`quote`的区块，每个区块内都包含`text`、`author`、`tags`。那么先找出所有的`quote`，然后提取每一个`quote`中的内容。\n\n![](Screenshot_1.webp)\n\n提取的方式可以是`CSS`选择器或`XPath`选择器。在这里使用`CSS`选择器进行选择，`parse`方法的改写如下所示：\n\n```python\nclass QuotesSpider(scrapy.Spider):\n    name = 'quotes'\n    allowed_domains = ['http://quotes.toscrape.com/']\n    start_urls = ['http://http://quotes.toscrape.com//']\n\n    def parse(self, response):\n        quotes = response.css('.quote')\n        for quote in quotes:\n            text = quote.css('.text::text').extract_first()\n            author = quote.css('.author::text').extract_first()\n            tags = quote.css('.tags .tag::text').extract()\n```\n\n对于`text`，获取结果的第一个元素即可，所以使用`extract_first`方法，对于`tags`，要获取所有结果组成的列表，所以使用`extract`方法。\n\n## 使用Item\n\n上文定义了`Item`，接下来就要使用它了。`Item`可以理解为一个字典，不过在声明的时候需要实例化。然后依次用刚才解析的结果赋值`Item`的每一个字段，最后将`Item`返回即可。\n\n`QuotesSpider`的改写如下所示：\n\n```python\n    def parse(self, response):\n        quotes = response.css('.quote')\n        for quote in quotes:\n            item = QuoteItem()\n            item['text'] = quote.css('.text::text').extract_first()\n            item['author'] = quote.css('.author::text').extract_first()\n            item['tags'] = quote.css('.tags .tag::text').extract()\n            yield item\n```\n\n如此一来，首页的所有内容被解析出来，并被赋值成了一个个`QuoteItem`。\n\n## 后续Request\n\n接下来就需要从当前页面中找到信息来生成下一个请求，然后在下一个请求的页面里面找到信息再构造下一个请求。这样循环往复迭代，从而实现整站的爬取。\n\n将刚才的页面拉到最底部，如图所示。\n\n![](Screenshot_2.webp)\n\n有一个`Next`按钮，查看一下源代码，可以发现它的链接是`/page/2/`，实际上全链接就是：`http://quotes.toscrape.com/page/2`，通过这个链接我们就可以构造下一个请求。\n\n构造请求时需要用到`scrapy.Request`。这里传递两个参数——`url`和`callback`，这两个参数的说明如下。\n\n- `url`：它是请求链接。\n- `callback`：它是回调函数。当指定了该回调函数的请求完成之后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。回调函数进行解析或生成下一个请求，回调函数如上文的`parse()`所示。\n\n由于`parse`就是解析`text`、`author`、`tags`的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以可以再次使用`parse`方法来做页面解析。\n\n接下来要做的就是利用选择器得到下一页链接并生成请求，在`parse`方法后追加如下的代码：\n\n```python\nnext = response.css('.pager .next a::attr(href)').extract_first()\nurl = response.urljoin(next)\nyield scrapy.Request(url=url, callback=self.parse, dont_filter=True)\n```\n\n第一句代码首先通过`CSS`选择器获取下一个页面的链接，即要获取`a`超链接中的`href`属性。这里用到了`::attr(href)`操作。然后再调用`extract_first`方法获取内容。\n\n第二句代码调用了`urljoin`方法，`urljoin()`方法可以将相对`URL`构造成一个绝对的`URL`。例如，获取到的下一页地址是`/page/2`，`urljoin`方法处理后得到的结果就是：`http://quotes.toscrape.com/page/2/`。\n\n第三句代码通过`url`和`callback`变量构造了一个新的请求，回调函数`callback`依然使用`parse`方法。这个请求完成后，响应会重新经过`parse`方法处理，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样爬虫就进入了一个循环，直到最后一页。`dont_filter`设置为`Ture`不进行域名过滤，这样就能继续爬取。\n\n通过几行代码，就轻松实现了一个抓取循环，将每个页面的结果抓取下来了。现在，改写之后的整个`Spider`类如下所示：\n\n```python\nimport scrapy\nfrom tutorial.items import QuoteItem\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = 'quotes'\n    allowed_domains = ['quotes.toscrape.com/']\n    start_urls = ['http://quotes.toscrape.com/']\n\n    def parse(self, response):\n        quotes = response.css('.quote')\n        for quote in quotes:\n            item = QuoteItem()\n            item['text'] = quote.css('.text::text').extract_first()\n            item['author'] = quote.css('.author::text').extract_first()\n            item['tags'] = quote.css('.tags .tag::text').extract()\n            yield item\n\n        next = response.css('.pager .next a::attr(href)').extract_first()\n        if next !== \"\":\n          url = response.urljoin(next)\n          yield scrapy.Request(url=url, callback=self.parse, dont_filter=True)\n```\n\n## 运行\n\n进入目录，运行如下命令：\n\n```python\nscrapy crawl quotes\n```\n\n爬虫一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。\n\n最后，`Scrapy`输出了整个抓取过程的统计信息，如请求的字节数、请求次数、响应次数、完成原因等。\n\n## 保存到文件\n\n`Scrapy`提供的`Feed Exports`可以轻松将抓取结果输出。例如，想将上面的结果保存成`JSON`文件，可以执行如下命令：\n\n```python\nscrapy crawl quotes -o quotes.json\n```\n\n命令运行后，项目内多了一个`quotes.json`文件，文件包含了刚才抓取的所有内容，内容是`JSON`格式。\n\n![](Screenshot_3.webp)\n\n另外还可以每一个`Item`输出一行`JSON`，输出后缀为`jl`，为`jsonline`的缩写，命令如下所示：\n\n```python\nscrapy crawl quotes -o quotes.jl\n```\n\n或\n\n```python\nscrapy crawl quotes -o quotes.jsonlines\n```\n\n输出格式还支持很多种，例如`csv`、`xml`、`pickle`、`marshal`等，还支持`ftp`、`s3` 等远程输出，另外还可以通过自定义`ItemExporter`来实现其他的输出。\n\n例如，下面命令对应的输出分别为`csv`、`xml`、`pickle`、`marshal`格式以及`ftp`远程输出：\n\n```python\nscrapy crawl quotes -o quotes.csv\nscrapy crawl quotes -o quotes.xml\nscrapy crawl quotes -o quotes.pickle\nscrapy crawl quotes -o quotes.marshal\nscrapy crawl quotes -o ftp://user:pass@ftp.example.com/path/to/quotes.csv \n```\n\n其中，`ftp`输出需要正确配置用户名、密码、地址、输出路径，否则会报错。通过`Scrapy`提供的`Feed Exports`，可以轻松地输出抓取结果到文件。对于一些小型项目来说，这应该足够了。不过如果想要更复杂的输出，如输出到数据库等，可以使用`ItemPileline`来完成。\n\n## 使用ItemPileline\n\n如果想进行更复杂的操作，如将结果保存到`MongoDB`数据库，或者筛选某些有用的`Item`，则可以定义`ItemPipeline`来实现。\n\n`ItemPipeline`为项目管道。当`Item`生成后，它会自动被送到`ItemPipeline`进行处理，常用`ItemPipeline`来做如下操作。\n\n- 清洗`HTML`数据；\n- 验证爬取数据，检查爬取字段；\n- 查重并丢弃重复内容；\n- 将爬取结果储存到数据库。\n\n要实现`ItemPipeline`很简单，只需要定义一个类并实现`process_item`方法即可。启用`ItemPipeline`后，`ItemPipeline`会自动调用这个方法。`process_item`方法必须返回包含数据的字典或`Item`对象，或者抛出`DropItem`异常。\n\n`process_item`方法有两个参数。一个参数是`item`，每次`Spider`生成的`Item`都会作为参数传递过来。另一个参数是`spider`，就是`Spider`的实例。\n\n接下来，实现一个`ItemPipeline`，筛掉`text`长度大于`50`的`Item`，并将结果保存到`MongoDB`。\n\n修改项目里的`pipelines`.py文件，之前用命令行自动生成的文件内容可以删掉，增加一个`TextPipeline`类，内容如下所示：\n\n```python\nfrom scrapy.exceptions import DropItem\n\nclass TextPipeline(object):\n    def __init__(self):\n        self.limit = 50\n    \n    def process_item(self, item, spider):\n        if item['text']:\n            if len(item['text']) > self.limit:\n                item['text'] =item['text'][0:self.limit].rstrip() + '...'\n                return item\n            else:\n                return DropItem\n```\n\n这段代码在构造方法里定义了限制长度为50，实现了`process_item`方法，其参数是`item`和`spider`。首先该方法判断`item`的`text`属性是否存在，如果不存在，则抛出`DropItem`异常；如果存在，再判断长度是否大于50，如果大于，那就截断然后拼接省略号，再将`item`返回即可。\n\n将处理后的`item`存入`MongoDB`，定义另外一个`Pipeline`。同样在`pipelines.py`中，实现另一个类`MongoPipeline`，内容如下所示：\n\n```python\nimport pymongo\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DB'))\n        \n    def open_spider(self, spider):\n        self.client = pymongo.MongoClient(self.mongo_uri)\n        self.db = self.client[self.mongo_db]\n    \n    def process_item(self, item, spider): \n        name = item.__class__.__name__ \n        self.db[name].insert(dict(item)) \n        return item \n    \n    def close_spider(self, spider): \n        self.client.close()\n```\n\n`MongoPipeline`类实现了`API`定义的另外几个方法。\n\n- `from_crawler`：这是一个类方法，用`@classmethod`标识，是一种依赖注入的方式，方法的参数就是`crawler`，通过`crawler`这个参数我们可以拿到全局配置的每个配置信息，在全局配置`settings.py`中可以定义`MONGO_URI`和`MONGO_DB`来指定`MongoDB`连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法的定义主要是用来获取`settings.py`中的配置的。\n- `open_spider`：当`Spider`被开启时，这个方法被调用。在这里主要进行了一些初始化操作。\n- `close_spider`：当`Spider`被关闭时，这个方法会调用，在这里将数据库连接关闭。\n\n最主要的`process_item`方法则执行了数据插入操作。\n\n定义好`TextPipeline`和`MongoPipeline`这两个类后，需要在`settings.py`中使用它们。`MongoDB`的连接信息还需要定义。\n\n```python\nITEM_PIPELINES = {\n    'tutorial.pipelines.TextPipeline': 300,\n    'tutorial.pipelines.MongoPipeline': 400,\n}\nMONGO_URI='localhost'\nMONGO_DB='tutorial'\n```\n\n赋值`ITEM_PIPELINES`字典，键名是`Pipeline`的类名称，键值是调用优先级，是一个数字，数字越小则对应的`Pipeline`越先被调用。\n再重新执行爬取，命令如下所示：\n\n```python\nscrapy crawl quotes\n```\n\n爬取结束后，`MongoDB`中创建了一个`tutorial`的数据库、`QuoteItem`的表。\n","source":"_posts/scrapy的基本使用.md","raw":"---\ntitle: scrapy的基本使用\ntags:\n  - scrapy\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-29 22:49:55\ncategories: 爬虫\npic:\n---\n\n## 抓取目标\n\n要完成的任务如下。\n\n- 创建一个`Scrapy`项目。\n- 创建一个`Spider`来抓取站点和处理数据。\n- 通过命令行将抓取的内容导出。\n- 将抓取的内容保存到`MongoDB`数据库。\n\n抓取的目标站点为[](http://quotes.toscrape.com/)。\n\n## 准备工作\n\n安装好`scrapy`框架、`MongoDB`和`PyMongo`库。\n\n## 创建项目\n\n创建一个`Scrapy`项目，项目文件可以直接用`Scrapy`命令生成，命令如下所示：\n\n```python\nscrapy startproject tutorial\n```\n\n这个命令将会创建一个名为`tutorial`的文件夹，文件夹结构如下所示：\n\n```python\nscrapy.cfg    # Scrapy 部署时的配置文件 \ntutorial    # 项目的模块，引入的时候需要从这里引入 \n  __init__.py \n  items.py    # Items 的定义，定义爬取的数据结构 \n  middlewares.py     # Middlewares 的定义，定义爬取时的中间件 \n  pipelines.py    # Pipelines 的定义，定义数据管道 \n  settings.py     # 配置文件 \n  spiders     # 放置 Spiders 的文件夹 \n    __init__.py\n```\n\n## 创建Spider\n\n`Spider`是自己定义的类，`Scrapy`用它从网页里抓取内容，并解析抓取的结果。不过这个类必须继承`Scrapy`提供的`Spider`类`scrapy.Spider`，还要定义`Spider`的名称和起始请求，以及怎样处理爬取后的结果的方法。\n\n也可以使用命令行创建一个`Spider`。比如要生成`Quotes`这个`Spider`，可以执行如下命令：\n\n```python\n>>> scrapy genspider quotes quotes.toscrape.com     \nCreated spider 'quotes' using template 'basic' in module:\n  tutorial.spiders.quotes\n```\n\n进入刚才创建的`tutorial`文件夹，然后执行`genspider`命令。第一个参数是`Spider`的名称，第二个参数是`网站域名`。执行完毕之后，`spiders`文件夹中多了一个`quotes.py`，它就是刚刚创建的`Spider`，内容如下所示：\n\n```python\nimport scrapy\n\nclass QuotesSpider(scrapy.Spider):\n    name = 'quotes'\n    allowed_domains = ['quotes.toscrape.com']\n    start_urls = ['http://quotes.toscrape.com/']\n\n    def parse(self, response):\n        pass\n```\n\n这里有三个属性——`name`、`allowed_domains`和`start_urls`，还有一个方法`parse`。\n\n- `name`：它是每个项目唯一的名字，用来区分不同的`Spider`。\n- `allowed_domains`：它是允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，则请求链接会被过滤掉。\n- `start_urls`：它包含了`Spider`在启动时爬取的`url`列表，初始请求是由它来定义的。\n- `parse`：它是`Spider`的一个方法。默认情况下，被调用时`start_urls`里面的链接构成的请求完成下载执行后，返回的响应就会作为唯一的参数传递给这个函数。该方法负责解析返回的响应、提取数据或者进一 步生成要处理的请求。\n\n## 创建Item\n\n`Item`是保存爬虫数据的容器，它的使用方法和字典类似，不过相比字典，`Item`多了额外的保护机制，可以避免拼写错误或者定义字段错误。\n\n创建`Item`需要继承`scrapy.Item`类，并且定义类型为`scrapy.Field`的字段。观察目标网站，可以获取到的内容有`text`、`author`、`tags`。\n\n定义`Item`，此时将`items.py`修改如下：\n\n```python\nimport scrapy\n\nclass QuoteItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    text = scrapy.Field()\n    author = scrapy.Field()\n    tags = scrapy.Field()\n```\n\n这里定义了三个字段，将类的名称修改为`QuoteItem`，接下来爬取时会使用到这个`Item`。\n\n## 解析Response\n\n`parse`方法的参数`response`是`start_urls`里面的链接爬取后的结果。所以在`parse`方法中，可以直接对`response`变量包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求。\n\n首先看看网页结构，如图所示。每一页都有多个`class`为`quote`的区块，每个区块内都包含`text`、`author`、`tags`。那么先找出所有的`quote`，然后提取每一个`quote`中的内容。\n\n![](Screenshot_1.webp)\n\n提取的方式可以是`CSS`选择器或`XPath`选择器。在这里使用`CSS`选择器进行选择，`parse`方法的改写如下所示：\n\n```python\nclass QuotesSpider(scrapy.Spider):\n    name = 'quotes'\n    allowed_domains = ['http://quotes.toscrape.com/']\n    start_urls = ['http://http://quotes.toscrape.com//']\n\n    def parse(self, response):\n        quotes = response.css('.quote')\n        for quote in quotes:\n            text = quote.css('.text::text').extract_first()\n            author = quote.css('.author::text').extract_first()\n            tags = quote.css('.tags .tag::text').extract()\n```\n\n对于`text`，获取结果的第一个元素即可，所以使用`extract_first`方法，对于`tags`，要获取所有结果组成的列表，所以使用`extract`方法。\n\n## 使用Item\n\n上文定义了`Item`，接下来就要使用它了。`Item`可以理解为一个字典，不过在声明的时候需要实例化。然后依次用刚才解析的结果赋值`Item`的每一个字段，最后将`Item`返回即可。\n\n`QuotesSpider`的改写如下所示：\n\n```python\n    def parse(self, response):\n        quotes = response.css('.quote')\n        for quote in quotes:\n            item = QuoteItem()\n            item['text'] = quote.css('.text::text').extract_first()\n            item['author'] = quote.css('.author::text').extract_first()\n            item['tags'] = quote.css('.tags .tag::text').extract()\n            yield item\n```\n\n如此一来，首页的所有内容被解析出来，并被赋值成了一个个`QuoteItem`。\n\n## 后续Request\n\n接下来就需要从当前页面中找到信息来生成下一个请求，然后在下一个请求的页面里面找到信息再构造下一个请求。这样循环往复迭代，从而实现整站的爬取。\n\n将刚才的页面拉到最底部，如图所示。\n\n![](Screenshot_2.webp)\n\n有一个`Next`按钮，查看一下源代码，可以发现它的链接是`/page/2/`，实际上全链接就是：`http://quotes.toscrape.com/page/2`，通过这个链接我们就可以构造下一个请求。\n\n构造请求时需要用到`scrapy.Request`。这里传递两个参数——`url`和`callback`，这两个参数的说明如下。\n\n- `url`：它是请求链接。\n- `callback`：它是回调函数。当指定了该回调函数的请求完成之后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。回调函数进行解析或生成下一个请求，回调函数如上文的`parse()`所示。\n\n由于`parse`就是解析`text`、`author`、`tags`的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以可以再次使用`parse`方法来做页面解析。\n\n接下来要做的就是利用选择器得到下一页链接并生成请求，在`parse`方法后追加如下的代码：\n\n```python\nnext = response.css('.pager .next a::attr(href)').extract_first()\nurl = response.urljoin(next)\nyield scrapy.Request(url=url, callback=self.parse, dont_filter=True)\n```\n\n第一句代码首先通过`CSS`选择器获取下一个页面的链接，即要获取`a`超链接中的`href`属性。这里用到了`::attr(href)`操作。然后再调用`extract_first`方法获取内容。\n\n第二句代码调用了`urljoin`方法，`urljoin()`方法可以将相对`URL`构造成一个绝对的`URL`。例如，获取到的下一页地址是`/page/2`，`urljoin`方法处理后得到的结果就是：`http://quotes.toscrape.com/page/2/`。\n\n第三句代码通过`url`和`callback`变量构造了一个新的请求，回调函数`callback`依然使用`parse`方法。这个请求完成后，响应会重新经过`parse`方法处理，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样爬虫就进入了一个循环，直到最后一页。`dont_filter`设置为`Ture`不进行域名过滤，这样就能继续爬取。\n\n通过几行代码，就轻松实现了一个抓取循环，将每个页面的结果抓取下来了。现在，改写之后的整个`Spider`类如下所示：\n\n```python\nimport scrapy\nfrom tutorial.items import QuoteItem\n\n\nclass QuotesSpider(scrapy.Spider):\n    name = 'quotes'\n    allowed_domains = ['quotes.toscrape.com/']\n    start_urls = ['http://quotes.toscrape.com/']\n\n    def parse(self, response):\n        quotes = response.css('.quote')\n        for quote in quotes:\n            item = QuoteItem()\n            item['text'] = quote.css('.text::text').extract_first()\n            item['author'] = quote.css('.author::text').extract_first()\n            item['tags'] = quote.css('.tags .tag::text').extract()\n            yield item\n\n        next = response.css('.pager .next a::attr(href)').extract_first()\n        if next !== \"\":\n          url = response.urljoin(next)\n          yield scrapy.Request(url=url, callback=self.parse, dont_filter=True)\n```\n\n## 运行\n\n进入目录，运行如下命令：\n\n```python\nscrapy crawl quotes\n```\n\n爬虫一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。\n\n最后，`Scrapy`输出了整个抓取过程的统计信息，如请求的字节数、请求次数、响应次数、完成原因等。\n\n## 保存到文件\n\n`Scrapy`提供的`Feed Exports`可以轻松将抓取结果输出。例如，想将上面的结果保存成`JSON`文件，可以执行如下命令：\n\n```python\nscrapy crawl quotes -o quotes.json\n```\n\n命令运行后，项目内多了一个`quotes.json`文件，文件包含了刚才抓取的所有内容，内容是`JSON`格式。\n\n![](Screenshot_3.webp)\n\n另外还可以每一个`Item`输出一行`JSON`，输出后缀为`jl`，为`jsonline`的缩写，命令如下所示：\n\n```python\nscrapy crawl quotes -o quotes.jl\n```\n\n或\n\n```python\nscrapy crawl quotes -o quotes.jsonlines\n```\n\n输出格式还支持很多种，例如`csv`、`xml`、`pickle`、`marshal`等，还支持`ftp`、`s3` 等远程输出，另外还可以通过自定义`ItemExporter`来实现其他的输出。\n\n例如，下面命令对应的输出分别为`csv`、`xml`、`pickle`、`marshal`格式以及`ftp`远程输出：\n\n```python\nscrapy crawl quotes -o quotes.csv\nscrapy crawl quotes -o quotes.xml\nscrapy crawl quotes -o quotes.pickle\nscrapy crawl quotes -o quotes.marshal\nscrapy crawl quotes -o ftp://user:pass@ftp.example.com/path/to/quotes.csv \n```\n\n其中，`ftp`输出需要正确配置用户名、密码、地址、输出路径，否则会报错。通过`Scrapy`提供的`Feed Exports`，可以轻松地输出抓取结果到文件。对于一些小型项目来说，这应该足够了。不过如果想要更复杂的输出，如输出到数据库等，可以使用`ItemPileline`来完成。\n\n## 使用ItemPileline\n\n如果想进行更复杂的操作，如将结果保存到`MongoDB`数据库，或者筛选某些有用的`Item`，则可以定义`ItemPipeline`来实现。\n\n`ItemPipeline`为项目管道。当`Item`生成后，它会自动被送到`ItemPipeline`进行处理，常用`ItemPipeline`来做如下操作。\n\n- 清洗`HTML`数据；\n- 验证爬取数据，检查爬取字段；\n- 查重并丢弃重复内容；\n- 将爬取结果储存到数据库。\n\n要实现`ItemPipeline`很简单，只需要定义一个类并实现`process_item`方法即可。启用`ItemPipeline`后，`ItemPipeline`会自动调用这个方法。`process_item`方法必须返回包含数据的字典或`Item`对象，或者抛出`DropItem`异常。\n\n`process_item`方法有两个参数。一个参数是`item`，每次`Spider`生成的`Item`都会作为参数传递过来。另一个参数是`spider`，就是`Spider`的实例。\n\n接下来，实现一个`ItemPipeline`，筛掉`text`长度大于`50`的`Item`，并将结果保存到`MongoDB`。\n\n修改项目里的`pipelines`.py文件，之前用命令行自动生成的文件内容可以删掉，增加一个`TextPipeline`类，内容如下所示：\n\n```python\nfrom scrapy.exceptions import DropItem\n\nclass TextPipeline(object):\n    def __init__(self):\n        self.limit = 50\n    \n    def process_item(self, item, spider):\n        if item['text']:\n            if len(item['text']) > self.limit:\n                item['text'] =item['text'][0:self.limit].rstrip() + '...'\n                return item\n            else:\n                return DropItem\n```\n\n这段代码在构造方法里定义了限制长度为50，实现了`process_item`方法，其参数是`item`和`spider`。首先该方法判断`item`的`text`属性是否存在，如果不存在，则抛出`DropItem`异常；如果存在，再判断长度是否大于50，如果大于，那就截断然后拼接省略号，再将`item`返回即可。\n\n将处理后的`item`存入`MongoDB`，定义另外一个`Pipeline`。同样在`pipelines.py`中，实现另一个类`MongoPipeline`，内容如下所示：\n\n```python\nimport pymongo\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DB'))\n        \n    def open_spider(self, spider):\n        self.client = pymongo.MongoClient(self.mongo_uri)\n        self.db = self.client[self.mongo_db]\n    \n    def process_item(self, item, spider): \n        name = item.__class__.__name__ \n        self.db[name].insert(dict(item)) \n        return item \n    \n    def close_spider(self, spider): \n        self.client.close()\n```\n\n`MongoPipeline`类实现了`API`定义的另外几个方法。\n\n- `from_crawler`：这是一个类方法，用`@classmethod`标识，是一种依赖注入的方式，方法的参数就是`crawler`，通过`crawler`这个参数我们可以拿到全局配置的每个配置信息，在全局配置`settings.py`中可以定义`MONGO_URI`和`MONGO_DB`来指定`MongoDB`连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法的定义主要是用来获取`settings.py`中的配置的。\n- `open_spider`：当`Spider`被开启时，这个方法被调用。在这里主要进行了一些初始化操作。\n- `close_spider`：当`Spider`被关闭时，这个方法会调用，在这里将数据库连接关闭。\n\n最主要的`process_item`方法则执行了数据插入操作。\n\n定义好`TextPipeline`和`MongoPipeline`这两个类后，需要在`settings.py`中使用它们。`MongoDB`的连接信息还需要定义。\n\n```python\nITEM_PIPELINES = {\n    'tutorial.pipelines.TextPipeline': 300,\n    'tutorial.pipelines.MongoPipeline': 400,\n}\nMONGO_URI='localhost'\nMONGO_DB='tutorial'\n```\n\n赋值`ITEM_PIPELINES`字典，键名是`Pipeline`的类名称，键值是调用优先级，是一个数字，数字越小则对应的`Pipeline`越先被调用。\n再重新执行爬取，命令如下所示：\n\n```python\nscrapy crawl quotes\n```\n\n爬取结束后，`MongoDB`中创建了一个`tutorial`的数据库、`QuoteItem`的表。\n","slug":"scrapy的基本使用","published":1,"updated":"2021-06-15T03:24:11.519Z","_id":"ckpapu7ig0010lcxucxt0bf3m","layout":"post","photos":[],"link":"","content":"<h2 id=\"抓取目标\"><a href=\"#抓取目标\" class=\"headerlink\" title=\"抓取目标\"></a>抓取目标</h2><p>要完成的任务如下。</p>\n<ul>\n<li>创建一个<code>Scrapy</code>项目。</li>\n<li>创建一个<code>Spider</code>来抓取站点和处理数据。</li>\n<li>通过命令行将抓取的内容导出。</li>\n<li>将抓取的内容保存到<code>MongoDB</code>数据库。</li>\n</ul>\n<p>抓取的目标站点为<a href=\"http://quotes.toscrape.com/\"></a>。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>安装好<code>scrapy</code>框架、<code>MongoDB</code>和<code>PyMongo</code>库。</p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p>创建一个<code>Scrapy</code>项目，项目文件可以直接用<code>Scrapy</code>命令生成，命令如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject tutorial</span><br></pre></td></tr></table></figure>\n\n<p>这个命令将会创建一个名为<code>tutorial</code>的文件夹，文件夹结构如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy.cfg    <span class=\"comment\"># Scrapy 部署时的配置文件 </span></span><br><span class=\"line\">tutorial    <span class=\"comment\"># 项目的模块，引入的时候需要从这里引入 </span></span><br><span class=\"line\">  __init__.py </span><br><span class=\"line\">  items.py    <span class=\"comment\"># Items 的定义，定义爬取的数据结构 </span></span><br><span class=\"line\">  middlewares.py     <span class=\"comment\"># Middlewares 的定义，定义爬取时的中间件 </span></span><br><span class=\"line\">  pipelines.py    <span class=\"comment\"># Pipelines 的定义，定义数据管道 </span></span><br><span class=\"line\">  settings.py     <span class=\"comment\"># 配置文件 </span></span><br><span class=\"line\">  spiders     <span class=\"comment\"># 放置 Spiders 的文件夹 </span></span><br><span class=\"line\">    __init__.py</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Spider\"><a href=\"#创建Spider\" class=\"headerlink\" title=\"创建Spider\"></a>创建Spider</h2><p><code>Spider</code>是自己定义的类，<code>Scrapy</code>用它从网页里抓取内容，并解析抓取的结果。不过这个类必须继承<code>Scrapy</code>提供的<code>Spider</code>类<code>scrapy.Spider</code>，还要定义<code>Spider</code>的名称和起始请求，以及怎样处理爬取后的结果的方法。</p>\n<p>也可以使用命令行创建一个<code>Spider</code>。比如要生成<code>Quotes</code>这个<code>Spider</code>，可以执行如下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scrapy genspider quotes quotes.toscrape.com     </span><br><span class=\"line\">Created spider <span class=\"string\">&#x27;quotes&#x27;</span> using template <span class=\"string\">&#x27;basic&#x27;</span> <span class=\"keyword\">in</span> module:</span><br><span class=\"line\">  tutorial.spiders.quotes</span><br></pre></td></tr></table></figure>\n\n<p>进入刚才创建的<code>tutorial</code>文件夹，然后执行<code>genspider</code>命令。第一个参数是<code>Spider</code>的名称，第二个参数是<code>网站域名</code>。执行完毕之后，<code>spiders</code>文件夹中多了一个<code>quotes.py</code>，它就是刚刚创建的<code>Spider</code>，内容如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span>(<span class=\"params\">scrapy.Spider</span>):</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;quotes&#x27;</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">&#x27;quotes.toscrape.com&#x27;</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;http://quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有三个属性——<code>name</code>、<code>allowed_domains</code>和<code>start_urls</code>，还有一个方法<code>parse</code>。</p>\n<ul>\n<li><code>name</code>：它是每个项目唯一的名字，用来区分不同的<code>Spider</code>。</li>\n<li><code>allowed_domains</code>：它是允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，则请求链接会被过滤掉。</li>\n<li><code>start_urls</code>：它包含了<code>Spider</code>在启动时爬取的<code>url</code>列表，初始请求是由它来定义的。</li>\n<li><code>parse</code>：它是<code>Spider</code>的一个方法。默认情况下，被调用时<code>start_urls</code>里面的链接构成的请求完成下载执行后，返回的响应就会作为唯一的参数传递给这个函数。该方法负责解析返回的响应、提取数据或者进一 步生成要处理的请求。</li>\n</ul>\n<h2 id=\"创建Item\"><a href=\"#创建Item\" class=\"headerlink\" title=\"创建Item\"></a>创建Item</h2><p><code>Item</code>是保存爬虫数据的容器，它的使用方法和字典类似，不过相比字典，<code>Item</code>多了额外的保护机制，可以避免拼写错误或者定义字段错误。</p>\n<p>创建<code>Item</code>需要继承<code>scrapy.Item</code>类，并且定义类型为<code>scrapy.Field</code>的字段。观察目标网站，可以获取到的内容有<code>text</code>、<code>author</code>、<code>tags</code>。</p>\n<p>定义<code>Item</code>，此时将<code>items.py</code>修改如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuoteItem</span>(<span class=\"params\">scrapy.Item</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># define the fields for your item here like:</span></span><br><span class=\"line\">    <span class=\"comment\"># name = scrapy.Field()</span></span><br><span class=\"line\">    text = scrapy.Field()</span><br><span class=\"line\">    author = scrapy.Field()</span><br><span class=\"line\">    tags = scrapy.Field()</span><br></pre></td></tr></table></figure>\n\n<p>这里定义了三个字段，将类的名称修改为<code>QuoteItem</code>，接下来爬取时会使用到这个<code>Item</code>。</p>\n<h2 id=\"解析Response\"><a href=\"#解析Response\" class=\"headerlink\" title=\"解析Response\"></a>解析Response</h2><p><code>parse</code>方法的参数<code>response</code>是<code>start_urls</code>里面的链接爬取后的结果。所以在<code>parse</code>方法中，可以直接对<code>response</code>变量包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求。</p>\n<p>首先看看网页结构，如图所示。每一页都有多个<code>class</code>为<code>quote</code>的区块，每个区块内都包含<code>text</code>、<code>author</code>、<code>tags</code>。那么先找出所有的<code>quote</code>，然后提取每一个<code>quote</code>中的内容。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>提取的方式可以是<code>CSS</code>选择器或<code>XPath</code>选择器。在这里使用<code>CSS</code>选择器进行选择，<code>parse</code>方法的改写如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span>(<span class=\"params\">scrapy.Spider</span>):</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;quotes&#x27;</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">&#x27;http://quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;http://http://quotes.toscrape.com//&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">        quotes = response.css(<span class=\"string\">&#x27;.quote&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> quote <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">            text = quote.css(<span class=\"string\">&#x27;.text::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            author = quote.css(<span class=\"string\">&#x27;.author::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            tags = quote.css(<span class=\"string\">&#x27;.tags .tag::text&#x27;</span>).extract()</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>text</code>，获取结果的第一个元素即可，所以使用<code>extract_first</code>方法，对于<code>tags</code>，要获取所有结果组成的列表，所以使用<code>extract</code>方法。</p>\n<h2 id=\"使用Item\"><a href=\"#使用Item\" class=\"headerlink\" title=\"使用Item\"></a>使用Item</h2><p>上文定义了<code>Item</code>，接下来就要使用它了。<code>Item</code>可以理解为一个字典，不过在声明的时候需要实例化。然后依次用刚才解析的结果赋值<code>Item</code>的每一个字段，最后将<code>Item</code>返回即可。</p>\n<p><code>QuotesSpider</code>的改写如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">    quotes = response.css(<span class=\"string\">&#x27;.quote&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> quote <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">        item = QuoteItem()</span><br><span class=\"line\">        item[<span class=\"string\">&#x27;text&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.text::text&#x27;</span>).extract_first()</span><br><span class=\"line\">        item[<span class=\"string\">&#x27;author&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.author::text&#x27;</span>).extract_first()</span><br><span class=\"line\">        item[<span class=\"string\">&#x27;tags&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.tags .tag::text&#x27;</span>).extract()</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> item</span><br></pre></td></tr></table></figure>\n\n<p>如此一来，首页的所有内容被解析出来，并被赋值成了一个个<code>QuoteItem</code>。</p>\n<h2 id=\"后续Request\"><a href=\"#后续Request\" class=\"headerlink\" title=\"后续Request\"></a>后续Request</h2><p>接下来就需要从当前页面中找到信息来生成下一个请求，然后在下一个请求的页面里面找到信息再构造下一个请求。这样循环往复迭代，从而实现整站的爬取。</p>\n<p>将刚才的页面拉到最底部，如图所示。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>有一个<code>Next</code>按钮，查看一下源代码，可以发现它的链接是<code>/page/2/</code>，实际上全链接就是：<code>http://quotes.toscrape.com/page/2</code>，通过这个链接我们就可以构造下一个请求。</p>\n<p>构造请求时需要用到<code>scrapy.Request</code>。这里传递两个参数——<code>url</code>和<code>callback</code>，这两个参数的说明如下。</p>\n<ul>\n<li><code>url</code>：它是请求链接。</li>\n<li><code>callback</code>：它是回调函数。当指定了该回调函数的请求完成之后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。回调函数进行解析或生成下一个请求，回调函数如上文的<code>parse()</code>所示。</li>\n</ul>\n<p>由于<code>parse</code>就是解析<code>text</code>、<code>author</code>、<code>tags</code>的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以可以再次使用<code>parse</code>方法来做页面解析。</p>\n<p>接下来要做的就是利用选择器得到下一页链接并生成请求，在<code>parse</code>方法后追加如下的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">next</span> = response.css(<span class=\"string\">&#x27;.pager .next a::attr(href)&#x27;</span>).extract_first()</span><br><span class=\"line\">url = response.urljoin(<span class=\"built_in\">next</span>)</span><br><span class=\"line\"><span class=\"keyword\">yield</span> scrapy.Request(url=url, callback=self.parse, dont_filter=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第一句代码首先通过<code>CSS</code>选择器获取下一个页面的链接，即要获取<code>a</code>超链接中的<code>href</code>属性。这里用到了<code>::attr(href)</code>操作。然后再调用<code>extract_first</code>方法获取内容。</p>\n<p>第二句代码调用了<code>urljoin</code>方法，<code>urljoin()</code>方法可以将相对<code>URL</code>构造成一个绝对的<code>URL</code>。例如，获取到的下一页地址是<code>/page/2</code>，<code>urljoin</code>方法处理后得到的结果就是：<code>http://quotes.toscrape.com/page/2/</code>。</p>\n<p>第三句代码通过<code>url</code>和<code>callback</code>变量构造了一个新的请求，回调函数<code>callback</code>依然使用<code>parse</code>方法。这个请求完成后，响应会重新经过<code>parse</code>方法处理，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样爬虫就进入了一个循环，直到最后一页。<code>dont_filter</code>设置为<code>Ture</code>不进行域名过滤，这样就能继续爬取。</p>\n<p>通过几行代码，就轻松实现了一个抓取循环，将每个页面的结果抓取下来了。现在，改写之后的整个<code>Spider</code>类如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> tutorial.items <span class=\"keyword\">import</span> QuoteItem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span>(<span class=\"params\">scrapy.Spider</span>):</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;quotes&#x27;</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">&#x27;quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;http://quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">        quotes = response.css(<span class=\"string\">&#x27;.quote&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> quote <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">            item = QuoteItem()</span><br><span class=\"line\">            item[<span class=\"string\">&#x27;text&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.text::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            item[<span class=\"string\">&#x27;author&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.author::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            item[<span class=\"string\">&#x27;tags&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.tags .tag::text&#x27;</span>).extract()</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">next</span> = response.css(<span class=\"string\">&#x27;.pager .next a::attr(href)&#x27;</span>).extract_first()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">next</span> !== <span class=\"string\">&quot;&quot;</span>:</span><br><span class=\"line\">          url = response.urljoin(<span class=\"built_in\">next</span>)</span><br><span class=\"line\">          <span class=\"keyword\">yield</span> scrapy.Request(url=url, callback=self.parse, dont_filter=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>进入目录，运行如下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes</span><br></pre></td></tr></table></figure>\n\n<p>爬虫一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。</p>\n<p>最后，<code>Scrapy</code>输出了整个抓取过程的统计信息，如请求的字节数、请求次数、响应次数、完成原因等。</p>\n<h2 id=\"保存到文件\"><a href=\"#保存到文件\" class=\"headerlink\" title=\"保存到文件\"></a>保存到文件</h2><p><code>Scrapy</code>提供的<code>Feed Exports</code>可以轻松将抓取结果输出。例如，想将上面的结果保存成<code>JSON</code>文件，可以执行如下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.json</span><br></pre></td></tr></table></figure>\n\n<p>命令运行后，项目内多了一个<code>quotes.json</code>文件，文件包含了刚才抓取的所有内容，内容是<code>JSON</code>格式。</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p>另外还可以每一个<code>Item</code>输出一行<code>JSON</code>，输出后缀为<code>jl</code>，为<code>jsonline</code>的缩写，命令如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.jl</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.jsonlines</span><br></pre></td></tr></table></figure>\n\n<p>输出格式还支持很多种，例如<code>csv</code>、<code>xml</code>、<code>pickle</code>、<code>marshal</code>等，还支持<code>ftp</code>、<code>s3</code> 等远程输出，另外还可以通过自定义<code>ItemExporter</code>来实现其他的输出。</p>\n<p>例如，下面命令对应的输出分别为<code>csv</code>、<code>xml</code>、<code>pickle</code>、<code>marshal</code>格式以及<code>ftp</code>远程输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.csv</span><br><span class=\"line\">scrapy crawl quotes -o quotes.xml</span><br><span class=\"line\">scrapy crawl quotes -o quotes.pickle</span><br><span class=\"line\">scrapy crawl quotes -o quotes.marshal</span><br><span class=\"line\">scrapy crawl quotes -o ftp://user:<span class=\"keyword\">pass</span>@ftp.example.com/path/to/quotes.csv </span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>ftp</code>输出需要正确配置用户名、密码、地址、输出路径，否则会报错。通过<code>Scrapy</code>提供的<code>Feed Exports</code>，可以轻松地输出抓取结果到文件。对于一些小型项目来说，这应该足够了。不过如果想要更复杂的输出，如输出到数据库等，可以使用<code>ItemPileline</code>来完成。</p>\n<h2 id=\"使用ItemPileline\"><a href=\"#使用ItemPileline\" class=\"headerlink\" title=\"使用ItemPileline\"></a>使用ItemPileline</h2><p>如果想进行更复杂的操作，如将结果保存到<code>MongoDB</code>数据库，或者筛选某些有用的<code>Item</code>，则可以定义<code>ItemPipeline</code>来实现。</p>\n<p><code>ItemPipeline</code>为项目管道。当<code>Item</code>生成后，它会自动被送到<code>ItemPipeline</code>进行处理，常用<code>ItemPipeline</code>来做如下操作。</p>\n<ul>\n<li>清洗<code>HTML</code>数据；</li>\n<li>验证爬取数据，检查爬取字段；</li>\n<li>查重并丢弃重复内容；</li>\n<li>将爬取结果储存到数据库。</li>\n</ul>\n<p>要实现<code>ItemPipeline</code>很简单，只需要定义一个类并实现<code>process_item</code>方法即可。启用<code>ItemPipeline</code>后，<code>ItemPipeline</code>会自动调用这个方法。<code>process_item</code>方法必须返回包含数据的字典或<code>Item</code>对象，或者抛出<code>DropItem</code>异常。</p>\n<p><code>process_item</code>方法有两个参数。一个参数是<code>item</code>，每次<code>Spider</code>生成的<code>Item</code>都会作为参数传递过来。另一个参数是<code>spider</code>，就是<code>Spider</code>的实例。</p>\n<p>接下来，实现一个<code>ItemPipeline</code>，筛掉<code>text</code>长度大于<code>50</code>的<code>Item</code>，并将结果保存到<code>MongoDB</code>。</p>\n<p>修改项目里的<code>pipelines</code>.py文件，之前用命令行自动生成的文件内容可以删掉，增加一个<code>TextPipeline</code>类，内容如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.exceptions <span class=\"keyword\">import</span> DropItem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextPipeline</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.limit = <span class=\"number\">50</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span>(<span class=\"params\">self, item, spider</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> item[<span class=\"string\">&#x27;text&#x27;</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(item[<span class=\"string\">&#x27;text&#x27;</span>]) &gt; self.limit:</span><br><span class=\"line\">                item[<span class=\"string\">&#x27;text&#x27;</span>] =item[<span class=\"string\">&#x27;text&#x27;</span>][<span class=\"number\">0</span>:self.limit].rstrip() + <span class=\"string\">&#x27;...&#x27;</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> item</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DropItem</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在构造方法里定义了限制长度为50，实现了<code>process_item</code>方法，其参数是<code>item</code>和<code>spider</code>。首先该方法判断<code>item</code>的<code>text</code>属性是否存在，如果不存在，则抛出<code>DropItem</code>异常；如果存在，再判断长度是否大于50，如果大于，那就截断然后拼接省略号，再将<code>item</code>返回即可。</p>\n<p>将处理后的<code>item</code>存入<code>MongoDB</code>，定义另外一个<code>Pipeline</code>。同样在<code>pipelines.py</code>中，实现另一个类<code>MongoPipeline</code>，内容如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span>(<span class=\"params\">cls, crawler</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls(mongo_uri=crawler.settings.get(<span class=\"string\">&#x27;MONGO_URI&#x27;</span>), mongo_db=crawler.settings.get(<span class=\"string\">&#x27;MONGO_DB&#x27;</span>))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">open_spider</span>(<span class=\"params\">self, spider</span>):</span></span><br><span class=\"line\">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class=\"line\">        self.db = self.client[self.mongo_db]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span>(<span class=\"params\">self, item, spider</span>):</span> </span><br><span class=\"line\">        name = item.__class__.__name__ </span><br><span class=\"line\">        self.db[name].insert(<span class=\"built_in\">dict</span>(item)) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> item </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">close_spider</span>(<span class=\"params\">self, spider</span>):</span> </span><br><span class=\"line\">        self.client.close()</span><br></pre></td></tr></table></figure>\n\n<p><code>MongoPipeline</code>类实现了<code>API</code>定义的另外几个方法。</p>\n<ul>\n<li><code>from_crawler</code>：这是一个类方法，用<code>@classmethod</code>标识，是一种依赖注入的方式，方法的参数就是<code>crawler</code>，通过<code>crawler</code>这个参数我们可以拿到全局配置的每个配置信息，在全局配置<code>settings.py</code>中可以定义<code>MONGO_URI</code>和<code>MONGO_DB</code>来指定<code>MongoDB</code>连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法的定义主要是用来获取<code>settings.py</code>中的配置的。</li>\n<li><code>open_spider</code>：当<code>Spider</code>被开启时，这个方法被调用。在这里主要进行了一些初始化操作。</li>\n<li><code>close_spider</code>：当<code>Spider</code>被关闭时，这个方法会调用，在这里将数据库连接关闭。</li>\n</ul>\n<p>最主要的<code>process_item</code>方法则执行了数据插入操作。</p>\n<p>定义好<code>TextPipeline</code>和<code>MongoPipeline</code>这两个类后，需要在<code>settings.py</code>中使用它们。<code>MongoDB</code>的连接信息还需要定义。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINES = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;tutorial.pipelines.TextPipeline&#x27;</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;tutorial.pipelines.MongoPipeline&#x27;</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MONGO_URI=<span class=\"string\">&#x27;localhost&#x27;</span></span><br><span class=\"line\">MONGO_DB=<span class=\"string\">&#x27;tutorial&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>赋值<code>ITEM_PIPELINES</code>字典，键名是<code>Pipeline</code>的类名称，键值是调用优先级，是一个数字，数字越小则对应的<code>Pipeline</code>越先被调用。<br>再重新执行爬取，命令如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes</span><br></pre></td></tr></table></figure>\n\n<p>爬取结束后，<code>MongoDB</code>中创建了一个<code>tutorial</code>的数据库、<code>QuoteItem</code>的表。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"抓取目标\"><a href=\"#抓取目标\" class=\"headerlink\" title=\"抓取目标\"></a>抓取目标</h2><p>要完成的任务如下。</p>\n<ul>\n<li>创建一个<code>Scrapy</code>项目。</li>\n<li>创建一个<code>Spider</code>来抓取站点和处理数据。</li>\n<li>通过命令行将抓取的内容导出。</li>\n<li>将抓取的内容保存到<code>MongoDB</code>数据库。</li>\n</ul>\n<p>抓取的目标站点为<a href=\"http://quotes.toscrape.com/\"></a>。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>安装好<code>scrapy</code>框架、<code>MongoDB</code>和<code>PyMongo</code>库。</p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p>创建一个<code>Scrapy</code>项目，项目文件可以直接用<code>Scrapy</code>命令生成，命令如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject tutorial</span><br></pre></td></tr></table></figure>\n\n<p>这个命令将会创建一个名为<code>tutorial</code>的文件夹，文件夹结构如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy.cfg    <span class=\"comment\"># Scrapy 部署时的配置文件 </span></span><br><span class=\"line\">tutorial    <span class=\"comment\"># 项目的模块，引入的时候需要从这里引入 </span></span><br><span class=\"line\">  __init__.py </span><br><span class=\"line\">  items.py    <span class=\"comment\"># Items 的定义，定义爬取的数据结构 </span></span><br><span class=\"line\">  middlewares.py     <span class=\"comment\"># Middlewares 的定义，定义爬取时的中间件 </span></span><br><span class=\"line\">  pipelines.py    <span class=\"comment\"># Pipelines 的定义，定义数据管道 </span></span><br><span class=\"line\">  settings.py     <span class=\"comment\"># 配置文件 </span></span><br><span class=\"line\">  spiders     <span class=\"comment\"># 放置 Spiders 的文件夹 </span></span><br><span class=\"line\">    __init__.py</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Spider\"><a href=\"#创建Spider\" class=\"headerlink\" title=\"创建Spider\"></a>创建Spider</h2><p><code>Spider</code>是自己定义的类，<code>Scrapy</code>用它从网页里抓取内容，并解析抓取的结果。不过这个类必须继承<code>Scrapy</code>提供的<code>Spider</code>类<code>scrapy.Spider</code>，还要定义<code>Spider</code>的名称和起始请求，以及怎样处理爬取后的结果的方法。</p>\n<p>也可以使用命令行创建一个<code>Spider</code>。比如要生成<code>Quotes</code>这个<code>Spider</code>，可以执行如下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scrapy genspider quotes quotes.toscrape.com     </span><br><span class=\"line\">Created spider <span class=\"string\">&#x27;quotes&#x27;</span> using template <span class=\"string\">&#x27;basic&#x27;</span> <span class=\"keyword\">in</span> module:</span><br><span class=\"line\">  tutorial.spiders.quotes</span><br></pre></td></tr></table></figure>\n\n<p>进入刚才创建的<code>tutorial</code>文件夹，然后执行<code>genspider</code>命令。第一个参数是<code>Spider</code>的名称，第二个参数是<code>网站域名</code>。执行完毕之后，<code>spiders</code>文件夹中多了一个<code>quotes.py</code>，它就是刚刚创建的<code>Spider</code>，内容如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span>(<span class=\"params\">scrapy.Spider</span>):</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;quotes&#x27;</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">&#x27;quotes.toscrape.com&#x27;</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;http://quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有三个属性——<code>name</code>、<code>allowed_domains</code>和<code>start_urls</code>，还有一个方法<code>parse</code>。</p>\n<ul>\n<li><code>name</code>：它是每个项目唯一的名字，用来区分不同的<code>Spider</code>。</li>\n<li><code>allowed_domains</code>：它是允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，则请求链接会被过滤掉。</li>\n<li><code>start_urls</code>：它包含了<code>Spider</code>在启动时爬取的<code>url</code>列表，初始请求是由它来定义的。</li>\n<li><code>parse</code>：它是<code>Spider</code>的一个方法。默认情况下，被调用时<code>start_urls</code>里面的链接构成的请求完成下载执行后，返回的响应就会作为唯一的参数传递给这个函数。该方法负责解析返回的响应、提取数据或者进一 步生成要处理的请求。</li>\n</ul>\n<h2 id=\"创建Item\"><a href=\"#创建Item\" class=\"headerlink\" title=\"创建Item\"></a>创建Item</h2><p><code>Item</code>是保存爬虫数据的容器，它的使用方法和字典类似，不过相比字典，<code>Item</code>多了额外的保护机制，可以避免拼写错误或者定义字段错误。</p>\n<p>创建<code>Item</code>需要继承<code>scrapy.Item</code>类，并且定义类型为<code>scrapy.Field</code>的字段。观察目标网站，可以获取到的内容有<code>text</code>、<code>author</code>、<code>tags</code>。</p>\n<p>定义<code>Item</code>，此时将<code>items.py</code>修改如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuoteItem</span>(<span class=\"params\">scrapy.Item</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># define the fields for your item here like:</span></span><br><span class=\"line\">    <span class=\"comment\"># name = scrapy.Field()</span></span><br><span class=\"line\">    text = scrapy.Field()</span><br><span class=\"line\">    author = scrapy.Field()</span><br><span class=\"line\">    tags = scrapy.Field()</span><br></pre></td></tr></table></figure>\n\n<p>这里定义了三个字段，将类的名称修改为<code>QuoteItem</code>，接下来爬取时会使用到这个<code>Item</code>。</p>\n<h2 id=\"解析Response\"><a href=\"#解析Response\" class=\"headerlink\" title=\"解析Response\"></a>解析Response</h2><p><code>parse</code>方法的参数<code>response</code>是<code>start_urls</code>里面的链接爬取后的结果。所以在<code>parse</code>方法中，可以直接对<code>response</code>变量包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求。</p>\n<p>首先看看网页结构，如图所示。每一页都有多个<code>class</code>为<code>quote</code>的区块，每个区块内都包含<code>text</code>、<code>author</code>、<code>tags</code>。那么先找出所有的<code>quote</code>，然后提取每一个<code>quote</code>中的内容。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>提取的方式可以是<code>CSS</code>选择器或<code>XPath</code>选择器。在这里使用<code>CSS</code>选择器进行选择，<code>parse</code>方法的改写如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span>(<span class=\"params\">scrapy.Spider</span>):</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;quotes&#x27;</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">&#x27;http://quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;http://http://quotes.toscrape.com//&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">        quotes = response.css(<span class=\"string\">&#x27;.quote&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> quote <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">            text = quote.css(<span class=\"string\">&#x27;.text::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            author = quote.css(<span class=\"string\">&#x27;.author::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            tags = quote.css(<span class=\"string\">&#x27;.tags .tag::text&#x27;</span>).extract()</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>text</code>，获取结果的第一个元素即可，所以使用<code>extract_first</code>方法，对于<code>tags</code>，要获取所有结果组成的列表，所以使用<code>extract</code>方法。</p>\n<h2 id=\"使用Item\"><a href=\"#使用Item\" class=\"headerlink\" title=\"使用Item\"></a>使用Item</h2><p>上文定义了<code>Item</code>，接下来就要使用它了。<code>Item</code>可以理解为一个字典，不过在声明的时候需要实例化。然后依次用刚才解析的结果赋值<code>Item</code>的每一个字段，最后将<code>Item</code>返回即可。</p>\n<p><code>QuotesSpider</code>的改写如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">    quotes = response.css(<span class=\"string\">&#x27;.quote&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> quote <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">        item = QuoteItem()</span><br><span class=\"line\">        item[<span class=\"string\">&#x27;text&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.text::text&#x27;</span>).extract_first()</span><br><span class=\"line\">        item[<span class=\"string\">&#x27;author&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.author::text&#x27;</span>).extract_first()</span><br><span class=\"line\">        item[<span class=\"string\">&#x27;tags&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.tags .tag::text&#x27;</span>).extract()</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> item</span><br></pre></td></tr></table></figure>\n\n<p>如此一来，首页的所有内容被解析出来，并被赋值成了一个个<code>QuoteItem</code>。</p>\n<h2 id=\"后续Request\"><a href=\"#后续Request\" class=\"headerlink\" title=\"后续Request\"></a>后续Request</h2><p>接下来就需要从当前页面中找到信息来生成下一个请求，然后在下一个请求的页面里面找到信息再构造下一个请求。这样循环往复迭代，从而实现整站的爬取。</p>\n<p>将刚才的页面拉到最底部，如图所示。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>有一个<code>Next</code>按钮，查看一下源代码，可以发现它的链接是<code>/page/2/</code>，实际上全链接就是：<code>http://quotes.toscrape.com/page/2</code>，通过这个链接我们就可以构造下一个请求。</p>\n<p>构造请求时需要用到<code>scrapy.Request</code>。这里传递两个参数——<code>url</code>和<code>callback</code>，这两个参数的说明如下。</p>\n<ul>\n<li><code>url</code>：它是请求链接。</li>\n<li><code>callback</code>：它是回调函数。当指定了该回调函数的请求完成之后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。回调函数进行解析或生成下一个请求，回调函数如上文的<code>parse()</code>所示。</li>\n</ul>\n<p>由于<code>parse</code>就是解析<code>text</code>、<code>author</code>、<code>tags</code>的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以可以再次使用<code>parse</code>方法来做页面解析。</p>\n<p>接下来要做的就是利用选择器得到下一页链接并生成请求，在<code>parse</code>方法后追加如下的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">next</span> = response.css(<span class=\"string\">&#x27;.pager .next a::attr(href)&#x27;</span>).extract_first()</span><br><span class=\"line\">url = response.urljoin(<span class=\"built_in\">next</span>)</span><br><span class=\"line\"><span class=\"keyword\">yield</span> scrapy.Request(url=url, callback=self.parse, dont_filter=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第一句代码首先通过<code>CSS</code>选择器获取下一个页面的链接，即要获取<code>a</code>超链接中的<code>href</code>属性。这里用到了<code>::attr(href)</code>操作。然后再调用<code>extract_first</code>方法获取内容。</p>\n<p>第二句代码调用了<code>urljoin</code>方法，<code>urljoin()</code>方法可以将相对<code>URL</code>构造成一个绝对的<code>URL</code>。例如，获取到的下一页地址是<code>/page/2</code>，<code>urljoin</code>方法处理后得到的结果就是：<code>http://quotes.toscrape.com/page/2/</code>。</p>\n<p>第三句代码通过<code>url</code>和<code>callback</code>变量构造了一个新的请求，回调函数<code>callback</code>依然使用<code>parse</code>方法。这个请求完成后，响应会重新经过<code>parse</code>方法处理，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样爬虫就进入了一个循环，直到最后一页。<code>dont_filter</code>设置为<code>Ture</code>不进行域名过滤，这样就能继续爬取。</p>\n<p>通过几行代码，就轻松实现了一个抓取循环，将每个页面的结果抓取下来了。现在，改写之后的整个<code>Spider</code>类如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> tutorial.items <span class=\"keyword\">import</span> QuoteItem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuotesSpider</span>(<span class=\"params\">scrapy.Spider</span>):</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;quotes&#x27;</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">&#x27;quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;http://quotes.toscrape.com/&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span>(<span class=\"params\">self, response</span>):</span></span><br><span class=\"line\">        quotes = response.css(<span class=\"string\">&#x27;.quote&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> quote <span class=\"keyword\">in</span> quotes:</span><br><span class=\"line\">            item = QuoteItem()</span><br><span class=\"line\">            item[<span class=\"string\">&#x27;text&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.text::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            item[<span class=\"string\">&#x27;author&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.author::text&#x27;</span>).extract_first()</span><br><span class=\"line\">            item[<span class=\"string\">&#x27;tags&#x27;</span>] = quote.css(<span class=\"string\">&#x27;.tags .tag::text&#x27;</span>).extract()</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">next</span> = response.css(<span class=\"string\">&#x27;.pager .next a::attr(href)&#x27;</span>).extract_first()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">next</span> !== <span class=\"string\">&quot;&quot;</span>:</span><br><span class=\"line\">          url = response.urljoin(<span class=\"built_in\">next</span>)</span><br><span class=\"line\">          <span class=\"keyword\">yield</span> scrapy.Request(url=url, callback=self.parse, dont_filter=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>进入目录，运行如下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes</span><br></pre></td></tr></table></figure>\n\n<p>爬虫一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。</p>\n<p>最后，<code>Scrapy</code>输出了整个抓取过程的统计信息，如请求的字节数、请求次数、响应次数、完成原因等。</p>\n<h2 id=\"保存到文件\"><a href=\"#保存到文件\" class=\"headerlink\" title=\"保存到文件\"></a>保存到文件</h2><p><code>Scrapy</code>提供的<code>Feed Exports</code>可以轻松将抓取结果输出。例如，想将上面的结果保存成<code>JSON</code>文件，可以执行如下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.json</span><br></pre></td></tr></table></figure>\n\n<p>命令运行后，项目内多了一个<code>quotes.json</code>文件，文件包含了刚才抓取的所有内容，内容是<code>JSON</code>格式。</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p>另外还可以每一个<code>Item</code>输出一行<code>JSON</code>，输出后缀为<code>jl</code>，为<code>jsonline</code>的缩写，命令如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.jl</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.jsonlines</span><br></pre></td></tr></table></figure>\n\n<p>输出格式还支持很多种，例如<code>csv</code>、<code>xml</code>、<code>pickle</code>、<code>marshal</code>等，还支持<code>ftp</code>、<code>s3</code> 等远程输出，另外还可以通过自定义<code>ItemExporter</code>来实现其他的输出。</p>\n<p>例如，下面命令对应的输出分别为<code>csv</code>、<code>xml</code>、<code>pickle</code>、<code>marshal</code>格式以及<code>ftp</code>远程输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes -o quotes.csv</span><br><span class=\"line\">scrapy crawl quotes -o quotes.xml</span><br><span class=\"line\">scrapy crawl quotes -o quotes.pickle</span><br><span class=\"line\">scrapy crawl quotes -o quotes.marshal</span><br><span class=\"line\">scrapy crawl quotes -o ftp://user:<span class=\"keyword\">pass</span>@ftp.example.com/path/to/quotes.csv </span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>ftp</code>输出需要正确配置用户名、密码、地址、输出路径，否则会报错。通过<code>Scrapy</code>提供的<code>Feed Exports</code>，可以轻松地输出抓取结果到文件。对于一些小型项目来说，这应该足够了。不过如果想要更复杂的输出，如输出到数据库等，可以使用<code>ItemPileline</code>来完成。</p>\n<h2 id=\"使用ItemPileline\"><a href=\"#使用ItemPileline\" class=\"headerlink\" title=\"使用ItemPileline\"></a>使用ItemPileline</h2><p>如果想进行更复杂的操作，如将结果保存到<code>MongoDB</code>数据库，或者筛选某些有用的<code>Item</code>，则可以定义<code>ItemPipeline</code>来实现。</p>\n<p><code>ItemPipeline</code>为项目管道。当<code>Item</code>生成后，它会自动被送到<code>ItemPipeline</code>进行处理，常用<code>ItemPipeline</code>来做如下操作。</p>\n<ul>\n<li>清洗<code>HTML</code>数据；</li>\n<li>验证爬取数据，检查爬取字段；</li>\n<li>查重并丢弃重复内容；</li>\n<li>将爬取结果储存到数据库。</li>\n</ul>\n<p>要实现<code>ItemPipeline</code>很简单，只需要定义一个类并实现<code>process_item</code>方法即可。启用<code>ItemPipeline</code>后，<code>ItemPipeline</code>会自动调用这个方法。<code>process_item</code>方法必须返回包含数据的字典或<code>Item</code>对象，或者抛出<code>DropItem</code>异常。</p>\n<p><code>process_item</code>方法有两个参数。一个参数是<code>item</code>，每次<code>Spider</code>生成的<code>Item</code>都会作为参数传递过来。另一个参数是<code>spider</code>，就是<code>Spider</code>的实例。</p>\n<p>接下来，实现一个<code>ItemPipeline</code>，筛掉<code>text</code>长度大于<code>50</code>的<code>Item</code>，并将结果保存到<code>MongoDB</code>。</p>\n<p>修改项目里的<code>pipelines</code>.py文件，之前用命令行自动生成的文件内容可以删掉，增加一个<code>TextPipeline</code>类，内容如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.exceptions <span class=\"keyword\">import</span> DropItem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextPipeline</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.limit = <span class=\"number\">50</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span>(<span class=\"params\">self, item, spider</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> item[<span class=\"string\">&#x27;text&#x27;</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(item[<span class=\"string\">&#x27;text&#x27;</span>]) &gt; self.limit:</span><br><span class=\"line\">                item[<span class=\"string\">&#x27;text&#x27;</span>] =item[<span class=\"string\">&#x27;text&#x27;</span>][<span class=\"number\">0</span>:self.limit].rstrip() + <span class=\"string\">&#x27;...&#x27;</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> item</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DropItem</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在构造方法里定义了限制长度为50，实现了<code>process_item</code>方法，其参数是<code>item</code>和<code>spider</code>。首先该方法判断<code>item</code>的<code>text</code>属性是否存在，如果不存在，则抛出<code>DropItem</code>异常；如果存在，再判断长度是否大于50，如果大于，那就截断然后拼接省略号，再将<code>item</code>返回即可。</p>\n<p>将处理后的<code>item</code>存入<code>MongoDB</code>，定义另外一个<code>Pipeline</code>。同样在<code>pipelines.py</code>中，实现另一个类<code>MongoPipeline</code>，内容如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span>(<span class=\"params\">cls, crawler</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls(mongo_uri=crawler.settings.get(<span class=\"string\">&#x27;MONGO_URI&#x27;</span>), mongo_db=crawler.settings.get(<span class=\"string\">&#x27;MONGO_DB&#x27;</span>))</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">open_spider</span>(<span class=\"params\">self, spider</span>):</span></span><br><span class=\"line\">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class=\"line\">        self.db = self.client[self.mongo_db]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span>(<span class=\"params\">self, item, spider</span>):</span> </span><br><span class=\"line\">        name = item.__class__.__name__ </span><br><span class=\"line\">        self.db[name].insert(<span class=\"built_in\">dict</span>(item)) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> item </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">close_spider</span>(<span class=\"params\">self, spider</span>):</span> </span><br><span class=\"line\">        self.client.close()</span><br></pre></td></tr></table></figure>\n\n<p><code>MongoPipeline</code>类实现了<code>API</code>定义的另外几个方法。</p>\n<ul>\n<li><code>from_crawler</code>：这是一个类方法，用<code>@classmethod</code>标识，是一种依赖注入的方式，方法的参数就是<code>crawler</code>，通过<code>crawler</code>这个参数我们可以拿到全局配置的每个配置信息，在全局配置<code>settings.py</code>中可以定义<code>MONGO_URI</code>和<code>MONGO_DB</code>来指定<code>MongoDB</code>连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法的定义主要是用来获取<code>settings.py</code>中的配置的。</li>\n<li><code>open_spider</code>：当<code>Spider</code>被开启时，这个方法被调用。在这里主要进行了一些初始化操作。</li>\n<li><code>close_spider</code>：当<code>Spider</code>被关闭时，这个方法会调用，在这里将数据库连接关闭。</li>\n</ul>\n<p>最主要的<code>process_item</code>方法则执行了数据插入操作。</p>\n<p>定义好<code>TextPipeline</code>和<code>MongoPipeline</code>这两个类后，需要在<code>settings.py</code>中使用它们。<code>MongoDB</code>的连接信息还需要定义。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINES = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;tutorial.pipelines.TextPipeline&#x27;</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;tutorial.pipelines.MongoPipeline&#x27;</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MONGO_URI=<span class=\"string\">&#x27;localhost&#x27;</span></span><br><span class=\"line\">MONGO_DB=<span class=\"string\">&#x27;tutorial&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>赋值<code>ITEM_PIPELINES</code>字典，键名是<code>Pipeline</code>的类名称，键值是调用优先级，是一个数字，数字越小则对应的<code>Pipeline</code>越先被调用。<br>再重新执行爬取，命令如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl quotes</span><br></pre></td></tr></table></figure>\n\n<p>爬取结束后，<code>MongoDB</code>中创建了一个<code>tutorial</code>的数据库、<code>QuoteItem</code>的表。</p>\n"},{"title":"web网页基础","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-11T15:32:38.000Z","pic":null,"_content":"\n# 网页的组成\n\n首先，我们来了解网页的基本组成，网页可以分为三大部分：`HTML`、`CSS`和`JavaScript`。 如果把网页比作一个人的话，`HTML`相当于骨架，`JavaScript`相当于肌肉，`CSS`相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。\n\n## HTML\n\n`HTML`是用来描述网页的一种语言，其全称叫作`Hyper Text Markup Language`，即超文本标记语言。\n\n我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是`HTML`。不同类型的元素通过不同类型的标签来表示，如图片用`img`标签表示，视频用`video`标签表示，段落用`p`标签表示，它们之间的布局又常通过布局标签`div`嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 \n\n在`Chrome`浏览器中打开百度，右击并选择 “检查”项（或按`F12键`），打开开发者模式，这时在`Elements`选项卡中即可看到网页的源代码，如图所示。\n\n![HTML结构](Screenshot_1.png)\n\n这就是`HTML`，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。\n\n## CSS\n\n虽然`HTML`定义了网页的结构，但是只有`HTML`页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助`CSS`了。\n\n`CSS`，全称叫作`Cascading Style Sheets`，即`层叠样式表`。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。\n\n`CSS`是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：\n\n```css\n#head_wrapper.s-ps-islite .s-p-top { \n    position: absolute; \n    bottom: 40px; \n    width: 100%; \n    height: 181px; \n    }\n```\n\n这就是一个`CSS`样式。大括号前面是一个`CSS选择器`。此选择器的作用是首先选中`id`为`head_wrapper`且`class` 为`s-ps-islite`的节点，然后再选中其内部的`class`为`s-p-top`的节点。大括号内部写的就是一条条样式规则，例如`position`指定了这个元素的布局方式为**绝对布局**，`bottom`指定元素的下边距为**40像素**，`width`指定了宽度为**100%**占满父元素，`height`则指定了元素的**高度**。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上`CSS`选择器，这就代表这个样式对`CSS`选择器选中的元素生效，元素就会根据此样式来展示了。\n\n在网页中，一般会统一定义整个网页的样式规则，并写入`CSS`文件中（其后缀为css）。在HTML中，只需要用`link`标签即可引入写好的`CSS`文件，这样整个页面就会变得美观、优雅。\n\n## JavaScript \n\n`JavaScript`，简称`JS`，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是`JavaScript`的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种**实时、动态、交互**的页面功能。\n\n`JavaScript`通常也是以单独的文件形式加载的，后缀为`js`，在 HTML中通过`script标签`即可引入，例如:\n\n```html\n<script src=\"jquery-2.1.0.js\"></script>\n```\n\n综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，`JavaScript`定义了网页的行为。\n","source":"_posts/web网页基础.md","raw":"---\ntitle: web网页基础\ntags:\n  - html\n  - css\n  - javascript\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-11 23:32:38\ncategories: 爬虫\npic:\n---\n\n# 网页的组成\n\n首先，我们来了解网页的基本组成，网页可以分为三大部分：`HTML`、`CSS`和`JavaScript`。 如果把网页比作一个人的话，`HTML`相当于骨架，`JavaScript`相当于肌肉，`CSS`相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。\n\n## HTML\n\n`HTML`是用来描述网页的一种语言，其全称叫作`Hyper Text Markup Language`，即超文本标记语言。\n\n我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是`HTML`。不同类型的元素通过不同类型的标签来表示，如图片用`img`标签表示，视频用`video`标签表示，段落用`p`标签表示，它们之间的布局又常通过布局标签`div`嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 \n\n在`Chrome`浏览器中打开百度，右击并选择 “检查”项（或按`F12键`），打开开发者模式，这时在`Elements`选项卡中即可看到网页的源代码，如图所示。\n\n![HTML结构](Screenshot_1.png)\n\n这就是`HTML`，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。\n\n## CSS\n\n虽然`HTML`定义了网页的结构，但是只有`HTML`页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助`CSS`了。\n\n`CSS`，全称叫作`Cascading Style Sheets`，即`层叠样式表`。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。\n\n`CSS`是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：\n\n```css\n#head_wrapper.s-ps-islite .s-p-top { \n    position: absolute; \n    bottom: 40px; \n    width: 100%; \n    height: 181px; \n    }\n```\n\n这就是一个`CSS`样式。大括号前面是一个`CSS选择器`。此选择器的作用是首先选中`id`为`head_wrapper`且`class` 为`s-ps-islite`的节点，然后再选中其内部的`class`为`s-p-top`的节点。大括号内部写的就是一条条样式规则，例如`position`指定了这个元素的布局方式为**绝对布局**，`bottom`指定元素的下边距为**40像素**，`width`指定了宽度为**100%**占满父元素，`height`则指定了元素的**高度**。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上`CSS`选择器，这就代表这个样式对`CSS`选择器选中的元素生效，元素就会根据此样式来展示了。\n\n在网页中，一般会统一定义整个网页的样式规则，并写入`CSS`文件中（其后缀为css）。在HTML中，只需要用`link`标签即可引入写好的`CSS`文件，这样整个页面就会变得美观、优雅。\n\n## JavaScript \n\n`JavaScript`，简称`JS`，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是`JavaScript`的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种**实时、动态、交互**的页面功能。\n\n`JavaScript`通常也是以单独的文件形式加载的，后缀为`js`，在 HTML中通过`script标签`即可引入，例如:\n\n```html\n<script src=\"jquery-2.1.0.js\"></script>\n```\n\n综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，`JavaScript`定义了网页的行为。\n","slug":"web网页基础","published":1,"updated":"2021-06-15T03:24:11.529Z","_id":"ckpapu7ij0012lcxuavhaejfe","layout":"post","photos":[],"link":"","content":"<h1 id=\"网页的组成\"><a href=\"#网页的组成\" class=\"headerlink\" title=\"网页的组成\"></a>网页的组成</h1><p>首先，我们来了解网页的基本组成，网页可以分为三大部分：<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>。 如果把网页比作一个人的话，<code>HTML</code>相当于骨架，<code>JavaScript</code>相当于肌肉，<code>CSS</code>相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p><code>HTML</code>是用来描述网页的一种语言，其全称叫作<code>Hyper Text Markup Language</code>，即超文本标记语言。</p>\n<p>我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是<code>HTML</code>。不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示，它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 </p>\n<p>在<code>Chrome</code>浏览器中打开百度，右击并选择 “检查”项（或按<code>F12键</code>），打开开发者模式，这时在<code>Elements</code>选项卡中即可看到网页的源代码，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"HTML结构\"></p>\n<p>这就是<code>HTML</code>，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>虽然<code>HTML</code>定义了网页的结构，但是只有<code>HTML</code>页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助<code>CSS</code>了。</p>\n<p><code>CSS</code>，全称叫作<code>Cascading Style Sheets</code>，即<code>层叠样式表</code>。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。</p>\n<p><code>CSS</code>是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#head_wrapper</span><span class=\"selector-class\">.s-ps-islite</span> <span class=\"selector-class\">.s-p-top</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">181px</span>; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个<code>CSS</code>样式。大括号前面是一个<code>CSS选择器</code>。此选择器的作用是首先选中<code>id</code>为<code>head_wrapper</code>且<code>class</code> 为<code>s-ps-islite</code>的节点，然后再选中其内部的<code>class</code>为<code>s-p-top</code>的节点。大括号内部写的就是一条条样式规则，例如<code>position</code>指定了这个元素的布局方式为<strong>绝对布局</strong>，<code>bottom</code>指定元素的下边距为<strong>40像素</strong>，<code>width</code>指定了宽度为<strong>100%<strong>占满父元素，<code>height</code>则指定了元素的</strong>高度</strong>。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上<code>CSS</code>选择器，这就代表这个样式对<code>CSS</code>选择器选中的元素生效，元素就会根据此样式来展示了。</p>\n<p>在网页中，一般会统一定义整个网页的样式规则，并写入<code>CSS</code>文件中（其后缀为css）。在HTML中，只需要用<code>link</code>标签即可引入写好的<code>CSS</code>文件，这样整个页面就会变得美观、优雅。</p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p><code>JavaScript</code>，简称<code>JS</code>，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是<code>JavaScript</code>的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种<strong>实时、动态、交互</strong>的页面功能。</p>\n<p><code>JavaScript</code>通常也是以单独的文件形式加载的，后缀为<code>js</code>，在 HTML中通过<code>script标签</code>即可引入，例如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;jquery-2.1.0.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，<code>JavaScript</code>定义了网页的行为。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网页的组成\"><a href=\"#网页的组成\" class=\"headerlink\" title=\"网页的组成\"></a>网页的组成</h1><p>首先，我们来了解网页的基本组成，网页可以分为三大部分：<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>。 如果把网页比作一个人的话，<code>HTML</code>相当于骨架，<code>JavaScript</code>相当于肌肉，<code>CSS</code>相当于皮肤，三者结合起来才能形成一个完整的网页。下面我们来分别介绍一下这三部分的功能。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p><code>HTML</code>是用来描述网页的一种语言，其全称叫作<code>Hyper Text Markup Language</code>，即超文本标记语言。</p>\n<p>我们浏览的网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是<code>HTML</code>。不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示，它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套就可以形成网页的框架。 </p>\n<p>在<code>Chrome</code>浏览器中打开百度，右击并选择 “检查”项（或按<code>F12键</code>），打开开发者模式，这时在<code>Elements</code>选项卡中即可看到网页的源代码，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"HTML结构\"></p>\n<p>这就是<code>HTML</code>，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>虽然<code>HTML</code>定义了网页的结构，但是只有<code>HTML</code>页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助<code>CSS</code>了。</p>\n<p><code>CSS</code>，全称叫作<code>Cascading Style Sheets</code>，即<code>层叠样式表</code>。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等 格式。</p>\n<p><code>CSS</code>是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#head_wrapper</span><span class=\"selector-class\">.s-ps-islite</span> <span class=\"selector-class\">.s-p-top</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; </span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">40px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">181px</span>; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个<code>CSS</code>样式。大括号前面是一个<code>CSS选择器</code>。此选择器的作用是首先选中<code>id</code>为<code>head_wrapper</code>且<code>class</code> 为<code>s-ps-islite</code>的节点，然后再选中其内部的<code>class</code>为<code>s-p-top</code>的节点。大括号内部写的就是一条条样式规则，例如<code>position</code>指定了这个元素的布局方式为<strong>绝对布局</strong>，<code>bottom</code>指定元素的下边距为<strong>40像素</strong>，<code>width</code>指定了宽度为<strong>100%<strong>占满父元素，<code>height</code>则指定了元素的</strong>高度</strong>。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上<code>CSS</code>选择器，这就代表这个样式对<code>CSS</code>选择器选中的元素生效，元素就会根据此样式来展示了。</p>\n<p>在网页中，一般会统一定义整个网页的样式规则，并写入<code>CSS</code>文件中（其后缀为css）。在HTML中，只需要用<code>link</code>标签即可引入写好的<code>CSS</code>文件，这样整个页面就会变得美观、优雅。</p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p><code>JavaScript</code>，简称<code>JS</code>，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是<code>JavaScript</code>的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种<strong>实时、动态、交互</strong>的页面功能。</p>\n<p><code>JavaScript</code>通常也是以单独的文件形式加载的，后缀为<code>js</code>，在 HTML中通过<code>script标签</code>即可引入，例如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;jquery-2.1.0.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，<code>JavaScript</code>定义了网页的行为。</p>\n"},{"title":"在Hexo博客中嵌入外链视频","date":"2021-05-11T01:12:11.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n# 嵌入的视频\n\nHexo支持Youtube视频的嵌入，可以参考其实现方式。\n\n首先，在`node_modules/hexo/lib/plugins/tag/index.js`中添加以下代码。\n\n```javascript\n  // 添加哔哩哔哩\n  tag.register('bilibili', require('./bilibili'));\n```\n\n然后在`node_modules/hexo/lib/plugins/tag/`目录下新建`bilibili.js`文件，打开并添加如下代码：\n\n```javascript\n'use strict';\n\nconst { htmlTag } = require('hexo-util');\n\n/**\n* bilibili tag\n*\n* Syntax:\n*   {% bilibili id %}\n*/\n\nfunction bilibiliTag(args, content) {\n  var id = args[0];\n  return `<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?${id}\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>`;\n}\n\nmodule.exports = bilibiliTag;\n\n```\n\n重新启动下`Hexo Server`,在`md`页面中添加下列：\n\n```javascript\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}\n```\n\n重新刷新页面，就可以看到视频正常加载了。\n\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}","source":"_posts/在Hexo博客中嵌入外链视频.md","raw":"---\ntitle: 在Hexo博客中嵌入外链视频\ndate: 2021-05-11 09:12:11\ncategories: 博客教程\ntags:\n- Hexo\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n# 嵌入的视频\n\nHexo支持Youtube视频的嵌入，可以参考其实现方式。\n\n首先，在`node_modules/hexo/lib/plugins/tag/index.js`中添加以下代码。\n\n```javascript\n  // 添加哔哩哔哩\n  tag.register('bilibili', require('./bilibili'));\n```\n\n然后在`node_modules/hexo/lib/plugins/tag/`目录下新建`bilibili.js`文件，打开并添加如下代码：\n\n```javascript\n'use strict';\n\nconst { htmlTag } = require('hexo-util');\n\n/**\n* bilibili tag\n*\n* Syntax:\n*   {% bilibili id %}\n*/\n\nfunction bilibiliTag(args, content) {\n  var id = args[0];\n  return `<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?${id}\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>`;\n}\n\nmodule.exports = bilibiliTag;\n\n```\n\n重新启动下`Hexo Server`,在`md`页面中添加下列：\n\n```javascript\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}\n```\n\n重新刷新页面，就可以看到视频正常加载了。\n\n{% bilibili aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1 %}","slug":"在Hexo博客中嵌入外链视频","published":1,"updated":"2021-06-15T03:24:11.544Z","_id":"ckpapu7il0017lcxu196gcfxk","layout":"post","photos":[],"link":"","content":"<h1 id=\"嵌入的视频\"><a href=\"#嵌入的视频\" class=\"headerlink\" title=\"嵌入的视频\"></a>嵌入的视频</h1><p>Hexo支持Youtube视频的嵌入，可以参考其实现方式。</p>\n<p>首先，在<code>node_modules/hexo/lib/plugins/tag/index.js</code>中添加以下代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加哔哩哔哩</span></span><br><span class=\"line\">tag.register(<span class=\"string\">&#x27;bilibili&#x27;</span>, <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./bilibili&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>node_modules/hexo/lib/plugins/tag/</code>目录下新建<code>bilibili.js</code>文件，打开并添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; htmlTag &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;hexo-util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* bilibili tag</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* Syntax:</span></span><br><span class=\"line\"><span class=\"comment\">*   &#123;% bilibili id %&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bilibiliTag</span>(<span class=\"params\">args, content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?<span class=\"subst\">$&#123;id&#125;</span>&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = bilibiliTag;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重新启动下<code>Hexo Server</code>,在<code>md</code>页面中添加下列：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% bilibili aid=<span class=\"number\">586894170</span>&amp;bvid=BV1uz4y1m72t&amp;cid=<span class=\"number\">305401685</span>&amp;page=<span class=\"number\">1</span> %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新刷新页面，就可以看到视频正常加载了。</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"嵌入的视频\"><a href=\"#嵌入的视频\" class=\"headerlink\" title=\"嵌入的视频\"></a>嵌入的视频</h1><p>Hexo支持Youtube视频的嵌入，可以参考其实现方式。</p>\n<p>首先，在<code>node_modules/hexo/lib/plugins/tag/index.js</code>中添加以下代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加哔哩哔哩</span></span><br><span class=\"line\">tag.register(<span class=\"string\">&#x27;bilibili&#x27;</span>, <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./bilibili&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>node_modules/hexo/lib/plugins/tag/</code>目录下新建<code>bilibili.js</code>文件，打开并添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; htmlTag &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;hexo-util&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* bilibili tag</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* Syntax:</span></span><br><span class=\"line\"><span class=\"comment\">*   &#123;% bilibili id %&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bilibiliTag</span>(<span class=\"params\">args, content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?<span class=\"subst\">$&#123;id&#125;</span>&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = bilibiliTag;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重新启动下<code>Hexo Server</code>,在<code>md</code>页面中添加下列：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% bilibili aid=<span class=\"number\">586894170</span>&amp;bvid=BV1uz4y1m72t&amp;cid=<span class=\"number\">305401685</span>&amp;page=<span class=\"number\">1</span> %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新刷新页面，就可以看到视频正常加载了。</p>\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe src=\"//player.bilibili.com/player.html?aid=586894170&bvid=BV1uz4y1m72t&cid=305401685&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"> </iframe></div>"},{"title":"内篇（一）——逍遥游","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-06-15T03:24:11.542Z","pic":null,"_content":"\n\n>**北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。**\n\n北方的大海里有一条鱼，它的名字叫鲲。鲲的体积，不知道大到有几千里。变化成为鸟，它的名字就叫做鹏。鹏的脊背，真不知道长到有几千里；当它奋起而飞的时候，那展开的翅膀就好像天边的云。这只鹏鸟，当海动风气的时候就要迁徙到南方的大海去了。南方的大海是一个天然的大池子。\n\n>**《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。**\n\n《齐谐》是一部专门记载怪异事情的书。这本书上记载：“鹏往南方的大海迁徙的时候，翅膀拍打水面，能激起三千里的浪涛，环绕着旋风飞上了九万里的高空，乘着六月的风离开了北海。”像野马奔腾一样的游气，飘飘扬扬的尘埃，都是活动着的生物的气息相互吹拂所致。天空是那么湛蓝湛蓝的，难道就是它真正的颜色吗？还是因为天空高远而看不到尽头呢？鹏鸟从高空往下看的时候，也不过就像这个样子罢了。\n\n>**且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟。置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。**\n\n如果聚集的水不深，那么它就没有负载一艘大船的力量了。在堂前低洼的地方倒上一杯水，一棵小草就能被当作是一艘船，放一个杯子在上面就会被粘住，这是水浅而船却大的原因。如果聚集的风不够强大的话，那么负载一个巨大的翅膀也就没有力量了。因此，鹏在九万里的高空飞行，风就在它的身下了，凭借着风力，背负着青天毫无阻挡，然后才开始朝南飞。\n\n>**蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！**\n\n蝉和小斑鸠讥笑鹏说：“我们奋力而飞，碰到榆树和檀树就停止，有时飞不上去，落在地上就是了。何必要飞九万里到南海去呢？”到近郊去的人，只带当天吃的三餐粮食，回来肚子还是饱饱的；到百里外的人，要用一整夜时间舂米准备干粮；到千里外的人，要聚积三个月的粮食。蝉和小斑鸠这两只小虫、鸟又知道什么呢。\n\n>**小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎！**\n\n小智比不上大智，短命比不上长寿。怎么知道是这样的呢？朝生暮死的菌类不知道是一天。春生夏死、夏生秋死的寒蝉，不知道一年的时光，这就是短命。楚国的南方有一种大树（灵龟），它把五百年当作一个春季，五百年当作一个秋季。上古时代有一种树叫做大椿，它把八千年当作一个春季，八千年当作一个秋季，这就是长寿。可是彭祖到如今还是以年寿长久而闻名于世，人们与他攀比，岂不可悲可叹！\n\n>**汤之问棘也是已：穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云，抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。**\n\n商汤问棘的话也是这样的：“在草木不生的极远的北方，有个很深的大海，那就是天池。里面有条鱼，它的身子有几千里宽，没有人知道它有多长，它的名字叫做鲲。有一只鸟，它的名字叫做鹏。鹏的背像泰山，翅膀像天边的云；借着旋风盘旋而上九万里，超越云层，背负青天，然后向南飞翔，将要飞到南海去。\n\n>**斥鴳笑之曰：“彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也，而彼且奚适也？”此小大之辩也。**\n\n小泽里的麻雀讥笑鹏说：‘它要飞到哪里去呢？我一跳就飞起来，不过数丈高就落下来，在蓬蒿丛中盘旋，这也是极好的飞行了。而它还要飞到哪里去呢？’”这就是小和大的不同了。\n\n>**故夫知效一官，行比一乡，德合一君，而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世而誉之而不加劝，举世而非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。**\n\n所以，那些才智能胜任一官的职守，行为能够庇护一乡百姓的，德行能投合一个君王的心意的，能力能够取得全国信任的，他们看待自己，也像上面说的那只小鸟一样。而宋荣子对这种人加以嘲笑。*宋荣子这个人，世上所有的人都称赞他，他并不因此就特别奋勉，世上所有的人都诽谤他，他也并不因此就感到沮丧。他认定了对自己和对外物的分寸，分辨清楚荣辱的界限，就觉得不过如此罢了。他对待人世间的一切，都没有拼命去追求。即使如此，他还是有未达到的境界。*\n\n>**夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。**\n\n列子乘风而行，飘然自得，驾轻就熟。十五天以后返回；他对于求福的事，没有拼命去追求。这样虽然免了步行，还是有所凭借的。\n\n>**若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉！故曰：至人无己，神人无功，圣人无名。**\n\n倘若顺应天地万物的本性，驾驭着六气的变化，邀游于无穷的境地，他还要凭借什么呢？所以说：修养最高的人能任顺自然、忘掉自己，修养达到神化不测境界的人无意于求功，有道德学问的圣人无意于求名。\n\n>**尧让天下于许由，曰：“日月出矣，而爝火不息，其于光也，不亦难乎！时雨降矣，而犹浸灌，其于泽也，不亦劳乎！夫子立而天下治，而我犹尸之，吾自视缺然。请致天下。”许由曰：“子治天下，天下既已治也，而我犹代子，吾将为名乎？名者，实之宾也，吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣。”**\n\n尧要把天下让给许由，说：“太阳月亮出来了，而小火把还不熄灭，它的亮度，要和日月相比不是太难了吗！及时雨降下了，还要灌溉田地，对于滋润禾苗，不是徒劳吗！你如果成了君王，天下一定大治，而我还徒居其位，我自己感到惭愧极了，请允许我把天下交给你。”许由说：“你治理天下，天下已经治理好了，而我再接替你，我岂不是为名而来吗？名，是依附于实的客体，我难道要做有名无实的客体吗？鹪鹩在深林中筑巢，只要一根树枝；鼹鼠饮河水，只要肚子喝饱。请你回去吧，天下对于我没有什么用！厨子虽然不下厨，主祭的人却不应该超越权限而代行厨子的职事。”\n\n>**肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不返。吾惊怖其言犹河汉而无极也，大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”“曰‘藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子；不食五谷，吸风饮露；乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。’吾以是狂而不信也。”连叔曰：“然，瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之。是其言也，犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤，大浸稽天而不溺，大旱金石流、土山焦而不热。是其尘垢粃糠，将犹陶铸尧舜者也，孰肯以物为事！”**\n\n肩吾向连叔求教：“我从接舆那里听到谈话，大话连篇没有边际，一说下去就回不到原来的话题上。我十分惊恐他的言谈，就好像天上的银河没有边际，跟一般人的言谈差异甚远，确实是太不近情理了。”连叔问：“他说的是些什么呢？”肩吾转述道：“‘在遥远的姑射山上，住着一位神人，皮肤润白像冰雪，体态柔美如处女，不食五谷，吸清风饮甘露，乘云气驾飞龙，遨游于四海之外。他的神情那么专注，使得世间万物不受病害，年年五谷丰登。’我认为这全是虚妄之言，一点也不可信。”连叔听后说：“是呀！对于瞎子没法同他们欣赏花纹和色彩，对于聋子没法同他们聆听钟鼓的乐声。难道只是形骸上有聋与瞎吗？思想上也有聋和瞎啊！这话似乎就是说你肩吾的呀。那位神人，他的德行，与万事万物混同一起，以此求得整个天下的治理，谁还会忙忙碌碌把管理天下当成回事！那样的人哪，外物没有什么能伤害他，滔天的大水不能淹没他，天下大旱使金石熔化、土山焦裂，他也不感到灼热。他所留下的尘埃以及瘪谷糠麸之类的废物，也可造就出尧舜那样的圣贤仁君来，他怎么会把忙着管理万物当作己任呢！\n\n>**宋人资章甫而适越，越人断发文身，无所用之。**\n\n北方的宋国有人贩卖帽子到南方的越国，越国人不蓄头发满身刺着花纹，没什么地方用得着帽子。\n\n>**尧治天下之民，平海内之政。往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。**\n\n尧治理好天下的百姓，安定了海内的政局，到姑射山上、汾水北面，去拜见四位得道的高士，不禁怅然若失，忘记了自己居于治理天下的地位。”\n\n>**惠子谓庄子曰：“魏王贻我大瓠之种，我树之成而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋之曰：‘我世世为澼絖，不过数金。今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将。冬，与越人水战，大败越人，裂地而封之。能不龟手一也，或以封，或不免于澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽而浮乎江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”**\n\n惠子对庄子说：“魏王送给我大葫芦的种子，我种下后结出的葫芦大得可以容纳五石。用它来盛水，它却因质地太脆无法提举。切开它当瓠，又大而平浅无法容纳东西。我不是嫌它不大，只是因为它无用，我把它砸了。”庄子说：“你真不善于使用大的物件。宋国有个人善于制作防止手冻裂的药，他家世世代代都以漂洗丝絮为职业。有个客人听说了，请求用一百金来买他的药方。这个宋国人召集全家商量说：‘我家世世代代靠这种药从事漂洗丝絮，一年所得不过数金；现在一旦卖掉这个药方马上可得百金，请大家答应我卖掉它。’这个客人买到药方，就去游说吴王。那时正逢越国有难，吴王就命他为将，在冬天跟越国人展开水战，大败越人，吴王就割地封侯来奖赏他。同样是一帖防止手冻裂的药方，有人靠它得到封赏，有人却只会用于漂洗丝絮，这是因为使用方法不同啊。现在你有可容五石东西的大葫芦，为什么不把它系在身上作为腰舟而浮游于江湖呢？却担忧它大而无处可容纳，可见你的心地过于浅陋狭隘了！”\n\n>**惠子谓庄子曰：“吾有大树，人谓之樗。其大本臃肿而不中绳墨，其小枝卷曲而不中规矩。立之涂，匠者不顾。今子之言，大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不避高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”**\n\n惠子对庄子说：“我有一棵大树，人家把它叫做臭椿；它那树干上有许多赘瘤，不合绳墨，它那枝权弯弯曲曲，不合规矩。它长在路边，木匠都不看它一眼。现在你说的那段话，大而没有用，大家都不相信。”庄子说：“你难道没见过野猫和黄鼠狼吗？屈身伏在那里，等待捕捉来来往往的小动物；它捉小动物时东跳西跃，不避高下；但是一踏中捕兽的机关陷阱，就死在网中。再看那牦牛，它大如天边的云；这可以说够大的了，但是却不能捕鼠。现在你有一棵大树，担忧它没有用处，为什么不把它种在虚无之乡，广阔无边的原野，随意地徘徊在它的旁边，逍遥自在地躺在它的下面；这样大树就不会遭到斧头的砍伐，也没有什么东西会伤害它。它没有什么用处，又哪里会有什么困苦呢？”\n","source":"_posts/内篇（一）——逍遥游.md","raw":"---\ntitle: 内篇（一）——逍遥游\ntags:\n- 读书\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\ndate: 2021-05-2912:46:06\ncategories: 庄子\npic:\n---\n\n\n>**北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。**\n\n北方的大海里有一条鱼，它的名字叫鲲。鲲的体积，不知道大到有几千里。变化成为鸟，它的名字就叫做鹏。鹏的脊背，真不知道长到有几千里；当它奋起而飞的时候，那展开的翅膀就好像天边的云。这只鹏鸟，当海动风气的时候就要迁徙到南方的大海去了。南方的大海是一个天然的大池子。\n\n>**《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。**\n\n《齐谐》是一部专门记载怪异事情的书。这本书上记载：“鹏往南方的大海迁徙的时候，翅膀拍打水面，能激起三千里的浪涛，环绕着旋风飞上了九万里的高空，乘着六月的风离开了北海。”像野马奔腾一样的游气，飘飘扬扬的尘埃，都是活动着的生物的气息相互吹拂所致。天空是那么湛蓝湛蓝的，难道就是它真正的颜色吗？还是因为天空高远而看不到尽头呢？鹏鸟从高空往下看的时候，也不过就像这个样子罢了。\n\n>**且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟。置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。**\n\n如果聚集的水不深，那么它就没有负载一艘大船的力量了。在堂前低洼的地方倒上一杯水，一棵小草就能被当作是一艘船，放一个杯子在上面就会被粘住，这是水浅而船却大的原因。如果聚集的风不够强大的话，那么负载一个巨大的翅膀也就没有力量了。因此，鹏在九万里的高空飞行，风就在它的身下了，凭借着风力，背负着青天毫无阻挡，然后才开始朝南飞。\n\n>**蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！**\n\n蝉和小斑鸠讥笑鹏说：“我们奋力而飞，碰到榆树和檀树就停止，有时飞不上去，落在地上就是了。何必要飞九万里到南海去呢？”到近郊去的人，只带当天吃的三餐粮食，回来肚子还是饱饱的；到百里外的人，要用一整夜时间舂米准备干粮；到千里外的人，要聚积三个月的粮食。蝉和小斑鸠这两只小虫、鸟又知道什么呢。\n\n>**小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎！**\n\n小智比不上大智，短命比不上长寿。怎么知道是这样的呢？朝生暮死的菌类不知道是一天。春生夏死、夏生秋死的寒蝉，不知道一年的时光，这就是短命。楚国的南方有一种大树（灵龟），它把五百年当作一个春季，五百年当作一个秋季。上古时代有一种树叫做大椿，它把八千年当作一个春季，八千年当作一个秋季，这就是长寿。可是彭祖到如今还是以年寿长久而闻名于世，人们与他攀比，岂不可悲可叹！\n\n>**汤之问棘也是已：穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云，抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。**\n\n商汤问棘的话也是这样的：“在草木不生的极远的北方，有个很深的大海，那就是天池。里面有条鱼，它的身子有几千里宽，没有人知道它有多长，它的名字叫做鲲。有一只鸟，它的名字叫做鹏。鹏的背像泰山，翅膀像天边的云；借着旋风盘旋而上九万里，超越云层，背负青天，然后向南飞翔，将要飞到南海去。\n\n>**斥鴳笑之曰：“彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也，而彼且奚适也？”此小大之辩也。**\n\n小泽里的麻雀讥笑鹏说：‘它要飞到哪里去呢？我一跳就飞起来，不过数丈高就落下来，在蓬蒿丛中盘旋，这也是极好的飞行了。而它还要飞到哪里去呢？’”这就是小和大的不同了。\n\n>**故夫知效一官，行比一乡，德合一君，而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世而誉之而不加劝，举世而非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。**\n\n所以，那些才智能胜任一官的职守，行为能够庇护一乡百姓的，德行能投合一个君王的心意的，能力能够取得全国信任的，他们看待自己，也像上面说的那只小鸟一样。而宋荣子对这种人加以嘲笑。*宋荣子这个人，世上所有的人都称赞他，他并不因此就特别奋勉，世上所有的人都诽谤他，他也并不因此就感到沮丧。他认定了对自己和对外物的分寸，分辨清楚荣辱的界限，就觉得不过如此罢了。他对待人世间的一切，都没有拼命去追求。即使如此，他还是有未达到的境界。*\n\n>**夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。**\n\n列子乘风而行，飘然自得，驾轻就熟。十五天以后返回；他对于求福的事，没有拼命去追求。这样虽然免了步行，还是有所凭借的。\n\n>**若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉！故曰：至人无己，神人无功，圣人无名。**\n\n倘若顺应天地万物的本性，驾驭着六气的变化，邀游于无穷的境地，他还要凭借什么呢？所以说：修养最高的人能任顺自然、忘掉自己，修养达到神化不测境界的人无意于求功，有道德学问的圣人无意于求名。\n\n>**尧让天下于许由，曰：“日月出矣，而爝火不息，其于光也，不亦难乎！时雨降矣，而犹浸灌，其于泽也，不亦劳乎！夫子立而天下治，而我犹尸之，吾自视缺然。请致天下。”许由曰：“子治天下，天下既已治也，而我犹代子，吾将为名乎？名者，实之宾也，吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣。”**\n\n尧要把天下让给许由，说：“太阳月亮出来了，而小火把还不熄灭，它的亮度，要和日月相比不是太难了吗！及时雨降下了，还要灌溉田地，对于滋润禾苗，不是徒劳吗！你如果成了君王，天下一定大治，而我还徒居其位，我自己感到惭愧极了，请允许我把天下交给你。”许由说：“你治理天下，天下已经治理好了，而我再接替你，我岂不是为名而来吗？名，是依附于实的客体，我难道要做有名无实的客体吗？鹪鹩在深林中筑巢，只要一根树枝；鼹鼠饮河水，只要肚子喝饱。请你回去吧，天下对于我没有什么用！厨子虽然不下厨，主祭的人却不应该超越权限而代行厨子的职事。”\n\n>**肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不返。吾惊怖其言犹河汉而无极也，大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”“曰‘藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子；不食五谷，吸风饮露；乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。’吾以是狂而不信也。”连叔曰：“然，瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之。是其言也，犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤，大浸稽天而不溺，大旱金石流、土山焦而不热。是其尘垢粃糠，将犹陶铸尧舜者也，孰肯以物为事！”**\n\n肩吾向连叔求教：“我从接舆那里听到谈话，大话连篇没有边际，一说下去就回不到原来的话题上。我十分惊恐他的言谈，就好像天上的银河没有边际，跟一般人的言谈差异甚远，确实是太不近情理了。”连叔问：“他说的是些什么呢？”肩吾转述道：“‘在遥远的姑射山上，住着一位神人，皮肤润白像冰雪，体态柔美如处女，不食五谷，吸清风饮甘露，乘云气驾飞龙，遨游于四海之外。他的神情那么专注，使得世间万物不受病害，年年五谷丰登。’我认为这全是虚妄之言，一点也不可信。”连叔听后说：“是呀！对于瞎子没法同他们欣赏花纹和色彩，对于聋子没法同他们聆听钟鼓的乐声。难道只是形骸上有聋与瞎吗？思想上也有聋和瞎啊！这话似乎就是说你肩吾的呀。那位神人，他的德行，与万事万物混同一起，以此求得整个天下的治理，谁还会忙忙碌碌把管理天下当成回事！那样的人哪，外物没有什么能伤害他，滔天的大水不能淹没他，天下大旱使金石熔化、土山焦裂，他也不感到灼热。他所留下的尘埃以及瘪谷糠麸之类的废物，也可造就出尧舜那样的圣贤仁君来，他怎么会把忙着管理万物当作己任呢！\n\n>**宋人资章甫而适越，越人断发文身，无所用之。**\n\n北方的宋国有人贩卖帽子到南方的越国，越国人不蓄头发满身刺着花纹，没什么地方用得着帽子。\n\n>**尧治天下之民，平海内之政。往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。**\n\n尧治理好天下的百姓，安定了海内的政局，到姑射山上、汾水北面，去拜见四位得道的高士，不禁怅然若失，忘记了自己居于治理天下的地位。”\n\n>**惠子谓庄子曰：“魏王贻我大瓠之种，我树之成而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋之曰：‘我世世为澼絖，不过数金。今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将。冬，与越人水战，大败越人，裂地而封之。能不龟手一也，或以封，或不免于澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽而浮乎江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”**\n\n惠子对庄子说：“魏王送给我大葫芦的种子，我种下后结出的葫芦大得可以容纳五石。用它来盛水，它却因质地太脆无法提举。切开它当瓠，又大而平浅无法容纳东西。我不是嫌它不大，只是因为它无用，我把它砸了。”庄子说：“你真不善于使用大的物件。宋国有个人善于制作防止手冻裂的药，他家世世代代都以漂洗丝絮为职业。有个客人听说了，请求用一百金来买他的药方。这个宋国人召集全家商量说：‘我家世世代代靠这种药从事漂洗丝絮，一年所得不过数金；现在一旦卖掉这个药方马上可得百金，请大家答应我卖掉它。’这个客人买到药方，就去游说吴王。那时正逢越国有难，吴王就命他为将，在冬天跟越国人展开水战，大败越人，吴王就割地封侯来奖赏他。同样是一帖防止手冻裂的药方，有人靠它得到封赏，有人却只会用于漂洗丝絮，这是因为使用方法不同啊。现在你有可容五石东西的大葫芦，为什么不把它系在身上作为腰舟而浮游于江湖呢？却担忧它大而无处可容纳，可见你的心地过于浅陋狭隘了！”\n\n>**惠子谓庄子曰：“吾有大树，人谓之樗。其大本臃肿而不中绳墨，其小枝卷曲而不中规矩。立之涂，匠者不顾。今子之言，大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不避高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”**\n\n惠子对庄子说：“我有一棵大树，人家把它叫做臭椿；它那树干上有许多赘瘤，不合绳墨，它那枝权弯弯曲曲，不合规矩。它长在路边，木匠都不看它一眼。现在你说的那段话，大而没有用，大家都不相信。”庄子说：“你难道没见过野猫和黄鼠狼吗？屈身伏在那里，等待捕捉来来往往的小动物；它捉小动物时东跳西跃，不避高下；但是一踏中捕兽的机关陷阱，就死在网中。再看那牦牛，它大如天边的云；这可以说够大的了，但是却不能捕鼠。现在你有一棵大树，担忧它没有用处，为什么不把它种在虚无之乡，广阔无边的原野，随意地徘徊在它的旁边，逍遥自在地躺在它的下面；这样大树就不会遭到斧头的砍伐，也没有什么东西会伤害它。它没有什么用处，又哪里会有什么困苦呢？”\n","slug":"内篇（一）——逍遥游","published":1,"updated":"2021-06-15T03:24:11.542Z","_id":"ckpapu7io001alcxu7jkz66xe","layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><strong>北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。</strong></p>\n</blockquote>\n<p>北方的大海里有一条鱼，它的名字叫鲲。鲲的体积，不知道大到有几千里。变化成为鸟，它的名字就叫做鹏。鹏的脊背，真不知道长到有几千里；当它奋起而飞的时候，那展开的翅膀就好像天边的云。这只鹏鸟，当海动风气的时候就要迁徙到南方的大海去了。南方的大海是一个天然的大池子。</p>\n<blockquote>\n<p><strong>《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。</strong></p>\n</blockquote>\n<p>《齐谐》是一部专门记载怪异事情的书。这本书上记载：“鹏往南方的大海迁徙的时候，翅膀拍打水面，能激起三千里的浪涛，环绕着旋风飞上了九万里的高空，乘着六月的风离开了北海。”像野马奔腾一样的游气，飘飘扬扬的尘埃，都是活动着的生物的气息相互吹拂所致。天空是那么湛蓝湛蓝的，难道就是它真正的颜色吗？还是因为天空高远而看不到尽头呢？鹏鸟从高空往下看的时候，也不过就像这个样子罢了。</p>\n<blockquote>\n<p><strong>且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟。置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。</strong></p>\n</blockquote>\n<p>如果聚集的水不深，那么它就没有负载一艘大船的力量了。在堂前低洼的地方倒上一杯水，一棵小草就能被当作是一艘船，放一个杯子在上面就会被粘住，这是水浅而船却大的原因。如果聚集的风不够强大的话，那么负载一个巨大的翅膀也就没有力量了。因此，鹏在九万里的高空飞行，风就在它的身下了，凭借着风力，背负着青天毫无阻挡，然后才开始朝南飞。</p>\n<blockquote>\n<p><strong>蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！</strong></p>\n</blockquote>\n<p>蝉和小斑鸠讥笑鹏说：“我们奋力而飞，碰到榆树和檀树就停止，有时飞不上去，落在地上就是了。何必要飞九万里到南海去呢？”到近郊去的人，只带当天吃的三餐粮食，回来肚子还是饱饱的；到百里外的人，要用一整夜时间舂米准备干粮；到千里外的人，要聚积三个月的粮食。蝉和小斑鸠这两只小虫、鸟又知道什么呢。</p>\n<blockquote>\n<p><strong>小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎！</strong></p>\n</blockquote>\n<p>小智比不上大智，短命比不上长寿。怎么知道是这样的呢？朝生暮死的菌类不知道是一天。春生夏死、夏生秋死的寒蝉，不知道一年的时光，这就是短命。楚国的南方有一种大树（灵龟），它把五百年当作一个春季，五百年当作一个秋季。上古时代有一种树叫做大椿，它把八千年当作一个春季，八千年当作一个秋季，这就是长寿。可是彭祖到如今还是以年寿长久而闻名于世，人们与他攀比，岂不可悲可叹！</p>\n<blockquote>\n<p><strong>汤之问棘也是已：穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云，抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。</strong></p>\n</blockquote>\n<p>商汤问棘的话也是这样的：“在草木不生的极远的北方，有个很深的大海，那就是天池。里面有条鱼，它的身子有几千里宽，没有人知道它有多长，它的名字叫做鲲。有一只鸟，它的名字叫做鹏。鹏的背像泰山，翅膀像天边的云；借着旋风盘旋而上九万里，超越云层，背负青天，然后向南飞翔，将要飞到南海去。</p>\n<blockquote>\n<p><strong>斥鴳笑之曰：“彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也，而彼且奚适也？”此小大之辩也。</strong></p>\n</blockquote>\n<p>小泽里的麻雀讥笑鹏说：‘它要飞到哪里去呢？我一跳就飞起来，不过数丈高就落下来，在蓬蒿丛中盘旋，这也是极好的飞行了。而它还要飞到哪里去呢？’”这就是小和大的不同了。</p>\n<blockquote>\n<p><strong>故夫知效一官，行比一乡，德合一君，而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世而誉之而不加劝，举世而非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。</strong></p>\n</blockquote>\n<p>所以，那些才智能胜任一官的职守，行为能够庇护一乡百姓的，德行能投合一个君王的心意的，能力能够取得全国信任的，他们看待自己，也像上面说的那只小鸟一样。而宋荣子对这种人加以嘲笑。<em>宋荣子这个人，世上所有的人都称赞他，他并不因此就特别奋勉，世上所有的人都诽谤他，他也并不因此就感到沮丧。他认定了对自己和对外物的分寸，分辨清楚荣辱的界限，就觉得不过如此罢了。他对待人世间的一切，都没有拼命去追求。即使如此，他还是有未达到的境界。</em></p>\n<blockquote>\n<p><strong>夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。</strong></p>\n</blockquote>\n<p>列子乘风而行，飘然自得，驾轻就熟。十五天以后返回；他对于求福的事，没有拼命去追求。这样虽然免了步行，还是有所凭借的。</p>\n<blockquote>\n<p><strong>若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉！故曰：至人无己，神人无功，圣人无名。</strong></p>\n</blockquote>\n<p>倘若顺应天地万物的本性，驾驭着六气的变化，邀游于无穷的境地，他还要凭借什么呢？所以说：修养最高的人能任顺自然、忘掉自己，修养达到神化不测境界的人无意于求功，有道德学问的圣人无意于求名。</p>\n<blockquote>\n<p><strong>尧让天下于许由，曰：“日月出矣，而爝火不息，其于光也，不亦难乎！时雨降矣，而犹浸灌，其于泽也，不亦劳乎！夫子立而天下治，而我犹尸之，吾自视缺然。请致天下。”许由曰：“子治天下，天下既已治也，而我犹代子，吾将为名乎？名者，实之宾也，吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣。”</strong></p>\n</blockquote>\n<p>尧要把天下让给许由，说：“太阳月亮出来了，而小火把还不熄灭，它的亮度，要和日月相比不是太难了吗！及时雨降下了，还要灌溉田地，对于滋润禾苗，不是徒劳吗！你如果成了君王，天下一定大治，而我还徒居其位，我自己感到惭愧极了，请允许我把天下交给你。”许由说：“你治理天下，天下已经治理好了，而我再接替你，我岂不是为名而来吗？名，是依附于实的客体，我难道要做有名无实的客体吗？鹪鹩在深林中筑巢，只要一根树枝；鼹鼠饮河水，只要肚子喝饱。请你回去吧，天下对于我没有什么用！厨子虽然不下厨，主祭的人却不应该超越权限而代行厨子的职事。”</p>\n<blockquote>\n<p><strong>肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不返。吾惊怖其言犹河汉而无极也，大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”“曰‘藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子；不食五谷，吸风饮露；乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。’吾以是狂而不信也。”连叔曰：“然，瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之。是其言也，犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤，大浸稽天而不溺，大旱金石流、土山焦而不热。是其尘垢粃糠，将犹陶铸尧舜者也，孰肯以物为事！”</strong></p>\n</blockquote>\n<p>肩吾向连叔求教：“我从接舆那里听到谈话，大话连篇没有边际，一说下去就回不到原来的话题上。我十分惊恐他的言谈，就好像天上的银河没有边际，跟一般人的言谈差异甚远，确实是太不近情理了。”连叔问：“他说的是些什么呢？”肩吾转述道：“‘在遥远的姑射山上，住着一位神人，皮肤润白像冰雪，体态柔美如处女，不食五谷，吸清风饮甘露，乘云气驾飞龙，遨游于四海之外。他的神情那么专注，使得世间万物不受病害，年年五谷丰登。’我认为这全是虚妄之言，一点也不可信。”连叔听后说：“是呀！对于瞎子没法同他们欣赏花纹和色彩，对于聋子没法同他们聆听钟鼓的乐声。难道只是形骸上有聋与瞎吗？思想上也有聋和瞎啊！这话似乎就是说你肩吾的呀。那位神人，他的德行，与万事万物混同一起，以此求得整个天下的治理，谁还会忙忙碌碌把管理天下当成回事！那样的人哪，外物没有什么能伤害他，滔天的大水不能淹没他，天下大旱使金石熔化、土山焦裂，他也不感到灼热。他所留下的尘埃以及瘪谷糠麸之类的废物，也可造就出尧舜那样的圣贤仁君来，他怎么会把忙着管理万物当作己任呢！</p>\n<blockquote>\n<p><strong>宋人资章甫而适越，越人断发文身，无所用之。</strong></p>\n</blockquote>\n<p>北方的宋国有人贩卖帽子到南方的越国，越国人不蓄头发满身刺着花纹，没什么地方用得着帽子。</p>\n<blockquote>\n<p><strong>尧治天下之民，平海内之政。往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。</strong></p>\n</blockquote>\n<p>尧治理好天下的百姓，安定了海内的政局，到姑射山上、汾水北面，去拜见四位得道的高士，不禁怅然若失，忘记了自己居于治理天下的地位。”</p>\n<blockquote>\n<p><strong>惠子谓庄子曰：“魏王贻我大瓠之种，我树之成而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋之曰：‘我世世为澼絖，不过数金。今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将。冬，与越人水战，大败越人，裂地而封之。能不龟手一也，或以封，或不免于澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽而浮乎江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”</strong></p>\n</blockquote>\n<p>惠子对庄子说：“魏王送给我大葫芦的种子，我种下后结出的葫芦大得可以容纳五石。用它来盛水，它却因质地太脆无法提举。切开它当瓠，又大而平浅无法容纳东西。我不是嫌它不大，只是因为它无用，我把它砸了。”庄子说：“你真不善于使用大的物件。宋国有个人善于制作防止手冻裂的药，他家世世代代都以漂洗丝絮为职业。有个客人听说了，请求用一百金来买他的药方。这个宋国人召集全家商量说：‘我家世世代代靠这种药从事漂洗丝絮，一年所得不过数金；现在一旦卖掉这个药方马上可得百金，请大家答应我卖掉它。’这个客人买到药方，就去游说吴王。那时正逢越国有难，吴王就命他为将，在冬天跟越国人展开水战，大败越人，吴王就割地封侯来奖赏他。同样是一帖防止手冻裂的药方，有人靠它得到封赏，有人却只会用于漂洗丝絮，这是因为使用方法不同啊。现在你有可容五石东西的大葫芦，为什么不把它系在身上作为腰舟而浮游于江湖呢？却担忧它大而无处可容纳，可见你的心地过于浅陋狭隘了！”</p>\n<blockquote>\n<p><strong>惠子谓庄子曰：“吾有大树，人谓之樗。其大本臃肿而不中绳墨，其小枝卷曲而不中规矩。立之涂，匠者不顾。今子之言，大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不避高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”</strong></p>\n</blockquote>\n<p>惠子对庄子说：“我有一棵大树，人家把它叫做臭椿；它那树干上有许多赘瘤，不合绳墨，它那枝权弯弯曲曲，不合规矩。它长在路边，木匠都不看它一眼。现在你说的那段话，大而没有用，大家都不相信。”庄子说：“你难道没见过野猫和黄鼠狼吗？屈身伏在那里，等待捕捉来来往往的小动物；它捉小动物时东跳西跃，不避高下；但是一踏中捕兽的机关陷阱，就死在网中。再看那牦牛，它大如天边的云；这可以说够大的了，但是却不能捕鼠。现在你有一棵大树，担忧它没有用处，为什么不把它种在虚无之乡，广阔无边的原野，随意地徘徊在它的旁边，逍遥自在地躺在它的下面；这样大树就不会遭到斧头的砍伐，也没有什么东西会伤害它。它没有什么用处，又哪里会有什么困苦呢？”</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也。怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。</strong></p>\n</blockquote>\n<p>北方的大海里有一条鱼，它的名字叫鲲。鲲的体积，不知道大到有几千里。变化成为鸟，它的名字就叫做鹏。鹏的脊背，真不知道长到有几千里；当它奋起而飞的时候，那展开的翅膀就好像天边的云。这只鹏鸟，当海动风气的时候就要迁徙到南方的大海去了。南方的大海是一个天然的大池子。</p>\n<blockquote>\n<p><strong>《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。</strong></p>\n</blockquote>\n<p>《齐谐》是一部专门记载怪异事情的书。这本书上记载：“鹏往南方的大海迁徙的时候，翅膀拍打水面，能激起三千里的浪涛，环绕着旋风飞上了九万里的高空，乘着六月的风离开了北海。”像野马奔腾一样的游气，飘飘扬扬的尘埃，都是活动着的生物的气息相互吹拂所致。天空是那么湛蓝湛蓝的，难道就是它真正的颜色吗？还是因为天空高远而看不到尽头呢？鹏鸟从高空往下看的时候，也不过就像这个样子罢了。</p>\n<blockquote>\n<p><strong>且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟。置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。</strong></p>\n</blockquote>\n<p>如果聚集的水不深，那么它就没有负载一艘大船的力量了。在堂前低洼的地方倒上一杯水，一棵小草就能被当作是一艘船，放一个杯子在上面就会被粘住，这是水浅而船却大的原因。如果聚集的风不够强大的话，那么负载一个巨大的翅膀也就没有力量了。因此，鹏在九万里的高空飞行，风就在它的身下了，凭借着风力，背负着青天毫无阻挡，然后才开始朝南飞。</p>\n<blockquote>\n<p><strong>蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！</strong></p>\n</blockquote>\n<p>蝉和小斑鸠讥笑鹏说：“我们奋力而飞，碰到榆树和檀树就停止，有时飞不上去，落在地上就是了。何必要飞九万里到南海去呢？”到近郊去的人，只带当天吃的三餐粮食，回来肚子还是饱饱的；到百里外的人，要用一整夜时间舂米准备干粮；到千里外的人，要聚积三个月的粮食。蝉和小斑鸠这两只小虫、鸟又知道什么呢。</p>\n<blockquote>\n<p><strong>小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎！</strong></p>\n</blockquote>\n<p>小智比不上大智，短命比不上长寿。怎么知道是这样的呢？朝生暮死的菌类不知道是一天。春生夏死、夏生秋死的寒蝉，不知道一年的时光，这就是短命。楚国的南方有一种大树（灵龟），它把五百年当作一个春季，五百年当作一个秋季。上古时代有一种树叫做大椿，它把八千年当作一个春季，八千年当作一个秋季，这就是长寿。可是彭祖到如今还是以年寿长久而闻名于世，人们与他攀比，岂不可悲可叹！</p>\n<blockquote>\n<p><strong>汤之问棘也是已：穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云，抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。</strong></p>\n</blockquote>\n<p>商汤问棘的话也是这样的：“在草木不生的极远的北方，有个很深的大海，那就是天池。里面有条鱼，它的身子有几千里宽，没有人知道它有多长，它的名字叫做鲲。有一只鸟，它的名字叫做鹏。鹏的背像泰山，翅膀像天边的云；借着旋风盘旋而上九万里，超越云层，背负青天，然后向南飞翔，将要飞到南海去。</p>\n<blockquote>\n<p><strong>斥鴳笑之曰：“彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也，而彼且奚适也？”此小大之辩也。</strong></p>\n</blockquote>\n<p>小泽里的麻雀讥笑鹏说：‘它要飞到哪里去呢？我一跳就飞起来，不过数丈高就落下来，在蓬蒿丛中盘旋，这也是极好的飞行了。而它还要飞到哪里去呢？’”这就是小和大的不同了。</p>\n<blockquote>\n<p><strong>故夫知效一官，行比一乡，德合一君，而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世而誉之而不加劝，举世而非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。</strong></p>\n</blockquote>\n<p>所以，那些才智能胜任一官的职守，行为能够庇护一乡百姓的，德行能投合一个君王的心意的，能力能够取得全国信任的，他们看待自己，也像上面说的那只小鸟一样。而宋荣子对这种人加以嘲笑。<em>宋荣子这个人，世上所有的人都称赞他，他并不因此就特别奋勉，世上所有的人都诽谤他，他也并不因此就感到沮丧。他认定了对自己和对外物的分寸，分辨清楚荣辱的界限，就觉得不过如此罢了。他对待人世间的一切，都没有拼命去追求。即使如此，他还是有未达到的境界。</em></p>\n<blockquote>\n<p><strong>夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。</strong></p>\n</blockquote>\n<p>列子乘风而行，飘然自得，驾轻就熟。十五天以后返回；他对于求福的事，没有拼命去追求。这样虽然免了步行，还是有所凭借的。</p>\n<blockquote>\n<p><strong>若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉！故曰：至人无己，神人无功，圣人无名。</strong></p>\n</blockquote>\n<p>倘若顺应天地万物的本性，驾驭着六气的变化，邀游于无穷的境地，他还要凭借什么呢？所以说：修养最高的人能任顺自然、忘掉自己，修养达到神化不测境界的人无意于求功，有道德学问的圣人无意于求名。</p>\n<blockquote>\n<p><strong>尧让天下于许由，曰：“日月出矣，而爝火不息，其于光也，不亦难乎！时雨降矣，而犹浸灌，其于泽也，不亦劳乎！夫子立而天下治，而我犹尸之，吾自视缺然。请致天下。”许由曰：“子治天下，天下既已治也，而我犹代子，吾将为名乎？名者，实之宾也，吾将为宾乎？鹪鹩巢于深林，不过一枝；偃鼠饮河，不过满腹。归休乎君，予无所用天下为！庖人虽不治庖，尸祝不越樽俎而代之矣。”</strong></p>\n</blockquote>\n<p>尧要把天下让给许由，说：“太阳月亮出来了，而小火把还不熄灭，它的亮度，要和日月相比不是太难了吗！及时雨降下了，还要灌溉田地，对于滋润禾苗，不是徒劳吗！你如果成了君王，天下一定大治，而我还徒居其位，我自己感到惭愧极了，请允许我把天下交给你。”许由说：“你治理天下，天下已经治理好了，而我再接替你，我岂不是为名而来吗？名，是依附于实的客体，我难道要做有名无实的客体吗？鹪鹩在深林中筑巢，只要一根树枝；鼹鼠饮河水，只要肚子喝饱。请你回去吧，天下对于我没有什么用！厨子虽然不下厨，主祭的人却不应该超越权限而代行厨子的职事。”</p>\n<blockquote>\n<p><strong>肩吾问于连叔曰：“吾闻言于接舆，大而无当，往而不返。吾惊怖其言犹河汉而无极也，大有径庭，不近人情焉。”连叔曰：“其言谓何哉？”“曰‘藐姑射之山，有神人居焉。肌肤若冰雪，淖约若处子；不食五谷，吸风饮露；乘云气，御飞龙，而游乎四海之外；其神凝，使物不疵疠而年谷熟。’吾以是狂而不信也。”连叔曰：“然，瞽者无以与乎文章之观，聋者无以与乎钟鼓之声。岂唯形骸有聋盲哉？夫知亦有之。是其言也，犹时女也。之人也，之德也，将旁礴万物以为一，世蕲乎乱，孰弊弊焉以天下为事！之人也，物莫之伤，大浸稽天而不溺，大旱金石流、土山焦而不热。是其尘垢粃糠，将犹陶铸尧舜者也，孰肯以物为事！”</strong></p>\n</blockquote>\n<p>肩吾向连叔求教：“我从接舆那里听到谈话，大话连篇没有边际，一说下去就回不到原来的话题上。我十分惊恐他的言谈，就好像天上的银河没有边际，跟一般人的言谈差异甚远，确实是太不近情理了。”连叔问：“他说的是些什么呢？”肩吾转述道：“‘在遥远的姑射山上，住着一位神人，皮肤润白像冰雪，体态柔美如处女，不食五谷，吸清风饮甘露，乘云气驾飞龙，遨游于四海之外。他的神情那么专注，使得世间万物不受病害，年年五谷丰登。’我认为这全是虚妄之言，一点也不可信。”连叔听后说：“是呀！对于瞎子没法同他们欣赏花纹和色彩，对于聋子没法同他们聆听钟鼓的乐声。难道只是形骸上有聋与瞎吗？思想上也有聋和瞎啊！这话似乎就是说你肩吾的呀。那位神人，他的德行，与万事万物混同一起，以此求得整个天下的治理，谁还会忙忙碌碌把管理天下当成回事！那样的人哪，外物没有什么能伤害他，滔天的大水不能淹没他，天下大旱使金石熔化、土山焦裂，他也不感到灼热。他所留下的尘埃以及瘪谷糠麸之类的废物，也可造就出尧舜那样的圣贤仁君来，他怎么会把忙着管理万物当作己任呢！</p>\n<blockquote>\n<p><strong>宋人资章甫而适越，越人断发文身，无所用之。</strong></p>\n</blockquote>\n<p>北方的宋国有人贩卖帽子到南方的越国，越国人不蓄头发满身刺着花纹，没什么地方用得着帽子。</p>\n<blockquote>\n<p><strong>尧治天下之民，平海内之政。往见四子藐姑射之山，汾水之阳，窅然丧其天下焉。</strong></p>\n</blockquote>\n<p>尧治理好天下的百姓，安定了海内的政局，到姑射山上、汾水北面，去拜见四位得道的高士，不禁怅然若失，忘记了自己居于治理天下的地位。”</p>\n<blockquote>\n<p><strong>惠子谓庄子曰：“魏王贻我大瓠之种，我树之成而实五石。以盛水浆，其坚不能自举也。剖之以为瓢，则瓠落无所容。非不呺然大也，吾为其无用而掊之。”庄子曰：“夫子固拙于用大矣。宋人有善为不龟手之药者，世世以洴澼絖为事。客闻之，请买其方百金。聚族而谋之曰：‘我世世为澼絖，不过数金。今一朝而鬻技百金，请与之。’客得之，以说吴王。越有难，吴王使之将。冬，与越人水战，大败越人，裂地而封之。能不龟手一也，或以封，或不免于澼絖，则所用之异也。今子有五石之瓠，何不虑以为大樽而浮乎江湖，而忧其瓠落无所容？则夫子犹有蓬之心也夫！”</strong></p>\n</blockquote>\n<p>惠子对庄子说：“魏王送给我大葫芦的种子，我种下后结出的葫芦大得可以容纳五石。用它来盛水，它却因质地太脆无法提举。切开它当瓠，又大而平浅无法容纳东西。我不是嫌它不大，只是因为它无用，我把它砸了。”庄子说：“你真不善于使用大的物件。宋国有个人善于制作防止手冻裂的药，他家世世代代都以漂洗丝絮为职业。有个客人听说了，请求用一百金来买他的药方。这个宋国人召集全家商量说：‘我家世世代代靠这种药从事漂洗丝絮，一年所得不过数金；现在一旦卖掉这个药方马上可得百金，请大家答应我卖掉它。’这个客人买到药方，就去游说吴王。那时正逢越国有难，吴王就命他为将，在冬天跟越国人展开水战，大败越人，吴王就割地封侯来奖赏他。同样是一帖防止手冻裂的药方，有人靠它得到封赏，有人却只会用于漂洗丝絮，这是因为使用方法不同啊。现在你有可容五石东西的大葫芦，为什么不把它系在身上作为腰舟而浮游于江湖呢？却担忧它大而无处可容纳，可见你的心地过于浅陋狭隘了！”</p>\n<blockquote>\n<p><strong>惠子谓庄子曰：“吾有大树，人谓之樗。其大本臃肿而不中绳墨，其小枝卷曲而不中规矩。立之涂，匠者不顾。今子之言，大而无用，众所同去也。”庄子曰：“子独不见狸狌乎？卑身而伏，以候敖者；东西跳梁，不避高下；中于机辟，死于罔罟。今夫斄牛，其大若垂天之云。此能为大矣，而不能执鼠。今子有大树，患其无用，何不树之于无何有之乡，广莫之野，彷徨乎无为其侧，逍遥乎寝卧其下。不夭斤斧，物无害者，无所可用，安所困苦哉！”</strong></p>\n</blockquote>\n<p>惠子对庄子说：“我有一棵大树，人家把它叫做臭椿；它那树干上有许多赘瘤，不合绳墨，它那枝权弯弯曲曲，不合规矩。它长在路边，木匠都不看它一眼。现在你说的那段话，大而没有用，大家都不相信。”庄子说：“你难道没见过野猫和黄鼠狼吗？屈身伏在那里，等待捕捉来来往往的小动物；它捉小动物时东跳西跃，不避高下；但是一踏中捕兽的机关陷阱，就死在网中。再看那牦牛，它大如天边的云；这可以说够大的了，但是却不能捕鼠。现在你有一棵大树，担忧它没有用处，为什么不把它种在虚无之乡，广阔无边的原野，随意地徘徊在它的旁边，逍遥自在地躺在它的下面；这样大树就不会遭到斧头的砍伐，也没有什么东西会伤害它。它没有什么用处，又哪里会有什么困苦呢？”</p>\n"},{"title":"基于NextCloud搭建个人网盘","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-20T08:16:41.000Z","pic":null,"_content":"\n## Nextcloud\n\n`Nextcloud`是一款开源免费的私有云存储网盘项目，可以让你快速便捷地搭建一套属于自己或团队的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。它的客户端覆盖了`Windows`、`Mac`、`Android`、`iOS`、`Linux`等各种平台，也提供了网页端以及`WebDAV`接口，所以你几乎可以在各种设备上方便地访问你的云盘。\n\n## 安装 Nextcloud\n\n### 安装Mysql\n\n```shell\ndocker pull mysql # 拉取镜像\n\ndocker images # 查看名称/镜像id\n\ndocker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=******** -d c0cdc95609f1 #c0cdc95609f1（镜像id）\n```\n\n运行`mysql`并且设置访问端口：`3306`，容器名称：`mysql` ,管理员密码：`********`\n\n进入容器`bash`。\n\n```shell\ndocker exec -it 容器名称/容器id bash\n```\n\n登陆`mysql`\n\n```shell\nmysql -uroot -p\n```\n\n接着输入管理员密码：`admin`,回车。\n创建一个数据库\n\n```mysql\nCREATE DATABASE nextcloud;\n```\n\n创建一个用户\n\n```mysql\nCREATE USER 'nextcloud'@'%' IDENTIFIED BY 'admin';\n```\n\n创建一个用户名称为：`nextcloud；‘%’`：代表不限`ip`登陆，远程登陆; 密码为：`admin`。\n\n授权。\n\n```mysql\nGRANT ALL PRIVILEGES ON nextcloud.* TO nextcloud@'%'  WITH GRANT OPTION;\n```\n\n给这个用户`nextcloud`授予 这个数据库`nextcloud.*`所有的权限，远程登陆，密码为`admin`；\n\n### 基于Docker部署Nextcloud服务端\n\n选择以`Docker`的方式来部署`nextcloud`是因为`Docker`可以跨平台上运行，可以确保执行环境的一致性，有利于应用的迁移和管理。\n\n服务端部署的基本流程是：**安装`Docker`并启动** --> **运行`Nextcloud`容器** --> **访问`Web`端初始化**。\n\n安装的话不做过多说明，参考官方文档或本博客其他博文。\n\n下载`Nextcloud`镜像\n\n```shell\ndocker pull nextcloud\n```\n\n运行`Nextcloud`\n\n参数说明：\n\n- -d #容器后台运行\n- --name nextcloud #容器名\n- -v /data/nextcloud:/var/www/html #将宿主机的目录/data/nextcloud挂载到容器的/var/www/html\n- -p 8000:80 #将宿主机的端口（此处以8000为例）映射到容器的80端口\"\n\n```shell\ndocker run -d \\\n--name nextcloud \\\n-p 8000:80 \\\n-v /data/nextcloud:/var/www/html \\\nnextcloud\n```\n\n查看运行的容器。\n\n```shell\ndocker ps -a\n```\n\n停止运行的容器。\n\n```shell\ndocker stop id\n```","source":"_posts/基于centos搭建个人网盘.md","raw":"---\ntitle: 基于NextCloud搭建个人网盘\ntags:\n  - nextCloud\n  - docker\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-20 16:16:41\ncategories: 博客教程\npic:\n---\n\n## Nextcloud\n\n`Nextcloud`是一款开源免费的私有云存储网盘项目，可以让你快速便捷地搭建一套属于自己或团队的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。它的客户端覆盖了`Windows`、`Mac`、`Android`、`iOS`、`Linux`等各种平台，也提供了网页端以及`WebDAV`接口，所以你几乎可以在各种设备上方便地访问你的云盘。\n\n## 安装 Nextcloud\n\n### 安装Mysql\n\n```shell\ndocker pull mysql # 拉取镜像\n\ndocker images # 查看名称/镜像id\n\ndocker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=******** -d c0cdc95609f1 #c0cdc95609f1（镜像id）\n```\n\n运行`mysql`并且设置访问端口：`3306`，容器名称：`mysql` ,管理员密码：`********`\n\n进入容器`bash`。\n\n```shell\ndocker exec -it 容器名称/容器id bash\n```\n\n登陆`mysql`\n\n```shell\nmysql -uroot -p\n```\n\n接着输入管理员密码：`admin`,回车。\n创建一个数据库\n\n```mysql\nCREATE DATABASE nextcloud;\n```\n\n创建一个用户\n\n```mysql\nCREATE USER 'nextcloud'@'%' IDENTIFIED BY 'admin';\n```\n\n创建一个用户名称为：`nextcloud；‘%’`：代表不限`ip`登陆，远程登陆; 密码为：`admin`。\n\n授权。\n\n```mysql\nGRANT ALL PRIVILEGES ON nextcloud.* TO nextcloud@'%'  WITH GRANT OPTION;\n```\n\n给这个用户`nextcloud`授予 这个数据库`nextcloud.*`所有的权限，远程登陆，密码为`admin`；\n\n### 基于Docker部署Nextcloud服务端\n\n选择以`Docker`的方式来部署`nextcloud`是因为`Docker`可以跨平台上运行，可以确保执行环境的一致性，有利于应用的迁移和管理。\n\n服务端部署的基本流程是：**安装`Docker`并启动** --> **运行`Nextcloud`容器** --> **访问`Web`端初始化**。\n\n安装的话不做过多说明，参考官方文档或本博客其他博文。\n\n下载`Nextcloud`镜像\n\n```shell\ndocker pull nextcloud\n```\n\n运行`Nextcloud`\n\n参数说明：\n\n- -d #容器后台运行\n- --name nextcloud #容器名\n- -v /data/nextcloud:/var/www/html #将宿主机的目录/data/nextcloud挂载到容器的/var/www/html\n- -p 8000:80 #将宿主机的端口（此处以8000为例）映射到容器的80端口\"\n\n```shell\ndocker run -d \\\n--name nextcloud \\\n-p 8000:80 \\\n-v /data/nextcloud:/var/www/html \\\nnextcloud\n```\n\n查看运行的容器。\n\n```shell\ndocker ps -a\n```\n\n停止运行的容器。\n\n```shell\ndocker stop id\n```","slug":"基于centos搭建个人网盘","published":1,"updated":"2021-06-15T03:24:11.545Z","_id":"ckpapu7ir001elcxu7jljfive","layout":"post","photos":[],"link":"","content":"<h2 id=\"Nextcloud\"><a href=\"#Nextcloud\" class=\"headerlink\" title=\"Nextcloud\"></a>Nextcloud</h2><p><code>Nextcloud</code>是一款开源免费的私有云存储网盘项目，可以让你快速便捷地搭建一套属于自己或团队的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。它的客户端覆盖了<code>Windows</code>、<code>Mac</code>、<code>Android</code>、<code>iOS</code>、<code>Linux</code>等各种平台，也提供了网页端以及<code>WebDAV</code>接口，所以你几乎可以在各种设备上方便地访问你的云盘。</p>\n<h2 id=\"安装-Nextcloud\"><a href=\"#安装-Nextcloud\" class=\"headerlink\" title=\"安装 Nextcloud\"></a>安装 Nextcloud</h2><h3 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql # 拉取镜像</span><br><span class=\"line\"></span><br><span class=\"line\">docker images # 查看名称/镜像id</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=******** -d c0cdc95609f1 #c0cdc95609f1（镜像id）</span><br></pre></td></tr></table></figure>\n\n<p>运行<code>mysql</code>并且设置访问端口：<code>3306</code>，容器名称：<code>mysql</code> ,管理员密码：<code>********</code></p>\n<p>进入容器<code>bash</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名称/容器id bash</span><br></pre></td></tr></table></figure>\n\n<p>登陆<code>mysql</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p</span><br></pre></td></tr></table></figure>\n\n<p>接着输入管理员密码：<code>admin</code>,回车。<br>创建一个数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE nextcloud;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE USER &#x27;nextcloud&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;admin&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个用户名称为：<code>nextcloud；‘%’</code>：代表不限<code>ip</code>登陆，远程登陆; 密码为：<code>admin</code>。</p>\n<p>授权。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON nextcloud.* TO nextcloud@&#x27;%&#x27;  WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>\n\n<p>给这个用户<code>nextcloud</code>授予 这个数据库<code>nextcloud.*</code>所有的权限，远程登陆，密码为<code>admin</code>；</p>\n<h3 id=\"基于Docker部署Nextcloud服务端\"><a href=\"#基于Docker部署Nextcloud服务端\" class=\"headerlink\" title=\"基于Docker部署Nextcloud服务端\"></a>基于Docker部署Nextcloud服务端</h3><p>选择以<code>Docker</code>的方式来部署<code>nextcloud</code>是因为<code>Docker</code>可以跨平台上运行，可以确保执行环境的一致性，有利于应用的迁移和管理。</p>\n<p>服务端部署的基本流程是：<strong>安装<code>Docker</code>并启动</strong> –&gt; <strong>运行<code>Nextcloud</code>容器</strong> –&gt; <strong>访问<code>Web</code>端初始化</strong>。</p>\n<p>安装的话不做过多说明，参考官方文档或本博客其他博文。</p>\n<p>下载<code>Nextcloud</code>镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull nextcloud</span><br></pre></td></tr></table></figure>\n\n<p>运行<code>Nextcloud</code></p>\n<p>参数说明：</p>\n<ul>\n<li>-d #容器后台运行</li>\n<li>–name nextcloud #容器名</li>\n<li>-v /data/nextcloud:/var/www/html #将宿主机的目录/data/nextcloud挂载到容器的/var/www/html</li>\n<li>-p 8000:80 #将宿主机的端口（此处以8000为例）映射到容器的80端口”</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--name nextcloud \\</span><br><span class=\"line\">-p 8000:80 \\</span><br><span class=\"line\">-v /data/nextcloud:/var/www/html \\</span><br><span class=\"line\">nextcloud</span><br></pre></td></tr></table></figure>\n\n<p>查看运行的容器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n\n<p>停止运行的容器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop id</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Nextcloud\"><a href=\"#Nextcloud\" class=\"headerlink\" title=\"Nextcloud\"></a>Nextcloud</h2><p><code>Nextcloud</code>是一款开源免费的私有云存储网盘项目，可以让你快速便捷地搭建一套属于自己或团队的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。它的客户端覆盖了<code>Windows</code>、<code>Mac</code>、<code>Android</code>、<code>iOS</code>、<code>Linux</code>等各种平台，也提供了网页端以及<code>WebDAV</code>接口，所以你几乎可以在各种设备上方便地访问你的云盘。</p>\n<h2 id=\"安装-Nextcloud\"><a href=\"#安装-Nextcloud\" class=\"headerlink\" title=\"安装 Nextcloud\"></a>安装 Nextcloud</h2><h3 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql # 拉取镜像</span><br><span class=\"line\"></span><br><span class=\"line\">docker images # 查看名称/镜像id</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=******** -d c0cdc95609f1 #c0cdc95609f1（镜像id）</span><br></pre></td></tr></table></figure>\n\n<p>运行<code>mysql</code>并且设置访问端口：<code>3306</code>，容器名称：<code>mysql</code> ,管理员密码：<code>********</code></p>\n<p>进入容器<code>bash</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名称/容器id bash</span><br></pre></td></tr></table></figure>\n\n<p>登陆<code>mysql</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p</span><br></pre></td></tr></table></figure>\n\n<p>接着输入管理员密码：<code>admin</code>,回车。<br>创建一个数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE nextcloud;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE USER &#x27;nextcloud&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;admin&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个用户名称为：<code>nextcloud；‘%’</code>：代表不限<code>ip</code>登陆，远程登陆; 密码为：<code>admin</code>。</p>\n<p>授权。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON nextcloud.* TO nextcloud@&#x27;%&#x27;  WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>\n\n<p>给这个用户<code>nextcloud</code>授予 这个数据库<code>nextcloud.*</code>所有的权限，远程登陆，密码为<code>admin</code>；</p>\n<h3 id=\"基于Docker部署Nextcloud服务端\"><a href=\"#基于Docker部署Nextcloud服务端\" class=\"headerlink\" title=\"基于Docker部署Nextcloud服务端\"></a>基于Docker部署Nextcloud服务端</h3><p>选择以<code>Docker</code>的方式来部署<code>nextcloud</code>是因为<code>Docker</code>可以跨平台上运行，可以确保执行环境的一致性，有利于应用的迁移和管理。</p>\n<p>服务端部署的基本流程是：<strong>安装<code>Docker</code>并启动</strong> –&gt; <strong>运行<code>Nextcloud</code>容器</strong> –&gt; <strong>访问<code>Web</code>端初始化</strong>。</p>\n<p>安装的话不做过多说明，参考官方文档或本博客其他博文。</p>\n<p>下载<code>Nextcloud</code>镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull nextcloud</span><br></pre></td></tr></table></figure>\n\n<p>运行<code>Nextcloud</code></p>\n<p>参数说明：</p>\n<ul>\n<li>-d #容器后台运行</li>\n<li>–name nextcloud #容器名</li>\n<li>-v /data/nextcloud:/var/www/html #将宿主机的目录/data/nextcloud挂载到容器的/var/www/html</li>\n<li>-p 8000:80 #将宿主机的端口（此处以8000为例）映射到容器的80端口”</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--name nextcloud \\</span><br><span class=\"line\">-p 8000:80 \\</span><br><span class=\"line\">-v /data/nextcloud:/var/www/html \\</span><br><span class=\"line\">nextcloud</span><br></pre></td></tr></table></figure>\n\n<p>查看运行的容器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n\n<p>停止运行的容器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop id</span><br></pre></td></tr></table></figure>"},{"title":"基于docker部署code-server","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-25T09:21:25.000Z","pic":null,"_content":"\n## 拉取镜像\n\n```shell\n# docker pull codercom/code-server\n# docker images\nREPOSITORY             TAG       IMAGE ID       CREATED       SIZE\ncodercom/code-server   latest    f3ac734fcec8   12 days ago   802MB\n```\n\n## 创建挂载目录\n\n```shell\n# CODE=/home/docker/code\n# mkdir $CODE && cd $CODE\n```\n\n## 配置文件\n\n启动一个容器：`-u`表示使用`root`用户运行\n\n```shell\n# docker run -d -u root -p 8088:8080 --name code-server -v $CODE:/home/code codercom/code-server\n# docker ps\nCONTAINER ID   IMAGE       COMMAND          CREATED    \\ STATUS         PORTS             NAMES\nf10030d88e1d  codercom/code-server \"/usr/bin/entrypoint鈥 3 minutes ago Up 3 minutes   0.0.0.0:8088->8080/tcp, :::8088->8080/tcp code-server\n```\n\n拉出配置文件\n\n```shell\n# docker cp code-server:/root/.config/code-server/config.yaml $CODE/\n# cat $CODE/config.yaml\nbind-addr: 127.0.0.1:8080\nauth: password\npassword: 59bd4df2841fbc77d67f674f\ncert: false\n```\n\n修改你的密码：\n\n```shell\ndocker run -d -u root \\\n  -p 8088:8080 \\\n  --name code-server \\\n  -v $CODE/config.yaml:/root/.config/code-server/config.yaml \\\n  -v $CODE:/home/code \\\n  codercom/code-server\n```\n\n## 启动服务\n\n```shell\n# docker stop code-server && docker rm code-server\n# docker run -d -u root \\\n  -p 8088:8080 \\\n  --name code-server \\\n  -v $CODE/config.yaml:/root/.config/code-server/config.yaml \\\n  -v $CODE:/home/code \\\n  codercom/code-server\n```\n\n## 登录\n\n访问`http://holychan.ltd:8088/`，输入密码登录。\n\n![](![](Screenshot_1.webp))","source":"_posts/基于docker部署code-server.md","raw":"---\ntitle: 基于docker部署code-server\ntags:\n  - docker\n  - vscode\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-25 17:21:25\ncategories: Docker\npic:\n---\n\n## 拉取镜像\n\n```shell\n# docker pull codercom/code-server\n# docker images\nREPOSITORY             TAG       IMAGE ID       CREATED       SIZE\ncodercom/code-server   latest    f3ac734fcec8   12 days ago   802MB\n```\n\n## 创建挂载目录\n\n```shell\n# CODE=/home/docker/code\n# mkdir $CODE && cd $CODE\n```\n\n## 配置文件\n\n启动一个容器：`-u`表示使用`root`用户运行\n\n```shell\n# docker run -d -u root -p 8088:8080 --name code-server -v $CODE:/home/code codercom/code-server\n# docker ps\nCONTAINER ID   IMAGE       COMMAND          CREATED    \\ STATUS         PORTS             NAMES\nf10030d88e1d  codercom/code-server \"/usr/bin/entrypoint鈥 3 minutes ago Up 3 minutes   0.0.0.0:8088->8080/tcp, :::8088->8080/tcp code-server\n```\n\n拉出配置文件\n\n```shell\n# docker cp code-server:/root/.config/code-server/config.yaml $CODE/\n# cat $CODE/config.yaml\nbind-addr: 127.0.0.1:8080\nauth: password\npassword: 59bd4df2841fbc77d67f674f\ncert: false\n```\n\n修改你的密码：\n\n```shell\ndocker run -d -u root \\\n  -p 8088:8080 \\\n  --name code-server \\\n  -v $CODE/config.yaml:/root/.config/code-server/config.yaml \\\n  -v $CODE:/home/code \\\n  codercom/code-server\n```\n\n## 启动服务\n\n```shell\n# docker stop code-server && docker rm code-server\n# docker run -d -u root \\\n  -p 8088:8080 \\\n  --name code-server \\\n  -v $CODE/config.yaml:/root/.config/code-server/config.yaml \\\n  -v $CODE:/home/code \\\n  codercom/code-server\n```\n\n## 登录\n\n访问`http://holychan.ltd:8088/`，输入密码登录。\n\n![](![](Screenshot_1.webp))","slug":"基于docker部署code-server","published":1,"updated":"2021-06-15T03:24:11.545Z","_id":"ckpapu7it001hlcxuf2fma75d","layout":"post","photos":[],"link":"","content":"<h2 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker pull codercom/code-server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker images</span></span><br><span class=\"line\">REPOSITORY             TAG       IMAGE ID       CREATED       SIZE</span><br><span class=\"line\">codercom/code-server   latest    f3ac734fcec8   12 days ago   802MB</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建挂载目录\"><a href=\"#创建挂载目录\" class=\"headerlink\" title=\"创建挂载目录\"></a>创建挂载目录</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> CODE=/home/docker/code</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir <span class=\"variable\">$CODE</span> &amp;&amp; <span class=\"built_in\">cd</span> <span class=\"variable\">$CODE</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>启动一个容器：<code>-u</code>表示使用<code>root</code>用户运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker run -d -u root -p 8088:8080 --name code-server -v <span class=\"variable\">$CODE</span>:/home/code codercom/code-server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker ps</span></span><br><span class=\"line\">CONTAINER ID   IMAGE       COMMAND          CREATED    \\ STATUS         PORTS             NAMES</span><br><span class=\"line\">f10030d88e1d  codercom/code-server &quot;/usr/bin/entrypoint鈥 3 minutes ago Up 3 minutes   0.0.0.0:8088-&gt;8080/tcp, :::8088-&gt;8080/tcp code-server</span><br></pre></td></tr></table></figure>\n\n<p>拉出配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker cp code-server:/root/.config/code-server/config.yaml <span class=\"variable\">$CODE</span>/</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat <span class=\"variable\">$CODE</span>/config.yaml</span></span><br><span class=\"line\">bind-addr: 127.0.0.1:8080</span><br><span class=\"line\">auth: password</span><br><span class=\"line\">password: 59bd4df2841fbc77d67f674f</span><br><span class=\"line\">cert: false</span><br></pre></td></tr></table></figure>\n\n<p>修改你的密码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -u root \\</span><br><span class=\"line\">  -p 8088:8080 \\</span><br><span class=\"line\">  --name code-server \\</span><br><span class=\"line\">  -v $CODE/config.yaml:/root/.config/code-server/config.yaml \\</span><br><span class=\"line\">  -v $CODE:/home/code \\</span><br><span class=\"line\">  codercom/code-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker stop code-server &amp;&amp; docker rm code-server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker run -d -u root \\</span></span><br><span class=\"line\"><span class=\"bash\">  -p 8088:8080 \\</span></span><br><span class=\"line\"><span class=\"bash\">  --name code-server \\</span></span><br><span class=\"line\"><span class=\"bash\">  -v <span class=\"variable\">$CODE</span>/config.yaml:/root/.config/code-server/config.yaml \\</span></span><br><span class=\"line\"><span class=\"bash\">  -v <span class=\"variable\">$CODE</span>:/home/code \\</span></span><br><span class=\"line\"><span class=\"bash\">  codercom/code-server</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h2><p>访问<code>http://holychan.ltd:8088/</code>，输入密码登录。</p>\n<p><img src=\"!%5B%5D(Screenshot_1.webp)\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker pull codercom/code-server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker images</span></span><br><span class=\"line\">REPOSITORY             TAG       IMAGE ID       CREATED       SIZE</span><br><span class=\"line\">codercom/code-server   latest    f3ac734fcec8   12 days ago   802MB</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建挂载目录\"><a href=\"#创建挂载目录\" class=\"headerlink\" title=\"创建挂载目录\"></a>创建挂载目录</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> CODE=/home/docker/code</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> mkdir <span class=\"variable\">$CODE</span> &amp;&amp; <span class=\"built_in\">cd</span> <span class=\"variable\">$CODE</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>启动一个容器：<code>-u</code>表示使用<code>root</code>用户运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker run -d -u root -p 8088:8080 --name code-server -v <span class=\"variable\">$CODE</span>:/home/code codercom/code-server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker ps</span></span><br><span class=\"line\">CONTAINER ID   IMAGE       COMMAND          CREATED    \\ STATUS         PORTS             NAMES</span><br><span class=\"line\">f10030d88e1d  codercom/code-server &quot;/usr/bin/entrypoint鈥 3 minutes ago Up 3 minutes   0.0.0.0:8088-&gt;8080/tcp, :::8088-&gt;8080/tcp code-server</span><br></pre></td></tr></table></figure>\n\n<p>拉出配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker cp code-server:/root/.config/code-server/config.yaml <span class=\"variable\">$CODE</span>/</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> cat <span class=\"variable\">$CODE</span>/config.yaml</span></span><br><span class=\"line\">bind-addr: 127.0.0.1:8080</span><br><span class=\"line\">auth: password</span><br><span class=\"line\">password: 59bd4df2841fbc77d67f674f</span><br><span class=\"line\">cert: false</span><br></pre></td></tr></table></figure>\n\n<p>修改你的密码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -u root \\</span><br><span class=\"line\">  -p 8088:8080 \\</span><br><span class=\"line\">  --name code-server \\</span><br><span class=\"line\">  -v $CODE/config.yaml:/root/.config/code-server/config.yaml \\</span><br><span class=\"line\">  -v $CODE:/home/code \\</span><br><span class=\"line\">  codercom/code-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker stop code-server &amp;&amp; docker rm code-server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> docker run -d -u root \\</span></span><br><span class=\"line\"><span class=\"bash\">  -p 8088:8080 \\</span></span><br><span class=\"line\"><span class=\"bash\">  --name code-server \\</span></span><br><span class=\"line\"><span class=\"bash\">  -v <span class=\"variable\">$CODE</span>/config.yaml:/root/.config/code-server/config.yaml \\</span></span><br><span class=\"line\"><span class=\"bash\">  -v <span class=\"variable\">$CODE</span>:/home/code \\</span></span><br><span class=\"line\"><span class=\"bash\">  codercom/code-server</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h2><p>访问<code>http://holychan.ltd:8088/</code>，输入密码登录。</p>\n<p><img src=\"!%5B%5D(Screenshot_1.webp)\"></p>\n"},{"title":"正则表达式","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-21T13:08:59.000Z","pic":null,"_content":"\n# 正则表达式\n\n正则表达式是处理字符串的强大工具，它有自己特定的语法结构。能实现字符串的检索、替换、匹配验证，对于爬虫来说，从`HTML`里提取想要的信息就非常方便。\n\n## 实例引入\n\n下面用几个实例来看一下正则表达式的用法。\n\n打开开源中国提供的正则表达式测试工具[http://tool.oschina.net/regex/](http://tool.oschina.net/regex/)，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。\n\n例如，输入下面这段待匹配的文本：\n\n```python\nHello, my phone number is 010-86432100 and email is espholychan@outlook.com, and my website is https://holychan.ltd.\n```\n\n这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。\n\n![](Screenshot_1.webp)\n\n在网页右侧选择**“匹配 Email地址”**，就可以看到下方出现了文本中的`E-mail`。如果选择**“匹配网址URL”**，就可以看到下方出现了文本中的`URL`。\n\n这里使用了正则表达式的匹配功能，也就是用一定规则将特定的文本提取出来。\n\n比方说，电子邮件是有其特定的组成格式的：`一段字符串` `+` `@` `符号` `+` `某个域名`。而`URL`的组成格式则是`协议类型``+``冒号``+``双斜线``+``域名和路径`。\n\n可以用下面的正则表达式匹配`URL`：\n\n```re\n[a-zA-z]+://[^\\s]*\n```\n\n用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似`URL`的文本，那就会被提取出来。\n\n下表中列出了常用的匹配规则：\n\n| 模式 | 描述 |\n| :--: | :--- |\n| \\w | 匹配字母、数字及下划线 |\n| \\W | 匹配不是字母、数字及下划线的字符 |\n| \\s | 匹配任意空白字符，等价于 [\\t\\n\\r\\f] |\n| \\S | 匹配任意非空字符 |\n| \\d | 匹配任意数字，等价于 [0~9] |\n| \\D | 匹配任意非数字的字符 |\n| \\A | 匹配字符串开头 |\n| \\Z | 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 |\n| \\z | 匹配字符串结尾，如果存在换行，同时还会匹配换行符 |\n| \\G | 匹配最后匹配完成的位置 |\n| \\n | 匹配一个换行符 |\n| \\t | 匹配一个制表符 |\n| ^ | 匹配一行字符串的开头 |\n| $ | 匹配一行字符串的结尾 |\n| . | 匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符 |\n| [...] | 用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k |\n| [^...] | 不在 [] 中的字符，比如 匹配除了 a、b、c 之外的字符 |\n| * | 匹配 0 个或多个表达式 |\n| + | 匹配 1 个或多个表达式 |\n| ? | 匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式 |\n| {n} | 精确匹配 n 个前面的表达式 |\n| {n, m} | 匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式 |\n| a\\|b | 匹配 a 或 b |\n| () | 匹配括号内的表达式，也表示一个组 |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n`Python`的`re库`提供了整个正则表达式的实现，利用这个库，可以在`Python`中使用正则表达式。\n\n## match\n\n首先介绍一个常用的匹配方法——`match`，向它传入要匹配的字符串，以及正则表达式，就可以检测这个正则表达式是否匹配字符串。`match`方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回`None`。\n\n```python\nimport re\n\ncontent = 'Hello 123 4567 World_This is a Regex Demo'\nprint(len(content))\nresult = re.match('^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}', content)\nprint(result)\nprint(result.group())\nprint(result.span())\n```\n\n运行结果如下：\n\n```python\n41\n<re.Match object; span=(0, 25), match='Hello 123 4567 World_This'>\nHello 123 4567 World_This\n(0, 25)\n```\n\n这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：\n\n```python\n^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}\n```\n\n用它来匹配这个长字符串。开头的`^`·匹配字符串的开头，也就是以`Hello`开头；`\\s`匹配空白字符，用来匹配目标字符串的空格；`\\d`匹配数字，3个`\\d`匹配`123`；再写1个`\\s`匹配空格；后面的`4567`，依然能用4个`\\d`来匹配，但是这么写比较烦琐，所以后面可以跟`{4}`代表匹配前面的规则4次，也就是匹配4个数字；后面再紧接1个空白字符，最后`\\w{10}`匹配10个字母及下划线。\n\n在`match`方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是`SRE_Match`对象，这证明成功匹配。该对象有两个方法：`group`方法可以输出匹配的内容，结果是`Hello 123 4567 World_This`，这恰好是正则表达式规则所匹配的内容；`span`方法可以输出匹配的范围，结果是`(0, 25)`，这就是匹配到的结果字符串在原字符串中的位置范围。\n\n在`match`方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是`SRE_Match`对象，这证明成功匹配。该对象有两个方法：`group`方法可以输出匹配的内容，结果是`Hello 123 4567 World_This`，这恰好是正则表达式规则所匹配的内容；`span`方法可以输出匹配的范围，结果是`(0, 25)`，这就是匹配到的结果字符串在原字符串中的位置范围。\n\n## 匹配目标\n\n用`match`方法得到了匹配到的字符串内容，想从字符串中提取一部分内容，该怎么办呢？\n\n要从一段文本中提取出邮件或电话号码等内容。可以使用`()`括号将想提取的子字符串括起来。`()`实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用`group`方法传入分组的索引即可获取提取的结果。\n\n示例如下：\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^Hello\\s(\\d+)\\sWorld', content)\nprint(result)\nprint(result.group())\nprint(result.group(1))\nprint(result.span())\n```\n\n这里把字符串中的`1234567`提取出来，此时可以将数字部分的正则表达式用`()`括起来，然后调用了`group(1)`获取匹配结果。\n\n运行结果如下：\n\n```python\n<re.Match object; span=(0, 19), match='Hello 1234567 World'>\nHello 1234567 World\n1234567\n(0,25)\n```\n\n可以看到，成功得到了`1234567`。这里用的是`group(1)`，它与`group()`有所不同，后者会输出完整的匹配结果，而前者会输出第一个被`()`包围的匹配结果。假如正则表达式后面还有`()`包括的内容，那么可以依次用`group(2)`、`group(3)`等来获取。\n\n## 通用匹配\n\n刚才写的正则表达比较复杂，出现空白字符写`\\s`匹配，出现数字用`\\d`匹配，这样的工作量非常大。\n\n可以用一个万能匹配来减少这些工作，那就是`.*`。其中`.`可以匹配任意字符（除换行符），`*`代表匹配前面的字符无限次，组合在一起可以匹配任意字符。\n\n改写一下正则表达式：\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^Hello.*Demo$', content)\nprint(result)\nprint(result.group())\nprint(result.span())\n```\n\n运行结果：\n\n```python\n<re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'>\nHello 1234567 World_This is a Regex Demo\n(0,40)\n```\n\n## 贪婪与非贪婪\n\n使用通用匹配`.*`时，有时候匹配到的并不是我们想要的结果。\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^He.*(\\d+).*Demo$', content)\nprint(result)\nprint(result.group(1))\n```\n\n想获取中间的数字，所以中间依然写的是`(\\d+)`。由于数字两侧的内容比较杂乱，所以略写成`.*`。最后，组成`^He.*(\\d+).*Demo$`，看样子并没有什么问题。\n\n运行结果：\n\n```python\n<re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'>\n7\n```\n\n奇怪的事情发生了，只得到了`7`这个数字，这是怎么回事呢？\n\n这里就涉及一个**贪婪匹配**与**非贪婪匹配**的问题了。在贪婪匹配下，`.*`会匹配尽可能多的字符。正则表达式中`.*`后面是`\\d+`，也就是至少一个数字，并没有指定具体多少个数字，因此，`.*`就尽可能匹配多的字符，这里就把`123456`匹配了，给`\\d+`留下一个可满足条件的数字`7`，最后得到的内容就只有数字`7`了。\n\n这里需要使用非贪婪匹配，非贪婪匹配的写法是`.*?`。\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^He.*?(\\d+).*Demo$', content)\nprint(result)\nprint(result.group(1))\n```\n\n将第一个`.*`改成了`.*?`，转变为非贪婪匹配。运行结果如下：\n\n```shell\n<re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'>\n1234567\n```\n\n成功获取`1234567`，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当`.*?`匹配到`Hello`后面的空白字符时，再往后的字符就是数字了，而`\\d+`恰好可以匹配，`.*?`就不再进行匹配，交给`\\d+`去匹配后面的数字。这样`.*?`匹配了尽可能少的字符，`\\d+`的结果就是`1234567`。\n\n在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用`.*?`来代替`.*`，以免出现匹配结果缺失的情况。\n\n需要注意的是，如果匹配的结果在字符串结尾，`.*?`就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：\n\n```python\nimport re \n\ncontent = 'http://weibo.com/comment/kEraCN' \nresult1 = re.match('http.*?comment/(.*?)', content) \nresult2 = re.match('http.*?comment/(.*)', content) \nprint('result1', result1.group(1)) \nprint('result2', result2.group(1))\n```\n\n运行结果如下：\n\n```python\nresult1 \nresult2 kEraCN\n```\n\n## 修饰符\n\n正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。\n\n用实例来看一下：\n\n```python\nimport re\n\ncontent =  '''Hello 1234567 World_This is \na Regex Demo \n'''\nresult = re.match('^He.*?(\\d+).*?Demo$', content) \nprint(result.group(1))\n```\n\n字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：\n\n```python\nTraceback (most recent call last):\n  File \"c:/Users/espho/PycharmProjects/PythonProjs/python模块/re库/修饰符.py\", line 7, in <module>\n    print(result.group(1))\nAttributeError: 'NoneType' object has no attribute 'group'\n```\n\n运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为`None`，又调用了`group`方法导致`AttributeError`。为什么加了一个换行符，就匹配不到了呢？这是因为我们匹配的是除换行符之外的任意字符，当遇到换行符时，`.*?`就不能匹配了，导致匹配失败。\n\n这里只需加一个修饰符`re.S`，即可修正这个错误：\n\n```python\nresult = re.match('^He.*?(\\d+).*?Demo$', content, re.S) \n```\n\n运行结果如下：\n\n```python\n1234567\n```\n\n这个`re.S`在网页匹配中经常用到。因为`HTML`节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。\n\n还有一些修饰符，在必要的情况下也可以使用，如表所示：\n\n| 修饰符 | 描述 |\n| :---: | :---- |\n| re.I | 使匹配对大小写不敏感 |\n| re.L | 做本地化识别（locale-aware）匹配 |\n| re.M | 多行匹配，影响 ^ 和 $ |\n| re.S | 使匹配包括换行在内的所有字符 |\n| re.U | 根据 Unicode 字符集解析字符。这个标志影响 \\w、\\W、\\b 和 \\B |\n| re.X | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 |\n","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ntags:\n  - python\n  - re\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-21 21:08:59\ncategories: 爬虫\npic:\n---\n\n# 正则表达式\n\n正则表达式是处理字符串的强大工具，它有自己特定的语法结构。能实现字符串的检索、替换、匹配验证，对于爬虫来说，从`HTML`里提取想要的信息就非常方便。\n\n## 实例引入\n\n下面用几个实例来看一下正则表达式的用法。\n\n打开开源中国提供的正则表达式测试工具[http://tool.oschina.net/regex/](http://tool.oschina.net/regex/)，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。\n\n例如，输入下面这段待匹配的文本：\n\n```python\nHello, my phone number is 010-86432100 and email is espholychan@outlook.com, and my website is https://holychan.ltd.\n```\n\n这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。\n\n![](Screenshot_1.webp)\n\n在网页右侧选择**“匹配 Email地址”**，就可以看到下方出现了文本中的`E-mail`。如果选择**“匹配网址URL”**，就可以看到下方出现了文本中的`URL`。\n\n这里使用了正则表达式的匹配功能，也就是用一定规则将特定的文本提取出来。\n\n比方说，电子邮件是有其特定的组成格式的：`一段字符串` `+` `@` `符号` `+` `某个域名`。而`URL`的组成格式则是`协议类型``+``冒号``+``双斜线``+``域名和路径`。\n\n可以用下面的正则表达式匹配`URL`：\n\n```re\n[a-zA-z]+://[^\\s]*\n```\n\n用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似`URL`的文本，那就会被提取出来。\n\n下表中列出了常用的匹配规则：\n\n| 模式 | 描述 |\n| :--: | :--- |\n| \\w | 匹配字母、数字及下划线 |\n| \\W | 匹配不是字母、数字及下划线的字符 |\n| \\s | 匹配任意空白字符，等价于 [\\t\\n\\r\\f] |\n| \\S | 匹配任意非空字符 |\n| \\d | 匹配任意数字，等价于 [0~9] |\n| \\D | 匹配任意非数字的字符 |\n| \\A | 匹配字符串开头 |\n| \\Z | 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 |\n| \\z | 匹配字符串结尾，如果存在换行，同时还会匹配换行符 |\n| \\G | 匹配最后匹配完成的位置 |\n| \\n | 匹配一个换行符 |\n| \\t | 匹配一个制表符 |\n| ^ | 匹配一行字符串的开头 |\n| $ | 匹配一行字符串的结尾 |\n| . | 匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符 |\n| [...] | 用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k |\n| [^...] | 不在 [] 中的字符，比如 匹配除了 a、b、c 之外的字符 |\n| * | 匹配 0 个或多个表达式 |\n| + | 匹配 1 个或多个表达式 |\n| ? | 匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式 |\n| {n} | 精确匹配 n 个前面的表达式 |\n| {n, m} | 匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式 |\n| a\\|b | 匹配 a 或 b |\n| () | 匹配括号内的表达式，也表示一个组 |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n`Python`的`re库`提供了整个正则表达式的实现，利用这个库，可以在`Python`中使用正则表达式。\n\n## match\n\n首先介绍一个常用的匹配方法——`match`，向它传入要匹配的字符串，以及正则表达式，就可以检测这个正则表达式是否匹配字符串。`match`方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回`None`。\n\n```python\nimport re\n\ncontent = 'Hello 123 4567 World_This is a Regex Demo'\nprint(len(content))\nresult = re.match('^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}', content)\nprint(result)\nprint(result.group())\nprint(result.span())\n```\n\n运行结果如下：\n\n```python\n41\n<re.Match object; span=(0, 25), match='Hello 123 4567 World_This'>\nHello 123 4567 World_This\n(0, 25)\n```\n\n这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：\n\n```python\n^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}\n```\n\n用它来匹配这个长字符串。开头的`^`·匹配字符串的开头，也就是以`Hello`开头；`\\s`匹配空白字符，用来匹配目标字符串的空格；`\\d`匹配数字，3个`\\d`匹配`123`；再写1个`\\s`匹配空格；后面的`4567`，依然能用4个`\\d`来匹配，但是这么写比较烦琐，所以后面可以跟`{4}`代表匹配前面的规则4次，也就是匹配4个数字；后面再紧接1个空白字符，最后`\\w{10}`匹配10个字母及下划线。\n\n在`match`方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是`SRE_Match`对象，这证明成功匹配。该对象有两个方法：`group`方法可以输出匹配的内容，结果是`Hello 123 4567 World_This`，这恰好是正则表达式规则所匹配的内容；`span`方法可以输出匹配的范围，结果是`(0, 25)`，这就是匹配到的结果字符串在原字符串中的位置范围。\n\n在`match`方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是`SRE_Match`对象，这证明成功匹配。该对象有两个方法：`group`方法可以输出匹配的内容，结果是`Hello 123 4567 World_This`，这恰好是正则表达式规则所匹配的内容；`span`方法可以输出匹配的范围，结果是`(0, 25)`，这就是匹配到的结果字符串在原字符串中的位置范围。\n\n## 匹配目标\n\n用`match`方法得到了匹配到的字符串内容，想从字符串中提取一部分内容，该怎么办呢？\n\n要从一段文本中提取出邮件或电话号码等内容。可以使用`()`括号将想提取的子字符串括起来。`()`实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用`group`方法传入分组的索引即可获取提取的结果。\n\n示例如下：\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^Hello\\s(\\d+)\\sWorld', content)\nprint(result)\nprint(result.group())\nprint(result.group(1))\nprint(result.span())\n```\n\n这里把字符串中的`1234567`提取出来，此时可以将数字部分的正则表达式用`()`括起来，然后调用了`group(1)`获取匹配结果。\n\n运行结果如下：\n\n```python\n<re.Match object; span=(0, 19), match='Hello 1234567 World'>\nHello 1234567 World\n1234567\n(0,25)\n```\n\n可以看到，成功得到了`1234567`。这里用的是`group(1)`，它与`group()`有所不同，后者会输出完整的匹配结果，而前者会输出第一个被`()`包围的匹配结果。假如正则表达式后面还有`()`包括的内容，那么可以依次用`group(2)`、`group(3)`等来获取。\n\n## 通用匹配\n\n刚才写的正则表达比较复杂，出现空白字符写`\\s`匹配，出现数字用`\\d`匹配，这样的工作量非常大。\n\n可以用一个万能匹配来减少这些工作，那就是`.*`。其中`.`可以匹配任意字符（除换行符），`*`代表匹配前面的字符无限次，组合在一起可以匹配任意字符。\n\n改写一下正则表达式：\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^Hello.*Demo$', content)\nprint(result)\nprint(result.group())\nprint(result.span())\n```\n\n运行结果：\n\n```python\n<re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'>\nHello 1234567 World_This is a Regex Demo\n(0,40)\n```\n\n## 贪婪与非贪婪\n\n使用通用匹配`.*`时，有时候匹配到的并不是我们想要的结果。\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^He.*(\\d+).*Demo$', content)\nprint(result)\nprint(result.group(1))\n```\n\n想获取中间的数字，所以中间依然写的是`(\\d+)`。由于数字两侧的内容比较杂乱，所以略写成`.*`。最后，组成`^He.*(\\d+).*Demo$`，看样子并没有什么问题。\n\n运行结果：\n\n```python\n<re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'>\n7\n```\n\n奇怪的事情发生了，只得到了`7`这个数字，这是怎么回事呢？\n\n这里就涉及一个**贪婪匹配**与**非贪婪匹配**的问题了。在贪婪匹配下，`.*`会匹配尽可能多的字符。正则表达式中`.*`后面是`\\d+`，也就是至少一个数字，并没有指定具体多少个数字，因此，`.*`就尽可能匹配多的字符，这里就把`123456`匹配了，给`\\d+`留下一个可满足条件的数字`7`，最后得到的内容就只有数字`7`了。\n\n这里需要使用非贪婪匹配，非贪婪匹配的写法是`.*?`。\n\n```python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\nresult = re.match('^He.*?(\\d+).*Demo$', content)\nprint(result)\nprint(result.group(1))\n```\n\n将第一个`.*`改成了`.*?`，转变为非贪婪匹配。运行结果如下：\n\n```shell\n<re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'>\n1234567\n```\n\n成功获取`1234567`，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当`.*?`匹配到`Hello`后面的空白字符时，再往后的字符就是数字了，而`\\d+`恰好可以匹配，`.*?`就不再进行匹配，交给`\\d+`去匹配后面的数字。这样`.*?`匹配了尽可能少的字符，`\\d+`的结果就是`1234567`。\n\n在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用`.*?`来代替`.*`，以免出现匹配结果缺失的情况。\n\n需要注意的是，如果匹配的结果在字符串结尾，`.*?`就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：\n\n```python\nimport re \n\ncontent = 'http://weibo.com/comment/kEraCN' \nresult1 = re.match('http.*?comment/(.*?)', content) \nresult2 = re.match('http.*?comment/(.*)', content) \nprint('result1', result1.group(1)) \nprint('result2', result2.group(1))\n```\n\n运行结果如下：\n\n```python\nresult1 \nresult2 kEraCN\n```\n\n## 修饰符\n\n正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。\n\n用实例来看一下：\n\n```python\nimport re\n\ncontent =  '''Hello 1234567 World_This is \na Regex Demo \n'''\nresult = re.match('^He.*?(\\d+).*?Demo$', content) \nprint(result.group(1))\n```\n\n字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：\n\n```python\nTraceback (most recent call last):\n  File \"c:/Users/espho/PycharmProjects/PythonProjs/python模块/re库/修饰符.py\", line 7, in <module>\n    print(result.group(1))\nAttributeError: 'NoneType' object has no attribute 'group'\n```\n\n运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为`None`，又调用了`group`方法导致`AttributeError`。为什么加了一个换行符，就匹配不到了呢？这是因为我们匹配的是除换行符之外的任意字符，当遇到换行符时，`.*?`就不能匹配了，导致匹配失败。\n\n这里只需加一个修饰符`re.S`，即可修正这个错误：\n\n```python\nresult = re.match('^He.*?(\\d+).*?Demo$', content, re.S) \n```\n\n运行结果如下：\n\n```python\n1234567\n```\n\n这个`re.S`在网页匹配中经常用到。因为`HTML`节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。\n\n还有一些修饰符，在必要的情况下也可以使用，如表所示：\n\n| 修饰符 | 描述 |\n| :---: | :---- |\n| re.I | 使匹配对大小写不敏感 |\n| re.L | 做本地化识别（locale-aware）匹配 |\n| re.M | 多行匹配，影响 ^ 和 $ |\n| re.S | 使匹配包括换行在内的所有字符 |\n| re.U | 根据 Unicode 字符集解析字符。这个标志影响 \\w、\\W、\\b 和 \\B |\n| re.X | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 |\n","slug":"正则表达式","published":1,"updated":"2021-06-15T03:24:11.548Z","_id":"ckpapu7iv001jlcxuc8825odl","layout":"post","photos":[],"link":"","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><p>正则表达式是处理字符串的强大工具，它有自己特定的语法结构。能实现字符串的检索、替换、匹配验证，对于爬虫来说，从<code>HTML</code>里提取想要的信息就非常方便。</p>\n<h2 id=\"实例引入\"><a href=\"#实例引入\" class=\"headerlink\" title=\"实例引入\"></a>实例引入</h2><p>下面用几个实例来看一下正则表达式的用法。</p>\n<p>打开开源中国提供的正则表达式测试工具<a href=\"http://tool.oschina.net/regex/\">http://tool.oschina.net/regex/</a>，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。</p>\n<p>例如，输入下面这段待匹配的文本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, my phone number <span class=\"keyword\">is</span> 010-<span class=\"number\">86432100</span> <span class=\"keyword\">and</span> email <span class=\"keyword\">is</span> espholychan@outlook.com, <span class=\"keyword\">and</span> my website <span class=\"keyword\">is</span> https://holychan.ltd.</span><br></pre></td></tr></table></figure>\n\n<p>这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>在网页右侧选择<strong>“匹配 Email地址”</strong>，就可以看到下方出现了文本中的<code>E-mail</code>。如果选择<strong>“匹配网址URL”</strong>，就可以看到下方出现了文本中的<code>URL</code>。</p>\n<p>这里使用了正则表达式的匹配功能，也就是用一定规则将特定的文本提取出来。</p>\n<p>比方说，电子邮件是有其特定的组成格式的：<code>一段字符串</code> <code>+</code> <code>@</code> <code>符号</code> <code>+</code> <code>某个域名</code>。而<code>URL</code>的组成格式则是<code>协议类型``+``冒号``+``双斜线``+``域名和路径</code>。</p>\n<p>可以用下面的正则表达式匹配<code>URL</code>：</p>\n<figure class=\"highlight re\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">[<span class=\"identifier\">a</span>-<span class=\"identifier\">zA</span>-<span class=\"identifier\">z</span>]</span>+:<span class=\"comment\">//[^\\s]*</span></span><br></pre></td></tr></table></figure>\n\n<p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似<code>URL</code>的文本，那就会被提取出来。</p>\n<p>下表中列出了常用的匹配规则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">模式</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">\\w</td>\n<td align=\"left\">匹配字母、数字及下划线</td>\n</tr>\n<tr>\n<td align=\"center\">\\W</td>\n<td align=\"left\">匹配不是字母、数字及下划线的字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\s</td>\n<td align=\"left\">匹配任意空白字符，等价于 [\\t\\n\\r\\f]</td>\n</tr>\n<tr>\n<td align=\"center\">\\S</td>\n<td align=\"left\">匹配任意非空字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\d</td>\n<td align=\"left\">匹配任意数字，等价于 [0~9]</td>\n</tr>\n<tr>\n<td align=\"center\">\\D</td>\n<td align=\"left\">匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\A</td>\n<td align=\"left\">匹配字符串开头</td>\n</tr>\n<tr>\n<td align=\"center\">\\Z</td>\n<td align=\"left\">匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td>\n</tr>\n<tr>\n<td align=\"center\">\\z</td>\n<td align=\"left\">匹配字符串结尾，如果存在换行，同时还会匹配换行符</td>\n</tr>\n<tr>\n<td align=\"center\">\\G</td>\n<td align=\"left\">匹配最后匹配完成的位置</td>\n</tr>\n<tr>\n<td align=\"center\">\\n</td>\n<td align=\"left\">匹配一个换行符</td>\n</tr>\n<tr>\n<td align=\"center\">\\t</td>\n<td align=\"left\">匹配一个制表符</td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"left\">匹配一行字符串的开头</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"left\">匹配一行字符串的结尾</td>\n</tr>\n<tr>\n<td align=\"center\">.</td>\n<td align=\"left\">匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td>\n</tr>\n<tr>\n<td align=\"center\">[…]</td>\n<td align=\"left\">用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k</td>\n</tr>\n<tr>\n<td align=\"center\">[^…]</td>\n<td align=\"left\">不在 [] 中的字符，比如 匹配除了 a、b、c 之外的字符</td>\n</tr>\n<tr>\n<td align=\"center\">*</td>\n<td align=\"left\">匹配 0 个或多个表达式</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"left\">匹配 1 个或多个表达式</td>\n</tr>\n<tr>\n<td align=\"center\">?</td>\n<td align=\"left\">匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td>\n</tr>\n<tr>\n<td align=\"center\">{n}</td>\n<td align=\"left\">精确匹配 n 个前面的表达式</td>\n</tr>\n<tr>\n<td align=\"center\">{n, m}</td>\n<td align=\"left\">匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td>\n</tr>\n<tr>\n<td align=\"center\">a|b</td>\n<td align=\"left\">匹配 a 或 b</td>\n</tr>\n<tr>\n<td align=\"center\">()</td>\n<td align=\"left\">匹配括号内的表达式，也表示一个组</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n<p><code>Python</code>的<code>re库</code>提供了整个正则表达式的实现，利用这个库，可以在<code>Python</code>中使用正则表达式。</p>\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><p>首先介绍一个常用的匹配方法——<code>match</code>，向它传入要匹配的字符串，以及正则表达式，就可以检测这个正则表达式是否匹配字符串。<code>match</code>方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回<code>None</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(content))</span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^Hello\\s\\d\\d\\d\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.span())</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">41</span></span><br><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">25</span>), match=<span class=\"string\">&#x27;Hello 123 4567 World_This&#x27;</span>&gt;</span><br><span class=\"line\">Hello <span class=\"number\">123</span> <span class=\"number\">4567</span> World_This</span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^Hello\\s\\d\\d\\d\\s\\d&#123;<span class=\"number\">4</span>&#125;\\s\\w&#123;<span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用它来匹配这个长字符串。开头的<code>^</code>·匹配字符串的开头，也就是以<code>Hello</code>开头；<code>\\s</code>匹配空白字符，用来匹配目标字符串的空格；<code>\\d</code>匹配数字，3个<code>\\d</code>匹配<code>123</code>；再写1个<code>\\s</code>匹配空格；后面的<code>4567</code>，依然能用4个<code>\\d</code>来匹配，但是这么写比较烦琐，所以后面可以跟<code>&#123;4&#125;</code>代表匹配前面的规则4次，也就是匹配4个数字；后面再紧接1个空白字符，最后<code>\\w&#123;10&#125;</code>匹配10个字母及下划线。</p>\n<p>在<code>match</code>方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是<code>SRE_Match</code>对象，这证明成功匹配。该对象有两个方法：<code>group</code>方法可以输出匹配的内容，结果是<code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code>方法可以输出匹配的范围，结果是<code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p>\n<p>在<code>match</code>方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是<code>SRE_Match</code>对象，这证明成功匹配。该对象有两个方法：<code>group</code>方法可以输出匹配的内容，结果是<code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code>方法可以输出匹配的范围，结果是<code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p>\n<h2 id=\"匹配目标\"><a href=\"#匹配目标\" class=\"headerlink\" title=\"匹配目标\"></a>匹配目标</h2><p>用<code>match</code>方法得到了匹配到的字符串内容，想从字符串中提取一部分内容，该怎么办呢？</p>\n<p>要从一段文本中提取出邮件或电话号码等内容。可以使用<code>()</code>括号将想提取的子字符串括起来。<code>()</code>实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用<code>group</code>方法传入分组的索引即可获取提取的结果。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^Hello\\s(\\d+)\\sWorld&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.span())</span><br></pre></td></tr></table></figure>\n\n<p>这里把字符串中的<code>1234567</code>提取出来，此时可以将数字部分的正则表达式用<code>()</code>括起来，然后调用了<code>group(1)</code>获取匹配结果。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">19</span>), match=<span class=\"string\">&#x27;Hello 1234567 World&#x27;</span>&gt;</span><br><span class=\"line\">Hello <span class=\"number\">1234567</span> World</span><br><span class=\"line\"><span class=\"number\">1234567</span></span><br><span class=\"line\">(<span class=\"number\">0</span>,<span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，成功得到了<code>1234567</code>。这里用的是<code>group(1)</code>，它与<code>group()</code>有所不同，后者会输出完整的匹配结果，而前者会输出第一个被<code>()</code>包围的匹配结果。假如正则表达式后面还有<code>()</code>包括的内容，那么可以依次用<code>group(2)</code>、<code>group(3)</code>等来获取。</p>\n<h2 id=\"通用匹配\"><a href=\"#通用匹配\" class=\"headerlink\" title=\"通用匹配\"></a>通用匹配</h2><p>刚才写的正则表达比较复杂，出现空白字符写<code>\\s</code>匹配，出现数字用<code>\\d</code>匹配，这样的工作量非常大。</p>\n<p>可以用一个万能匹配来减少这些工作，那就是<code>.*</code>。其中<code>.</code>可以匹配任意字符（除换行符），<code>*</code>代表匹配前面的字符无限次，组合在一起可以匹配任意字符。</p>\n<p>改写一下正则表达式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^Hello.*Demo$&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.span())</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">40</span>), match=<span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class=\"line\">Hello <span class=\"number\">1234567</span> World_This <span class=\"keyword\">is</span> a Regex Demo</span><br><span class=\"line\">(<span class=\"number\">0</span>,<span class=\"number\">40</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h2><p>使用通用匹配<code>.*</code>时，有时候匹配到的并不是我们想要的结果。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*(\\d+).*Demo$&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>想获取中间的数字，所以中间依然写的是<code>(\\d+)</code>。由于数字两侧的内容比较杂乱，所以略写成<code>.*</code>。最后，组成<code>^He.*(\\d+).*Demo$</code>，看样子并没有什么问题。</p>\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">40</span>), match=<span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>奇怪的事情发生了，只得到了<code>7</code>这个数字，这是怎么回事呢？</p>\n<p>这里就涉及一个<strong>贪婪匹配</strong>与<strong>非贪婪匹配</strong>的问题了。在贪婪匹配下，<code>.*</code>会匹配尽可能多的字符。正则表达式中<code>.*</code>后面是<code>\\d+</code>，也就是至少一个数字，并没有指定具体多少个数字，因此，<code>.*</code>就尽可能匹配多的字符，这里就把<code>123456</code>匹配了，给<code>\\d+</code>留下一个可满足条件的数字<code>7</code>，最后得到的内容就只有数字<code>7</code>了。</p>\n<p>这里需要使用非贪婪匹配，非贪婪匹配的写法是<code>.*?</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*?(\\d+).*Demo$&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>将第一个<code>.*</code>改成了<code>.*?</code>，转变为非贪婪匹配。运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match object; span=(0, 40), match=&#x27;Hello 1234567 World_This is a Regex Demo&#x27;&gt;</span><br><span class=\"line\">1234567</span><br></pre></td></tr></table></figure>\n\n<p>成功获取<code>1234567</code>，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当<code>.*?</code>匹配到<code>Hello</code>后面的空白字符时，再往后的字符就是数字了，而<code>\\d+</code>恰好可以匹配，<code>.*?</code>就不再进行匹配，交给<code>\\d+</code>去匹配后面的数字。这样<code>.*?</code>匹配了尽可能少的字符，<code>\\d+</code>的结果就是<code>1234567</code>。</p>\n<p>在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用<code>.*?</code>来代替<code>.*</code>，以免出现匹配结果缺失的情况。</p>\n<p>需要注意的是，如果匹配的结果在字符串结尾，<code>.*?</code>就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re </span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;http://weibo.com/comment/kEraCN&#x27;</span> </span><br><span class=\"line\">result1 = re.match(<span class=\"string\">&#x27;http.*?comment/(.*?)&#x27;</span>, content) </span><br><span class=\"line\">result2 = re.match(<span class=\"string\">&#x27;http.*?comment/(.*)&#x27;</span>, content) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;result1&#x27;</span>, result1.group(<span class=\"number\">1</span>)) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;result2&#x27;</span>, result2.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result1 </span><br><span class=\"line\">result2 kEraCN</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。</p>\n<p>用实例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content =  <span class=\"string\">&#x27;&#x27;&#x27;Hello 1234567 World_This is </span></span><br><span class=\"line\"><span class=\"string\">a Regex Demo </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*?(\\d+).*?Demo$&#x27;</span>, content) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;c:/Users/espho/PycharmProjects/PythonProjs/python模块/re库/修饰符.py&quot;</span>, line <span class=\"number\">7</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br><span class=\"line\">AttributeError: <span class=\"string\">&#x27;NoneType&#x27;</span> <span class=\"built_in\">object</span> has no attribute <span class=\"string\">&#x27;group&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为<code>None</code>，又调用了<code>group</code>方法导致<code>AttributeError</code>。为什么加了一个换行符，就匹配不到了呢？这是因为我们匹配的是除换行符之外的任意字符，当遇到换行符时，<code>.*?</code>就不能匹配了，导致匹配失败。</p>\n<p>这里只需加一个修饰符<code>re.S</code>，即可修正这个错误：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*?(\\d+).*?Demo$&#x27;</span>, content, re.S) </span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n\n<p>这个<code>re.S</code>在网页匹配中经常用到。因为<code>HTML</code>节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p>\n<p>还有一些修饰符，在必要的情况下也可以使用，如表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">re.I</td>\n<td align=\"left\">使匹配对大小写不敏感</td>\n</tr>\n<tr>\n<td align=\"center\">re.L</td>\n<td align=\"left\">做本地化识别（locale-aware）匹配</td>\n</tr>\n<tr>\n<td align=\"center\">re.M</td>\n<td align=\"left\">多行匹配，影响 ^ 和 $</td>\n</tr>\n<tr>\n<td align=\"center\">re.S</td>\n<td align=\"left\">使匹配包括换行在内的所有字符</td>\n</tr>\n<tr>\n<td align=\"center\">re.U</td>\n<td align=\"left\">根据 Unicode 字符集解析字符。这个标志影响 \\w、\\W、\\b 和 \\B</td>\n</tr>\n<tr>\n<td align=\"center\">re.X</td>\n<td align=\"left\">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><p>正则表达式是处理字符串的强大工具，它有自己特定的语法结构。能实现字符串的检索、替换、匹配验证，对于爬虫来说，从<code>HTML</code>里提取想要的信息就非常方便。</p>\n<h2 id=\"实例引入\"><a href=\"#实例引入\" class=\"headerlink\" title=\"实例引入\"></a>实例引入</h2><p>下面用几个实例来看一下正则表达式的用法。</p>\n<p>打开开源中国提供的正则表达式测试工具<a href=\"http://tool.oschina.net/regex/\">http://tool.oschina.net/regex/</a>，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。</p>\n<p>例如，输入下面这段待匹配的文本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, my phone number <span class=\"keyword\">is</span> 010-<span class=\"number\">86432100</span> <span class=\"keyword\">and</span> email <span class=\"keyword\">is</span> espholychan@outlook.com, <span class=\"keyword\">and</span> my website <span class=\"keyword\">is</span> https://holychan.ltd.</span><br></pre></td></tr></table></figure>\n\n<p>这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>在网页右侧选择<strong>“匹配 Email地址”</strong>，就可以看到下方出现了文本中的<code>E-mail</code>。如果选择<strong>“匹配网址URL”</strong>，就可以看到下方出现了文本中的<code>URL</code>。</p>\n<p>这里使用了正则表达式的匹配功能，也就是用一定规则将特定的文本提取出来。</p>\n<p>比方说，电子邮件是有其特定的组成格式的：<code>一段字符串</code> <code>+</code> <code>@</code> <code>符号</code> <code>+</code> <code>某个域名</code>。而<code>URL</code>的组成格式则是<code>协议类型``+``冒号``+``双斜线``+``域名和路径</code>。</p>\n<p>可以用下面的正则表达式匹配<code>URL</code>：</p>\n<figure class=\"highlight re\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">[<span class=\"identifier\">a</span>-<span class=\"identifier\">zA</span>-<span class=\"identifier\">z</span>]</span>+:<span class=\"comment\">//[^\\s]*</span></span><br></pre></td></tr></table></figure>\n\n<p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似<code>URL</code>的文本，那就会被提取出来。</p>\n<p>下表中列出了常用的匹配规则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">模式</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">\\w</td>\n<td align=\"left\">匹配字母、数字及下划线</td>\n</tr>\n<tr>\n<td align=\"center\">\\W</td>\n<td align=\"left\">匹配不是字母、数字及下划线的字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\s</td>\n<td align=\"left\">匹配任意空白字符，等价于 [\\t\\n\\r\\f]</td>\n</tr>\n<tr>\n<td align=\"center\">\\S</td>\n<td align=\"left\">匹配任意非空字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\d</td>\n<td align=\"left\">匹配任意数字，等价于 [0~9]</td>\n</tr>\n<tr>\n<td align=\"center\">\\D</td>\n<td align=\"left\">匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td align=\"center\">\\A</td>\n<td align=\"left\">匹配字符串开头</td>\n</tr>\n<tr>\n<td align=\"center\">\\Z</td>\n<td align=\"left\">匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td>\n</tr>\n<tr>\n<td align=\"center\">\\z</td>\n<td align=\"left\">匹配字符串结尾，如果存在换行，同时还会匹配换行符</td>\n</tr>\n<tr>\n<td align=\"center\">\\G</td>\n<td align=\"left\">匹配最后匹配完成的位置</td>\n</tr>\n<tr>\n<td align=\"center\">\\n</td>\n<td align=\"left\">匹配一个换行符</td>\n</tr>\n<tr>\n<td align=\"center\">\\t</td>\n<td align=\"left\">匹配一个制表符</td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"left\">匹配一行字符串的开头</td>\n</tr>\n<tr>\n<td align=\"center\">$</td>\n<td align=\"left\">匹配一行字符串的结尾</td>\n</tr>\n<tr>\n<td align=\"center\">.</td>\n<td align=\"left\">匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td>\n</tr>\n<tr>\n<td align=\"center\">[…]</td>\n<td align=\"left\">用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k</td>\n</tr>\n<tr>\n<td align=\"center\">[^…]</td>\n<td align=\"left\">不在 [] 中的字符，比如 匹配除了 a、b、c 之外的字符</td>\n</tr>\n<tr>\n<td align=\"center\">*</td>\n<td align=\"left\">匹配 0 个或多个表达式</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"left\">匹配 1 个或多个表达式</td>\n</tr>\n<tr>\n<td align=\"center\">?</td>\n<td align=\"left\">匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td>\n</tr>\n<tr>\n<td align=\"center\">{n}</td>\n<td align=\"left\">精确匹配 n 个前面的表达式</td>\n</tr>\n<tr>\n<td align=\"center\">{n, m}</td>\n<td align=\"left\">匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td>\n</tr>\n<tr>\n<td align=\"center\">a|b</td>\n<td align=\"left\">匹配 a 或 b</td>\n</tr>\n<tr>\n<td align=\"center\">()</td>\n<td align=\"left\">匹配括号内的表达式，也表示一个组</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 80%;\n    }\n</style>\n\n<p><code>Python</code>的<code>re库</code>提供了整个正则表达式的实现，利用这个库，可以在<code>Python</code>中使用正则表达式。</p>\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><p>首先介绍一个常用的匹配方法——<code>match</code>，向它传入要匹配的字符串，以及正则表达式，就可以检测这个正则表达式是否匹配字符串。<code>match</code>方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回<code>None</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(content))</span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^Hello\\s\\d\\d\\d\\s\\d&#123;4&#125;\\s\\w&#123;10&#125;&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.span())</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">41</span></span><br><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">25</span>), match=<span class=\"string\">&#x27;Hello 123 4567 World_This&#x27;</span>&gt;</span><br><span class=\"line\">Hello <span class=\"number\">123</span> <span class=\"number\">4567</span> World_This</span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^Hello\\s\\d\\d\\d\\s\\d&#123;<span class=\"number\">4</span>&#125;\\s\\w&#123;<span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用它来匹配这个长字符串。开头的<code>^</code>·匹配字符串的开头，也就是以<code>Hello</code>开头；<code>\\s</code>匹配空白字符，用来匹配目标字符串的空格；<code>\\d</code>匹配数字，3个<code>\\d</code>匹配<code>123</code>；再写1个<code>\\s</code>匹配空格；后面的<code>4567</code>，依然能用4个<code>\\d</code>来匹配，但是这么写比较烦琐，所以后面可以跟<code>&#123;4&#125;</code>代表匹配前面的规则4次，也就是匹配4个数字；后面再紧接1个空白字符，最后<code>\\w&#123;10&#125;</code>匹配10个字母及下划线。</p>\n<p>在<code>match</code>方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是<code>SRE_Match</code>对象，这证明成功匹配。该对象有两个方法：<code>group</code>方法可以输出匹配的内容，结果是<code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code>方法可以输出匹配的范围，结果是<code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p>\n<p>在<code>match</code>方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是<code>SRE_Match</code>对象，这证明成功匹配。该对象有两个方法：<code>group</code>方法可以输出匹配的内容，结果是<code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code>方法可以输出匹配的范围，结果是<code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p>\n<h2 id=\"匹配目标\"><a href=\"#匹配目标\" class=\"headerlink\" title=\"匹配目标\"></a>匹配目标</h2><p>用<code>match</code>方法得到了匹配到的字符串内容，想从字符串中提取一部分内容，该怎么办呢？</p>\n<p>要从一段文本中提取出邮件或电话号码等内容。可以使用<code>()</code>括号将想提取的子字符串括起来。<code>()</code>实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用<code>group</code>方法传入分组的索引即可获取提取的结果。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^Hello\\s(\\d+)\\sWorld&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.span())</span><br></pre></td></tr></table></figure>\n\n<p>这里把字符串中的<code>1234567</code>提取出来，此时可以将数字部分的正则表达式用<code>()</code>括起来，然后调用了<code>group(1)</code>获取匹配结果。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">19</span>), match=<span class=\"string\">&#x27;Hello 1234567 World&#x27;</span>&gt;</span><br><span class=\"line\">Hello <span class=\"number\">1234567</span> World</span><br><span class=\"line\"><span class=\"number\">1234567</span></span><br><span class=\"line\">(<span class=\"number\">0</span>,<span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，成功得到了<code>1234567</code>。这里用的是<code>group(1)</code>，它与<code>group()</code>有所不同，后者会输出完整的匹配结果，而前者会输出第一个被<code>()</code>包围的匹配结果。假如正则表达式后面还有<code>()</code>包括的内容，那么可以依次用<code>group(2)</code>、<code>group(3)</code>等来获取。</p>\n<h2 id=\"通用匹配\"><a href=\"#通用匹配\" class=\"headerlink\" title=\"通用匹配\"></a>通用匹配</h2><p>刚才写的正则表达比较复杂，出现空白字符写<code>\\s</code>匹配，出现数字用<code>\\d</code>匹配，这样的工作量非常大。</p>\n<p>可以用一个万能匹配来减少这些工作，那就是<code>.*</code>。其中<code>.</code>可以匹配任意字符（除换行符），<code>*</code>代表匹配前面的字符无限次，组合在一起可以匹配任意字符。</p>\n<p>改写一下正则表达式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^Hello.*Demo$&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.span())</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">40</span>), match=<span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class=\"line\">Hello <span class=\"number\">1234567</span> World_This <span class=\"keyword\">is</span> a Regex Demo</span><br><span class=\"line\">(<span class=\"number\">0</span>,<span class=\"number\">40</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h2><p>使用通用匹配<code>.*</code>时，有时候匹配到的并不是我们想要的结果。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*(\\d+).*Demo$&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>想获取中间的数字，所以中间依然写的是<code>(\\d+)</code>。由于数字两侧的内容比较杂乱，所以略写成<code>.*</code>。最后，组成<code>^He.*(\\d+).*Demo$</code>，看样子并没有什么问题。</p>\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match <span class=\"built_in\">object</span>; span=(<span class=\"number\">0</span>, <span class=\"number\">40</span>), match=<span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>奇怪的事情发生了，只得到了<code>7</code>这个数字，这是怎么回事呢？</p>\n<p>这里就涉及一个<strong>贪婪匹配</strong>与<strong>非贪婪匹配</strong>的问题了。在贪婪匹配下，<code>.*</code>会匹配尽可能多的字符。正则表达式中<code>.*</code>后面是<code>\\d+</code>，也就是至少一个数字，并没有指定具体多少个数字，因此，<code>.*</code>就尽可能匹配多的字符，这里就把<code>123456</code>匹配了，给<code>\\d+</code>留下一个可满足条件的数字<code>7</code>，最后得到的内容就只有数字<code>7</code>了。</p>\n<p>这里需要使用非贪婪匹配，非贪婪匹配的写法是<code>.*?</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*?(\\d+).*Demo$&#x27;</span>, content)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>将第一个<code>.*</code>改成了<code>.*?</code>，转变为非贪婪匹配。运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;re.Match object; span=(0, 40), match=&#x27;Hello 1234567 World_This is a Regex Demo&#x27;&gt;</span><br><span class=\"line\">1234567</span><br></pre></td></tr></table></figure>\n\n<p>成功获取<code>1234567</code>，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当<code>.*?</code>匹配到<code>Hello</code>后面的空白字符时，再往后的字符就是数字了，而<code>\\d+</code>恰好可以匹配，<code>.*?</code>就不再进行匹配，交给<code>\\d+</code>去匹配后面的数字。这样<code>.*?</code>匹配了尽可能少的字符，<code>\\d+</code>的结果就是<code>1234567</code>。</p>\n<p>在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用<code>.*?</code>来代替<code>.*</code>，以免出现匹配结果缺失的情况。</p>\n<p>需要注意的是，如果匹配的结果在字符串结尾，<code>.*?</code>就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re </span><br><span class=\"line\"></span><br><span class=\"line\">content = <span class=\"string\">&#x27;http://weibo.com/comment/kEraCN&#x27;</span> </span><br><span class=\"line\">result1 = re.match(<span class=\"string\">&#x27;http.*?comment/(.*?)&#x27;</span>, content) </span><br><span class=\"line\">result2 = re.match(<span class=\"string\">&#x27;http.*?comment/(.*)&#x27;</span>, content) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;result1&#x27;</span>, result1.group(<span class=\"number\">1</span>)) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;result2&#x27;</span>, result2.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result1 </span><br><span class=\"line\">result2 kEraCN</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。</p>\n<p>用实例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">content =  <span class=\"string\">&#x27;&#x27;&#x27;Hello 1234567 World_This is </span></span><br><span class=\"line\"><span class=\"string\">a Regex Demo </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*?(\\d+).*?Demo$&#x27;</span>, content) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;c:/Users/espho/PycharmProjects/PythonProjs/python模块/re库/修饰符.py&quot;</span>, line <span class=\"number\">7</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result.group(<span class=\"number\">1</span>))</span><br><span class=\"line\">AttributeError: <span class=\"string\">&#x27;NoneType&#x27;</span> <span class=\"built_in\">object</span> has no attribute <span class=\"string\">&#x27;group&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为<code>None</code>，又调用了<code>group</code>方法导致<code>AttributeError</code>。为什么加了一个换行符，就匹配不到了呢？这是因为我们匹配的是除换行符之外的任意字符，当遇到换行符时，<code>.*?</code>就不能匹配了，导致匹配失败。</p>\n<p>这里只需加一个修饰符<code>re.S</code>，即可修正这个错误：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = re.match(<span class=\"string\">&#x27;^He.*?(\\d+).*?Demo$&#x27;</span>, content, re.S) </span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n\n<p>这个<code>re.S</code>在网页匹配中经常用到。因为<code>HTML</code>节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p>\n<p>还有一些修饰符，在必要的情况下也可以使用，如表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">re.I</td>\n<td align=\"left\">使匹配对大小写不敏感</td>\n</tr>\n<tr>\n<td align=\"center\">re.L</td>\n<td align=\"left\">做本地化识别（locale-aware）匹配</td>\n</tr>\n<tr>\n<td align=\"center\">re.M</td>\n<td align=\"left\">多行匹配，影响 ^ 和 $</td>\n</tr>\n<tr>\n<td align=\"center\">re.S</td>\n<td align=\"left\">使匹配包括换行在内的所有字符</td>\n</tr>\n<tr>\n<td align=\"center\">re.U</td>\n<td align=\"left\">根据 Unicode 字符集解析字符。这个标志影响 \\w、\\W、\\b 和 \\B</td>\n</tr>\n<tr>\n<td align=\"center\">re.X</td>\n<td align=\"left\">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td>\n</tr>\n</tbody></table>\n"},{"title":"爬虫的基本原理","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-11T16:12:50.000Z","pic":null,"_content":"\n我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。\n\n## 爬虫概述\n\n简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。\n\n### 获取网页\n\n获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。\n\n源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。\n\n前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？\n\n`Python`提供了许多库来帮助我们实现这个操作，如`urllib`、`requests`等。可以用这些库来帮助我们实现`HTTP`请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的`Body`部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 \n\n### 提取信息\n\n提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用`正则表达式`提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。\n\n另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或`XPath`来提取网页信息的库，如`Beautiful Soup`、`pyquery`、`lxml`等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。\n\n提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。\n\n### 保存数据\n\n提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为`TXT文本`或`JSON文本`，也可以保存到数据库，如`MySQL`和`MongoDB`等，还可保存至远程服务器，如借助`SFTP`进行操作等。\n\n### 自动化程序\n\n自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。\n\n### 能抓怎样的数据\n\n能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是`HTML源代码`。\n\n另外，可能有些网页返回的不是`HTML代码`，而是一个`JSON字符串`（其中`API`接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。\n\n此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。\n\n另外，还可以看到各种扩展名的文件，如`CSS`、`JavaScript`和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。\n\n上述内容其实都对应各自的`URL`，是基于`HTTP`或`HTTPS`协议的，只要是这种数据，爬虫都可以抓取。\n\n### JavaScript渲染页面\n\n有时候，在用`urllib`或`requests`抓取网页时，得到的源代码实际和浏览器中看到的不一样。\n\n这是一个非常常见的问题。现在网页越来越多地采用`Ajax`、`前端模块化工具`来构建，整个网页可能都是由`JavaScript`渲染出来的，也就是说原始的`HTML代码`就是一个空壳，例如：\n\n```html\n<!DOCTYPE html> \n<html> \n  <head> \n    <meta charset=\"UTF-8\"> \n    <title>This is a Demo</title> \n  </head> \n  <body>\n    <div id=\"container\"> </div> \n  </body> \n  <script src=\"app.js\"></script> \n</html> \n```\n\n`body`节点里面只有一个`id`为`container`的节点，但是需要注意在`body`节点后引入了`app.js`，它便负责整个网站的渲染。\n\n在浏览器中打开这个页面时，首先会加载这个`HTML`内容，接着浏览器会发现其中引入了一个`app.js`文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的`JavaScript`代码，而`JavaScript`则会改变`HTML`中的节点，向其添加内容，最后得到完整的页面。\n\n但是在用`urllib`或`requests`等库请求当前页面时，我们得到的只是这个`HTML代码`，它不会帮助我们去继续加载这个`JavaScript`文件，这样也就看不到浏览器中的内容。\n\n这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。\n\n因此，使用基本`HTTP`请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台`Ajax`接口，也可使用`Selenium`、`Splash`这样的库来实现模拟`JavaScript`渲染。\n","source":"_posts/爬虫的基本原理.md","raw":"---\ntitle: 爬虫的基本原理\ntags:\n  - http\n  - 爬虫\n  - python\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-12 00:12:50\ncategories: 爬虫\npic:\n---\n\n我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。\n\n## 爬虫概述\n\n简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。\n\n### 获取网页\n\n获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。\n\n源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。\n\n前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？\n\n`Python`提供了许多库来帮助我们实现这个操作，如`urllib`、`requests`等。可以用这些库来帮助我们实现`HTTP`请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的`Body`部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 \n\n### 提取信息\n\n提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用`正则表达式`提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。\n\n另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或`XPath`来提取网页信息的库，如`Beautiful Soup`、`pyquery`、`lxml`等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。\n\n提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。\n\n### 保存数据\n\n提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为`TXT文本`或`JSON文本`，也可以保存到数据库，如`MySQL`和`MongoDB`等，还可保存至远程服务器，如借助`SFTP`进行操作等。\n\n### 自动化程序\n\n自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。\n\n### 能抓怎样的数据\n\n能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是`HTML源代码`。\n\n另外，可能有些网页返回的不是`HTML代码`，而是一个`JSON字符串`（其中`API`接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。\n\n此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。\n\n另外，还可以看到各种扩展名的文件，如`CSS`、`JavaScript`和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。\n\n上述内容其实都对应各自的`URL`，是基于`HTTP`或`HTTPS`协议的，只要是这种数据，爬虫都可以抓取。\n\n### JavaScript渲染页面\n\n有时候，在用`urllib`或`requests`抓取网页时，得到的源代码实际和浏览器中看到的不一样。\n\n这是一个非常常见的问题。现在网页越来越多地采用`Ajax`、`前端模块化工具`来构建，整个网页可能都是由`JavaScript`渲染出来的，也就是说原始的`HTML代码`就是一个空壳，例如：\n\n```html\n<!DOCTYPE html> \n<html> \n  <head> \n    <meta charset=\"UTF-8\"> \n    <title>This is a Demo</title> \n  </head> \n  <body>\n    <div id=\"container\"> </div> \n  </body> \n  <script src=\"app.js\"></script> \n</html> \n```\n\n`body`节点里面只有一个`id`为`container`的节点，但是需要注意在`body`节点后引入了`app.js`，它便负责整个网站的渲染。\n\n在浏览器中打开这个页面时，首先会加载这个`HTML`内容，接着浏览器会发现其中引入了一个`app.js`文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的`JavaScript`代码，而`JavaScript`则会改变`HTML`中的节点，向其添加内容，最后得到完整的页面。\n\n但是在用`urllib`或`requests`等库请求当前页面时，我们得到的只是这个`HTML代码`，它不会帮助我们去继续加载这个`JavaScript`文件，这样也就看不到浏览器中的内容。\n\n这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。\n\n因此，使用基本`HTTP`请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台`Ajax`接口，也可使用`Selenium`、`Splash`这样的库来实现模拟`JavaScript`渲染。\n","slug":"爬虫的基本原理","published":1,"updated":"2021-06-15T03:24:11.551Z","_id":"ckpapu7k70039lcxue1lnfjc9","layout":"post","photos":[],"link":"","content":"<p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>\n<h2 id=\"爬虫概述\"><a href=\"#爬虫概述\" class=\"headerlink\" title=\"爬虫概述\"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。</p>\n<h3 id=\"获取网页\"><a href=\"#获取网页\" class=\"headerlink\" title=\"获取网页\"></a>获取网页</h3><p>获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。</p>\n<p>源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</p>\n<p>前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？</p>\n<p><code>Python</code>提供了许多库来帮助我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。可以用这些库来帮助我们实现<code>HTTP</code>请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的<code>Body</code>部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 </p>\n<h3 id=\"提取信息\"><a href=\"#提取信息\" class=\"headerlink\" title=\"提取信息\"></a>提取信息</h3><p>提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用<code>正则表达式</code>提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p>\n<p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或<code>XPath</code>来提取网页信息的库，如<code>Beautiful Soup</code>、<code>pyquery</code>、<code>lxml</code>等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。</p>\n<p>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p>\n<h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为<code>TXT文本</code>或<code>JSON文本</code>，也可以保存到数据库，如<code>MySQL</code>和<code>MongoDB</code>等，还可保存至远程服务器，如借助<code>SFTP</code>进行操作等。</p>\n<h3 id=\"自动化程序\"><a href=\"#自动化程序\" class=\"headerlink\" title=\"自动化程序\"></a>自动化程序</h3><p>自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>\n<h3 id=\"能抓怎样的数据\"><a href=\"#能抓怎样的数据\" class=\"headerlink\" title=\"能抓怎样的数据\"></a>能抓怎样的数据</h3><p>能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是<code>HTML源代码</code>。</p>\n<p>另外，可能有些网页返回的不是<code>HTML代码</code>，而是一个<code>JSON字符串</code>（其中<code>API</code>接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p>\n<p>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p>\n<p>另外，还可以看到各种扩展名的文件，如<code>CSS</code>、<code>JavaScript</code>和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</p>\n<p>上述内容其实都对应各自的<code>URL</code>，是基于<code>HTTP</code>或<code>HTTPS</code>协议的，只要是这种数据，爬虫都可以抓取。</p>\n<h3 id=\"JavaScript渲染页面\"><a href=\"#JavaScript渲染页面\" class=\"headerlink\" title=\"JavaScript渲染页面\"></a>JavaScript渲染页面</h3><p>有时候，在用<code>urllib</code>或<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p>\n<p>这是一个非常常见的问题。现在网页越来越多地采用<code>Ajax</code>、<code>前端模块化工具</code>来构建，整个网页可能都是由<code>JavaScript</code>渲染出来的，也就是说原始的<code>HTML代码</code>就是一个空壳，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;app.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p><code>body</code>节点里面只有一个<code>id</code>为<code>container</code>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p>\n<p>在浏览器中打开这个页面时，首先会加载这个<code>HTML</code>内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的<code>JavaScript</code>代码，而<code>JavaScript</code>则会改变<code>HTML</code>中的节点，向其添加内容，最后得到完整的页面。</p>\n<p>但是在用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个<code>HTML代码</code>，它不会帮助我们去继续加载这个<code>JavaScript</code>文件，这样也就看不到浏览器中的内容。</p>\n<p>这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p>\n<p>因此，使用基本<code>HTTP</code>请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台<code>Ajax</code>接口，也可使用<code>Selenium</code>、<code>Splash</code>这样的库来实现模拟<code>JavaScript</code>渲染。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>\n<h2 id=\"爬虫概述\"><a href=\"#爬虫概述\" class=\"headerlink\" title=\"爬虫概述\"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，概要介绍一下。</p>\n<h3 id=\"获取网页\"><a href=\"#获取网页\" class=\"headerlink\" title=\"获取网页\"></a>获取网页</h3><p>获爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。</p>\n<p>源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</p>\n<p>前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个 请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？</p>\n<p><code>Python</code>提供了许多库来帮助我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。可以用这些库来帮助我们实现<code>HTTP</code>请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的<code>Body</code>部分，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。 </p>\n<h3 id=\"提取信息\"><a href=\"#提取信息\" class=\"headerlink\" title=\"提取信息\"></a>提取信息</h3><p>提获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用<code>正则表达式</code>提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p>\n<p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或<code>XPath</code>来提取网页信息的库，如<code>Beautiful Soup</code>、<code>pyquery</code>、<code>lxml</code>等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。</p>\n<p>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p>\n<h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为<code>TXT文本</code>或<code>JSON文本</code>，也可以保存到数据库，如<code>MySQL</code>和<code>MongoDB</code>等，还可保存至远程服务器，如借助<code>SFTP</code>进行操作等。</p>\n<h3 id=\"自动化程序\"><a href=\"#自动化程序\" class=\"headerlink\" title=\"自动化程序\"></a>自动化程序</h3><p>自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各 种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>\n<h3 id=\"能抓怎样的数据\"><a href=\"#能抓怎样的数据\" class=\"headerlink\" title=\"能抓怎样的数据\"></a>能抓怎样的数据</h3><p>能在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML代码，而最常抓取的便是<code>HTML源代码</code>。</p>\n<p>另外，可能有些网页返回的不是<code>HTML代码</code>，而是一个<code>JSON字符串</code>（其中<code>API</code>接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p>\n<p>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p>\n<p>另外，还可以看到各种扩展名的文件，如<code>CSS</code>、<code>JavaScript</code>和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</p>\n<p>上述内容其实都对应各自的<code>URL</code>，是基于<code>HTTP</code>或<code>HTTPS</code>协议的，只要是这种数据，爬虫都可以抓取。</p>\n<h3 id=\"JavaScript渲染页面\"><a href=\"#JavaScript渲染页面\" class=\"headerlink\" title=\"JavaScript渲染页面\"></a>JavaScript渲染页面</h3><p>有时候，在用<code>urllib</code>或<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p>\n<p>这是一个非常常见的问题。现在网页越来越多地采用<code>Ajax</code>、<code>前端模块化工具</code>来构建，整个网页可能都是由<code>JavaScript</code>渲染出来的，也就是说原始的<code>HTML代码</code>就是一个空壳，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>This is a Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;app.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p><code>body</code>节点里面只有一个<code>id</code>为<code>container</code>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p>\n<p>在浏览器中打开这个页面时，首先会加载这个<code>HTML</code>内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的<code>JavaScript</code>代码，而<code>JavaScript</code>则会改变<code>HTML</code>中的节点，向其添加内容，最后得到完整的页面。</p>\n<p>但是在用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个<code>HTML代码</code>，它不会帮助我们去继续加载这个<code>JavaScript</code>文件，这样也就看不到浏览器中的内容。</p>\n<p>这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p>\n<p>因此，使用基本<code>HTTP</code>请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，可以分析其后台<code>Ajax</code>接口，也可使用<code>Selenium</code>、<code>Splash</code>这样的库来实现模拟<code>JavaScript</code>渲染。</p>\n"},{"title":"腾讯云主机CPU占用100%","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-25T08:32:01.000Z","pic":null,"_content":"\n\n## 异常情况\n\n使用`ssh`登录发现连接很缓慢，排除网络问题。登陆后使用`top`查看进程，发现`git`用户的两个进程占用了`95%`的`CPU`。\n\n![](Screenshot_1.webp)\n\n网上查了下，`kswapd0`被植入挖矿病毒，立马`kill`这个进程，CPU的负荷马上降了下来。\n\n## 查看进程端口\n\n```shell\nnetstat -anltp|grep kswapd0\n```\n\n## 查看程序路径\n\n```shell\nls -l /proc/3882/exe\n```\n\n## 定时器查看\n\n```shell\ncrontab -l -u git\n```\n\n查看到定时任务，这个就是病毒的执行路径。\n\n```shell\n[root@VM-0-15-centos ~]# crontab -l -u git\n1 1 */2 * * /var/tmp/.X18263/.rsync/a/upd>/dev/null 2>&1\n5 8 * * 0 /var/tmp/.X18263/.rsync/b/sync>/dev/null 2>&1 \n@reboot /var/tmp/.X18263/.rsync/b/sync>/dev/null 2>&1  \n0 0 */3 * * /var/tmp/.X18263/.rsync/c/aptitude>/dev/null 2>&1\n```\n\n## 临时目录查看\n\n```shell\n[root@VM-0-15-centos tmp]# cd /temp\n[root@VM-0-15-centos tmp]# ll -sa | grep git\n0 -rw-rw-r--   1 git  git     0 May 24 21:41 .out\n4 -rw-rw-r--   1 git  git     9 May 24 07:28 up.txt\n4 drwxrwxr-x   2 git  git  4096 May 24 21:25 .X25-unix\n4 drwxrwxr-x   2 git  git  4096 May 24 21:50 .X3-u111\n```\n\n## 处理办法\n\n1. 直接杀掉进程\n\n2. 删除所有的crontab计划任务\n\n```sheel\ncrontab -e -u git\n```\n\n3. 删除用户和文件（前提是正规业务没有用到此用户）\n\n```shell\nuserdel -r git\n```\n\n4. 删除/tmp目录下test用户的文件\n\n## Xmrig挖矿木马之暴力分析\n\n可以参考大神的分析[https://www.jianshu.com/p/3dd5ad1cd51b](https://www.jianshu.com/p/3dd5ad1cd51b)。\n\n密码一定要复杂！！！\n","source":"_posts/腾讯云主机CPU占用百分百.md","raw":"---\ntitle: 腾讯云主机CPU占用100%\ntags:\n  - git\n  - linux\n  - 病毒\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-25 16:32:01\ncategories: Linux\npic:\n---\n\n\n## 异常情况\n\n使用`ssh`登录发现连接很缓慢，排除网络问题。登陆后使用`top`查看进程，发现`git`用户的两个进程占用了`95%`的`CPU`。\n\n![](Screenshot_1.webp)\n\n网上查了下，`kswapd0`被植入挖矿病毒，立马`kill`这个进程，CPU的负荷马上降了下来。\n\n## 查看进程端口\n\n```shell\nnetstat -anltp|grep kswapd0\n```\n\n## 查看程序路径\n\n```shell\nls -l /proc/3882/exe\n```\n\n## 定时器查看\n\n```shell\ncrontab -l -u git\n```\n\n查看到定时任务，这个就是病毒的执行路径。\n\n```shell\n[root@VM-0-15-centos ~]# crontab -l -u git\n1 1 */2 * * /var/tmp/.X18263/.rsync/a/upd>/dev/null 2>&1\n5 8 * * 0 /var/tmp/.X18263/.rsync/b/sync>/dev/null 2>&1 \n@reboot /var/tmp/.X18263/.rsync/b/sync>/dev/null 2>&1  \n0 0 */3 * * /var/tmp/.X18263/.rsync/c/aptitude>/dev/null 2>&1\n```\n\n## 临时目录查看\n\n```shell\n[root@VM-0-15-centos tmp]# cd /temp\n[root@VM-0-15-centos tmp]# ll -sa | grep git\n0 -rw-rw-r--   1 git  git     0 May 24 21:41 .out\n4 -rw-rw-r--   1 git  git     9 May 24 07:28 up.txt\n4 drwxrwxr-x   2 git  git  4096 May 24 21:25 .X25-unix\n4 drwxrwxr-x   2 git  git  4096 May 24 21:50 .X3-u111\n```\n\n## 处理办法\n\n1. 直接杀掉进程\n\n2. 删除所有的crontab计划任务\n\n```sheel\ncrontab -e -u git\n```\n\n3. 删除用户和文件（前提是正规业务没有用到此用户）\n\n```shell\nuserdel -r git\n```\n\n4. 删除/tmp目录下test用户的文件\n\n## Xmrig挖矿木马之暴力分析\n\n可以参考大神的分析[https://www.jianshu.com/p/3dd5ad1cd51b](https://www.jianshu.com/p/3dd5ad1cd51b)。\n\n密码一定要复杂！！！\n","slug":"腾讯云主机CPU占用百分百","published":1,"updated":"2021-06-15T03:24:11.551Z","_id":"ckpapu7k8003alcxuhcaj5rb5","layout":"post","photos":[],"link":"","content":"<h2 id=\"异常情况\"><a href=\"#异常情况\" class=\"headerlink\" title=\"异常情况\"></a>异常情况</h2><p>使用<code>ssh</code>登录发现连接很缓慢，排除网络问题。登陆后使用<code>top</code>查看进程，发现<code>git</code>用户的两个进程占用了<code>95%</code>的<code>CPU</code>。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>网上查了下，<code>kswapd0</code>被植入挖矿病毒，立马<code>kill</code>这个进程，CPU的负荷马上降了下来。</p>\n<h2 id=\"查看进程端口\"><a href=\"#查看进程端口\" class=\"headerlink\" title=\"查看进程端口\"></a>查看进程端口</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -anltp|grep kswapd0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看程序路径\"><a href=\"#查看程序路径\" class=\"headerlink\" title=\"查看程序路径\"></a>查看程序路径</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /proc/3882/exe</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时器查看\"><a href=\"#定时器查看\" class=\"headerlink\" title=\"定时器查看\"></a>定时器查看</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l -u git</span><br></pre></td></tr></table></figure>\n\n<p>查看到定时任务，这个就是病毒的执行路径。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos ~]# crontab -l -u git</span><br><span class=\"line\">1 1 */2 * * /var/tmp/.X18263/.rsync/a/upd&gt;/dev/null 2&gt;&amp;1</span><br><span class=\"line\">5 8 * * 0 /var/tmp/.X18263/.rsync/b/sync&gt;/dev/null 2&gt;&amp;1 </span><br><span class=\"line\">@reboot /var/tmp/.X18263/.rsync/b/sync&gt;/dev/null 2&gt;&amp;1  </span><br><span class=\"line\">0 0 */3 * * /var/tmp/.X18263/.rsync/c/aptitude&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"临时目录查看\"><a href=\"#临时目录查看\" class=\"headerlink\" title=\"临时目录查看\"></a>临时目录查看</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos tmp]# cd /temp</span><br><span class=\"line\">[root@VM-0-15-centos tmp]# ll -sa | grep git</span><br><span class=\"line\">0 -rw-rw-r--   1 git  git     0 May 24 21:41 .out</span><br><span class=\"line\">4 -rw-rw-r--   1 git  git     9 May 24 07:28 up.txt</span><br><span class=\"line\">4 drwxrwxr-x   2 git  git  4096 May 24 21:25 .X25-unix</span><br><span class=\"line\">4 drwxrwxr-x   2 git  git  4096 May 24 21:50 .X3-u111</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理办法\"><a href=\"#处理办法\" class=\"headerlink\" title=\"处理办法\"></a>处理办法</h2><ol>\n<li><p>直接杀掉进程</p>\n</li>\n<li><p>删除所有的crontab计划任务</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e -u git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>删除用户和文件（前提是正规业务没有用到此用户）</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>删除/tmp目录下test用户的文件</li>\n</ol>\n<h2 id=\"Xmrig挖矿木马之暴力分析\"><a href=\"#Xmrig挖矿木马之暴力分析\" class=\"headerlink\" title=\"Xmrig挖矿木马之暴力分析\"></a>Xmrig挖矿木马之暴力分析</h2><p>可以参考大神的分析<a href=\"https://www.jianshu.com/p/3dd5ad1cd51b\">https://www.jianshu.com/p/3dd5ad1cd51b</a>。</p>\n<p>密码一定要复杂！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"异常情况\"><a href=\"#异常情况\" class=\"headerlink\" title=\"异常情况\"></a>异常情况</h2><p>使用<code>ssh</code>登录发现连接很缓慢，排除网络问题。登陆后使用<code>top</code>查看进程，发现<code>git</code>用户的两个进程占用了<code>95%</code>的<code>CPU</code>。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>网上查了下，<code>kswapd0</code>被植入挖矿病毒，立马<code>kill</code>这个进程，CPU的负荷马上降了下来。</p>\n<h2 id=\"查看进程端口\"><a href=\"#查看进程端口\" class=\"headerlink\" title=\"查看进程端口\"></a>查看进程端口</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -anltp|grep kswapd0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看程序路径\"><a href=\"#查看程序路径\" class=\"headerlink\" title=\"查看程序路径\"></a>查看程序路径</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /proc/3882/exe</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时器查看\"><a href=\"#定时器查看\" class=\"headerlink\" title=\"定时器查看\"></a>定时器查看</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l -u git</span><br></pre></td></tr></table></figure>\n\n<p>查看到定时任务，这个就是病毒的执行路径。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos ~]# crontab -l -u git</span><br><span class=\"line\">1 1 */2 * * /var/tmp/.X18263/.rsync/a/upd&gt;/dev/null 2&gt;&amp;1</span><br><span class=\"line\">5 8 * * 0 /var/tmp/.X18263/.rsync/b/sync&gt;/dev/null 2&gt;&amp;1 </span><br><span class=\"line\">@reboot /var/tmp/.X18263/.rsync/b/sync&gt;/dev/null 2&gt;&amp;1  </span><br><span class=\"line\">0 0 */3 * * /var/tmp/.X18263/.rsync/c/aptitude&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"临时目录查看\"><a href=\"#临时目录查看\" class=\"headerlink\" title=\"临时目录查看\"></a>临时目录查看</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos tmp]# cd /temp</span><br><span class=\"line\">[root@VM-0-15-centos tmp]# ll -sa | grep git</span><br><span class=\"line\">0 -rw-rw-r--   1 git  git     0 May 24 21:41 .out</span><br><span class=\"line\">4 -rw-rw-r--   1 git  git     9 May 24 07:28 up.txt</span><br><span class=\"line\">4 drwxrwxr-x   2 git  git  4096 May 24 21:25 .X25-unix</span><br><span class=\"line\">4 drwxrwxr-x   2 git  git  4096 May 24 21:50 .X3-u111</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理办法\"><a href=\"#处理办法\" class=\"headerlink\" title=\"处理办法\"></a>处理办法</h2><ol>\n<li><p>直接杀掉进程</p>\n</li>\n<li><p>删除所有的crontab计划任务</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e -u git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>删除用户和文件（前提是正规业务没有用到此用户）</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>删除/tmp目录下test用户的文件</li>\n</ol>\n<h2 id=\"Xmrig挖矿木马之暴力分析\"><a href=\"#Xmrig挖矿木马之暴力分析\" class=\"headerlink\" title=\"Xmrig挖矿木马之暴力分析\"></a>Xmrig挖矿木马之暴力分析</h2><p>可以参考大神的分析<a href=\"https://www.jianshu.com/p/3dd5ad1cd51b\">https://www.jianshu.com/p/3dd5ad1cd51b</a>。</p>\n<p>密码一定要复杂！！！</p>\n"},{"title":"腾讯云配置ssl证书","date":"2021-05-10T07:36:11.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n## 什么是SSL证书？\n\nSSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。\n\n## 申请腾讯云SSL证书\n\n百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。\n\n## nginx配置修改\n\n下载SSL证书，上传到服务器`/etc/pki/nginx/`目录下。\n\n修改`/etc/`配置文件，注意SSL证书的路径和实际上传的路径和名称一致。\n\n```shell\n    # server {\n    #     listen       80 default_server;\n    #     listen       [::]:80 default_server;\n    #     server_name  www.holychan.ltd;\n    #     root         /home/hexo;\n\n    #     # Load configuration files for the default server block.\n    #     include /etc/nginx/default.d/*.conf;\n\n    #     location / {\n    #     }\n\n    #     error_page 404 /404.html;\n    #         location = /40x.html {\n    #     }\n\n    #     error_page 500 502 503 504 /50x.html;\n    #         location = /50x.html {\n    #     }\n    # }\n    # 以上的配置注释，使用下面的配置\n\n    # Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  www.holychan.ltd;\n        root         /home/hexo;    # 根目录\n\n        ssl_certificate \"/etc/pki/nginx/1_holychan.ltd_bundle.crt\";    # ssl证书路径\n        ssl_certificate_key \"/etc/pki/nginx/2_holychan.ltd.key\"; # ssl证书密钥\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_ciphers PROFILE=SYSTEM;\n        ssl_prefer_server_ciphers on;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n}\n```","source":"_posts/腾讯云配置ssl证书.md","raw":"---\ntitle: 腾讯云配置ssl证书\ndate: 2021-05-10 15:36:11\ncategories: 博客教程\ntags:\n- nginx\n- https\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n## 什么是SSL证书？\n\nSSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。\n\n## 申请腾讯云SSL证书\n\n百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。\n\n## nginx配置修改\n\n下载SSL证书，上传到服务器`/etc/pki/nginx/`目录下。\n\n修改`/etc/`配置文件，注意SSL证书的路径和实际上传的路径和名称一致。\n\n```shell\n    # server {\n    #     listen       80 default_server;\n    #     listen       [::]:80 default_server;\n    #     server_name  www.holychan.ltd;\n    #     root         /home/hexo;\n\n    #     # Load configuration files for the default server block.\n    #     include /etc/nginx/default.d/*.conf;\n\n    #     location / {\n    #     }\n\n    #     error_page 404 /404.html;\n    #         location = /40x.html {\n    #     }\n\n    #     error_page 500 502 503 504 /50x.html;\n    #         location = /50x.html {\n    #     }\n    # }\n    # 以上的配置注释，使用下面的配置\n\n    # Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  www.holychan.ltd;\n        root         /home/hexo;    # 根目录\n\n        ssl_certificate \"/etc/pki/nginx/1_holychan.ltd_bundle.crt\";    # ssl证书路径\n        ssl_certificate_key \"/etc/pki/nginx/2_holychan.ltd.key\"; # ssl证书密钥\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_ciphers PROFILE=SYSTEM;\n        ssl_prefer_server_ciphers on;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n}\n```","slug":"腾讯云配置ssl证书","published":1,"updated":"2021-06-15T03:24:11.557Z","_id":"ckpapu7ka003clcxu4iqa0eh7","layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是SSL证书？\"><a href=\"#什么是SSL证书？\" class=\"headerlink\" title=\"什么是SSL证书？\"></a>什么是SSL证书？</h2><p>SSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。</p>\n<h2 id=\"申请腾讯云SSL证书\"><a href=\"#申请腾讯云SSL证书\" class=\"headerlink\" title=\"申请腾讯云SSL证书\"></a>申请腾讯云SSL证书</h2><p>百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。</p>\n<h2 id=\"nginx配置修改\"><a href=\"#nginx配置修改\" class=\"headerlink\" title=\"nginx配置修改\"></a>nginx配置修改</h2><p>下载SSL证书，上传到服务器<code>/etc/pki/nginx/</code>目录下。</p>\n<p>修改<code>/etc/</code>配置文件，注意SSL证书的路径和实际上传的路径和名称一致。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    # server &#123;</span><br><span class=\"line\">    #     listen       80 default_server;</span><br><span class=\"line\">    #     listen       [::]:80 default_server;</span><br><span class=\"line\">    #     server_name  www.holychan.ltd;</span><br><span class=\"line\">    #     root         /home/hexo;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     # Load configuration files for the default server block.</span><br><span class=\"line\">    #     include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     location / &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 404 /404.html;</span><br><span class=\"line\">    #         location = /40x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">    #         location = /50x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\">    # &#125;</span><br><span class=\"line\">    # 以上的配置注释，使用下面的配置</span><br><span class=\"line\"></span><br><span class=\"line\">    # Settings for a TLS enabled server.</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  www.holychan.ltd;</span><br><span class=\"line\">        root         /home/hexo;    # 根目录</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_certificate &quot;/etc/pki/nginx/1_holychan.ltd_bundle.crt&quot;;    # ssl证书路径</span><br><span class=\"line\">        ssl_certificate_key &quot;/etc/pki/nginx/2_holychan.ltd.key&quot;; # ssl证书密钥</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_ciphers PROFILE=SYSTEM;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是SSL证书？\"><a href=\"#什么是SSL证书？\" class=\"headerlink\" title=\"什么是SSL证书？\"></a>什么是SSL证书？</h2><p>SSL证书是用于在Web服务器与浏览器以及客户端之间建立加密链接的加密技术，通过配置和应用SSL证书来启用HTTPS协议，来保证互联网数据传输的安全，全球每天有数以亿计的网站都是通过HTTPS来确保数据安全，保护用户隐私。</p>\n<h2 id=\"申请腾讯云SSL证书\"><a href=\"#申请腾讯云SSL证书\" class=\"headerlink\" title=\"申请腾讯云SSL证书\"></a>申请腾讯云SSL证书</h2><p>百毒搜索腾讯SSL证书，找到免费使用SSL一年的产品，一系列骚操作后得到证书。</p>\n<h2 id=\"nginx配置修改\"><a href=\"#nginx配置修改\" class=\"headerlink\" title=\"nginx配置修改\"></a>nginx配置修改</h2><p>下载SSL证书，上传到服务器<code>/etc/pki/nginx/</code>目录下。</p>\n<p>修改<code>/etc/</code>配置文件，注意SSL证书的路径和实际上传的路径和名称一致。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    # server &#123;</span><br><span class=\"line\">    #     listen       80 default_server;</span><br><span class=\"line\">    #     listen       [::]:80 default_server;</span><br><span class=\"line\">    #     server_name  www.holychan.ltd;</span><br><span class=\"line\">    #     root         /home/hexo;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     # Load configuration files for the default server block.</span><br><span class=\"line\">    #     include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     location / &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 404 /404.html;</span><br><span class=\"line\">    #         location = /40x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #     error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">    #         location = /50x.html &#123;</span><br><span class=\"line\">    #     &#125;</span><br><span class=\"line\">    # &#125;</span><br><span class=\"line\">    # 以上的配置注释，使用下面的配置</span><br><span class=\"line\"></span><br><span class=\"line\">    # Settings for a TLS enabled server.</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  www.holychan.ltd;</span><br><span class=\"line\">        root         /home/hexo;    # 根目录</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_certificate &quot;/etc/pki/nginx/1_holychan.ltd_bundle.crt&quot;;    # ssl证书路径</span><br><span class=\"line\">        ssl_certificate_key &quot;/etc/pki/nginx/2_holychan.ltd.key&quot;; # ssl证书密钥</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_ciphers PROFILE=SYSTEM;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # Load configuration files for the default server block.</span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HTTP基本原理","date":"2021-05-09T12:48:23.000Z","pic":null,"comments":1,"toc":true,"only":["home","category","tag"],"_content":"\n\n## URI和URL\n\n`URI （Uniform Resource Identifier）` 即**统一资源标志符**。\n`URL （Uniform Resource Locator` 即**统一资源定位符**。\n\n例如：\n`https://github.com/favicon.ico`既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称`favicon.ico`。\n\nURL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。\n\nURI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。\n\n## 超文本\n\n`Hypertext`，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如`img`显示图片，`p`指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码`HTML`就可以称作超文本。\n\n## HTTP和HTTPS\n\n`HTTP`的全称是Hyper Text Transfer Protocol，中文名叫作**超文本传输协议**，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是`HTTP 1.1`版本。\n\n`HTTPS`的全称是`Hyper Text Transfer Protocol over Secure Socket Layer`，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入`SSL`层，简称为`HTTPS`。\n\n`HTTPS`的安全基础是`SSL`，因此通过它传输的内容都是经过`SSL`加密的，它的主要作用可以分为两种：\n\n- 建立一个信息安全通道，来保证数据传输的安全。\n- 确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过`CA`机构颁发的安全签章来查询。\n  \n现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：\n\n- 苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。\n- 谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。\n- 腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。\n  \n因此，HTTPS 已经已经是大势所趋。\n\n## HTTP请求过程\n\n我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的**响应**，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：\n\n![传输模型](1.png)\n\n此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。\n\n为了更直观地说明这个过程，这里用浏览器的开发者模式下的`Network监听组件`来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度`http://www.baidu.com/`，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在`Network`页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:\n\n![Network监听](Screenshot_2.png)\n\n我们先观察第一个网络请求，即`www.baidu.com`，其中各列的含义如下。\n\n- 第一列 `Name：请求的名称`，一般会将 URL的最后一部分内容当作名称。\n- 第二列 `Status：响应的状态码`，这里显示为 `200`，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 \n- 第三列 `Type：请求的文档类型`。这里为`document`，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。\n- 第四列 `Initiator：请求源`。用来标记请求是由哪个对象或进程发起的。\n- 第五列 `Size：从服务器下载的文件和请求的资源大小`。如果是从缓存中取得的资源，则该列会显示 fromcache。\n- 第六列 `Time：发起请求到获取响应所用的总时间`。\n- 第七列 `Waterfall：网络请求的可视化瀑布流`。 我们点击这个条目即可看到其更详细的信息，如图所示。\n\n![详细信息](Screenshot_3.png)\n\n首先是`General`部分，`Request URL`为请求的URL，`Request Method`为请求的方法，`Status Code`为响应状态码，`Remote Address`为远程服务器的地址和端口，`Referrer Policy`为 Referrer判别策略。 \n\n再继续往下，可以看到，有`Response Headers`和`Request Headers`，这分别代表`响应头`和`请求头`。请求头里带有许多请求信息，例如`浏览器标识、Cookies、Host`等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的`Response Headers`就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。\n\n## 请求\n\n**请求**，由客户端向服务端发出，可以分为4部分内容：`请求方法（Request Method`、`请求的网址（Request URL）`、`请求头（Request Headers）`、`请求体（Request Body）`。\n\n### 请求方法\n\n常见的请求方法有两种：`GET`和`POST`。 在浏览器中直接输入URL并回车，这便发起了一个`GET请求`，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为`https://www.baidu.com/s?wd=Python`，其中URL中包 含了请求的参数信息，这里参数`wd`表示要搜寻的关键字。`POST请求`大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个`POST请求`，其数据通常 以表单的形式传输，而不会体现在URL中。\n\n`GET`和`POST`请求方法有如下区别。\n\n- `GET请求`中的参数包含在URL里面，数据可以在URL中看到，而`POST请求`的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。\n- `GET请求`提交的数据最多只有*1024字节*，而`POST请求`没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用`GET方式`请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以`POST方式`发送。上传文件时，由于文件内容比较大，也会选用`POST方式`。 我们平常遇到的绝大部分请求都是`GET`或`POST`请求，另外还有一些请求方法，如`HEAD`、`PUT`、`DELETE`、`OPTIONS`、`CONNECT`、`TRACE`等，我们简单将其总结为下表。\n\n| 方法 | 描述 |\n| :--- | :---- |\n| GET | 请求页面，并返回页面内容 |\n| HEAD | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 |\n| POST | 大多用于表单提交或上传文件，数据包含在请求体中 |\n| PUT | 从客户端向服务器传送的数据取代指定文档中的内容 |\n| DELETE | 请求服务器删除指定的页面 |\n| CONNECT | 把服务器当作跳板，让服务器代替客户端访问其他网页 |\n| OPTIONS | 允许客户端查看服务器的性能 |\n| TRACE | 回显服务器收到的请求，主要用于测试或诊断 |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。\n\n### 请求头\n\n请求头，用来说明服务器要使用的附加信息，比较重要的信息有`Cookie`、`Referer`、`User-Agent`等。下面简要说明一些常用的头信息。\n\n- `Accept`：请求报头域，用于指定客户端可接受哪些类型的信息。\n- `Accept-Language`：指定客户端可接受的语言类型。\n- `Accept-Encoding`：指定客户端可接受的内容编码。\n- `Host`：用于指定请求资源的主机`IP`和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。\n- `Cookie`：也常用复数形式`Cookies`，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是`Cookies`的功劳。`Cookies`里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上`Cookies`并将其发送给服务器，服务器通过`Cookies`识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。\n- `Referer`：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。\n- `User-Agent`：简称`UA`，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。\n- `Content-Type`：也叫互联网媒体类型`（Internet Media Type）`或者`MIME类型`，在`HTTP`协议消息头中，它用来表示具体请求中的媒体类型信息。例如，`text/html`代表`HTML`格式，`image/gif`代表`GIF`图片，`application/json`代表`JSON`类型，更多对应关系可以查看此对照表：`http://tool.oschina.net/commons`。\n\n因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。\n\n### 请求体\n\n请请求体一般承载的内容是`POST`请求中的表单数据，而对于`GET`请求，请求体则为空。\n\n登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意`Request Headers`中指定`Content-Type`为`application/x-www-form-urlencoded`。只有设置`Content-Type`为`application/x-www-form-urlencoded`，才会以表单数据的形式提交。另外，我们也可以将`Content-Type`设置为`application/json`来提交`JSON`数据，或者设置为`multipart/form-data`来上传文件。 \n\n表格中列出了`Content-Type`和`POST`提交数据方式的关系。\n\n| Content-Type | 提交数据的方式 |\n| :--- | :---- |\n| application/x-www-form-urlencodeed | 表单数据 |\n| multipart/form-data | 表单文件上传 |\n| application/json | 序列化JSON数据 |\n| text/xml | XML数据 |\n\n在爬虫中，如果要构造`POST`请求，需要使用正确的`Content-Type`，并了解各种请求库的各个参数设置时使用的是哪种`Content-Type`，不然可能会导致`POST`提交后无法正常响应。\n\n## 响应\n\n响应，由服务端返回给客户端，可以分为三部分：`响应状态码（Response Status Code）`、`响应头（Response Headers）`和`响应体（Response Body）`。\n\n### 响应状态码\n\n响应状态码表示服务器的响应状态，如`200`代表服务器正常响应，`404`代表页面未找到，`500`代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为`200`，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。\n\n| 状态码 | 说明 | 详情 |\n| :---- | :---: | :----- |\n| 100 | 继续 | 请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分 |\n| 101 | 切换协议 | 请求者已要求服务器切换协议，服务器已确认并确认切换 |\n| 200 | 成功 | 服务器已成功处理了请求 |\n| 201 | 已创建 | 请求成功并且服务器创建了新的资源 |\n| 202 | 已接受 | 服务器已接受请求，但尚未处理 |\n| 203 | 非授权信息 | 服务器已经成功处理请求，但返回的信息可能来自另一个源 |\n| 204 | 无内容 | 服务器成功处理了请求，但没有返回任何内容 |\n| 205 | 重置内容 | 服务器成功处理了请求，但内容被重置 |\n| 206 | 部分内容 | 服务器成功处理了部分请求 |\n| 300 | 多种选择 | 针对请求，服务器可执行多种操作 |\n| 301 | 永久移动 | 请求的网页已永久移动到新位置，即永久重定向 |\n| 302 | 临时移动 | 请求的网页暂时跳转到其他页面，即暂时重定向 |\n| 303 | 查看其他位置 | 如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源 |\n| 304 | 未修改 | 此次请求返回的网页未修改，继续使用上次的资源 |\n| 305 | 使用代理 | 请求者应该使用代理访问该网页 |\n| 307 | 临时重定向 | 请求的资源临时从其他位置响应 |\n| 400 | 错误请求 | 服务器无法解析该请求 |\n| 401 | 未授权 | 请求没有进行身份验证或验证未通过 |\n| 403 | 禁止访问 | 服务器拒绝此请求 |\n| 404 | 未找到 | 服务器找不到请求的网页 |\n| 405 | 方法禁用 | 服务器禁用了请求中指定的方法 |\n| 406 | 不接受 | 无法使用请求的内容响应请求的网页 |\n| 407 | 需要代理授权 | 请求者需要使用代理授权 |\n| 408 | 请求超时 | 服务器请求超时 |\n| 409 | 冲突 | 服务器在完成请求时发生冲突 |\n| 410 | 已删除 | 请求的资源已永久删除 |\n| 411 | 需要有效长度 | 服务器不接受不含有效内容长度标头字段的请求 |\n| 412 | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |\n| 413 | 请求实体过大 | 请求实体过大，超出服务器的处理能力 |\n| 415 | 请求URL过长 | 请求的网址过长，服务器无法处理 |\n| 416 | 请求范围不符 | 页面无法提供请求页面支持 |\n| 417 | 未满足期望值 | 服务器为满足期望请求标头字段的要求 |\n| 500 | 服务器内部错误 | 服务器遇到错误，无法完成请求 |\n| 501 | 未实现 | 服务器不具备完成请求的功能 |\n| 502 | 错误网关 | 服务器作为网关或代理，从上游服务器收到无效响应 |\n| 503 | 服务不可用 | 服务器目前无法使用 |\n| 504 | 网关超时 | 服务器作为网关或代理，但是没有及时从上游服务器收到响应 |\n| 505 | HTTP版本不支持 | 服务器不支持请求中所用的HTTP协议版本 |\n\n响应头包含了服务器对请求的应答信息，如`Content-Type`、`Server`、`Set-Cookie`等。下面简要说明一些常用的响应头信息。 \n\n- `Date`：标识响应产生的时间。\n- `Last-Modified`：指定资源的最后修改时间。\n- `Content-Encoding`：指定响应内容的编码。\n- `Server`：包含服务器的信息，比如名称、版本号等。\n- `Content-Type`：文档类型，指定返回的数据类型是什么，如`text/html`代表返回`HTML`文档，`application/x-javascript`则代表返回`JavaScript`文件，`image/jpeg`则代表返回图片。\n- `Set-Cookie`：设置`Cookies`。响应头中的`Set-Cookie`告诉浏览器需要将此内容放在`Cookies`中，下次请求携带`Cookies`请求。\n- `Expires`：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。\n\n### 响应体\n\n最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的`HTML`代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。\n\n![响应体](Screenshot_1.png)\n\n在浏览器开发者工具中点击`Response`，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、`JSON`数据等，然后从中做相应内容的提取。\n","source":"_posts/HTTP基本原理.md","raw":"---\ntitle: HTTP基本原理\ndate: 2021-05-09 20:48:23\ncategories: 爬虫\ntags:\n- http\n# sticky: 100\npic:\ncomments: true\ntoc: true\nonly:\n- home\n- category\n- tag\n---\n\n\n## URI和URL\n\n`URI （Uniform Resource Identifier）` 即**统一资源标志符**。\n`URL （Uniform Resource Locator` 即**统一资源定位符**。\n\n例如：\n`https://github.com/favicon.ico`既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称`favicon.ico`。\n\nURL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。\n\nURI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。\n\n## 超文本\n\n`Hypertext`，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如`img`显示图片，`p`指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码`HTML`就可以称作超文本。\n\n## HTTP和HTTPS\n\n`HTTP`的全称是Hyper Text Transfer Protocol，中文名叫作**超文本传输协议**，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是`HTTP 1.1`版本。\n\n`HTTPS`的全称是`Hyper Text Transfer Protocol over Secure Socket Layer`，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入`SSL`层，简称为`HTTPS`。\n\n`HTTPS`的安全基础是`SSL`，因此通过它传输的内容都是经过`SSL`加密的，它的主要作用可以分为两种：\n\n- 建立一个信息安全通道，来保证数据传输的安全。\n- 确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过`CA`机构颁发的安全签章来查询。\n  \n现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：\n\n- 苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。\n- 谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。\n- 腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。\n  \n因此，HTTPS 已经已经是大势所趋。\n\n## HTTP请求过程\n\n我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的**响应**，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：\n\n![传输模型](1.png)\n\n此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。\n\n为了更直观地说明这个过程，这里用浏览器的开发者模式下的`Network监听组件`来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度`http://www.baidu.com/`，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在`Network`页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:\n\n![Network监听](Screenshot_2.png)\n\n我们先观察第一个网络请求，即`www.baidu.com`，其中各列的含义如下。\n\n- 第一列 `Name：请求的名称`，一般会将 URL的最后一部分内容当作名称。\n- 第二列 `Status：响应的状态码`，这里显示为 `200`，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 \n- 第三列 `Type：请求的文档类型`。这里为`document`，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。\n- 第四列 `Initiator：请求源`。用来标记请求是由哪个对象或进程发起的。\n- 第五列 `Size：从服务器下载的文件和请求的资源大小`。如果是从缓存中取得的资源，则该列会显示 fromcache。\n- 第六列 `Time：发起请求到获取响应所用的总时间`。\n- 第七列 `Waterfall：网络请求的可视化瀑布流`。 我们点击这个条目即可看到其更详细的信息，如图所示。\n\n![详细信息](Screenshot_3.png)\n\n首先是`General`部分，`Request URL`为请求的URL，`Request Method`为请求的方法，`Status Code`为响应状态码，`Remote Address`为远程服务器的地址和端口，`Referrer Policy`为 Referrer判别策略。 \n\n再继续往下，可以看到，有`Response Headers`和`Request Headers`，这分别代表`响应头`和`请求头`。请求头里带有许多请求信息，例如`浏览器标识、Cookies、Host`等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的`Response Headers`就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。\n\n## 请求\n\n**请求**，由客户端向服务端发出，可以分为4部分内容：`请求方法（Request Method`、`请求的网址（Request URL）`、`请求头（Request Headers）`、`请求体（Request Body）`。\n\n### 请求方法\n\n常见的请求方法有两种：`GET`和`POST`。 在浏览器中直接输入URL并回车，这便发起了一个`GET请求`，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为`https://www.baidu.com/s?wd=Python`，其中URL中包 含了请求的参数信息，这里参数`wd`表示要搜寻的关键字。`POST请求`大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个`POST请求`，其数据通常 以表单的形式传输，而不会体现在URL中。\n\n`GET`和`POST`请求方法有如下区别。\n\n- `GET请求`中的参数包含在URL里面，数据可以在URL中看到，而`POST请求`的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。\n- `GET请求`提交的数据最多只有*1024字节*，而`POST请求`没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用`GET方式`请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以`POST方式`发送。上传文件时，由于文件内容比较大，也会选用`POST方式`。 我们平常遇到的绝大部分请求都是`GET`或`POST`请求，另外还有一些请求方法，如`HEAD`、`PUT`、`DELETE`、`OPTIONS`、`CONNECT`、`TRACE`等，我们简单将其总结为下表。\n\n| 方法 | 描述 |\n| :--- | :---- |\n| GET | 请求页面，并返回页面内容 |\n| HEAD | 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 |\n| POST | 大多用于表单提交或上传文件，数据包含在请求体中 |\n| PUT | 从客户端向服务器传送的数据取代指定文档中的内容 |\n| DELETE | 请求服务器删除指定的页面 |\n| CONNECT | 把服务器当作跳板，让服务器代替客户端访问其他网页 |\n| OPTIONS | 允许客户端查看服务器的性能 |\n| TRACE | 回显服务器收到的请求，主要用于测试或诊断 |\n\n[//]:#(设置表格整体居中显示)\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。\n\n### 请求头\n\n请求头，用来说明服务器要使用的附加信息，比较重要的信息有`Cookie`、`Referer`、`User-Agent`等。下面简要说明一些常用的头信息。\n\n- `Accept`：请求报头域，用于指定客户端可接受哪些类型的信息。\n- `Accept-Language`：指定客户端可接受的语言类型。\n- `Accept-Encoding`：指定客户端可接受的内容编码。\n- `Host`：用于指定请求资源的主机`IP`和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。\n- `Cookie`：也常用复数形式`Cookies`，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是`Cookies`的功劳。`Cookies`里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上`Cookies`并将其发送给服务器，服务器通过`Cookies`识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。\n- `Referer`：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。\n- `User-Agent`：简称`UA`，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。\n- `Content-Type`：也叫互联网媒体类型`（Internet Media Type）`或者`MIME类型`，在`HTTP`协议消息头中，它用来表示具体请求中的媒体类型信息。例如，`text/html`代表`HTML`格式，`image/gif`代表`GIF`图片，`application/json`代表`JSON`类型，更多对应关系可以查看此对照表：`http://tool.oschina.net/commons`。\n\n因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。\n\n### 请求体\n\n请请求体一般承载的内容是`POST`请求中的表单数据，而对于`GET`请求，请求体则为空。\n\n登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意`Request Headers`中指定`Content-Type`为`application/x-www-form-urlencoded`。只有设置`Content-Type`为`application/x-www-form-urlencoded`，才会以表单数据的形式提交。另外，我们也可以将`Content-Type`设置为`application/json`来提交`JSON`数据，或者设置为`multipart/form-data`来上传文件。 \n\n表格中列出了`Content-Type`和`POST`提交数据方式的关系。\n\n| Content-Type | 提交数据的方式 |\n| :--- | :---- |\n| application/x-www-form-urlencodeed | 表单数据 |\n| multipart/form-data | 表单文件上传 |\n| application/json | 序列化JSON数据 |\n| text/xml | XML数据 |\n\n在爬虫中，如果要构造`POST`请求，需要使用正确的`Content-Type`，并了解各种请求库的各个参数设置时使用的是哪种`Content-Type`，不然可能会导致`POST`提交后无法正常响应。\n\n## 响应\n\n响应，由服务端返回给客户端，可以分为三部分：`响应状态码（Response Status Code）`、`响应头（Response Headers）`和`响应体（Response Body）`。\n\n### 响应状态码\n\n响应状态码表示服务器的响应状态，如`200`代表服务器正常响应，`404`代表页面未找到，`500`代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为`200`，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。\n\n| 状态码 | 说明 | 详情 |\n| :---- | :---: | :----- |\n| 100 | 继续 | 请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分 |\n| 101 | 切换协议 | 请求者已要求服务器切换协议，服务器已确认并确认切换 |\n| 200 | 成功 | 服务器已成功处理了请求 |\n| 201 | 已创建 | 请求成功并且服务器创建了新的资源 |\n| 202 | 已接受 | 服务器已接受请求，但尚未处理 |\n| 203 | 非授权信息 | 服务器已经成功处理请求，但返回的信息可能来自另一个源 |\n| 204 | 无内容 | 服务器成功处理了请求，但没有返回任何内容 |\n| 205 | 重置内容 | 服务器成功处理了请求，但内容被重置 |\n| 206 | 部分内容 | 服务器成功处理了部分请求 |\n| 300 | 多种选择 | 针对请求，服务器可执行多种操作 |\n| 301 | 永久移动 | 请求的网页已永久移动到新位置，即永久重定向 |\n| 302 | 临时移动 | 请求的网页暂时跳转到其他页面，即暂时重定向 |\n| 303 | 查看其他位置 | 如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源 |\n| 304 | 未修改 | 此次请求返回的网页未修改，继续使用上次的资源 |\n| 305 | 使用代理 | 请求者应该使用代理访问该网页 |\n| 307 | 临时重定向 | 请求的资源临时从其他位置响应 |\n| 400 | 错误请求 | 服务器无法解析该请求 |\n| 401 | 未授权 | 请求没有进行身份验证或验证未通过 |\n| 403 | 禁止访问 | 服务器拒绝此请求 |\n| 404 | 未找到 | 服务器找不到请求的网页 |\n| 405 | 方法禁用 | 服务器禁用了请求中指定的方法 |\n| 406 | 不接受 | 无法使用请求的内容响应请求的网页 |\n| 407 | 需要代理授权 | 请求者需要使用代理授权 |\n| 408 | 请求超时 | 服务器请求超时 |\n| 409 | 冲突 | 服务器在完成请求时发生冲突 |\n| 410 | 已删除 | 请求的资源已永久删除 |\n| 411 | 需要有效长度 | 服务器不接受不含有效内容长度标头字段的请求 |\n| 412 | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |\n| 413 | 请求实体过大 | 请求实体过大，超出服务器的处理能力 |\n| 415 | 请求URL过长 | 请求的网址过长，服务器无法处理 |\n| 416 | 请求范围不符 | 页面无法提供请求页面支持 |\n| 417 | 未满足期望值 | 服务器为满足期望请求标头字段的要求 |\n| 500 | 服务器内部错误 | 服务器遇到错误，无法完成请求 |\n| 501 | 未实现 | 服务器不具备完成请求的功能 |\n| 502 | 错误网关 | 服务器作为网关或代理，从上游服务器收到无效响应 |\n| 503 | 服务不可用 | 服务器目前无法使用 |\n| 504 | 网关超时 | 服务器作为网关或代理，但是没有及时从上游服务器收到响应 |\n| 505 | HTTP版本不支持 | 服务器不支持请求中所用的HTTP协议版本 |\n\n响应头包含了服务器对请求的应答信息，如`Content-Type`、`Server`、`Set-Cookie`等。下面简要说明一些常用的响应头信息。 \n\n- `Date`：标识响应产生的时间。\n- `Last-Modified`：指定资源的最后修改时间。\n- `Content-Encoding`：指定响应内容的编码。\n- `Server`：包含服务器的信息，比如名称、版本号等。\n- `Content-Type`：文档类型，指定返回的数据类型是什么，如`text/html`代表返回`HTML`文档，`application/x-javascript`则代表返回`JavaScript`文件，`image/jpeg`则代表返回图片。\n- `Set-Cookie`：设置`Cookies`。响应头中的`Set-Cookie`告诉浏览器需要将此内容放在`Cookies`中，下次请求携带`Cookies`请求。\n- `Expires`：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。\n\n### 响应体\n\n最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的`HTML`代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。\n\n![响应体](Screenshot_1.png)\n\n在浏览器开发者工具中点击`Response`，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、`JSON`数据等，然后从中做相应内容的提取。\n","slug":"HTTP基本原理","published":1,"updated":"2021-06-15T03:24:11.442Z","_id":"ckpapu7kb003dlcxu0ku34b0v","layout":"post","photos":[],"link":"","content":"<h2 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h2><p><code>URI （Uniform Resource Identifier）</code> 即<strong>统一资源标志符</strong>。<br><code>URL （Uniform Resource Locator</code> 即<strong>统一资源定位符</strong>。</p>\n<p>例如：<br><code>https://github.com/favicon.ico</code>既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称<code>favicon.ico</code>。</p>\n<p>URL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。</p>\n<p>URI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。</p>\n<h2 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h2><p><code>Hypertext</code>，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如<code>img</code>显示图片，<code>p</code>指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码<code>HTML</code>就可以称作超文本。</p>\n<h2 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h2><p><code>HTTP</code>的全称是Hyper Text Transfer Protocol，中文名叫作<strong>超文本传输协议</strong>，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是<code>HTTP 1.1</code>版本。</p>\n<p><code>HTTPS</code>的全称是<code>Hyper Text Transfer Protocol over Secure Socket Layer</code>，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入<code>SSL</code>层，简称为<code>HTTPS</code>。</p>\n<p><code>HTTPS</code>的安全基础是<code>SSL</code>，因此通过它传输的内容都是经过<code>SSL</code>加密的，它的主要作用可以分为两种：</p>\n<ul>\n<li>建立一个信息安全通道，来保证数据传输的安全。</li>\n<li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过<code>CA</code>机构颁发的安全签章来查询。</li>\n</ul>\n<p>现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：</p>\n<ul>\n<li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。</li>\n<li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。</li>\n<li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li>\n</ul>\n<p>因此，HTTPS 已经已经是大势所趋。</p>\n<h2 id=\"HTTP请求过程\"><a href=\"#HTTP请求过程\" class=\"headerlink\" title=\"HTTP请求过程\"></a>HTTP请求过程</h2><p>我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的<strong>响应</strong>，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：</p>\n<p><img src=\"1.png\" alt=\"传输模型\"></p>\n<p>此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。</p>\n<p>为了更直观地说明这个过程，这里用浏览器的开发者模式下的<code>Network监听组件</code>来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度<code>http://www.baidu.com/</code>，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在<code>Network</code>页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:</p>\n<p><img src=\"Screenshot_2.png\" alt=\"Network监听\"></p>\n<p>我们先观察第一个网络请求，即<code>www.baidu.com</code>，其中各列的含义如下。</p>\n<ul>\n<li>第一列 <code>Name：请求的名称</code>，一般会将 URL的最后一部分内容当作名称。</li>\n<li>第二列 <code>Status：响应的状态码</code>，这里显示为 <code>200</code>，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 </li>\n<li>第三列 <code>Type：请求的文档类型</code>。这里为<code>document</code>，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。</li>\n<li>第四列 <code>Initiator：请求源</code>。用来标记请求是由哪个对象或进程发起的。</li>\n<li>第五列 <code>Size：从服务器下载的文件和请求的资源大小</code>。如果是从缓存中取得的资源，则该列会显示 fromcache。</li>\n<li>第六列 <code>Time：发起请求到获取响应所用的总时间</code>。</li>\n<li>第七列 <code>Waterfall：网络请求的可视化瀑布流</code>。 我们点击这个条目即可看到其更详细的信息，如图所示。</li>\n</ul>\n<p><img src=\"Screenshot_3.png\" alt=\"详细信息\"></p>\n<p>首先是<code>General</code>部分，<code>Request URL</code>为请求的URL，<code>Request Method</code>为请求的方法，<code>Status Code</code>为响应状态码，<code>Remote Address</code>为远程服务器的地址和端口，<code>Referrer Policy</code>为 Referrer判别策略。 </p>\n<p>再继续往下，可以看到，有<code>Response Headers</code>和<code>Request Headers</code>，这分别代表<code>响应头</code>和<code>请求头</code>。请求头里带有许多请求信息，例如<code>浏览器标识、Cookies、Host</code>等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的<code>Response Headers</code>就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p>\n<h2 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h2><p><strong>请求</strong>，由客户端向服务端发出，可以分为4部分内容：<code>请求方法（Request Method</code>、<code>请求的网址（Request URL）</code>、<code>请求头（Request Headers）</code>、<code>请求体（Request Body）</code>。</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>常见的请求方法有两种：<code>GET</code>和<code>POST</code>。 在浏览器中直接输入URL并回车，这便发起了一个<code>GET请求</code>，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为<code>https://www.baidu.com/s?wd=Python</code>，其中URL中包 含了请求的参数信息，这里参数<code>wd</code>表示要搜寻的关键字。<code>POST请求</code>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个<code>POST请求</code>，其数据通常 以表单的形式传输，而不会体现在URL中。</p>\n<p><code>GET</code>和<code>POST</code>请求方法有如下区别。</p>\n<ul>\n<li><code>GET请求</code>中的参数包含在URL里面，数据可以在URL中看到，而<code>POST请求</code>的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li>\n<li><code>GET请求</code>提交的数据最多只有<em>1024字节</em>，而<code>POST请求</code>没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用<code>GET方式</code>请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以<code>POST方式</code>发送。上传文件时，由于文件内容比较大，也会选用<code>POST方式</code>。 我们平常遇到的绝大部分请求都是<code>GET</code>或<code>POST</code>请求，另外还有一些请求方法，如<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>CONNECT</code>、<code>TRACE</code>等，我们简单将其总结为下表。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GET</td>\n<td align=\"left\">请求页面，并返回页面内容</td>\n</tr>\n<tr>\n<td align=\"left\">HEAD</td>\n<td align=\"left\">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td align=\"left\">POST</td>\n<td align=\"left\">大多用于表单提交或上传文件，数据包含在请求体中</td>\n</tr>\n<tr>\n<td align=\"left\">PUT</td>\n<td align=\"left\">从客户端向服务器传送的数据取代指定文档中的内容</td>\n</tr>\n<tr>\n<td align=\"left\">DELETE</td>\n<td align=\"left\">请求服务器删除指定的页面</td>\n</tr>\n<tr>\n<td align=\"left\">CONNECT</td>\n<td align=\"left\">把服务器当作跳板，让服务器代替客户端访问其他网页</td>\n</tr>\n<tr>\n<td align=\"left\">OPTIONS</td>\n<td align=\"left\">允许客户端查看服务器的性能</td>\n</tr>\n<tr>\n<td align=\"left\">TRACE</td>\n<td align=\"left\">回显服务器收到的请求，主要用于测试或诊断</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n<p>请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>请求头，用来说明服务器要使用的附加信息，比较重要的信息有<code>Cookie</code>、<code>Referer</code>、<code>User-Agent</code>等。下面简要说明一些常用的头信息。</p>\n<ul>\n<li><code>Accept</code>：请求报头域，用于指定客户端可接受哪些类型的信息。</li>\n<li><code>Accept-Language</code>：指定客户端可接受的语言类型。</li>\n<li><code>Accept-Encoding</code>：指定客户端可接受的内容编码。</li>\n<li><code>Host</code>：用于指定请求资源的主机<code>IP</code>和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li>\n<li><code>Cookie</code>：也常用复数形式<code>Cookies</code>，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是<code>Cookies</code>的功劳。<code>Cookies</code>里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上<code>Cookies</code>并将其发送给服务器，服务器通过<code>Cookies</code>识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li>\n<li><code>Referer</code>：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li>\n<li><code>User-Agent</code>：简称<code>UA</code>，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li>\n<li><code>Content-Type</code>：也叫互联网媒体类型<code>（Internet Media Type）</code>或者<code>MIME类型</code>，在<code>HTTP</code>协议消息头中，它用来表示具体请求中的媒体类型信息。例如，<code>text/html</code>代表<code>HTML</code>格式，<code>image/gif</code>代表<code>GIF</code>图片，<code>application/json</code>代表<code>JSON</code>类型，更多对应关系可以查看此对照表：<code>http://tool.oschina.net/commons</code>。</li>\n</ul>\n<p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p>\n<h3 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h3><p>请请求体一般承载的内容是<code>POST</code>请求中的表单数据，而对于<code>GET</code>请求，请求体则为空。</p>\n<p>登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意<code>Request Headers</code>中指定<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>。只有设置<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>，才会以表单数据的形式提交。另外，我们也可以将<code>Content-Type</code>设置为<code>application/json</code>来提交<code>JSON</code>数据，或者设置为<code>multipart/form-data</code>来上传文件。 </p>\n<p>表格中列出了<code>Content-Type</code>和<code>POST</code>提交数据方式的关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Content-Type</th>\n<th align=\"left\">提交数据的方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">application/x-www-form-urlencodeed</td>\n<td align=\"left\">表单数据</td>\n</tr>\n<tr>\n<td align=\"left\">multipart/form-data</td>\n<td align=\"left\">表单文件上传</td>\n</tr>\n<tr>\n<td align=\"left\">application/json</td>\n<td align=\"left\">序列化JSON数据</td>\n</tr>\n<tr>\n<td align=\"left\">text/xml</td>\n<td align=\"left\">XML数据</td>\n</tr>\n</tbody></table>\n<p>在爬虫中，如果要构造<code>POST</code>请求，需要使用正确的<code>Content-Type</code>，并了解各种请求库的各个参数设置时使用的是哪种<code>Content-Type</code>，不然可能会导致<code>POST</code>提交后无法正常响应。</p>\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><p>响应，由服务端返回给客户端，可以分为三部分：<code>响应状态码（Response Status Code）</code>、<code>响应头（Response Headers）</code>和<code>响应体（Response Body）</code>。</p>\n<h3 id=\"响应状态码\"><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<code>200</code>代表服务器正常响应，<code>404</code>代表页面未找到，<code>500</code>代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为<code>200</code>，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">状态码</th>\n<th align=\"center\">说明</th>\n<th align=\"left\">详情</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">100</td>\n<td align=\"center\">继续</td>\n<td align=\"left\">请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分</td>\n</tr>\n<tr>\n<td align=\"left\">101</td>\n<td align=\"center\">切换协议</td>\n<td align=\"left\">请求者已要求服务器切换协议，服务器已确认并确认切换</td>\n</tr>\n<tr>\n<td align=\"left\">200</td>\n<td align=\"center\">成功</td>\n<td align=\"left\">服务器已成功处理了请求</td>\n</tr>\n<tr>\n<td align=\"left\">201</td>\n<td align=\"center\">已创建</td>\n<td align=\"left\">请求成功并且服务器创建了新的资源</td>\n</tr>\n<tr>\n<td align=\"left\">202</td>\n<td align=\"center\">已接受</td>\n<td align=\"left\">服务器已接受请求，但尚未处理</td>\n</tr>\n<tr>\n<td align=\"left\">203</td>\n<td align=\"center\">非授权信息</td>\n<td align=\"left\">服务器已经成功处理请求，但返回的信息可能来自另一个源</td>\n</tr>\n<tr>\n<td align=\"left\">204</td>\n<td align=\"center\">无内容</td>\n<td align=\"left\">服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td align=\"left\">205</td>\n<td align=\"center\">重置内容</td>\n<td align=\"left\">服务器成功处理了请求，但内容被重置</td>\n</tr>\n<tr>\n<td align=\"left\">206</td>\n<td align=\"center\">部分内容</td>\n<td align=\"left\">服务器成功处理了部分请求</td>\n</tr>\n<tr>\n<td align=\"left\">300</td>\n<td align=\"center\">多种选择</td>\n<td align=\"left\">针对请求，服务器可执行多种操作</td>\n</tr>\n<tr>\n<td align=\"left\">301</td>\n<td align=\"center\">永久移动</td>\n<td align=\"left\">请求的网页已永久移动到新位置，即永久重定向</td>\n</tr>\n<tr>\n<td align=\"left\">302</td>\n<td align=\"center\">临时移动</td>\n<td align=\"left\">请求的网页暂时跳转到其他页面，即暂时重定向</td>\n</tr>\n<tr>\n<td align=\"left\">303</td>\n<td align=\"center\">查看其他位置</td>\n<td align=\"left\">如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源</td>\n</tr>\n<tr>\n<td align=\"left\">304</td>\n<td align=\"center\">未修改</td>\n<td align=\"left\">此次请求返回的网页未修改，继续使用上次的资源</td>\n</tr>\n<tr>\n<td align=\"left\">305</td>\n<td align=\"center\">使用代理</td>\n<td align=\"left\">请求者应该使用代理访问该网页</td>\n</tr>\n<tr>\n<td align=\"left\">307</td>\n<td align=\"center\">临时重定向</td>\n<td align=\"left\">请求的资源临时从其他位置响应</td>\n</tr>\n<tr>\n<td align=\"left\">400</td>\n<td align=\"center\">错误请求</td>\n<td align=\"left\">服务器无法解析该请求</td>\n</tr>\n<tr>\n<td align=\"left\">401</td>\n<td align=\"center\">未授权</td>\n<td align=\"left\">请求没有进行身份验证或验证未通过</td>\n</tr>\n<tr>\n<td align=\"left\">403</td>\n<td align=\"center\">禁止访问</td>\n<td align=\"left\">服务器拒绝此请求</td>\n</tr>\n<tr>\n<td align=\"left\">404</td>\n<td align=\"center\">未找到</td>\n<td align=\"left\">服务器找不到请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">405</td>\n<td align=\"center\">方法禁用</td>\n<td align=\"left\">服务器禁用了请求中指定的方法</td>\n</tr>\n<tr>\n<td align=\"left\">406</td>\n<td align=\"center\">不接受</td>\n<td align=\"left\">无法使用请求的内容响应请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">407</td>\n<td align=\"center\">需要代理授权</td>\n<td align=\"left\">请求者需要使用代理授权</td>\n</tr>\n<tr>\n<td align=\"left\">408</td>\n<td align=\"center\">请求超时</td>\n<td align=\"left\">服务器请求超时</td>\n</tr>\n<tr>\n<td align=\"left\">409</td>\n<td align=\"center\">冲突</td>\n<td align=\"left\">服务器在完成请求时发生冲突</td>\n</tr>\n<tr>\n<td align=\"left\">410</td>\n<td align=\"center\">已删除</td>\n<td align=\"left\">请求的资源已永久删除</td>\n</tr>\n<tr>\n<td align=\"left\">411</td>\n<td align=\"center\">需要有效长度</td>\n<td align=\"left\">服务器不接受不含有效内容长度标头字段的请求</td>\n</tr>\n<tr>\n<td align=\"left\">412</td>\n<td align=\"center\">未满足前提条件</td>\n<td align=\"left\">服务器未满足请求者在请求中设置的其中一个前提条件</td>\n</tr>\n<tr>\n<td align=\"left\">413</td>\n<td align=\"center\">请求实体过大</td>\n<td align=\"left\">请求实体过大，超出服务器的处理能力</td>\n</tr>\n<tr>\n<td align=\"left\">415</td>\n<td align=\"center\">请求URL过长</td>\n<td align=\"left\">请求的网址过长，服务器无法处理</td>\n</tr>\n<tr>\n<td align=\"left\">416</td>\n<td align=\"center\">请求范围不符</td>\n<td align=\"left\">页面无法提供请求页面支持</td>\n</tr>\n<tr>\n<td align=\"left\">417</td>\n<td align=\"center\">未满足期望值</td>\n<td align=\"left\">服务器为满足期望请求标头字段的要求</td>\n</tr>\n<tr>\n<td align=\"left\">500</td>\n<td align=\"center\">服务器内部错误</td>\n<td align=\"left\">服务器遇到错误，无法完成请求</td>\n</tr>\n<tr>\n<td align=\"left\">501</td>\n<td align=\"center\">未实现</td>\n<td align=\"left\">服务器不具备完成请求的功能</td>\n</tr>\n<tr>\n<td align=\"left\">502</td>\n<td align=\"center\">错误网关</td>\n<td align=\"left\">服务器作为网关或代理，从上游服务器收到无效响应</td>\n</tr>\n<tr>\n<td align=\"left\">503</td>\n<td align=\"center\">服务不可用</td>\n<td align=\"left\">服务器目前无法使用</td>\n</tr>\n<tr>\n<td align=\"left\">504</td>\n<td align=\"center\">网关超时</td>\n<td align=\"left\">服务器作为网关或代理，但是没有及时从上游服务器收到响应</td>\n</tr>\n<tr>\n<td align=\"left\">505</td>\n<td align=\"center\">HTTP版本不支持</td>\n<td align=\"left\">服务器不支持请求中所用的HTTP协议版本</td>\n</tr>\n</tbody></table>\n<p>响应头包含了服务器对请求的应答信息，如<code>Content-Type</code>、<code>Server</code>、<code>Set-Cookie</code>等。下面简要说明一些常用的响应头信息。 </p>\n<ul>\n<li><code>Date</code>：标识响应产生的时间。</li>\n<li><code>Last-Modified</code>：指定资源的最后修改时间。</li>\n<li><code>Content-Encoding</code>：指定响应内容的编码。</li>\n<li><code>Server</code>：包含服务器的信息，比如名称、版本号等。</li>\n<li><code>Content-Type</code>：文档类型，指定返回的数据类型是什么，如<code>text/html</code>代表返回<code>HTML</code>文档，<code>application/x-javascript</code>则代表返回<code>JavaScript</code>文件，<code>image/jpeg</code>则代表返回图片。</li>\n<li><code>Set-Cookie</code>：设置<code>Cookies</code>。响应头中的<code>Set-Cookie</code>告诉浏览器需要将此内容放在<code>Cookies</code>中，下次请求携带<code>Cookies</code>请求。</li>\n<li><code>Expires</code>：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li>\n</ul>\n<h3 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h3><p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的<code>HTML</code>代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"响应体\"></p>\n<p>在浏览器开发者工具中点击<code>Response</code>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、<code>JSON</code>数据等，然后从中做相应内容的提取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h2><p><code>URI （Uniform Resource Identifier）</code> 即<strong>统一资源标志符</strong>。<br><code>URL （Uniform Resource Locator</code> 即<strong>统一资源定位符</strong>。</p>\n<p>例如：<br><code>https://github.com/favicon.ico</code>既是一个URL，也是一个URI。用URL/URI来唯一指定了它的访问方式，这其中包括了访问协议Https，访问路径（即根目录）和资源名称<code>favicon.ico</code>。</p>\n<p>URL是URI的一个子集，也就是每个URL都是URI，但不是每个URI都是URL。</p>\n<p>URI还包括一个子类叫做URN（Universal Resource Name）即统一资源名称。但是在目前的互联网，URN的使用非常少，几乎所有的 URI都是URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI。</p>\n<h2 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h2><p><code>Hypertext</code>，我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML代码，里面包含了一系列标签，比如<code>img</code>显示图片，<code>p</code>指定显示段落等。浏览器解析这些标签后，便形成了我们平常看到的网页，而网页的源代码<code>HTML</code>就可以称作超文本。</p>\n<h2 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h2><p><code>HTTP</code>的全称是Hyper Text Transfer Protocol，中文名叫作<strong>超文本传输协议</strong>，HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet EngineeringTask Force）共同合作制定的规范，目前广泛使用的是<code>HTTP 1.1</code>版本。</p>\n<p><code>HTTPS</code>的全称是<code>Hyper Text Transfer Protocol over Secure Socket Layer</code>，是以安全为目标HTTP通道，简单讲是HTTP的安全版，即HTTP下加入<code>SSL</code>层，简称为<code>HTTPS</code>。</p>\n<p><code>HTTPS</code>的安全基础是<code>SSL</code>，因此通过它传输的内容都是经过<code>SSL</code>加密的，它的主要作用可以分为两种：</p>\n<ul>\n<li>建立一个信息安全通道，来保证数据传输的安全。</li>\n<li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过<code>CA</code>机构颁发的安全签章来查询。</li>\n</ul>\n<p>现在越来越多的网站和 App 都已经向 HTTPS 方向发展。例如：</p>\n<ul>\n<li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。</li>\n<li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。</li>\n<li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li>\n</ul>\n<p>因此，HTTPS 已经已经是大势所趋。</p>\n<h2 id=\"HTTP请求过程\"><a href=\"#HTTP请求过程\" class=\"headerlink\" title=\"HTTP请求过程\"></a>HTTP请求过程</h2><p>我们在浏览器中输入一个URL，回车之后便可以在浏览器中观察到页面内容。实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的<strong>响应</strong>，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示：</p>\n<p><img src=\"1.png\" alt=\"传输模型\"></p>\n<p>此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。</p>\n<p>为了更直观地说明这个过程，这里用浏览器的开发者模式下的<code>Network监听组件</code>来做演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。打开浏览器（Chrome或Edge都可以），右击并选择 “检查”项，即可打开浏览器的开发者工具。这里访问百度<code>http://www.baidu.com/</code>，输入该 URL后回车，观察这个过程中发生了怎样的网络请求。可以看到，在<code>Network</code>页面下方 出现了一个个的条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示:</p>\n<p><img src=\"Screenshot_2.png\" alt=\"Network监听\"></p>\n<p>我们先观察第一个网络请求，即<code>www.baidu.com</code>，其中各列的含义如下。</p>\n<ul>\n<li>第一列 <code>Name：请求的名称</code>，一般会将 URL的最后一部分内容当作名称。</li>\n<li>第二列 <code>Status：响应的状态码</code>，这里显示为 <code>200</code>，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。 </li>\n<li>第三列 <code>Type：请求的文档类型</code>。这里为<code>document</code>，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。</li>\n<li>第四列 <code>Initiator：请求源</code>。用来标记请求是由哪个对象或进程发起的。</li>\n<li>第五列 <code>Size：从服务器下载的文件和请求的资源大小</code>。如果是从缓存中取得的资源，则该列会显示 fromcache。</li>\n<li>第六列 <code>Time：发起请求到获取响应所用的总时间</code>。</li>\n<li>第七列 <code>Waterfall：网络请求的可视化瀑布流</code>。 我们点击这个条目即可看到其更详细的信息，如图所示。</li>\n</ul>\n<p><img src=\"Screenshot_3.png\" alt=\"详细信息\"></p>\n<p>首先是<code>General</code>部分，<code>Request URL</code>为请求的URL，<code>Request Method</code>为请求的方法，<code>Status Code</code>为响应状态码，<code>Remote Address</code>为远程服务器的地址和端口，<code>Referrer Policy</code>为 Referrer判别策略。 </p>\n<p>再继续往下，可以看到，有<code>Response Headers</code>和<code>Request Headers</code>，这分别代表<code>响应头</code>和<code>请求头</code>。请求头里带有许多请求信息，例如<code>浏览器标识、Cookies、Host</code>等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图中看到的<code>Response Headers</code>就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p>\n<h2 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h2><p><strong>请求</strong>，由客户端向服务端发出，可以分为4部分内容：<code>请求方法（Request Method</code>、<code>请求的网址（Request URL）</code>、<code>请求头（Request Headers）</code>、<code>请求体（Request Body）</code>。</p>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>常见的请求方法有两种：<code>GET</code>和<code>POST</code>。 在浏览器中直接输入URL并回车，这便发起了一个<code>GET请求</code>，请求的参数会直接包含到URL里。例如，在百度中搜索Python，这就是一个GET请求，链接为<code>https://www.baidu.com/s?wd=Python</code>，其中URL中包 含了请求的参数信息，这里参数<code>wd</code>表示要搜寻的关键字。<code>POST请求</code>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击“登录”按钮，这通常会发起一个<code>POST请求</code>，其数据通常 以表单的形式传输，而不会体现在URL中。</p>\n<p><code>GET</code>和<code>POST</code>请求方法有如下区别。</p>\n<ul>\n<li><code>GET请求</code>中的参数包含在URL里面，数据可以在URL中看到，而<code>POST请求</code>的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li>\n<li><code>GET请求</code>提交的数据最多只有<em>1024字节</em>，而<code>POST请求</code>没有限制。 一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用<code>GET方式</code>请求的话，密码就会暴露在URL里面，造成密码泄露，所以这里最好以<code>POST方式</code>发送。上传文件时，由于文件内容比较大，也会选用<code>POST方式</code>。 我们平常遇到的绝大部分请求都是<code>GET</code>或<code>POST</code>请求，另外还有一些请求方法，如<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>CONNECT</code>、<code>TRACE</code>等，我们简单将其总结为下表。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GET</td>\n<td align=\"left\">请求页面，并返回页面内容</td>\n</tr>\n<tr>\n<td align=\"left\">HEAD</td>\n<td align=\"left\">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td align=\"left\">POST</td>\n<td align=\"left\">大多用于表单提交或上传文件，数据包含在请求体中</td>\n</tr>\n<tr>\n<td align=\"left\">PUT</td>\n<td align=\"left\">从客户端向服务器传送的数据取代指定文档中的内容</td>\n</tr>\n<tr>\n<td align=\"left\">DELETE</td>\n<td align=\"left\">请求服务器删除指定的页面</td>\n</tr>\n<tr>\n<td align=\"left\">CONNECT</td>\n<td align=\"left\">把服务器当作跳板，让服务器代替客户端访问其他网页</td>\n</tr>\n<tr>\n<td align=\"left\">OPTIONS</td>\n<td align=\"left\">允许客户端查看服务器的性能</td>\n</tr>\n<tr>\n<td align=\"left\">TRACE</td>\n<td align=\"left\">回显服务器收到的请求，主要用于测试或诊断</td>\n</tr>\n</tbody></table>\n<style>\n    table\n    {\n        margin: auto;\n        font-size: 50%;\n    }\n</style>\n\n<p>请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>请求头，用来说明服务器要使用的附加信息，比较重要的信息有<code>Cookie</code>、<code>Referer</code>、<code>User-Agent</code>等。下面简要说明一些常用的头信息。</p>\n<ul>\n<li><code>Accept</code>：请求报头域，用于指定客户端可接受哪些类型的信息。</li>\n<li><code>Accept-Language</code>：指定客户端可接受的语言类型。</li>\n<li><code>Accept-Encoding</code>：指定客户端可接受的内容编码。</li>\n<li><code>Host</code>：用于指定请求资源的主机<code>IP</code>和端口号，其内容为请求URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li>\n<li><code>Cookie</code>：也常用复数形式<code>Cookies</code>，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会 话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是<code>Cookies</code>的功劳。<code>Cookies</code>里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页 面时，都会在请求头中加上<code>Cookies</code>并将其发送给服务器，服务器通过<code>Cookies</code>识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li>\n<li><code>Referer</code>：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li>\n<li><code>User-Agent</code>：简称<code>UA</code>，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li>\n<li><code>Content-Type</code>：也叫互联网媒体类型<code>（Internet Media Type）</code>或者<code>MIME类型</code>，在<code>HTTP</code>协议消息头中，它用来表示具体请求中的媒体类型信息。例如，<code>text/html</code>代表<code>HTML</code>格式，<code>image/gif</code>代表<code>GIF</code>图片，<code>application/json</code>代表<code>JSON</code>类型，更多对应关系可以查看此对照表：<code>http://tool.oschina.net/commons</code>。</li>\n</ul>\n<p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p>\n<h3 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h3><p>请请求体一般承载的内容是<code>POST</code>请求中的表单数据，而对于<code>GET</code>请求，请求体则为空。</p>\n<p>登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意<code>Request Headers</code>中指定<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>。只有设置<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>，才会以表单数据的形式提交。另外，我们也可以将<code>Content-Type</code>设置为<code>application/json</code>来提交<code>JSON</code>数据，或者设置为<code>multipart/form-data</code>来上传文件。 </p>\n<p>表格中列出了<code>Content-Type</code>和<code>POST</code>提交数据方式的关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Content-Type</th>\n<th align=\"left\">提交数据的方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">application/x-www-form-urlencodeed</td>\n<td align=\"left\">表单数据</td>\n</tr>\n<tr>\n<td align=\"left\">multipart/form-data</td>\n<td align=\"left\">表单文件上传</td>\n</tr>\n<tr>\n<td align=\"left\">application/json</td>\n<td align=\"left\">序列化JSON数据</td>\n</tr>\n<tr>\n<td align=\"left\">text/xml</td>\n<td align=\"left\">XML数据</td>\n</tr>\n</tbody></table>\n<p>在爬虫中，如果要构造<code>POST</code>请求，需要使用正确的<code>Content-Type</code>，并了解各种请求库的各个参数设置时使用的是哪种<code>Content-Type</code>，不然可能会导致<code>POST</code>提交后无法正常响应。</p>\n<h2 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h2><p>响应，由服务端返回给客户端，可以分为三部分：<code>响应状态码（Response Status Code）</code>、<code>响应头（Response Headers）</code>和<code>响应体（Response Body）</code>。</p>\n<h3 id=\"响应状态码\"><a href=\"#响应状态码\" class=\"headerlink\" title=\"响应状态码\"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<code>200</code>代表服务器正常响应，<code>404</code>代表页面未找到，<code>500</code>代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为<code>200</code>，则证明成功返 回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">状态码</th>\n<th align=\"center\">说明</th>\n<th align=\"left\">详情</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">100</td>\n<td align=\"center\">继续</td>\n<td align=\"left\">请求者应当继续提出请求，服务器已收到请求的一部分，正在等待其余部分</td>\n</tr>\n<tr>\n<td align=\"left\">101</td>\n<td align=\"center\">切换协议</td>\n<td align=\"left\">请求者已要求服务器切换协议，服务器已确认并确认切换</td>\n</tr>\n<tr>\n<td align=\"left\">200</td>\n<td align=\"center\">成功</td>\n<td align=\"left\">服务器已成功处理了请求</td>\n</tr>\n<tr>\n<td align=\"left\">201</td>\n<td align=\"center\">已创建</td>\n<td align=\"left\">请求成功并且服务器创建了新的资源</td>\n</tr>\n<tr>\n<td align=\"left\">202</td>\n<td align=\"center\">已接受</td>\n<td align=\"left\">服务器已接受请求，但尚未处理</td>\n</tr>\n<tr>\n<td align=\"left\">203</td>\n<td align=\"center\">非授权信息</td>\n<td align=\"left\">服务器已经成功处理请求，但返回的信息可能来自另一个源</td>\n</tr>\n<tr>\n<td align=\"left\">204</td>\n<td align=\"center\">无内容</td>\n<td align=\"left\">服务器成功处理了请求，但没有返回任何内容</td>\n</tr>\n<tr>\n<td align=\"left\">205</td>\n<td align=\"center\">重置内容</td>\n<td align=\"left\">服务器成功处理了请求，但内容被重置</td>\n</tr>\n<tr>\n<td align=\"left\">206</td>\n<td align=\"center\">部分内容</td>\n<td align=\"left\">服务器成功处理了部分请求</td>\n</tr>\n<tr>\n<td align=\"left\">300</td>\n<td align=\"center\">多种选择</td>\n<td align=\"left\">针对请求，服务器可执行多种操作</td>\n</tr>\n<tr>\n<td align=\"left\">301</td>\n<td align=\"center\">永久移动</td>\n<td align=\"left\">请求的网页已永久移动到新位置，即永久重定向</td>\n</tr>\n<tr>\n<td align=\"left\">302</td>\n<td align=\"center\">临时移动</td>\n<td align=\"left\">请求的网页暂时跳转到其他页面，即暂时重定向</td>\n</tr>\n<tr>\n<td align=\"left\">303</td>\n<td align=\"center\">查看其他位置</td>\n<td align=\"left\">如果原来的请求是POST，重定向目标文档应当通过GET方式访问资源</td>\n</tr>\n<tr>\n<td align=\"left\">304</td>\n<td align=\"center\">未修改</td>\n<td align=\"left\">此次请求返回的网页未修改，继续使用上次的资源</td>\n</tr>\n<tr>\n<td align=\"left\">305</td>\n<td align=\"center\">使用代理</td>\n<td align=\"left\">请求者应该使用代理访问该网页</td>\n</tr>\n<tr>\n<td align=\"left\">307</td>\n<td align=\"center\">临时重定向</td>\n<td align=\"left\">请求的资源临时从其他位置响应</td>\n</tr>\n<tr>\n<td align=\"left\">400</td>\n<td align=\"center\">错误请求</td>\n<td align=\"left\">服务器无法解析该请求</td>\n</tr>\n<tr>\n<td align=\"left\">401</td>\n<td align=\"center\">未授权</td>\n<td align=\"left\">请求没有进行身份验证或验证未通过</td>\n</tr>\n<tr>\n<td align=\"left\">403</td>\n<td align=\"center\">禁止访问</td>\n<td align=\"left\">服务器拒绝此请求</td>\n</tr>\n<tr>\n<td align=\"left\">404</td>\n<td align=\"center\">未找到</td>\n<td align=\"left\">服务器找不到请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">405</td>\n<td align=\"center\">方法禁用</td>\n<td align=\"left\">服务器禁用了请求中指定的方法</td>\n</tr>\n<tr>\n<td align=\"left\">406</td>\n<td align=\"center\">不接受</td>\n<td align=\"left\">无法使用请求的内容响应请求的网页</td>\n</tr>\n<tr>\n<td align=\"left\">407</td>\n<td align=\"center\">需要代理授权</td>\n<td align=\"left\">请求者需要使用代理授权</td>\n</tr>\n<tr>\n<td align=\"left\">408</td>\n<td align=\"center\">请求超时</td>\n<td align=\"left\">服务器请求超时</td>\n</tr>\n<tr>\n<td align=\"left\">409</td>\n<td align=\"center\">冲突</td>\n<td align=\"left\">服务器在完成请求时发生冲突</td>\n</tr>\n<tr>\n<td align=\"left\">410</td>\n<td align=\"center\">已删除</td>\n<td align=\"left\">请求的资源已永久删除</td>\n</tr>\n<tr>\n<td align=\"left\">411</td>\n<td align=\"center\">需要有效长度</td>\n<td align=\"left\">服务器不接受不含有效内容长度标头字段的请求</td>\n</tr>\n<tr>\n<td align=\"left\">412</td>\n<td align=\"center\">未满足前提条件</td>\n<td align=\"left\">服务器未满足请求者在请求中设置的其中一个前提条件</td>\n</tr>\n<tr>\n<td align=\"left\">413</td>\n<td align=\"center\">请求实体过大</td>\n<td align=\"left\">请求实体过大，超出服务器的处理能力</td>\n</tr>\n<tr>\n<td align=\"left\">415</td>\n<td align=\"center\">请求URL过长</td>\n<td align=\"left\">请求的网址过长，服务器无法处理</td>\n</tr>\n<tr>\n<td align=\"left\">416</td>\n<td align=\"center\">请求范围不符</td>\n<td align=\"left\">页面无法提供请求页面支持</td>\n</tr>\n<tr>\n<td align=\"left\">417</td>\n<td align=\"center\">未满足期望值</td>\n<td align=\"left\">服务器为满足期望请求标头字段的要求</td>\n</tr>\n<tr>\n<td align=\"left\">500</td>\n<td align=\"center\">服务器内部错误</td>\n<td align=\"left\">服务器遇到错误，无法完成请求</td>\n</tr>\n<tr>\n<td align=\"left\">501</td>\n<td align=\"center\">未实现</td>\n<td align=\"left\">服务器不具备完成请求的功能</td>\n</tr>\n<tr>\n<td align=\"left\">502</td>\n<td align=\"center\">错误网关</td>\n<td align=\"left\">服务器作为网关或代理，从上游服务器收到无效响应</td>\n</tr>\n<tr>\n<td align=\"left\">503</td>\n<td align=\"center\">服务不可用</td>\n<td align=\"left\">服务器目前无法使用</td>\n</tr>\n<tr>\n<td align=\"left\">504</td>\n<td align=\"center\">网关超时</td>\n<td align=\"left\">服务器作为网关或代理，但是没有及时从上游服务器收到响应</td>\n</tr>\n<tr>\n<td align=\"left\">505</td>\n<td align=\"center\">HTTP版本不支持</td>\n<td align=\"left\">服务器不支持请求中所用的HTTP协议版本</td>\n</tr>\n</tbody></table>\n<p>响应头包含了服务器对请求的应答信息，如<code>Content-Type</code>、<code>Server</code>、<code>Set-Cookie</code>等。下面简要说明一些常用的响应头信息。 </p>\n<ul>\n<li><code>Date</code>：标识响应产生的时间。</li>\n<li><code>Last-Modified</code>：指定资源的最后修改时间。</li>\n<li><code>Content-Encoding</code>：指定响应内容的编码。</li>\n<li><code>Server</code>：包含服务器的信息，比如名称、版本号等。</li>\n<li><code>Content-Type</code>：文档类型，指定返回的数据类型是什么，如<code>text/html</code>代表返回<code>HTML</code>文档，<code>application/x-javascript</code>则代表返回<code>JavaScript</code>文件，<code>image/jpeg</code>则代表返回图片。</li>\n<li><code>Set-Cookie</code>：设置<code>Cookies</code>。响应头中的<code>Set-Cookie</code>告诉浏览器需要将此内容放在<code>Cookies</code>中，下次请求携带<code>Cookies</code>请求。</li>\n<li><code>Expires</code>：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li>\n</ul>\n<h3 id=\"响应体\"><a href=\"#响应体\" class=\"headerlink\" title=\"响应体\"></a>响应体</h3><p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的<code>HTML</code>代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图所示。</p>\n<p><img src=\"Screenshot_1.png\" alt=\"响应体\"></p>\n<p>在浏览器开发者工具中点击<code>Response</code>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。在做爬虫时，我们主要通过响应体得到网页的源代码、<code>JSON</code>数据等，然后从中做相应内容的提取。</p>\n"},{"title":"Pyquery的使用","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-22T16:49:30.000Z","pic":null,"_content":"\n## 准备工作\n\n`pyquery`是`Python`的第三方库，安装命令如下：\n\n```python\npip3 install pyquery\n```\n\n## 初始化\n\n解析`HTML`文本的时候，首先需要将其初始化为一个`pyquery`对象。它的初始化方式有多种，比如直接**传入字符串**、**传入`URL`**、**传入文件名**，等等。\n\n### 字符串初始化\n\n可以直接把`HTML`的内容当作参数来初始化`pyquery`对象。\n\n```python\nhtml = ''' \n<div>\n    <ul> \n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li> \n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li> \n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li> \n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul> \n</div> \n''' \n\nfrom pyquery import PyQuery as pq \n\ndoc = pq(html) \n\nprint(doc('li'))\n```\n\n运行结果如下：\n\n```python\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li> \n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li> \n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li> \n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n引入`pyquery`这个对象，取别名为`pq`，然后声明了一个长`HTML`字符串，并将其当作参数传递给`pyquery`类，这样就成功完成了初始化。\n\n接下来，将初始化的对象传入`CSS`选择器。在这个实例中，传入`li`节点，这样就可以选择所有的`li`节点。\n\n### URL初始化 \n\n初始化的参数不仅可以以字符串的形式传递，还可以传入网页的`URL`，只需要指定参数为`url`即可：\n\n```python\nfrom pyquery import PyQuery as pq \n\ndoc = pq(url='https://www.holychan.ltd')\n\nprint(doc('title'))\n```\n\n```python\n<title>Holy的个人站点</title>\n```\n\n`pyquery`对象会首先请求这个`URL`，然后用得到的`HTML`内容完成初始化。这就相当于将网页的源代码以字符串的形式传递给`pyquery`类来初始化。\n\n它与下面的功能是相同的：\n\n```python\nfrom pyquery import PyQuery as pq\nimport requests\n\ndoc = pq(requests.get('https://www.holychan.ltd').text)\nprint(doc('title'))\n```\n\n### 文件初始化\n\n除了传递一个`URL`，还可以传递本地的文件名，参数指定为`filename`即可：\n\n```python\nfrom pyquery import PyQuery as pq\n\ndoc = pq(filename='demo.html')\nprint(doc('li'))\n```\n\n这里需要有一个本地`HTML`文件`demo.html`，其内容是待解析的`HTML`字符串。这样它会先读取本地的文件内容，然后将文件内容以字符串的形式传递给 `pyquery`类来初始化。\n\n以上3种方式均可初始化，当然最常用的初始化方式还是以字符串形式传递。\n\n## 基本CSS选择器\n\n```python\nhtml = '''\n<div id=\"container\">\n    <ul class=\"list\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n</div> \n''' \nfrom pyquery import PyQuery as pq \ndoc = pq(html)\nprint(doc('#container .list li'))\nprint(type(doc('#container .list li')))\n```\n\n运行结果：\n\n```python\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n\n<class 'pyquery.pyquery.PyQuery'>\n```\n\n初始化`pyquery`对象之后，传入`CSS`选择器`#container .list li`，它的意思是先选取`id`为`container`的节点，然后再选取其内部`class`为`list`的所有`li`节点，最后打印输出。成功获取到了符合条件的节点。将它的类型打印输出后发现，它的类型依然是`pyquery`类型。\n\n直接遍历这些节点，然后调用`text`方法，就可以获取节点的文本内容，代码示例如下：\n\n```python\nfor item in doc('#container .list li').items():\n    print(item.text())\n```\n\n结果如下：\n\n```python\nfirst item\nsecond item\nthird item\nfourth item\nfifth item\n```\n\n## 查找节点\n\n### 子节点\n\n查找子节点需要用到`find`方法，传入的参数是`CSS`选择器：\n\n```python\nhtml = '''\n<div id=\"container\">\n    <ul class=\"list\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n</div> \n''' \n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nitems = doc('.list')\nprint(type(items))\nprint(items)\nlis = items.find('li')\nprint(type(lis))\nprint(lis)\n```\n\n运行结果：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<ul class=\"list\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n\n<class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n通过`.list`参数选取`class`为`list`的节点，然后调用`find`方法，传入`CSS`选择器，选取其内部的`li`节点，最后打印输出。可以发现，`find`方法会将符合条件的所有节点选择出来，结果的类型是`pyquery`类型。\n\n`find`的查找范围是节点的所有子孙节点，而如果我们只想查找子节点，那可以用`children`方法：\n\n```python\nlis = items.children()\nprint(type(lis))\nprint(lis)\n```\n\n运行结果：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n如果要筛选所有子节点中符合条件的节点，比如想筛选出子节点中`class`为`active`的节点，可以向`children`方法传入`CSS`选择器`.active`，代码如下：\n\n```python\nlis = items.children('.active')\nprint(lis)\n```\n\n结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n```\n\n输出的结果做了筛选，留下了`class`为`active`的节点。\n\n### 父节点\n\n可以用`parent`方法获取某个节点的父节点：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nitems = doc('.list')\ncontainer = items.parent()\nprint(type(container))\nprint(container)\n```\n\n运行结果如下：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n```\n\n用`.list`选取`class`为`list`的节点，然后调用`parent`方法得到其父节点，其类型依然是`pyquery`类型。这里的父节点是该节点的直接父节点，也就是说，它不会再去查找父节点的父节点，即祖先节点。\n\n如果你想获取某个祖先节点，该怎么办呢？可以用`parents`方法：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nitems = doc('.list')\ncontainer = items.parents()\nprint(type(container))\nprint(container)\n```\n\n运行结果如下：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div><div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n```\n\n输出结果有两个：一个是`class`为`wrap`的节点，一个是`id`为`container`的节点。也就是说，使用`parents`方法会返回所有的祖先节点。\n\n要筛选某个祖先节点的话，可以向`parents`方法传入`CSS`选择器，这样就会返回祖先节点中符合`CSS`选择器的节点：\n\n```python\nparent = items.parents('.wrap')\nprint(parent)\n```\n\n结果如下：\n\n```python\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n```\n\n输出结果少了一个节点，只保留了`class`为`wrap`的节点。\n\n### 兄弟节点\n\n要获取兄弟节点，可以使用`siblings`方法。这里还是以上面的`HTML`代码为例：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.list .item-0.active')\nprint(li.siblings())\n```\n\n结果如下：\n\n```python\n<li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n先选择`class`为`list`的节点，内部`class`为`item-0`和`active`的节点，也就是第3个`li`节点。很明显，它的兄弟节点有4个，那就是第`1`、`2`、`4`、`5 `个`li`节点。结果显示的正是4个兄弟节点。\n\n筛选某个兄弟节点，可以用`siblings`方法传入`CSS`选择器，这样就会从所有兄弟节点中挑选出符合条件的节点了：\n\n```python\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nli = doc('.list .item-0.active')\nprint(li.siblings('.active')) \n```\n\n筛选`class`为`active`的节点，从刚才的结果中可以观察到，`class`为`active`兄弟节点的是第4个`li`节点，所以结果应该是1个。运行结果：\n\n```python\n<li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n```\n\n## 遍历\n\n`pyquery`的选择结果既可能是多个节点，也可能是单个节点，类型都是`pyquery`类型，并没有返回列表。对于单个节点来说，可以直接打印输出，也可以直接转成字符串：\n\n```python\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nprint(str(li))\n```\n\n运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n```\n\n对于有多个节点的结果，我们就需要用遍历来获取了。例如，如果要把每一个`li`节点进行遍历，需要调用`items`方法：\n\n```python\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\nlis = doc('li').items()\nprint(type(lis))\nfor li in lis:\n    print(li, type(li))\n```\n\n运行结果如下：\n\n```python\n<class 'generator'>\n<li class=\"item-0\">first item</li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         <class 'pyquery.pyquery.PyQuery'>\n```\n\n调用`items`方法后，会得到一个生成器，遍历一下，就可以逐个得到`li`节点对象了，它的类型也是`pyquery`类型。每个`li`节点还可以调用前面所说的方法进行选择，比如继续查询子节点，寻找某个祖先节点等。\n\n## 获取信息\n\n提取到节点之后，最终目的是提取节点包含的信息。比较重要的信息有两类，一是获取属性，二是获取文本。\n\n### 获取属性\n\n提取到某个`pyquery`类型的节点后，就可以调用`attr`方法来获取属性：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\na = doc('.item-0.active a')\nprint(a, type(a))\nprint(a.attr('href'))\n```\n\n运行结果如下：\n\n```python\n<a href=\"link3.html\"><span class=\"bold\">third item</span></a> <class 'pyquery.pyquery.PyQuery'>\nlink3.html\n```\n\n首先选中`class`为`item-0`和`active`的`li`节点内的`a`节点，它的类型是`pyquery`类型。然后调用`attr`方法。在这个方法中传入属性的名称，就可以得到属性值了。此外，也可以通过调用`attr`属性来获取属性值，用法如下：\n\n```python\nprint(a.attr.href)\n```\n\n结果：`link3.html`，这两种方法的结果完全一样。\n\n### 获取文本\n\n获取节点之后的另一个主要操作就是获取其内部文本了，此时可以调用`text`方法来实现：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\na = doc('.item-0.active a')\nprint(a)\nprint(a.text())\n```\n\n运行结果如下：\n\n```python\n<a href=\"link3.html\"><span class=\"bold\">third item</span></a>\nthird item\n```\n\n首先选中一个`a`节点，然后调用`text`方法，就可以获取其内部的文本信息了。`text`会忽略节点内部包含的所有`HTML`，只返回纯文字内容。\n\n如果想要获取这个节点内部的`HTML`文本，就要用`html`方法：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nprint(li.html())\n``\n这里我们选中第3个`li`节点，然后调用`html`方法，它返回的结果应该是`li`节点内的所有`HTML`文本。运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n<a href=\"link3.html\"><span class=\"bold\">third item</span></a>\n```\n\n如果我们选中的结果是多个节点，`text`或`html`方法会返回什么内容？我们用实例来看一下：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('li')\nprint(li.html())\nprint(li.text())\nprint(type(li.text()))\n```\n\n运行结果如下：\n\n```python\nfirst item\nfirst item second item third item fourth item fifth item\n<class 'str'>\n```\n\n`html`方法返回的是第1个`li`节点的内部`HTML`文本，而`text`则返回了所有的`li`节点内部的纯文本，中间用一个空格分割开，即返回结果是一个字符串。\n\n## 节点操作\n\n`pyquery`提供了一系列方法来对节点进行动态修改，比如为某个节点添加一个`class`，移除某个节点等，这些操作有时会为提取信息带来极大的便利。\n由于节点操作的方法太多，下面举几个典型的例子来说明它的用法。\n\n### addClass和removeClass\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nli.remove_class('active')\nprint(li)\nli.add_class('active')\nprint(li)\n```\n\n首先选中第3个`li`节点，然后调用`removeClass`方法，将`li`节点的`active`这`class`移除，第2步调用`addClass`方法，将`class`添加回来。每执行一次操作，就打印输出当前`li`节点的内容。\n\n运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n```\n\n一共输出了3次。第2次输出时，`li`节点的`active`这个`class`被移除了，第3次`class`又添加回来了。`addClass`和`removeClass`方法可以动态改变节点的`class`属性。\n\n### attr、text、html\n\n除了操作`class`这个属性外，也可以用`attr`方法对属性进行操作。此外，还可以用`text`和`html`方法来改变节点内部的内容。示例如下：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nli.attr('name', 'link')\nprint(li)\nli.text('changed item')\nprint(li)\nli.html('<span>changed item</span>')\nprint(li)\n```\n\n首先选中`li`节点，然后调用`attr`方法来修改属性。该方法的第1个参数为属性名，第2个参数为属性值。最后调用`text`和`html`方法来改变节点内部的内容。3次操作后，分别打印输出当前的`li`节点。 运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\" name=\"link\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\" name=\"link\">changed item</li>\n\n<li class=\"item-0 active\" name=\"link\"><span>changed item</span></li>\n```\n\n调用`attr`方法后，`li`节点多了一个原本不存在的属性`name`，其值为`link`。接着调用`text`方法传入文本，`li`节点内部的文本全被改为传入的字符串文本。最后，调用`html`方法传入`HTML`文本，`li`节点内部又变为传入的`HTML`文本了。\n\n使用`attr`方法时如果只传入第1个参数的属性名，则是获取这个属性值；如果传入第2个参数，可以用来修改属性值。使用`text`和`html`方法时如果不传参数，则是获取节点内纯文本和`HTML`文本，如果传入参数，则进行赋值。\n\n### remove\n\n`remove`方法就是移除，它有时会为信息的提取带来非常大的便利。下面有一段 HTML文本：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    hello, world\n    <p>This is a paragraph.</p>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\nwrap = doc('.wrap')\nprint(wrap.text())\n```\n\n想提取`“Hello, World”`这个字符串，该怎样操作呢？\n\n这里先直接尝试提取`class`为`wrap`的节点的内容，看看是不是我们想要的。\n\n运行结果如下：\n\n```python\nHello, World This is a paragraph.\n```\n\n这个结果还包含了内部的`p`节点的内容，也就是说`text`把所有的纯文本全提取出来了。\n\n如果想去掉`p`节点内部的文本，可以选择再把`p`节点内的文本提取一遍，然后从整个结果中移除这个子串，但这个做法明显比较烦琐。\n\n这时`remove`方法就可以派上用场了，可以接着这么做：\n\n```python\nwrap.find('p').remove()\nprint(wrap.text())\n```\n\n首先选中`p`节点，然后调用`remove`方法将其移除，这时`wrap`内部就只剩下`“Hello, World”`这句话了，最后利用`text`方法提取即可。\n\n其实还有很多其他节点操作的方法，比如`append`、`empty`和`prepend`等方法，详细的用法可以参考官方文档：[http://pyquery.readthedocs.io/en/latest/api.html](http://pyquery.readthedocs.io/en/latest/api.html)。\n\n## 伪类选择器\n\n`CSS`选择器之所以强大，还有一个很重要的原因，那就是它支持多种多样的伪类选择器，例如选择第一个节点、最后一个节点、奇偶数节点、包含某一文本的节点等。示例如下：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nli = doc('li:first-child')\nprint(li)\nli = doc('li:last-child')\nprint(li)\nli = doc('li:nth-child(2)')\nprint(li)\nli = doc('li:gt(2)')\nprint(li)\nli = doc('li:nth-child(2n)')\nprint(li)\nli = doc('li:contains(second)')\nprint(li)\n```\n\n在这个例子中使用了`CSS3`的伪类选择器，依次选择了第1个`li`节点、最后一个`li`节点、第2个`li`节点、第3个`li`之后的`li`节点、偶数位置的`li`节点、包含`second`文本的`li`节点。\n","source":"_posts/Pyquery的使用.md","raw":"---\ntitle: Pyquery的使用\ntags:\n  - pyquery\n  - python\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-23 00:49:30\ncategories: 爬虫\npic:\n---\n\n## 准备工作\n\n`pyquery`是`Python`的第三方库，安装命令如下：\n\n```python\npip3 install pyquery\n```\n\n## 初始化\n\n解析`HTML`文本的时候，首先需要将其初始化为一个`pyquery`对象。它的初始化方式有多种，比如直接**传入字符串**、**传入`URL`**、**传入文件名**，等等。\n\n### 字符串初始化\n\n可以直接把`HTML`的内容当作参数来初始化`pyquery`对象。\n\n```python\nhtml = ''' \n<div>\n    <ul> \n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li> \n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li> \n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li> \n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul> \n</div> \n''' \n\nfrom pyquery import PyQuery as pq \n\ndoc = pq(html) \n\nprint(doc('li'))\n```\n\n运行结果如下：\n\n```python\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li> \n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li> \n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li> \n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n引入`pyquery`这个对象，取别名为`pq`，然后声明了一个长`HTML`字符串，并将其当作参数传递给`pyquery`类，这样就成功完成了初始化。\n\n接下来，将初始化的对象传入`CSS`选择器。在这个实例中，传入`li`节点，这样就可以选择所有的`li`节点。\n\n### URL初始化 \n\n初始化的参数不仅可以以字符串的形式传递，还可以传入网页的`URL`，只需要指定参数为`url`即可：\n\n```python\nfrom pyquery import PyQuery as pq \n\ndoc = pq(url='https://www.holychan.ltd')\n\nprint(doc('title'))\n```\n\n```python\n<title>Holy的个人站点</title>\n```\n\n`pyquery`对象会首先请求这个`URL`，然后用得到的`HTML`内容完成初始化。这就相当于将网页的源代码以字符串的形式传递给`pyquery`类来初始化。\n\n它与下面的功能是相同的：\n\n```python\nfrom pyquery import PyQuery as pq\nimport requests\n\ndoc = pq(requests.get('https://www.holychan.ltd').text)\nprint(doc('title'))\n```\n\n### 文件初始化\n\n除了传递一个`URL`，还可以传递本地的文件名，参数指定为`filename`即可：\n\n```python\nfrom pyquery import PyQuery as pq\n\ndoc = pq(filename='demo.html')\nprint(doc('li'))\n```\n\n这里需要有一个本地`HTML`文件`demo.html`，其内容是待解析的`HTML`字符串。这样它会先读取本地的文件内容，然后将文件内容以字符串的形式传递给 `pyquery`类来初始化。\n\n以上3种方式均可初始化，当然最常用的初始化方式还是以字符串形式传递。\n\n## 基本CSS选择器\n\n```python\nhtml = '''\n<div id=\"container\">\n    <ul class=\"list\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n</div> \n''' \nfrom pyquery import PyQuery as pq \ndoc = pq(html)\nprint(doc('#container .list li'))\nprint(type(doc('#container .list li')))\n```\n\n运行结果：\n\n```python\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n\n<class 'pyquery.pyquery.PyQuery'>\n```\n\n初始化`pyquery`对象之后，传入`CSS`选择器`#container .list li`，它的意思是先选取`id`为`container`的节点，然后再选取其内部`class`为`list`的所有`li`节点，最后打印输出。成功获取到了符合条件的节点。将它的类型打印输出后发现，它的类型依然是`pyquery`类型。\n\n直接遍历这些节点，然后调用`text`方法，就可以获取节点的文本内容，代码示例如下：\n\n```python\nfor item in doc('#container .list li').items():\n    print(item.text())\n```\n\n结果如下：\n\n```python\nfirst item\nsecond item\nthird item\nfourth item\nfifth item\n```\n\n## 查找节点\n\n### 子节点\n\n查找子节点需要用到`find`方法，传入的参数是`CSS`选择器：\n\n```python\nhtml = '''\n<div id=\"container\">\n    <ul class=\"list\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n</div> \n''' \n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nitems = doc('.list')\nprint(type(items))\nprint(items)\nlis = items.find('li')\nprint(type(lis))\nprint(lis)\n```\n\n运行结果：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<ul class=\"list\">\n        <li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n    </ul>\n\n<class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n通过`.list`参数选取`class`为`list`的节点，然后调用`find`方法，传入`CSS`选择器，选取其内部的`li`节点，最后打印输出。可以发现，`find`方法会将符合条件的所有节点选择出来，结果的类型是`pyquery`类型。\n\n`find`的查找范围是节点的所有子孙节点，而如果我们只想查找子节点，那可以用`children`方法：\n\n```python\nlis = items.children()\nprint(type(lis))\nprint(lis)\n```\n\n运行结果：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0\">first item</li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n如果要筛选所有子节点中符合条件的节点，比如想筛选出子节点中`class`为`active`的节点，可以向`children`方法传入`CSS`选择器`.active`，代码如下：\n\n```python\nlis = items.children('.active')\nprint(lis)\n```\n\n结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n        <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n```\n\n输出的结果做了筛选，留下了`class`为`active`的节点。\n\n### 父节点\n\n可以用`parent`方法获取某个节点的父节点：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nitems = doc('.list')\ncontainer = items.parent()\nprint(type(container))\nprint(container)\n```\n\n运行结果如下：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n```\n\n用`.list`选取`class`为`list`的节点，然后调用`parent`方法得到其父节点，其类型依然是`pyquery`类型。这里的父节点是该节点的直接父节点，也就是说，它不会再去查找父节点的父节点，即祖先节点。\n\n如果你想获取某个祖先节点，该怎么办呢？可以用`parents`方法：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nitems = doc('.list')\ncontainer = items.parents()\nprint(type(container))\nprint(container)\n```\n\n运行结果如下：\n\n```python\n<class 'pyquery.pyquery.PyQuery'>\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div><div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n```\n\n输出结果有两个：一个是`class`为`wrap`的节点，一个是`id`为`container`的节点。也就是说，使用`parents`方法会返回所有的祖先节点。\n\n要筛选某个祖先节点的话，可以向`parents`方法传入`CSS`选择器，这样就会返回祖先节点中符合`CSS`选择器的节点：\n\n```python\nparent = items.parents('.wrap')\nprint(parent)\n```\n\n结果如下：\n\n```python\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n```\n\n输出结果少了一个节点，只保留了`class`为`wrap`的节点。\n\n### 兄弟节点\n\n要获取兄弟节点，可以使用`siblings`方法。这里还是以上面的`HTML`代码为例：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.list .item-0.active')\nprint(li.siblings())\n```\n\n结果如下：\n\n```python\n<li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n```\n\n先选择`class`为`list`的节点，内部`class`为`item-0`和`active`的节点，也就是第3个`li`节点。很明显，它的兄弟节点有4个，那就是第`1`、`2`、`4`、`5 `个`li`节点。结果显示的正是4个兄弟节点。\n\n筛选某个兄弟节点，可以用`siblings`方法传入`CSS`选择器，这样就会从所有兄弟节点中挑选出符合条件的节点了：\n\n```python\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nli = doc('.list .item-0.active')\nprint(li.siblings('.active')) \n```\n\n筛选`class`为`active`的节点，从刚才的结果中可以观察到，`class`为`active`兄弟节点的是第4个`li`节点，所以结果应该是1个。运行结果：\n\n```python\n<li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n```\n\n## 遍历\n\n`pyquery`的选择结果既可能是多个节点，也可能是单个节点，类型都是`pyquery`类型，并没有返回列表。对于单个节点来说，可以直接打印输出，也可以直接转成字符串：\n\n```python\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nprint(str(li))\n```\n\n运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n```\n\n对于有多个节点的结果，我们就需要用遍历来获取了。例如，如果要把每一个`li`节点进行遍历，需要调用`items`方法：\n\n```python\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\nlis = doc('li').items()\nprint(type(lis))\nfor li in lis:\n    print(li, type(li))\n```\n\n运行结果如下：\n\n```python\n<class 'generator'>\n<li class=\"item-0\">first item</li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <class 'pyquery.pyquery.PyQuery'>\n<li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         <class 'pyquery.pyquery.PyQuery'>\n```\n\n调用`items`方法后，会得到一个生成器，遍历一下，就可以逐个得到`li`节点对象了，它的类型也是`pyquery`类型。每个`li`节点还可以调用前面所说的方法进行选择，比如继续查询子节点，寻找某个祖先节点等。\n\n## 获取信息\n\n提取到节点之后，最终目的是提取节点包含的信息。比较重要的信息有两类，一是获取属性，二是获取文本。\n\n### 获取属性\n\n提取到某个`pyquery`类型的节点后，就可以调用`attr`方法来获取属性：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\na = doc('.item-0.active a')\nprint(a, type(a))\nprint(a.attr('href'))\n```\n\n运行结果如下：\n\n```python\n<a href=\"link3.html\"><span class=\"bold\">third item</span></a> <class 'pyquery.pyquery.PyQuery'>\nlink3.html\n```\n\n首先选中`class`为`item-0`和`active`的`li`节点内的`a`节点，它的类型是`pyquery`类型。然后调用`attr`方法。在这个方法中传入属性的名称，就可以得到属性值了。此外，也可以通过调用`attr`属性来获取属性值，用法如下：\n\n```python\nprint(a.attr.href)\n```\n\n结果：`link3.html`，这两种方法的结果完全一样。\n\n### 获取文本\n\n获取节点之后的另一个主要操作就是获取其内部文本了，此时可以调用`text`方法来实现：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\na = doc('.item-0.active a')\nprint(a)\nprint(a.text())\n```\n\n运行结果如下：\n\n```python\n<a href=\"link3.html\"><span class=\"bold\">third item</span></a>\nthird item\n```\n\n首先选中一个`a`节点，然后调用`text`方法，就可以获取其内部的文本信息了。`text`会忽略节点内部包含的所有`HTML`，只返回纯文字内容。\n\n如果想要获取这个节点内部的`HTML`文本，就要用`html`方法：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nprint(li.html())\n``\n这里我们选中第3个`li`节点，然后调用`html`方法，它返回的结果应该是`li`节点内的所有`HTML`文本。运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n<a href=\"link3.html\"><span class=\"bold\">third item</span></a>\n```\n\n如果我们选中的结果是多个节点，`text`或`html`方法会返回什么内容？我们用实例来看一下：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('li')\nprint(li.html())\nprint(li.text())\nprint(type(li.text()))\n```\n\n运行结果如下：\n\n```python\nfirst item\nfirst item second item third item fourth item fifth item\n<class 'str'>\n```\n\n`html`方法返回的是第1个`li`节点的内部`HTML`文本，而`text`则返回了所有的`li`节点内部的纯文本，中间用一个空格分割开，即返回结果是一个字符串。\n\n## 节点操作\n\n`pyquery`提供了一系列方法来对节点进行动态修改，比如为某个节点添加一个`class`，移除某个节点等，这些操作有时会为提取信息带来极大的便利。\n由于节点操作的方法太多，下面举几个典型的例子来说明它的用法。\n\n### addClass和removeClass\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nli.remove_class('active')\nprint(li)\nli.add_class('active')\nprint(li)\n```\n\n首先选中第3个`li`节点，然后调用`removeClass`方法，将`li`节点的`active`这`class`移除，第2步调用`addClass`方法，将`class`添加回来。每执行一次操作，就打印输出当前`li`节点的内容。\n\n运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n```\n\n一共输出了3次。第2次输出时，`li`节点的`active`这个`class`被移除了，第3次`class`又添加回来了。`addClass`和`removeClass`方法可以动态改变节点的`class`属性。\n\n### attr、text、html\n\n除了操作`class`这个属性外，也可以用`attr`方法对属性进行操作。此外，还可以用`text`和`html`方法来改变节点内部的内容。示例如下：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\n\nli = doc('.item-0.active')\nprint(li)\nli.attr('name', 'link')\nprint(li)\nli.text('changed item')\nprint(li)\nli.html('<span>changed item</span>')\nprint(li)\n```\n\n首先选中`li`节点，然后调用`attr`方法来修改属性。该方法的第1个参数为属性名，第2个参数为属性值。最后调用`text`和`html`方法来改变节点内部的内容。3次操作后，分别打印输出当前的`li`节点。 运行结果如下：\n\n```python\n<li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\" name=\"link\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n\n<li class=\"item-0 active\" name=\"link\">changed item</li>\n\n<li class=\"item-0 active\" name=\"link\"><span>changed item</span></li>\n```\n\n调用`attr`方法后，`li`节点多了一个原本不存在的属性`name`，其值为`link`。接着调用`text`方法传入文本，`li`节点内部的文本全被改为传入的字符串文本。最后，调用`html`方法传入`HTML`文本，`li`节点内部又变为传入的`HTML`文本了。\n\n使用`attr`方法时如果只传入第1个参数的属性名，则是获取这个属性值；如果传入第2个参数，可以用来修改属性值。使用`text`和`html`方法时如果不传参数，则是获取节点内纯文本和`HTML`文本，如果传入参数，则进行赋值。\n\n### remove\n\n`remove`方法就是移除，它有时会为信息的提取带来非常大的便利。下面有一段 HTML文本：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    hello, world\n    <p>This is a paragraph.</p>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\n\ndoc = pq(html)\nwrap = doc('.wrap')\nprint(wrap.text())\n```\n\n想提取`“Hello, World”`这个字符串，该怎样操作呢？\n\n这里先直接尝试提取`class`为`wrap`的节点的内容，看看是不是我们想要的。\n\n运行结果如下：\n\n```python\nHello, World This is a paragraph.\n```\n\n这个结果还包含了内部的`p`节点的内容，也就是说`text`把所有的纯文本全提取出来了。\n\n如果想去掉`p`节点内部的文本，可以选择再把`p`节点内的文本提取一遍，然后从整个结果中移除这个子串，但这个做法明显比较烦琐。\n\n这时`remove`方法就可以派上用场了，可以接着这么做：\n\n```python\nwrap.find('p').remove()\nprint(wrap.text())\n```\n\n首先选中`p`节点，然后调用`remove`方法将其移除，这时`wrap`内部就只剩下`“Hello, World”`这句话了，最后利用`text`方法提取即可。\n\n其实还有很多其他节点操作的方法，比如`append`、`empty`和`prepend`等方法，详细的用法可以参考官方文档：[http://pyquery.readthedocs.io/en/latest/api.html](http://pyquery.readthedocs.io/en/latest/api.html)。\n\n## 伪类选择器\n\n`CSS`选择器之所以强大，还有一个很重要的原因，那就是它支持多种多样的伪类选择器，例如选择第一个节点、最后一个节点、奇偶数节点、包含某一文本的节点等。示例如下：\n\n```python\nhtml = '''\n<div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n            <li class=\"item-0\">first item</li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n            <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n        </ul>\n    </div>\n</div>\n'''\n\nfrom pyquery import PyQuery as pq\ndoc = pq(html)\nli = doc('li:first-child')\nprint(li)\nli = doc('li:last-child')\nprint(li)\nli = doc('li:nth-child(2)')\nprint(li)\nli = doc('li:gt(2)')\nprint(li)\nli = doc('li:nth-child(2n)')\nprint(li)\nli = doc('li:contains(second)')\nprint(li)\n```\n\n在这个例子中使用了`CSS3`的伪类选择器，依次选择了第1个`li`节点、最后一个`li`节点、第2个`li`节点、第3个`li`之后的`li`节点、偶数位置的`li`节点、包含`second`文本的`li`节点。\n","slug":"Pyquery的使用","published":1,"updated":"2021-06-15T03:24:11.474Z","_id":"ckpapu7kc003flcxuapss6zux","layout":"post","photos":[],"link":"","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p><code>pyquery</code>是<code>Python</code>的第三方库，安装命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install pyquery</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>解析<code>HTML</code>文本的时候，首先需要将其初始化为一个<code>pyquery</code>对象。它的初始化方式有多种，比如直接<strong>传入字符串</strong>、<strong>传入<code>URL</code><strong>、</strong>传入文件名</strong>，等等。</p>\n<h3 id=\"字符串初始化\"><a href=\"#字符串初始化\" class=\"headerlink\" title=\"字符串初始化\"></a>字符串初始化</h3><p>可以直接把<code>HTML</code>的内容当作参数来初始化<code>pyquery</code>对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27; </span></span><br><span class=\"line\"><span class=\"string\">&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt; </span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt; </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq </span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入<code>pyquery</code>这个对象，取别名为<code>pq</code>，然后声明了一个长<code>HTML</code>字符串，并将其当作参数传递给<code>pyquery</code>类，这样就成功完成了初始化。</p>\n<p>接下来，将初始化的对象传入<code>CSS</code>选择器。在这个实例中，传入<code>li</code>节点，这样就可以选择所有的<code>li</code>节点。</p>\n<h3 id=\"URL初始化\"><a href=\"#URL初始化\" class=\"headerlink\" title=\"URL初始化\"></a>URL初始化</h3><p>初始化的参数不仅可以以字符串的形式传递，还可以传入网页的<code>URL</code>，只需要指定参数为<code>url</code>即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq </span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(url=<span class=\"string\">&#x27;https://www.holychan.ltd&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;title&gt;Holy的个人站点&lt;/title&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>pyquery</code>对象会首先请求这个<code>URL</code>，然后用得到的<code>HTML</code>内容完成初始化。这就相当于将网页的源代码以字符串的形式传递给<code>pyquery</code>类来初始化。</p>\n<p>它与下面的功能是相同的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(requests.get(<span class=\"string\">&#x27;https://www.holychan.ltd&#x27;</span>).text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件初始化\"><a href=\"#文件初始化\" class=\"headerlink\" title=\"文件初始化\"></a>文件初始化</h3><p>除了传递一个<code>URL</code>，还可以传递本地的文件名，参数指定为<code>filename</code>即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(filename=<span class=\"string\">&#x27;demo.html&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>这里需要有一个本地<code>HTML</code>文件<code>demo.html</code>，其内容是待解析的<code>HTML</code>字符串。这样它会先读取本地的文件内容，然后将文件内容以字符串的形式传递给 <code>pyquery</code>类来初始化。</p>\n<p>以上3种方式均可初始化，当然最常用的初始化方式还是以字符串形式传递。</p>\n<h2 id=\"基本CSS选择器\"><a href=\"#基本CSS选择器\" class=\"headerlink\" title=\"基本CSS选择器\"></a>基本CSS选择器</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt; </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq </span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;#container .list li&#x27;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(doc(<span class=\"string\">&#x27;#container .list li&#x27;</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>初始化<code>pyquery</code>对象之后，传入<code>CSS</code>选择器<code>#container .list li</code>，它的意思是先选取<code>id</code>为<code>container</code>的节点，然后再选取其内部<code>class</code>为<code>list</code>的所有<code>li</code>节点，最后打印输出。成功获取到了符合条件的节点。将它的类型打印输出后发现，它的类型依然是<code>pyquery</code>类型。</p>\n<p>直接遍历这些节点，然后调用<code>text</code>方法，就可以获取节点的文本内容，代码示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> doc(<span class=\"string\">&#x27;#container .list li&#x27;</span>).items():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(item.text())</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first item</span><br><span class=\"line\">second item</span><br><span class=\"line\">third item</span><br><span class=\"line\">fourth item</span><br><span class=\"line\">fifth item</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h2><h3 id=\"子节点\"><a href=\"#子节点\" class=\"headerlink\" title=\"子节点\"></a>子节点</h3><p>查找子节点需要用到<code>find</code>方法，传入的参数是<code>CSS</code>选择器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt; </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">items = doc(<span class=\"string\">&#x27;.list&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(items))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(items)</span><br><span class=\"line\">lis = items.find(<span class=\"string\">&#x27;li&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(lis))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>.list</code>参数选取<code>class</code>为<code>list</code>的节点，然后调用<code>find</code>方法，传入<code>CSS</code>选择器，选取其内部的<code>li</code>节点，最后打印输出。可以发现，<code>find</code>方法会将符合条件的所有节点选择出来，结果的类型是<code>pyquery</code>类型。</p>\n<p><code>find</code>的查找范围是节点的所有子孙节点，而如果我们只想查找子节点，那可以用<code>children</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = items.children()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(lis))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要筛选所有子节点中符合条件的节点，比如想筛选出子节点中<code>class</code>为<code>active</code>的节点，可以向<code>children</code>方法传入<code>CSS</code>选择器<code>.active</code>，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = items.children(<span class=\"string\">&#x27;.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出的结果做了筛选，留下了<code>class</code>为<code>active</code>的节点。</p>\n<h3 id=\"父节点\"><a href=\"#父节点\" class=\"headerlink\" title=\"父节点\"></a>父节点</h3><p>可以用<code>parent</code>方法获取某个节点的父节点：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">items = doc(<span class=\"string\">&#x27;.list&#x27;</span>)</span><br><span class=\"line\">container = items.parent()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(container))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(container)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>用<code>.list</code>选取<code>class</code>为<code>list</code>的节点，然后调用<code>parent</code>方法得到其父节点，其类型依然是<code>pyquery</code>类型。这里的父节点是该节点的直接父节点，也就是说，它不会再去查找父节点的父节点，即祖先节点。</p>\n<p>如果你想获取某个祖先节点，该怎么办呢？可以用<code>parents</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">items = doc(<span class=\"string\">&#x27;.list&#x27;</span>)</span><br><span class=\"line\">container = items.parents()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(container))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(container)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">div</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">wrap</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">div</span>&gt;&lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果有两个：一个是<code>class</code>为<code>wrap</code>的节点，一个是<code>id</code>为<code>container</code>的节点。也就是说，使用<code>parents</code>方法会返回所有的祖先节点。</p>\n<p>要筛选某个祖先节点的话，可以向<code>parents</code>方法传入<code>CSS</code>选择器，这样就会返回祖先节点中符合<code>CSS</code>选择器的节点：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent = items.parents(<span class=\"string\">&#x27;.wrap&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(parent)</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">wrap</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果少了一个节点，只保留了<code>class</code>为<code>wrap</code>的节点。</p>\n<h3 id=\"兄弟节点\"><a href=\"#兄弟节点\" class=\"headerlink\" title=\"兄弟节点\"></a>兄弟节点</h3><p>要获取兄弟节点，可以使用<code>siblings</code>方法。这里还是以上面的<code>HTML</code>代码为例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.list .item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.siblings())</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>先选择<code>class</code>为<code>list</code>的节点，内部<code>class</code>为<code>item-0</code>和<code>active</code>的节点，也就是第3个<code>li</code>节点。很明显，它的兄弟节点有4个，那就是第<code>1</code>、<code>2</code>、<code>4</code>、<code>5 </code>个<code>li</code>节点。结果显示的正是4个兄弟节点。</p>\n<p>筛选某个兄弟节点，可以用<code>siblings</code>方法传入<code>CSS</code>选择器，这样就会从所有兄弟节点中挑选出符合条件的节点了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.list .item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.siblings(<span class=\"string\">&#x27;.active&#x27;</span>)) </span><br></pre></td></tr></table></figure>\n\n<p>筛选<code>class</code>为<code>active</code>的节点，从刚才的结果中可以观察到，<code>class</code>为<code>active</code>兄弟节点的是第4个<code>li</code>节点，所以结果应该是1个。运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p><code>pyquery</code>的选择结果既可能是多个节点，也可能是单个节点，类型都是<code>pyquery</code>类型，并没有返回列表。对于单个节点来说，可以直接打印输出，也可以直接转成字符串：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>(li))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于有多个节点的结果，我们就需要用遍历来获取了。例如，如果要把每一个<code>li</code>节点进行遍历，需要调用<code>items</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">lis = doc(<span class=\"string\">&#x27;li&#x27;</span>).items()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(lis))</span><br><span class=\"line\"><span class=\"keyword\">for</span> li <span class=\"keyword\">in</span> lis:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(li, <span class=\"built_in\">type</span>(li))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">generator</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">         &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>items</code>方法后，会得到一个生成器，遍历一下，就可以逐个得到<code>li</code>节点对象了，它的类型也是<code>pyquery</code>类型。每个<code>li</code>节点还可以调用前面所说的方法进行选择，比如继续查询子节点，寻找某个祖先节点等。</p>\n<h2 id=\"获取信息\"><a href=\"#获取信息\" class=\"headerlink\" title=\"获取信息\"></a>获取信息</h2><p>提取到节点之后，最终目的是提取节点包含的信息。比较重要的信息有两类，一是获取属性，二是获取文本。</p>\n<h3 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h3><p>提取到某个<code>pyquery</code>类型的节点后，就可以调用<code>attr</code>方法来获取属性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">a = doc(<span class=\"string\">&#x27;.item-0.active a&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a, <span class=\"built_in\">type</span>(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.attr(<span class=\"string\">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;link3.html&quot;</span>&gt;&lt;span <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt; &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">link3</span>.<span class=\"title\">html</span></span></span><br></pre></td></tr></table></figure>\n\n<p>首先选中<code>class</code>为<code>item-0</code>和<code>active</code>的<code>li</code>节点内的<code>a</code>节点，它的类型是<code>pyquery</code>类型。然后调用<code>attr</code>方法。在这个方法中传入属性的名称，就可以得到属性值了。此外，也可以通过调用<code>attr</code>属性来获取属性值，用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(a.attr.href)</span><br></pre></td></tr></table></figure>\n\n<p>结果：<code>link3.html</code>，这两种方法的结果完全一样。</p>\n<h3 id=\"获取文本\"><a href=\"#获取文本\" class=\"headerlink\" title=\"获取文本\"></a>获取文本</h3><p>获取节点之后的另一个主要操作就是获取其内部文本了，此时可以调用<code>text</code>方法来实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">a = doc(<span class=\"string\">&#x27;.item-0.active a&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.text())</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;link3.html&quot;</span>&gt;&lt;span <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">third</span> <span class=\"title\">item</span></span></span><br></pre></td></tr></table></figure>\n\n<p>首先选中一个<code>a</code>节点，然后调用<code>text</code>方法，就可以获取其内部的文本信息了。<code>text</code>会忽略节点内部包含的所有<code>HTML</code>，只返回纯文字内容。</p>\n<p>如果想要获取这个节点内部的<code>HTML</code>文本，就要用<code>html</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.html())</span><br><span class=\"line\">``</span><br><span class=\"line\">这里我们选中第<span class=\"number\">3</span>个`li`节点，然后调用`html`方法，它返回的结果应该是`li`节点内的所有`HTML`文本。运行结果如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```python</span><br><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们选中的结果是多个节点，<code>text</code>或<code>html</code>方法会返回什么内容？我们用实例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.html())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.text())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(li.text()))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first item</span><br><span class=\"line\">first item second item third item fourth item fifth item</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>html</code>方法返回的是第1个<code>li</code>节点的内部<code>HTML</code>文本，而<code>text</code>则返回了所有的<code>li</code>节点内部的纯文本，中间用一个空格分割开，即返回结果是一个字符串。</p>\n<h2 id=\"节点操作\"><a href=\"#节点操作\" class=\"headerlink\" title=\"节点操作\"></a>节点操作</h2><p><code>pyquery</code>提供了一系列方法来对节点进行动态修改，比如为某个节点添加一个<code>class</code>，移除某个节点等，这些操作有时会为提取信息带来极大的便利。<br>由于节点操作的方法太多，下面举几个典型的例子来说明它的用法。</p>\n<h3 id=\"addClass和removeClass\"><a href=\"#addClass和removeClass\" class=\"headerlink\" title=\"addClass和removeClass\"></a>addClass和removeClass</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.remove_class(<span class=\"string\">&#x27;active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.add_class(<span class=\"string\">&#x27;active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br></pre></td></tr></table></figure>\n\n<p>首先选中第3个<code>li</code>节点，然后调用<code>removeClass</code>方法，将<code>li</code>节点的<code>active</code>这<code>class</code>移除，第2步调用<code>addClass</code>方法，将<code>class</code>添加回来。每执行一次操作，就打印输出当前<code>li</code>节点的内容。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>一共输出了3次。第2次输出时，<code>li</code>节点的<code>active</code>这个<code>class</code>被移除了，第3次<code>class</code>又添加回来了。<code>addClass</code>和<code>removeClass</code>方法可以动态改变节点的<code>class</code>属性。</p>\n<h3 id=\"attr、text、html\"><a href=\"#attr、text、html\" class=\"headerlink\" title=\"attr、text、html\"></a>attr、text、html</h3><p>除了操作<code>class</code>这个属性外，也可以用<code>attr</code>方法对属性进行操作。此外，还可以用<code>text</code>和<code>html</code>方法来改变节点内部的内容。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.attr(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.text(<span class=\"string\">&#x27;changed item&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.html(<span class=\"string\">&#x27;&lt;span&gt;changed item&lt;/span&gt;&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br></pre></td></tr></table></figure>\n\n<p>首先选中<code>li</code>节点，然后调用<code>attr</code>方法来修改属性。该方法的第1个参数为属性名，第2个参数为属性值。最后调用<code>text</code>和<code>html</code>方法来改变节点内部的内容。3次操作后，分别打印输出当前的<code>li</code>节点。 运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot; <span class=\"title\">name</span>=&quot;<span class=\"title\">link</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot; <span class=\"title\">name</span>=&quot;<span class=\"title\">link</span>&quot;&gt;<span class=\"title\">changed</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot; <span class=\"title\">name</span>=&quot;<span class=\"title\">link</span>&quot;&gt;&lt;<span class=\"title\">span</span>&gt;<span class=\"title\">changed</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>attr</code>方法后，<code>li</code>节点多了一个原本不存在的属性<code>name</code>，其值为<code>link</code>。接着调用<code>text</code>方法传入文本，<code>li</code>节点内部的文本全被改为传入的字符串文本。最后，调用<code>html</code>方法传入<code>HTML</code>文本，<code>li</code>节点内部又变为传入的<code>HTML</code>文本了。</p>\n<p>使用<code>attr</code>方法时如果只传入第1个参数的属性名，则是获取这个属性值；如果传入第2个参数，可以用来修改属性值。使用<code>text</code>和<code>html</code>方法时如果不传参数，则是获取节点内纯文本和<code>HTML</code>文本，如果传入参数，则进行赋值。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><p><code>remove</code>方法就是移除，它有时会为信息的提取带来非常大的便利。下面有一段 HTML文本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    hello, world</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">wrap = doc(<span class=\"string\">&#x27;.wrap&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(wrap.text())</span><br></pre></td></tr></table></figure>\n\n<p>想提取<code>“Hello, World”</code>这个字符串，该怎样操作呢？</p>\n<p>这里先直接尝试提取<code>class</code>为<code>wrap</code>的节点的内容，看看是不是我们想要的。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, World This <span class=\"keyword\">is</span> a paragraph.</span><br></pre></td></tr></table></figure>\n\n<p>这个结果还包含了内部的<code>p</code>节点的内容，也就是说<code>text</code>把所有的纯文本全提取出来了。</p>\n<p>如果想去掉<code>p</code>节点内部的文本，可以选择再把<code>p</code>节点内的文本提取一遍，然后从整个结果中移除这个子串，但这个做法明显比较烦琐。</p>\n<p>这时<code>remove</code>方法就可以派上用场了，可以接着这么做：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrap.find(<span class=\"string\">&#x27;p&#x27;</span>).remove()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(wrap.text())</span><br></pre></td></tr></table></figure>\n\n<p>首先选中<code>p</code>节点，然后调用<code>remove</code>方法将其移除，这时<code>wrap</code>内部就只剩下<code>“Hello, World”</code>这句话了，最后利用<code>text</code>方法提取即可。</p>\n<p>其实还有很多其他节点操作的方法，比如<code>append</code>、<code>empty</code>和<code>prepend</code>等方法，详细的用法可以参考官方文档：<a href=\"http://pyquery.readthedocs.io/en/latest/api.html\">http://pyquery.readthedocs.io/en/latest/api.html</a>。</p>\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><p><code>CSS</code>选择器之所以强大，还有一个很重要的原因，那就是它支持多种多样的伪类选择器，例如选择第一个节点、最后一个节点、奇偶数节点、包含某一文本的节点等。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:first-child&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:last-child&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:nth-child(2)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:gt(2)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:nth-child(2n)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:contains(second)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中使用了<code>CSS3</code>的伪类选择器，依次选择了第1个<code>li</code>节点、最后一个<code>li</code>节点、第2个<code>li</code>节点、第3个<code>li</code>之后的<code>li</code>节点、偶数位置的<code>li</code>节点、包含<code>second</code>文本的<code>li</code>节点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p><code>pyquery</code>是<code>Python</code>的第三方库，安装命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install pyquery</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>解析<code>HTML</code>文本的时候，首先需要将其初始化为一个<code>pyquery</code>对象。它的初始化方式有多种，比如直接<strong>传入字符串</strong>、<strong>传入<code>URL</code><strong>、</strong>传入文件名</strong>，等等。</p>\n<h3 id=\"字符串初始化\"><a href=\"#字符串初始化\" class=\"headerlink\" title=\"字符串初始化\"></a>字符串初始化</h3><p>可以直接把<code>HTML</code>的内容当作参数来初始化<code>pyquery</code>对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27; </span></span><br><span class=\"line\"><span class=\"string\">&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt; </span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt; </span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt; </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq </span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt; </span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入<code>pyquery</code>这个对象，取别名为<code>pq</code>，然后声明了一个长<code>HTML</code>字符串，并将其当作参数传递给<code>pyquery</code>类，这样就成功完成了初始化。</p>\n<p>接下来，将初始化的对象传入<code>CSS</code>选择器。在这个实例中，传入<code>li</code>节点，这样就可以选择所有的<code>li</code>节点。</p>\n<h3 id=\"URL初始化\"><a href=\"#URL初始化\" class=\"headerlink\" title=\"URL初始化\"></a>URL初始化</h3><p>初始化的参数不仅可以以字符串的形式传递，还可以传入网页的<code>URL</code>，只需要指定参数为<code>url</code>即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq </span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(url=<span class=\"string\">&#x27;https://www.holychan.ltd&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;title&gt;Holy的个人站点&lt;/title&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>pyquery</code>对象会首先请求这个<code>URL</code>，然后用得到的<code>HTML</code>内容完成初始化。这就相当于将网页的源代码以字符串的形式传递给<code>pyquery</code>类来初始化。</p>\n<p>它与下面的功能是相同的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(requests.get(<span class=\"string\">&#x27;https://www.holychan.ltd&#x27;</span>).text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件初始化\"><a href=\"#文件初始化\" class=\"headerlink\" title=\"文件初始化\"></a>文件初始化</h3><p>除了传递一个<code>URL</code>，还可以传递本地的文件名，参数指定为<code>filename</code>即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(filename=<span class=\"string\">&#x27;demo.html&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>这里需要有一个本地<code>HTML</code>文件<code>demo.html</code>，其内容是待解析的<code>HTML</code>字符串。这样它会先读取本地的文件内容，然后将文件内容以字符串的形式传递给 <code>pyquery</code>类来初始化。</p>\n<p>以上3种方式均可初始化，当然最常用的初始化方式还是以字符串形式传递。</p>\n<h2 id=\"基本CSS选择器\"><a href=\"#基本CSS选择器\" class=\"headerlink\" title=\"基本CSS选择器\"></a>基本CSS选择器</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt; </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq </span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(doc(<span class=\"string\">&#x27;#container .list li&#x27;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(doc(<span class=\"string\">&#x27;#container .list li&#x27;</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>初始化<code>pyquery</code>对象之后，传入<code>CSS</code>选择器<code>#container .list li</code>，它的意思是先选取<code>id</code>为<code>container</code>的节点，然后再选取其内部<code>class</code>为<code>list</code>的所有<code>li</code>节点，最后打印输出。成功获取到了符合条件的节点。将它的类型打印输出后发现，它的类型依然是<code>pyquery</code>类型。</p>\n<p>直接遍历这些节点，然后调用<code>text</code>方法，就可以获取节点的文本内容，代码示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> doc(<span class=\"string\">&#x27;#container .list li&#x27;</span>).items():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(item.text())</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first item</span><br><span class=\"line\">second item</span><br><span class=\"line\">third item</span><br><span class=\"line\">fourth item</span><br><span class=\"line\">fifth item</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h2><h3 id=\"子节点\"><a href=\"#子节点\" class=\"headerlink\" title=\"子节点\"></a>子节点</h3><p>查找子节点需要用到<code>find</code>方法，传入的参数是<code>CSS</code>选择器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt; </span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">items = doc(<span class=\"string\">&#x27;.list&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(items))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(items)</span><br><span class=\"line\">lis = items.find(<span class=\"string\">&#x27;li&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(lis))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>.list</code>参数选取<code>class</code>为<code>list</code>的节点，然后调用<code>find</code>方法，传入<code>CSS</code>选择器，选取其内部的<code>li</code>节点，最后打印输出。可以发现，<code>find</code>方法会将符合条件的所有节点选择出来，结果的类型是<code>pyquery</code>类型。</p>\n<p><code>find</code>的查找范围是节点的所有子孙节点，而如果我们只想查找子节点，那可以用<code>children</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = items.children()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(lis))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要筛选所有子节点中符合条件的节点，比如想筛选出子节点中<code>class</code>为<code>active</code>的节点，可以向<code>children</code>方法传入<code>CSS</code>选择器<code>.active</code>，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = items.children(<span class=\"string\">&#x27;.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出的结果做了筛选，留下了<code>class</code>为<code>active</code>的节点。</p>\n<h3 id=\"父节点\"><a href=\"#父节点\" class=\"headerlink\" title=\"父节点\"></a>父节点</h3><p>可以用<code>parent</code>方法获取某个节点的父节点：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">items = doc(<span class=\"string\">&#x27;.list&#x27;</span>)</span><br><span class=\"line\">container = items.parent()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(container))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(container)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>用<code>.list</code>选取<code>class</code>为<code>list</code>的节点，然后调用<code>parent</code>方法得到其父节点，其类型依然是<code>pyquery</code>类型。这里的父节点是该节点的直接父节点，也就是说，它不会再去查找父节点的父节点，即祖先节点。</p>\n<p>如果你想获取某个祖先节点，该怎么办呢？可以用<code>parents</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">items = doc(<span class=\"string\">&#x27;.list&#x27;</span>)</span><br><span class=\"line\">container = items.parents()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(container))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(container)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">div</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">wrap</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">div</span>&gt;&lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果有两个：一个是<code>class</code>为<code>wrap</code>的节点，一个是<code>id</code>为<code>container</code>的节点。也就是说，使用<code>parents</code>方法会返回所有的祖先节点。</p>\n<p>要筛选某个祖先节点的话，可以向<code>parents</code>方法传入<code>CSS</code>选择器，这样就会返回祖先节点中符合<code>CSS</code>选择器的节点：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent = items.parents(<span class=\"string\">&#x27;.wrap&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(parent)</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">wrap</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">div</span> <span class=\"title\">id</span>=&quot;<span class=\"title\">container</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">ul</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">list</span>&quot;&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;/<span class=\"title\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果少了一个节点，只保留了<code>class</code>为<code>wrap</code>的节点。</p>\n<h3 id=\"兄弟节点\"><a href=\"#兄弟节点\" class=\"headerlink\" title=\"兄弟节点\"></a>兄弟节点</h3><p>要获取兄弟节点，可以使用<code>siblings</code>方法。这里还是以上面的<code>HTML</code>代码为例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.list .item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.siblings())</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">            &lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>先选择<code>class</code>为<code>list</code>的节点，内部<code>class</code>为<code>item-0</code>和<code>active</code>的节点，也就是第3个<code>li</code>节点。很明显，它的兄弟节点有4个，那就是第<code>1</code>、<code>2</code>、<code>4</code>、<code>5 </code>个<code>li</code>节点。结果显示的正是4个兄弟节点。</p>\n<p>筛选某个兄弟节点，可以用<code>siblings</code>方法传入<code>CSS</code>选择器，这样就会从所有兄弟节点中挑选出符合条件的节点了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.list .item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.siblings(<span class=\"string\">&#x27;.active&#x27;</span>)) </span><br></pre></td></tr></table></figure>\n\n<p>筛选<code>class</code>为<code>active</code>的节点，从刚才的结果中可以观察到，<code>class</code>为<code>active</code>兄弟节点的是第4个<code>li</code>节点，所以结果应该是1个。运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p><code>pyquery</code>的选择结果既可能是多个节点，也可能是单个节点，类型都是<code>pyquery</code>类型，并没有返回列表。对于单个节点来说，可以直接打印输出，也可以直接转成字符串：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>(li))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于有多个节点的结果，我们就需要用遍历来获取了。例如，如果要把每一个<code>li</code>节点进行遍历，需要调用<code>items</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">lis = doc(<span class=\"string\">&#x27;li&#x27;</span>).items()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(lis))</span><br><span class=\"line\"><span class=\"keyword\">for</span> li <span class=\"keyword\">in</span> lis:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(li, <span class=\"built_in\">type</span>(li))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">generator</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;<span class=\"title\">first</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link2</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">second</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-1 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link4</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fourth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">             &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link5</span>.<span class=\"title\">html</span>&quot;&gt;<span class=\"title\">fifth</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">         &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>items</code>方法后，会得到一个生成器，遍历一下，就可以逐个得到<code>li</code>节点对象了，它的类型也是<code>pyquery</code>类型。每个<code>li</code>节点还可以调用前面所说的方法进行选择，比如继续查询子节点，寻找某个祖先节点等。</p>\n<h2 id=\"获取信息\"><a href=\"#获取信息\" class=\"headerlink\" title=\"获取信息\"></a>获取信息</h2><p>提取到节点之后，最终目的是提取节点包含的信息。比较重要的信息有两类，一是获取属性，二是获取文本。</p>\n<h3 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h3><p>提取到某个<code>pyquery</code>类型的节点后，就可以调用<code>attr</code>方法来获取属性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">a = doc(<span class=\"string\">&#x27;.item-0.active a&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a, <span class=\"built_in\">type</span>(a))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.attr(<span class=\"string\">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;link3.html&quot;</span>&gt;&lt;span <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt; &lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">pyquery</span>.<span class=\"title\">pyquery</span>.<span class=\"title\">PyQuery</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">link3</span>.<span class=\"title\">html</span></span></span><br></pre></td></tr></table></figure>\n\n<p>首先选中<code>class</code>为<code>item-0</code>和<code>active</code>的<code>li</code>节点内的<code>a</code>节点，它的类型是<code>pyquery</code>类型。然后调用<code>attr</code>方法。在这个方法中传入属性的名称，就可以得到属性值了。此外，也可以通过调用<code>attr</code>属性来获取属性值，用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(a.attr.href)</span><br></pre></td></tr></table></figure>\n\n<p>结果：<code>link3.html</code>，这两种方法的结果完全一样。</p>\n<h3 id=\"获取文本\"><a href=\"#获取文本\" class=\"headerlink\" title=\"获取文本\"></a>获取文本</h3><p>获取节点之后的另一个主要操作就是获取其内部文本了，此时可以调用<code>text</code>方法来实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">a = doc(<span class=\"string\">&#x27;.item-0.active a&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.text())</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;link3.html&quot;</span>&gt;&lt;span <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">third</span> <span class=\"title\">item</span></span></span><br></pre></td></tr></table></figure>\n\n<p>首先选中一个<code>a</code>节点，然后调用<code>text</code>方法，就可以获取其内部的文本信息了。<code>text</code>会忽略节点内部包含的所有<code>HTML</code>，只返回纯文字内容。</p>\n<p>如果想要获取这个节点内部的<code>HTML</code>文本，就要用<code>html</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.html())</span><br><span class=\"line\">``</span><br><span class=\"line\">这里我们选中第<span class=\"number\">3</span>个`li`节点，然后调用`html`方法，它返回的结果应该是`li`节点内的所有`HTML`文本。运行结果如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```python</span><br><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们选中的结果是多个节点，<code>text</code>或<code>html</code>方法会返回什么内容？我们用实例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.html())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li.text())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(li.text()))</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first item</span><br><span class=\"line\">first item second item third item fourth item fifth item</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>html</code>方法返回的是第1个<code>li</code>节点的内部<code>HTML</code>文本，而<code>text</code>则返回了所有的<code>li</code>节点内部的纯文本，中间用一个空格分割开，即返回结果是一个字符串。</p>\n<h2 id=\"节点操作\"><a href=\"#节点操作\" class=\"headerlink\" title=\"节点操作\"></a>节点操作</h2><p><code>pyquery</code>提供了一系列方法来对节点进行动态修改，比如为某个节点添加一个<code>class</code>，移除某个节点等，这些操作有时会为提取信息带来极大的便利。<br>由于节点操作的方法太多，下面举几个典型的例子来说明它的用法。</p>\n<h3 id=\"addClass和removeClass\"><a href=\"#addClass和removeClass\" class=\"headerlink\" title=\"addClass和removeClass\"></a>addClass和removeClass</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.remove_class(<span class=\"string\">&#x27;active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.add_class(<span class=\"string\">&#x27;active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br></pre></td></tr></table></figure>\n\n<p>首先选中第3个<code>li</code>节点，然后调用<code>removeClass</code>方法，将<code>li</code>节点的<code>active</code>这<code>class</code>移除，第2步调用<code>addClass</code>方法，将<code>class</code>添加回来。每执行一次操作，就打印输出当前<code>li</code>节点的内容。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>一共输出了3次。第2次输出时，<code>li</code>节点的<code>active</code>这个<code>class</code>被移除了，第3次<code>class</code>又添加回来了。<code>addClass</code>和<code>removeClass</code>方法可以动态改变节点的<code>class</code>属性。</p>\n<h3 id=\"attr、text、html\"><a href=\"#attr、text、html\" class=\"headerlink\" title=\"attr、text、html\"></a>attr、text、html</h3><p>除了操作<code>class</code>这个属性外，也可以用<code>attr</code>方法对属性进行操作。此外，还可以用<code>text</code>和<code>html</code>方法来改变节点内部的内容。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\"></span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;.item-0.active&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.attr(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.text(<span class=\"string\">&#x27;changed item&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li.html(<span class=\"string\">&#x27;&lt;span&gt;changed item&lt;/span&gt;&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br></pre></td></tr></table></figure>\n\n<p>首先选中<code>li</code>节点，然后调用<code>attr</code>方法来修改属性。该方法的第1个参数为属性名，第2个参数为属性值。最后调用<code>text</code>和<code>html</code>方法来改变节点内部的内容。3次操作后，分别打印输出当前的<code>li</code>节点。 运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li <span class=\"class\"><span class=\"keyword\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot; <span class=\"title\">name</span>=&quot;<span class=\"title\">link</span>&quot;&gt;&lt;<span class=\"title\">a</span> <span class=\"title\">href</span>=&quot;<span class=\"title\">link3</span>.<span class=\"title\">html</span>&quot;&gt;&lt;<span class=\"title\">span</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">bold</span>&quot;&gt;<span class=\"title\">third</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">a</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot; <span class=\"title\">name</span>=&quot;<span class=\"title\">link</span>&quot;&gt;<span class=\"title\">changed</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">li</span> <span class=\"title\">class</span>=&quot;<span class=\"title\">item</span>-0 <span class=\"title\">active</span>&quot; <span class=\"title\">name</span>=&quot;<span class=\"title\">link</span>&quot;&gt;&lt;<span class=\"title\">span</span>&gt;<span class=\"title\">changed</span> <span class=\"title\">item</span>&lt;/<span class=\"title\">span</span>&gt;&lt;/<span class=\"title\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>attr</code>方法后，<code>li</code>节点多了一个原本不存在的属性<code>name</code>，其值为<code>link</code>。接着调用<code>text</code>方法传入文本，<code>li</code>节点内部的文本全被改为传入的字符串文本。最后，调用<code>html</code>方法传入<code>HTML</code>文本，<code>li</code>节点内部又变为传入的<code>HTML</code>文本了。</p>\n<p>使用<code>attr</code>方法时如果只传入第1个参数的属性名，则是获取这个属性值；如果传入第2个参数，可以用来修改属性值。使用<code>text</code>和<code>html</code>方法时如果不传参数，则是获取节点内纯文本和<code>HTML</code>文本，如果传入参数，则进行赋值。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><p><code>remove</code>方法就是移除，它有时会为信息的提取带来非常大的便利。下面有一段 HTML文本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    hello, world</span></span><br><span class=\"line\"><span class=\"string\">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"></span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">wrap = doc(<span class=\"string\">&#x27;.wrap&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(wrap.text())</span><br></pre></td></tr></table></figure>\n\n<p>想提取<code>“Hello, World”</code>这个字符串，该怎样操作呢？</p>\n<p>这里先直接尝试提取<code>class</code>为<code>wrap</code>的节点的内容，看看是不是我们想要的。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, World This <span class=\"keyword\">is</span> a paragraph.</span><br></pre></td></tr></table></figure>\n\n<p>这个结果还包含了内部的<code>p</code>节点的内容，也就是说<code>text</code>把所有的纯文本全提取出来了。</p>\n<p>如果想去掉<code>p</code>节点内部的文本，可以选择再把<code>p</code>节点内的文本提取一遍，然后从整个结果中移除这个子串，但这个做法明显比较烦琐。</p>\n<p>这时<code>remove</code>方法就可以派上用场了，可以接着这么做：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrap.find(<span class=\"string\">&#x27;p&#x27;</span>).remove()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(wrap.text())</span><br></pre></td></tr></table></figure>\n\n<p>首先选中<code>p</code>节点，然后调用<code>remove</code>方法将其移除，这时<code>wrap</code>内部就只剩下<code>“Hello, World”</code>这句话了，最后利用<code>text</code>方法提取即可。</p>\n<p>其实还有很多其他节点操作的方法，比如<code>append</code>、<code>empty</code>和<code>prepend</code>等方法，详细的用法可以参考官方文档：<a href=\"http://pyquery.readthedocs.io/en/latest/api.html\">http://pyquery.readthedocs.io/en/latest/api.html</a>。</p>\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><p><code>CSS</code>选择器之所以强大，还有一个很重要的原因，那就是它支持多种多样的伪类选择器，例如选择第一个节点、最后一个节点、奇偶数节点、包含某一文本的节点等。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&lt;div class=&quot;wrap&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;container&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\">doc = pq(html)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:first-child&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:last-child&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:nth-child(2)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:gt(2)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:nth-child(2n)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br><span class=\"line\">li = doc(<span class=\"string\">&#x27;li:contains(second)&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(li)</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中使用了<code>CSS3</code>的伪类选择器，依次选择了第1个<code>li</code>节点、最后一个<code>li</code>节点、第2个<code>li</code>节点、第3个<code>li</code>之后的<code>li</code>节点、偶数位置的<code>li</code>节点、包含<code>second</code>文本的<code>li</code>节点。</p>\n"},{"title":"Selenium的基本使用","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-25T13:15:51.000Z","pic":null,"_content":"\n在很多情况下，`Ajax`请求的接口通常会包含加密的参数，如`token`、`sign`等，如：[https://dynamic2.scrape.cuiqingcai.com/](https://dynamic2.scrape.cuiqingcai.com/)，它的`Ajax`接口是包含一个`token`参数的，如图所示。\n\n![](Screenshot_5.webp)\n\n由于接口的请求加上了`token`参数，如果不深入分析并找到`token`的构造逻辑，是难以直接模拟这些`Ajax`请求的。\n\n`Selenium`是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面源代码，做到可见即可爬。对于一些使用`JavaScript`动态渲染的页面来说，此种抓取方式非常有效。\n\n## 准备工作\n\n确保已经正确安装好了`Chrome`浏览器并配置好了`ChromeDriver`。另外，还需要正确安装好`Python`的`Selenium`库。\n\n### Selenium安装\n\n```python\npip3 install selenium\n```\n\n### chrome driver安装\n\n查看安装的浏览器版本，在`chrome`搜索栏输入`chrome://version/`，会显示带当前浏览器的版本信息。\n\n![](Screenshot_1.webp)\n\n在[https://npm.taobao.org/mirrors/chromedriver/](https://npm.taobao.org/mirrors/chromedriver/)下载对应版本的`chrome driver`，一定要对应，否则不能使用。\n\n![](Screenshot_2.webp)\n\n下载到本地后，将`chromedriver.exe`分别拷贝到`chrome.exe`和`python`安装路径下。\n\n![](Screenshot_3.webp)\n\n![](Screenshot_4.webp)\n\n以上，安装就完成了！\n\n## 基本使用\n\n首先来看一下`Selenium`有一些怎样的功能。示例如下：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait\n\nbrowser = webdriver.Chrome()\ntry:\n    browser.get('https://www.baidu.com')\n    input = browser.find_element_by_id('kw')\n    input.send_keys('Python')\n    input.send_keys(Keys.ENTER)\n    wait = WebDriverWait(browser, 10)\n    wait.until(EC.presence_of_element_located((By.ID, 'content_left')))\n    print(browser.current_url)\n    print(browser.get_cookies())\n    print(browser.page_source)\nfinally:\n    browser.close()\n```\n\n运行代码后会自动弹出一个`Chrome`浏览器，浏览器会跳转到百度，然后在搜索框中输入`Python`，接着跳转到搜索结果页，如图所示。\n\n![](Screenshot_6.webp)\n\n此时在控制台的输出结果如下：\n\n```shell\nhref=\"http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_\" target=\"_blank\">你都用 <em>Python</em> 来做什么? - 知乎</a></h3><div class=\"c-row c-gap-top-small\"><div class=\"general_image_pic c-span3\" style=\"position:relative;top:2px;\"><a class=\"c-img c-img3 c-img-radius-large\" style=\"height:85px\" href=\"http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_\" target=\"_blank\"><img class=\"c-img c-img3 c-img-radius-large\" src=\"https://dss1.bdstatic.com/6OF1bjeh1BF3odCf/it/u=958012630,1445793633&amp;fm=218&amp;app=92&amp;f=JPEG?w=121&amp;h=75&amp;s=44A638725CB7469C82F4FFF40200D025\" style=\"height:85px;\"><span class=\"c-img-border c-img-radius-large\"></span></a></div><div class=\"c-span9 c-span-last\"><div class=\"c-abstract\"><span class=\" newTimeFactor_before_abs c-color-gray2 m\">2019年10月17日&nbsp;</span>所有项目的代码和数据在Github:interesting-<em>python</em> 如果你也想用<em>Python</em>获取数据,进行有趣的 \n数据分析,Alfred数据室应众多读者要求出品的《实战玩转<em>python</em>爬虫》课程将会是你的好帮手...</div><style>.user-avatar {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n        justify-content: flex-start;\n}</style><div class=\"f13 c-gap-top-xsmall se_st_footer user-avatar\"><a target=\"_blank\" href=\"http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_\" class=\"c-showurl c-color-gray\" style=\"text-decoration:none;position:relative;\"><div class=\"c-img c-img-circle c-gap-right-xsmall\" style=\"display: inline-block;width: 16px;height: 16px;position: relative;top: 3px;vertical-align:top;\"><span class=\"c-img-border c-img-source-border c-img-radius-large\"></span><img src=\"https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=493147230,3096476255&amp;fm=195&amp;app=88&amp;f=JPEG?w=200&amp;h=200\"></div>知乎</a><div class=\"c-tools c-gap-left\" id=\"tools_9637258987948217910_8\" data-tools=\"{&quot;title&quot;:&quot;你都用 Python 来做什么? - 知乎&quot;,&quot;url&quot;:&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot;}\"><i class=\"c-icon f13\"></i></div><span class=\"c-icons-outer\"><span class=\"c-icons-inner\"></span></span><style>.snapshoot, .snapshoot:visited {\n        color: #9195A3!important;\n    }\n    .snapshoot:active, .snapshoot:hover {\n        color: #626675!important;\n    }</style><a data-click=\"{'rsv_snapshot':'1'}\" href=\"http://cache.baiducontent.com/c?m=JgFgeas2iHrh6pppvD-MHkvHPj9DsOz-wd718JIlv_IJy7d0KdQ2HvVIYznaRWwGrKHLEtVbqjR4uoZg6X_h4g62yFf5FgBVDUBkRfcWrOG&amp;p=8b2a9715d9c647f904aec5344f57&amp;newp=8b2a9729c5df1bb508e291784f4a92695d0fc20e3ad0d001298ffe0cc4241a1a1a3aecbf2c261600d7c279650aab4a5feff336743d0034f1f689df08d2ecce7e439b3b6e6a&amp;s=45c48cce2e2d7fbd&amp;user=baidu&amp;fm=sc&amp;query=Python&amp;qid=dc4c1a0300139b42&amp;p1=8\" target=\"_blank\" class=\"m c-gap-left c-color-gray kuaizhao snapshoot\">百度快照</a></div></div></div></div>\n```\n\n源代码过长，在此省略。可以看到，当前得到的`URL`、`Cookies`和源代码都是浏览器中的真实内容。所以说，如果用`Selenium`来驱动浏览器加载网页的话，就可以直接拿到`JavaScript`渲染的结果了，不用担心使用的是什么加密系统。\n\n了解一下`Selenium`的用法。\n\n## 声明浏览器对象\n\n`Selenium`支持非常多的浏览器，如`Chrome`、`Firefox`、`Edge`等，还有`Android`、`BlackBerry`等手机端的浏览器。\n\n可以用如下方式进行初始化：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome()\nbrowser = webdriver.Firefox()\nbrowser = webdriver.Edge()\nbrowser = webdriver.Safari()\n```\n\n这样就完成了浏览器对象的初始化并将其赋值为`browser`对象。接下来，要做的就是调用`browser`对象，让其执行各个动作以模拟浏览器操作。\n\n## 访问页面\n\n可以用`get`方法请求页面，只需要把参数传入连接`URL`即可。比如，这里用`get`方法访问淘宝，代码如下：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.taobao.com')\nprint(browser.page_source)\nbrowser.close()\n```\n\n运行后会弹出`Chrome`浏览器并且自动访问淘宝，然后控制台会输出淘宝页面的源代码，随后浏览器关闭。\n\n## 查找节点\n\n`Selenium`可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。举个例子，当想要完成向某个输入框输入文字的操作时，首先需要知道这个输入框在哪，而 `Selenium`提供了一系列查找节点的方法，可以用这些方法来获取想要的节点，以便执行下一步动作或者提取信息。\n\n### 单个节点\n\n想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码。\n\n可以发现，它的`id`是`q`，`name`也是`q`，此外还有许多其他属性。此时就可以用多种方式获取它了。比如，`find_element_by_name`代表根据`name`值获取，`find_element_by_id`则是根据`id`获取，另外，还有根据`XPath`、`CSS`选择器等获取的方式。\n\n这里使用`3`种方式获取输入框，分别是根据`id`、`CSS`选择器和`XPath`获取，它们返回的结果完全一致。运行结果如下：\n\n```python\n<selenium.webdriver.remote.webelement.WebElement (session=\"fbca625cd8bb4eb98ae76bb68a23bd4f\",element=\"de630823-02d3-409a-ba19-4e892a0fad15\")> \n<selenium.webdriver.remote.webelement.WebElement (session=\"fbca625cd8bb4eb98ae76bb68a23bd4f\", element=\"de630823-02d3-409a-ba19-4e892a0fad15\")> \n[<selenium.webdriver.remote.webelement.WebElement (session=\"fbca625cd8bb4eb98ae76bb68a23bd4f\", element=\"de630823-02d3-409a-ba19-4e892a0fad15\")>]\n```\n\n这3个节点的类型是一致的，都是`WebElement`。\n\n这里列出所有获取单个节点的方法：\n\n```python\nfind_element_by_id \nfind_element_by_name \nfind_element_by_xpath \nfind_element_by_link_text \nfind_element_by_partial_link_text \nfind_element_by_tag_name \nfind_element_by_class_name \nfind_element_by_css_selector\n```\n\n### 多个节点\n\n多如果在网页中只查找一个目标，那么完全可以用`find_element`方法。但如果有多个节点需要查找，再用`find_element`方法，就只能得到第1个节点了。如果要查找所有满足条件的节点，需要用`find_elements`这样的 方法。注意，在这个方法的名称中， 注`element`多了一个多`s`，注意区分。\n\n举个例子，假如要查找淘宝左侧导航条的所有条目，就可以这样来实现：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.taobao.com')\nlis = browser.find_elements_by_css_selector('.service-bd li')\nprint(lis)\nbrowser.close()\n```\n\n结果如下：\n\n```python\n[<selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"01e78303-6103-4f1a-96dc-0386a755a9f4\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"7a4e764e-9a05-4dad-9188-636512591835\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"16219266-ff57-4f42-95ab-4b8dbb4b811a\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"4f23598b-3ca6-4b20-9192-3e06e98984df\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"d837e630-e546-4f8b-babd-e3fdc539d2a6\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"1da195c9-d959-4d47-b729-21d8eac2756f\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"175c2217-dbe6-4d27-997f-58fbe46cbf1a\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"4747359f-d93c-4a7a-976e-501087d96e5f\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"2537bb34-3a26-4ccd-8f53-4ebbef5c70b2\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"04210bc7-ebba-44ef-8757-d88dfd0d023f\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"7bd1b6e4-31e5-4120-8017-afc59ca56f48\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"930a7b6c-26ff-468c-896e-6204b0555747\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"81305b6e-0893-46d2-b7a7-89a85c00132c\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"763237aa-5925-426d-9a76-90b3567870eb\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"60ca3595-3f74-4f1d-9224-7beb9e381a4b\")>]\n```\n\n得到的内容变成了列表类型，列表中的每个节点都是`WebElement`类型。\n\n也就是说，如果用`find_element`方法，只能获取匹配的第一个节点，结果是`WebElement`类型。如果用`find_elements`方法，则结果是列表类型，列表中的每个节点是`WebElement`类型。\n\n这里列出所有获取多个节点的方法：\n\n```python\nfind_elements_by_id\nfind_elements_by_name\nfind_elements_by_xpath\nfind_elements_by_link_text\nfind_elements_by_partial_link_text\nfind_elements_by_tag_name\nfind_elements_by_class_name\nfind_elements_by_css_selector\n```\n\n当然，也可以直接用`find_elements`方法来选择，这时可以这样写：\n\n```python\nlis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li') \n```\n\n结果是完全一致的。\n\n### 节点交互\n\n`Selenium`可以驱动浏览器来执行一些操作，或者说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用`send_keys`方法，清空文字时用`clear`方法，点击按钮时用`click`方法。示例如下：\n\n```python\nimport time\n\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.taobao.com')\ninput = browser.find_element_by_id('q')\ninput.send_keys('apple')\ntime.sleep(1)\ninput.clear()\ninput.send_keys('小米')\nbutton = browser.find_element_by_class_name('btn-search')\nbutton.click()\n```\n\n这里首先驱动浏览器打开淘宝，用`find_element_by_id`方法获取输入框，然后用`send_keys`方法输入`iPhone`文字，等待一秒后用`clear`方法清空输入框，接着再次调用`send_keys`方法输入`iPad`文字，之后再用`find_element_by_class_name`方法获取搜索按钮，最后调用`click`方法完成搜索动作。\n\n### 动作链\n\n在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，调用它的输入文字和清空文字方法；对于按钮，调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等，这些动作用另一种方式来执行，那就是动作链。\n\n比如，现在要实现一个节点的拖拽操作，将某个节点从一处拖拽到另外一处，可以这样实现：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver import ActionChains\n\nbrowser = webdriver.Chrome()\nurl = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'\n\nbrowser.get(url)\nbrowser.switch_to.frame('iframeResult')\nsource = browser.find_element_by_css_selector(\"#draggable\")\ntarget = browser.find_element_by_css_selector(\"#droppable\")\nactions = ActionChains(browser)\nactions.drag_and_drop(source, target)\nactions.perform()\n```\n\n打开网页中的一个拖拽实例，依次选中要拖拽的节点和拖拽到的目标节点，接着声明`ActionChains`对象并将其赋值为`actions`变量，然后通过调用`actions`变量的`drag_and_drop`方法，再调用`perform`方法执行动作，此时就完成了拖拽操作，如图所示：\n\n![](Screenshot_7.webp)\n\n拖拽前页面：\n\n![](Screenshot_8.webp)\n\n### 执行执`JavaScript`\n\n`SeleniumAPI`并没有提供实现某些操作的方法，比如，下拉进度条。但它可以直接模拟运行`JavaScript`，此时使用`execute_script`方法即可实现，代码如下：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.zhihu.com/explore')\nbrowser.execute_script('window.scrollTo(0, document.body.scrollHeight)')\nbrowser.execute_script('alert(\" To Bottom)')\n```\n\n这里利用`execute_script`方法将进度条下拉到最底部，然后弹出`alert`提示框。\n\n有了这个方法，基本上`API`没有提供的所有功能都可以用执行`JavaScript`的方式来实现了。\n\n## 获取节点信息\n\n`Selenium`已经提供了选择节点的方法，并且返回的是`WebElement`类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，就可以不用通过解析源代码来提取信息了，非常方便。\n\n### 获取属性\n\n可以使用`get_attribute`方法来获取节点的属性，但是前提是得先选中这个节点，示例如下：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nurl = 'https://www.baidu.com/'\nbrowser.get(url)\nlogo = browser.find_element_by_class_name('index-logo-src')\nprint(logo)\nprint(logo.get_attribute('src'))\n```\n\n运行之后，程序便会驱动浏览器打开该页面，然后获取`class`为`logo-image`的节点，最后打印出它的`src`属性。\n\n返回结果：\n\n```python\n<selenium.webdriver.remote.webelement.WebElement (session=\"c90d6158ff9e3e6ba88d5f9b9358a358\", element=\"c99170cd-b0c1-44b6-a0a0-f4ccf1105e91\")>\nhttps://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\n```\n\n通过`get_attribute`方法，只需要传入想要获取的属性名，就可以得到它的值了。\n\n### 获取文本值\n\n每个`WebElement`节点都有`text`属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于`pyquery`的`text`方法，示例如下：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nurl = 'https://holychan.ltd/archives/'\nbrowser.get(url)\ntitle = browser.find_element_by_class_name('title-h2')\nprint(title)\nprint(title.text)\n```\n\n结果如下：\n\n```python\n<selenium.webdriver.remote.webelement.WebElement (session=\"79f97c0aa935723e276438a5fff2610c\", element=\"b86ec344-cb00-4538-b9e9-8959a076bc75\")>\n文章归档\n```\n\n### 获取获ID、位置、标签名、大小\n\n`WebElement`节点还有一些其他属性，比如`id`属性可以获取节点`id`，`location`属性可以获取该节点在页面中的相对位置，`tag_name`属性可以获取标签名称，`size`属性可以获取节点的大小，也就是宽高，这些 属性有时候还是很有用的。示例如下：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome() \nurl = 'https://dynamic2.scrape.cuiqingcai.com/' \nbrowser.get(url) \ninput = browser.find_element_by_class_name('logo-title') \nprint(input.id) \nprint(input.location) \nprint(input.tag_name) \nprint(input.size) \n```\n\n这里首先获得`class`为`logo-title`这个节点，然后调用其`id`、`location`、`tag_name`、`size`属性来获取对应的属性值。\n\n## 切换Frame\n\n网页中有一种节点叫作`iframe`，也就是子`Frame`，相当于页面的子页面，它的结构和外部网页的结构完全一致。`Selenium`打开页面后，默认是在父级`Frame`里面操作，而此时如果页面中还有子`Frame`，`Selenium`是不能获取到子`Frame`里面的节点的。这时就需要使用`switch_to.frame`方法来切换`Frame`。示例如下：\n\n```python\nfrom selenium import webdriver\nfrom selenium.common.exceptions import NoSuchElementException\nbrowser = webdriver.Chrome()\nurl = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'\nbrowser.get(url)\nbrowser.switch_to('iframeResult')\ntry:\n    logo = browser.find_element_by_class_name('logo')\nexcept NoSuchElementException:\n    print('No logo found')\nbrowser.switch_to.parent_frame()\nlogo = browser.find_element_by_class_name('logo')\nprint(logo)\nprint(logo.text)\n```\n\n控制台输出：\n\n```python\nNo logo found\n<selenium.webdriver.remote.webelement.WebElement (session=\"ce74c2d83e0aca64c9ef8c4540b2fe16\", element=\"1d2c3c25-bd01-4b9a-b11b-16b8534bf6c2\")>\nRUNOOB.COM\n```\n\n首先通过`switch_to.frame`方法切换到子`Frame`里面，然后尝试获取子`Frame`里的`logo`节点（这是不能找到的），如果找不到的话，就会抛出`NoSuchElementException`异常，异常被捕捉之后，就会输出`No logo found`。接下来，我们需要重新切换回父级`Frame`，然后再次重新获取节点，发现此时可以成功获取了。\n\n所以，当页面中包含子`Frame`时，如果想获取子`Frame`中的节点，需要先调用`switch_to.frame`方法切换到对应的`Frame`，然后再进行操作。\n\n## 延时等待\n\n在`Selenium`中，`get`方法会在网页框架加载结束后结束执行，此时如果获取`page_source`，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的`Ajax`请求，在网页源代码中也不一定能成功获取 \\到。所以，这里需要延时等待一定时间，确保节点已经加载出来。\n\n这里等待的方式有两种：一种是隐式等待，一种是显式等待。\n\n### 隐式等待 \n\n当使用隐式等待执行测试的时候，如果`Selenium`没有在`DOM`中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，隐式等待可以在我们查找节点而节点并没有立即出现的时候， 等待一段时间再查找`DOM`，默认的时间是`0`。示例如下：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nbrowser.implicitly_wait(10)\nbrowser.get('https://dynamic2. scrape.cuiqingcai.com/') \ninput = browser.find_element_by_class_name('logo-image') \nprint(input)\n```\n\n","source":"_posts/Selenium的基本使用.md","raw":"---\ntitle: Selenium的基本使用\ntags:\n  - selenium\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-25 21:15:51\ncategories: 爬虫\npic:\n---\n\n在很多情况下，`Ajax`请求的接口通常会包含加密的参数，如`token`、`sign`等，如：[https://dynamic2.scrape.cuiqingcai.com/](https://dynamic2.scrape.cuiqingcai.com/)，它的`Ajax`接口是包含一个`token`参数的，如图所示。\n\n![](Screenshot_5.webp)\n\n由于接口的请求加上了`token`参数，如果不深入分析并找到`token`的构造逻辑，是难以直接模拟这些`Ajax`请求的。\n\n`Selenium`是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面源代码，做到可见即可爬。对于一些使用`JavaScript`动态渲染的页面来说，此种抓取方式非常有效。\n\n## 准备工作\n\n确保已经正确安装好了`Chrome`浏览器并配置好了`ChromeDriver`。另外，还需要正确安装好`Python`的`Selenium`库。\n\n### Selenium安装\n\n```python\npip3 install selenium\n```\n\n### chrome driver安装\n\n查看安装的浏览器版本，在`chrome`搜索栏输入`chrome://version/`，会显示带当前浏览器的版本信息。\n\n![](Screenshot_1.webp)\n\n在[https://npm.taobao.org/mirrors/chromedriver/](https://npm.taobao.org/mirrors/chromedriver/)下载对应版本的`chrome driver`，一定要对应，否则不能使用。\n\n![](Screenshot_2.webp)\n\n下载到本地后，将`chromedriver.exe`分别拷贝到`chrome.exe`和`python`安装路径下。\n\n![](Screenshot_3.webp)\n\n![](Screenshot_4.webp)\n\n以上，安装就完成了！\n\n## 基本使用\n\n首先来看一下`Selenium`有一些怎样的功能。示例如下：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait\n\nbrowser = webdriver.Chrome()\ntry:\n    browser.get('https://www.baidu.com')\n    input = browser.find_element_by_id('kw')\n    input.send_keys('Python')\n    input.send_keys(Keys.ENTER)\n    wait = WebDriverWait(browser, 10)\n    wait.until(EC.presence_of_element_located((By.ID, 'content_left')))\n    print(browser.current_url)\n    print(browser.get_cookies())\n    print(browser.page_source)\nfinally:\n    browser.close()\n```\n\n运行代码后会自动弹出一个`Chrome`浏览器，浏览器会跳转到百度，然后在搜索框中输入`Python`，接着跳转到搜索结果页，如图所示。\n\n![](Screenshot_6.webp)\n\n此时在控制台的输出结果如下：\n\n```shell\nhref=\"http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_\" target=\"_blank\">你都用 <em>Python</em> 来做什么? - 知乎</a></h3><div class=\"c-row c-gap-top-small\"><div class=\"general_image_pic c-span3\" style=\"position:relative;top:2px;\"><a class=\"c-img c-img3 c-img-radius-large\" style=\"height:85px\" href=\"http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_\" target=\"_blank\"><img class=\"c-img c-img3 c-img-radius-large\" src=\"https://dss1.bdstatic.com/6OF1bjeh1BF3odCf/it/u=958012630,1445793633&amp;fm=218&amp;app=92&amp;f=JPEG?w=121&amp;h=75&amp;s=44A638725CB7469C82F4FFF40200D025\" style=\"height:85px;\"><span class=\"c-img-border c-img-radius-large\"></span></a></div><div class=\"c-span9 c-span-last\"><div class=\"c-abstract\"><span class=\" newTimeFactor_before_abs c-color-gray2 m\">2019年10月17日&nbsp;</span>所有项目的代码和数据在Github:interesting-<em>python</em> 如果你也想用<em>Python</em>获取数据,进行有趣的 \n数据分析,Alfred数据室应众多读者要求出品的《实战玩转<em>python</em>爬虫》课程将会是你的好帮手...</div><style>.user-avatar {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n        justify-content: flex-start;\n}</style><div class=\"f13 c-gap-top-xsmall se_st_footer user-avatar\"><a target=\"_blank\" href=\"http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_\" class=\"c-showurl c-color-gray\" style=\"text-decoration:none;position:relative;\"><div class=\"c-img c-img-circle c-gap-right-xsmall\" style=\"display: inline-block;width: 16px;height: 16px;position: relative;top: 3px;vertical-align:top;\"><span class=\"c-img-border c-img-source-border c-img-radius-large\"></span><img src=\"https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=493147230,3096476255&amp;fm=195&amp;app=88&amp;f=JPEG?w=200&amp;h=200\"></div>知乎</a><div class=\"c-tools c-gap-left\" id=\"tools_9637258987948217910_8\" data-tools=\"{&quot;title&quot;:&quot;你都用 Python 来做什么? - 知乎&quot;,&quot;url&quot;:&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot;}\"><i class=\"c-icon f13\"></i></div><span class=\"c-icons-outer\"><span class=\"c-icons-inner\"></span></span><style>.snapshoot, .snapshoot:visited {\n        color: #9195A3!important;\n    }\n    .snapshoot:active, .snapshoot:hover {\n        color: #626675!important;\n    }</style><a data-click=\"{'rsv_snapshot':'1'}\" href=\"http://cache.baiducontent.com/c?m=JgFgeas2iHrh6pppvD-MHkvHPj9DsOz-wd718JIlv_IJy7d0KdQ2HvVIYznaRWwGrKHLEtVbqjR4uoZg6X_h4g62yFf5FgBVDUBkRfcWrOG&amp;p=8b2a9715d9c647f904aec5344f57&amp;newp=8b2a9729c5df1bb508e291784f4a92695d0fc20e3ad0d001298ffe0cc4241a1a1a3aecbf2c261600d7c279650aab4a5feff336743d0034f1f689df08d2ecce7e439b3b6e6a&amp;s=45c48cce2e2d7fbd&amp;user=baidu&amp;fm=sc&amp;query=Python&amp;qid=dc4c1a0300139b42&amp;p1=8\" target=\"_blank\" class=\"m c-gap-left c-color-gray kuaizhao snapshoot\">百度快照</a></div></div></div></div>\n```\n\n源代码过长，在此省略。可以看到，当前得到的`URL`、`Cookies`和源代码都是浏览器中的真实内容。所以说，如果用`Selenium`来驱动浏览器加载网页的话，就可以直接拿到`JavaScript`渲染的结果了，不用担心使用的是什么加密系统。\n\n了解一下`Selenium`的用法。\n\n## 声明浏览器对象\n\n`Selenium`支持非常多的浏览器，如`Chrome`、`Firefox`、`Edge`等，还有`Android`、`BlackBerry`等手机端的浏览器。\n\n可以用如下方式进行初始化：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome()\nbrowser = webdriver.Firefox()\nbrowser = webdriver.Edge()\nbrowser = webdriver.Safari()\n```\n\n这样就完成了浏览器对象的初始化并将其赋值为`browser`对象。接下来，要做的就是调用`browser`对象，让其执行各个动作以模拟浏览器操作。\n\n## 访问页面\n\n可以用`get`方法请求页面，只需要把参数传入连接`URL`即可。比如，这里用`get`方法访问淘宝，代码如下：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.taobao.com')\nprint(browser.page_source)\nbrowser.close()\n```\n\n运行后会弹出`Chrome`浏览器并且自动访问淘宝，然后控制台会输出淘宝页面的源代码，随后浏览器关闭。\n\n## 查找节点\n\n`Selenium`可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。举个例子，当想要完成向某个输入框输入文字的操作时，首先需要知道这个输入框在哪，而 `Selenium`提供了一系列查找节点的方法，可以用这些方法来获取想要的节点，以便执行下一步动作或者提取信息。\n\n### 单个节点\n\n想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码。\n\n可以发现，它的`id`是`q`，`name`也是`q`，此外还有许多其他属性。此时就可以用多种方式获取它了。比如，`find_element_by_name`代表根据`name`值获取，`find_element_by_id`则是根据`id`获取，另外，还有根据`XPath`、`CSS`选择器等获取的方式。\n\n这里使用`3`种方式获取输入框，分别是根据`id`、`CSS`选择器和`XPath`获取，它们返回的结果完全一致。运行结果如下：\n\n```python\n<selenium.webdriver.remote.webelement.WebElement (session=\"fbca625cd8bb4eb98ae76bb68a23bd4f\",element=\"de630823-02d3-409a-ba19-4e892a0fad15\")> \n<selenium.webdriver.remote.webelement.WebElement (session=\"fbca625cd8bb4eb98ae76bb68a23bd4f\", element=\"de630823-02d3-409a-ba19-4e892a0fad15\")> \n[<selenium.webdriver.remote.webelement.WebElement (session=\"fbca625cd8bb4eb98ae76bb68a23bd4f\", element=\"de630823-02d3-409a-ba19-4e892a0fad15\")>]\n```\n\n这3个节点的类型是一致的，都是`WebElement`。\n\n这里列出所有获取单个节点的方法：\n\n```python\nfind_element_by_id \nfind_element_by_name \nfind_element_by_xpath \nfind_element_by_link_text \nfind_element_by_partial_link_text \nfind_element_by_tag_name \nfind_element_by_class_name \nfind_element_by_css_selector\n```\n\n### 多个节点\n\n多如果在网页中只查找一个目标，那么完全可以用`find_element`方法。但如果有多个节点需要查找，再用`find_element`方法，就只能得到第1个节点了。如果要查找所有满足条件的节点，需要用`find_elements`这样的 方法。注意，在这个方法的名称中， 注`element`多了一个多`s`，注意区分。\n\n举个例子，假如要查找淘宝左侧导航条的所有条目，就可以这样来实现：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.taobao.com')\nlis = browser.find_elements_by_css_selector('.service-bd li')\nprint(lis)\nbrowser.close()\n```\n\n结果如下：\n\n```python\n[<selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"01e78303-6103-4f1a-96dc-0386a755a9f4\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"7a4e764e-9a05-4dad-9188-636512591835\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"16219266-ff57-4f42-95ab-4b8dbb4b811a\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"4f23598b-3ca6-4b20-9192-3e06e98984df\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"d837e630-e546-4f8b-babd-e3fdc539d2a6\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"1da195c9-d959-4d47-b729-21d8eac2756f\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"175c2217-dbe6-4d27-997f-58fbe46cbf1a\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"4747359f-d93c-4a7a-976e-501087d96e5f\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"2537bb34-3a26-4ccd-8f53-4ebbef5c70b2\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"04210bc7-ebba-44ef-8757-d88dfd0d023f\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"7bd1b6e4-31e5-4120-8017-afc59ca56f48\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"930a7b6c-26ff-468c-896e-6204b0555747\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"81305b6e-0893-46d2-b7a7-89a85c00132c\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"763237aa-5925-426d-9a76-90b3567870eb\")>, <selenium.webdriver.remote.webelement.WebElement (session=\"f9550f7bf1204e4d481803cf7a69c736\", element=\"60ca3595-3f74-4f1d-9224-7beb9e381a4b\")>]\n```\n\n得到的内容变成了列表类型，列表中的每个节点都是`WebElement`类型。\n\n也就是说，如果用`find_element`方法，只能获取匹配的第一个节点，结果是`WebElement`类型。如果用`find_elements`方法，则结果是列表类型，列表中的每个节点是`WebElement`类型。\n\n这里列出所有获取多个节点的方法：\n\n```python\nfind_elements_by_id\nfind_elements_by_name\nfind_elements_by_xpath\nfind_elements_by_link_text\nfind_elements_by_partial_link_text\nfind_elements_by_tag_name\nfind_elements_by_class_name\nfind_elements_by_css_selector\n```\n\n当然，也可以直接用`find_elements`方法来选择，这时可以这样写：\n\n```python\nlis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li') \n```\n\n结果是完全一致的。\n\n### 节点交互\n\n`Selenium`可以驱动浏览器来执行一些操作，或者说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用`send_keys`方法，清空文字时用`clear`方法，点击按钮时用`click`方法。示例如下：\n\n```python\nimport time\n\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.taobao.com')\ninput = browser.find_element_by_id('q')\ninput.send_keys('apple')\ntime.sleep(1)\ninput.clear()\ninput.send_keys('小米')\nbutton = browser.find_element_by_class_name('btn-search')\nbutton.click()\n```\n\n这里首先驱动浏览器打开淘宝，用`find_element_by_id`方法获取输入框，然后用`send_keys`方法输入`iPhone`文字，等待一秒后用`clear`方法清空输入框，接着再次调用`send_keys`方法输入`iPad`文字，之后再用`find_element_by_class_name`方法获取搜索按钮，最后调用`click`方法完成搜索动作。\n\n### 动作链\n\n在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，调用它的输入文字和清空文字方法；对于按钮，调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等，这些动作用另一种方式来执行，那就是动作链。\n\n比如，现在要实现一个节点的拖拽操作，将某个节点从一处拖拽到另外一处，可以这样实现：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver import ActionChains\n\nbrowser = webdriver.Chrome()\nurl = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'\n\nbrowser.get(url)\nbrowser.switch_to.frame('iframeResult')\nsource = browser.find_element_by_css_selector(\"#draggable\")\ntarget = browser.find_element_by_css_selector(\"#droppable\")\nactions = ActionChains(browser)\nactions.drag_and_drop(source, target)\nactions.perform()\n```\n\n打开网页中的一个拖拽实例，依次选中要拖拽的节点和拖拽到的目标节点，接着声明`ActionChains`对象并将其赋值为`actions`变量，然后通过调用`actions`变量的`drag_and_drop`方法，再调用`perform`方法执行动作，此时就完成了拖拽操作，如图所示：\n\n![](Screenshot_7.webp)\n\n拖拽前页面：\n\n![](Screenshot_8.webp)\n\n### 执行执`JavaScript`\n\n`SeleniumAPI`并没有提供实现某些操作的方法，比如，下拉进度条。但它可以直接模拟运行`JavaScript`，此时使用`execute_script`方法即可实现，代码如下：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.zhihu.com/explore')\nbrowser.execute_script('window.scrollTo(0, document.body.scrollHeight)')\nbrowser.execute_script('alert(\" To Bottom)')\n```\n\n这里利用`execute_script`方法将进度条下拉到最底部，然后弹出`alert`提示框。\n\n有了这个方法，基本上`API`没有提供的所有功能都可以用执行`JavaScript`的方式来实现了。\n\n## 获取节点信息\n\n`Selenium`已经提供了选择节点的方法，并且返回的是`WebElement`类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，就可以不用通过解析源代码来提取信息了，非常方便。\n\n### 获取属性\n\n可以使用`get_attribute`方法来获取节点的属性，但是前提是得先选中这个节点，示例如下：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nurl = 'https://www.baidu.com/'\nbrowser.get(url)\nlogo = browser.find_element_by_class_name('index-logo-src')\nprint(logo)\nprint(logo.get_attribute('src'))\n```\n\n运行之后，程序便会驱动浏览器打开该页面，然后获取`class`为`logo-image`的节点，最后打印出它的`src`属性。\n\n返回结果：\n\n```python\n<selenium.webdriver.remote.webelement.WebElement (session=\"c90d6158ff9e3e6ba88d5f9b9358a358\", element=\"c99170cd-b0c1-44b6-a0a0-f4ccf1105e91\")>\nhttps://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\n```\n\n通过`get_attribute`方法，只需要传入想要获取的属性名，就可以得到它的值了。\n\n### 获取文本值\n\n每个`WebElement`节点都有`text`属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于`pyquery`的`text`方法，示例如下：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nurl = 'https://holychan.ltd/archives/'\nbrowser.get(url)\ntitle = browser.find_element_by_class_name('title-h2')\nprint(title)\nprint(title.text)\n```\n\n结果如下：\n\n```python\n<selenium.webdriver.remote.webelement.WebElement (session=\"79f97c0aa935723e276438a5fff2610c\", element=\"b86ec344-cb00-4538-b9e9-8959a076bc75\")>\n文章归档\n```\n\n### 获取获ID、位置、标签名、大小\n\n`WebElement`节点还有一些其他属性，比如`id`属性可以获取节点`id`，`location`属性可以获取该节点在页面中的相对位置，`tag_name`属性可以获取标签名称，`size`属性可以获取节点的大小，也就是宽高，这些 属性有时候还是很有用的。示例如下：\n\n```python\nfrom selenium import webdriver\nbrowser = webdriver.Chrome() \nurl = 'https://dynamic2.scrape.cuiqingcai.com/' \nbrowser.get(url) \ninput = browser.find_element_by_class_name('logo-title') \nprint(input.id) \nprint(input.location) \nprint(input.tag_name) \nprint(input.size) \n```\n\n这里首先获得`class`为`logo-title`这个节点，然后调用其`id`、`location`、`tag_name`、`size`属性来获取对应的属性值。\n\n## 切换Frame\n\n网页中有一种节点叫作`iframe`，也就是子`Frame`，相当于页面的子页面，它的结构和外部网页的结构完全一致。`Selenium`打开页面后，默认是在父级`Frame`里面操作，而此时如果页面中还有子`Frame`，`Selenium`是不能获取到子`Frame`里面的节点的。这时就需要使用`switch_to.frame`方法来切换`Frame`。示例如下：\n\n```python\nfrom selenium import webdriver\nfrom selenium.common.exceptions import NoSuchElementException\nbrowser = webdriver.Chrome()\nurl = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'\nbrowser.get(url)\nbrowser.switch_to('iframeResult')\ntry:\n    logo = browser.find_element_by_class_name('logo')\nexcept NoSuchElementException:\n    print('No logo found')\nbrowser.switch_to.parent_frame()\nlogo = browser.find_element_by_class_name('logo')\nprint(logo)\nprint(logo.text)\n```\n\n控制台输出：\n\n```python\nNo logo found\n<selenium.webdriver.remote.webelement.WebElement (session=\"ce74c2d83e0aca64c9ef8c4540b2fe16\", element=\"1d2c3c25-bd01-4b9a-b11b-16b8534bf6c2\")>\nRUNOOB.COM\n```\n\n首先通过`switch_to.frame`方法切换到子`Frame`里面，然后尝试获取子`Frame`里的`logo`节点（这是不能找到的），如果找不到的话，就会抛出`NoSuchElementException`异常，异常被捕捉之后，就会输出`No logo found`。接下来，我们需要重新切换回父级`Frame`，然后再次重新获取节点，发现此时可以成功获取了。\n\n所以，当页面中包含子`Frame`时，如果想获取子`Frame`中的节点，需要先调用`switch_to.frame`方法切换到对应的`Frame`，然后再进行操作。\n\n## 延时等待\n\n在`Selenium`中，`get`方法会在网页框架加载结束后结束执行，此时如果获取`page_source`，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的`Ajax`请求，在网页源代码中也不一定能成功获取 \\到。所以，这里需要延时等待一定时间，确保节点已经加载出来。\n\n这里等待的方式有两种：一种是隐式等待，一种是显式等待。\n\n### 隐式等待 \n\n当使用隐式等待执行测试的时候，如果`Selenium`没有在`DOM`中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，隐式等待可以在我们查找节点而节点并没有立即出现的时候， 等待一段时间再查找`DOM`，默认的时间是`0`。示例如下：\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nbrowser.implicitly_wait(10)\nbrowser.get('https://dynamic2. scrape.cuiqingcai.com/') \ninput = browser.find_element_by_class_name('logo-image') \nprint(input)\n```\n\n","slug":"Selenium的基本使用","published":1,"updated":"2021-06-15T03:24:11.475Z","_id":"ckpapu7kg003jlcxuc53k84x2","layout":"post","photos":[],"link":"","content":"<p>在很多情况下，<code>Ajax</code>请求的接口通常会包含加密的参数，如<code>token</code>、<code>sign</code>等，如：<a href=\"https://dynamic2.scrape.cuiqingcai.com/\">https://dynamic2.scrape.cuiqingcai.com/</a>，它的<code>Ajax</code>接口是包含一个<code>token</code>参数的，如图所示。</p>\n<p><img src=\"Screenshot_5.webp\"></p>\n<p>由于接口的请求加上了<code>token</code>参数，如果不深入分析并找到<code>token</code>的构造逻辑，是难以直接模拟这些<code>Ajax</code>请求的。</p>\n<p><code>Selenium</code>是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面源代码，做到可见即可爬。对于一些使用<code>JavaScript</code>动态渲染的页面来说，此种抓取方式非常有效。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>确保已经正确安装好了<code>Chrome</code>浏览器并配置好了<code>ChromeDriver</code>。另外，还需要正确安装好<code>Python</code>的<code>Selenium</code>库。</p>\n<h3 id=\"Selenium安装\"><a href=\"#Selenium安装\" class=\"headerlink\" title=\"Selenium安装\"></a>Selenium安装</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install selenium</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"chrome-driver安装\"><a href=\"#chrome-driver安装\" class=\"headerlink\" title=\"chrome driver安装\"></a>chrome driver安装</h3><p>查看安装的浏览器版本，在<code>chrome</code>搜索栏输入<code>chrome://version/</code>，会显示带当前浏览器的版本信息。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>在<a href=\"https://npm.taobao.org/mirrors/chromedriver/\">https://npm.taobao.org/mirrors/chromedriver/</a>下载对应版本的<code>chrome driver</code>，一定要对应，否则不能使用。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>下载到本地后，将<code>chromedriver.exe</code>分别拷贝到<code>chrome.exe</code>和<code>python</code>安装路径下。</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p><img src=\"Screenshot_4.webp\"></p>\n<p>以上，安装就完成了！</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>首先来看一下<code>Selenium</code>有一些怎样的功能。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.keys <span class=\"keyword\">import</span> Keys</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.wait <span class=\"keyword\">import</span> WebDriverWait</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    browser.get(<span class=\"string\">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">input</span> = browser.find_element_by_id(<span class=\"string\">&#x27;kw&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">input</span>.send_keys(<span class=\"string\">&#x27;Python&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">input</span>.send_keys(Keys.ENTER)</span><br><span class=\"line\">    wait = WebDriverWait(browser, <span class=\"number\">10</span>)</span><br><span class=\"line\">    wait.until(EC.presence_of_element_located((By.ID, <span class=\"string\">&#x27;content_left&#x27;</span>)))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(browser.current_url)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(browser.get_cookies())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(browser.page_source)</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    browser.close()</span><br></pre></td></tr></table></figure>\n\n<p>运行代码后会自动弹出一个<code>Chrome</code>浏览器，浏览器会跳转到百度，然后在搜索框中输入<code>Python</code>，接着跳转到搜索结果页，如图所示。</p>\n<p><img src=\"Screenshot_6.webp\"></p>\n<p>此时在控制台的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">href=&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot; target=&quot;_blank&quot;&gt;你都用 &lt;em&gt;Python&lt;/em&gt; 来做什么? - 知乎&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;c-row c-gap-top-small&quot;&gt;&lt;div class=&quot;general_image_pic c-span3&quot; style=&quot;position:relative;top:2px;&quot;&gt;&lt;a class=&quot;c-img c-img3 c-img-radius-large&quot; style=&quot;height:85px&quot; href=&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;c-img c-img3 c-img-radius-large&quot; src=&quot;https://dss1.bdstatic.com/6OF1bjeh1BF3odCf/it/u=958012630,1445793633&amp;amp;fm=218&amp;amp;app=92&amp;amp;f=JPEG?w=121&amp;amp;h=75&amp;amp;s=44A638725CB7469C82F4FFF40200D025&quot; style=&quot;height:85px;&quot;&gt;&lt;span class=&quot;c-img-border c-img-radius-large&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;c-span9 c-span-last&quot;&gt;&lt;div class=&quot;c-abstract&quot;&gt;&lt;span class=&quot; newTimeFactor_before_abs c-color-gray2 m&quot;&gt;2019年10月17日&amp;nbsp;&lt;/span&gt;所有项目的代码和数据在Github:interesting-&lt;em&gt;python&lt;/em&gt; 如果你也想用&lt;em&gt;Python&lt;/em&gt;获取数据,进行有趣的 </span><br><span class=\"line\">数据分析,Alfred数据室应众多读者要求出品的《实战玩转&lt;em&gt;python&lt;/em&gt;爬虫》课程将会是你的好帮手...&lt;/div&gt;&lt;style&gt;.user-avatar &#123;</span><br><span class=\"line\">        display: flex;</span><br><span class=\"line\">        flex-direction: row;</span><br><span class=\"line\">        align-items: center;</span><br><span class=\"line\">        justify-content: flex-start;</span><br><span class=\"line\">&#125;&lt;/style&gt;&lt;div class=&quot;f13 c-gap-top-xsmall se_st_footer user-avatar&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot; class=&quot;c-showurl c-color-gray&quot; style=&quot;text-decoration:none;position:relative;&quot;&gt;&lt;div class=&quot;c-img c-img-circle c-gap-right-xsmall&quot; style=&quot;display: inline-block;width: 16px;height: 16px;position: relative;top: 3px;vertical-align:top;&quot;&gt;&lt;span class=&quot;c-img-border c-img-source-border c-img-radius-large&quot;&gt;&lt;/span&gt;&lt;img src=&quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=493147230,3096476255&amp;amp;fm=195&amp;amp;app=88&amp;amp;f=JPEG?w=200&amp;amp;h=200&quot;&gt;&lt;/div&gt;知乎&lt;/a&gt;&lt;div class=&quot;c-tools c-gap-left&quot; id=&quot;tools_9637258987948217910_8&quot; data-tools=&quot;&#123;&amp;quot;title&amp;quot;:&amp;quot;你都用 Python 来做什么? - 知乎&amp;quot;,&amp;quot;url&amp;quot;:&amp;quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&amp;quot;&#125;&quot;&gt;&lt;i class=&quot;c-icon f13&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;span class=&quot;c-icons-outer&quot;&gt;&lt;span class=&quot;c-icons-inner&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;style&gt;.snapshoot, .snapshoot:visited &#123;</span><br><span class=\"line\">        color: #9195A3!important;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .snapshoot:active, .snapshoot:hover &#123;</span><br><span class=\"line\">        color: #626675!important;</span><br><span class=\"line\">    &#125;&lt;/style&gt;&lt;a data-click=&quot;&#123;&#x27;rsv_snapshot&#x27;:&#x27;1&#x27;&#125;&quot; href=&quot;http://cache.baiducontent.com/c?m=JgFgeas2iHrh6pppvD-MHkvHPj9DsOz-wd718JIlv_IJy7d0KdQ2HvVIYznaRWwGrKHLEtVbqjR4uoZg6X_h4g62yFf5FgBVDUBkRfcWrOG&amp;amp;p=8b2a9715d9c647f904aec5344f57&amp;amp;newp=8b2a9729c5df1bb508e291784f4a92695d0fc20e3ad0d001298ffe0cc4241a1a1a3aecbf2c261600d7c279650aab4a5feff336743d0034f1f689df08d2ecce7e439b3b6e6a&amp;amp;s=45c48cce2e2d7fbd&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=Python&amp;amp;qid=dc4c1a0300139b42&amp;amp;p1=8&quot; target=&quot;_blank&quot; class=&quot;m c-gap-left c-color-gray kuaizhao snapshoot&quot;&gt;百度快照&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>源代码过长，在此省略。可以看到，当前得到的<code>URL</code>、<code>Cookies</code>和源代码都是浏览器中的真实内容。所以说，如果用<code>Selenium</code>来驱动浏览器加载网页的话，就可以直接拿到<code>JavaScript</code>渲染的结果了，不用担心使用的是什么加密系统。</p>\n<p>了解一下<code>Selenium</code>的用法。</p>\n<h2 id=\"声明浏览器对象\"><a href=\"#声明浏览器对象\" class=\"headerlink\" title=\"声明浏览器对象\"></a>声明浏览器对象</h2><p><code>Selenium</code>支持非常多的浏览器，如<code>Chrome</code>、<code>Firefox</code>、<code>Edge</code>等，还有<code>Android</code>、<code>BlackBerry</code>等手机端的浏览器。</p>\n<p>可以用如下方式进行初始化：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser = webdriver.Firefox()</span><br><span class=\"line\">browser = webdriver.Edge()</span><br><span class=\"line\">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了浏览器对象的初始化并将其赋值为<code>browser</code>对象。接下来，要做的就是调用<code>browser</code>对象，让其执行各个动作以模拟浏览器操作。</p>\n<h2 id=\"访问页面\"><a href=\"#访问页面\" class=\"headerlink\" title=\"访问页面\"></a>访问页面</h2><p>可以用<code>get</code>方法请求页面，只需要把参数传入连接<code>URL</code>即可。比如，这里用<code>get</code>方法访问淘宝，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(browser.page_source)</span><br><span class=\"line\">browser.close()</span><br></pre></td></tr></table></figure>\n\n<p>运行后会弹出<code>Chrome</code>浏览器并且自动访问淘宝，然后控制台会输出淘宝页面的源代码，随后浏览器关闭。</p>\n<h2 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h2><p><code>Selenium</code>可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。举个例子，当想要完成向某个输入框输入文字的操作时，首先需要知道这个输入框在哪，而 <code>Selenium</code>提供了一系列查找节点的方法，可以用这些方法来获取想要的节点，以便执行下一步动作或者提取信息。</p>\n<h3 id=\"单个节点\"><a href=\"#单个节点\" class=\"headerlink\" title=\"单个节点\"></a>单个节点</h3><p>想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码。</p>\n<p>可以发现，它的<code>id</code>是<code>q</code>，<code>name</code>也是<code>q</code>，此外还有许多其他属性。此时就可以用多种方式获取它了。比如，<code>find_element_by_name</code>代表根据<code>name</code>值获取，<code>find_element_by_id</code>则是根据<code>id</code>获取，另外，还有根据<code>XPath</code>、<code>CSS</code>选择器等获取的方式。</p>\n<p>这里使用<code>3</code>种方式获取输入框，分别是根据<code>id</code>、<code>CSS</code>选择器和<code>XPath</code>获取，它们返回的结果完全一致。运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;fbca625cd8bb4eb98ae76bb68a23bd4f&quot;</span>,element=<span class=\"string\">&quot;de630823-02d3-409a-ba19-4e892a0fad15&quot;</span>)&gt; </span><br><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;fbca625cd8bb4eb98ae76bb68a23bd4f&quot;</span>, element=<span class=\"string\">&quot;de630823-02d3-409a-ba19-4e892a0fad15&quot;</span>)&gt; </span><br><span class=\"line\">[&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;fbca625cd8bb4eb98ae76bb68a23bd4f&quot;</span>, element=<span class=\"string\">&quot;de630823-02d3-409a-ba19-4e892a0fad15&quot;</span>)&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>这3个节点的类型是一致的，都是<code>WebElement</code>。</p>\n<p>这里列出所有获取单个节点的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_element_by_id </span><br><span class=\"line\">find_element_by_name </span><br><span class=\"line\">find_element_by_xpath </span><br><span class=\"line\">find_element_by_link_text </span><br><span class=\"line\">find_element_by_partial_link_text </span><br><span class=\"line\">find_element_by_tag_name </span><br><span class=\"line\">find_element_by_class_name </span><br><span class=\"line\">find_element_by_css_selector</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个节点\"><a href=\"#多个节点\" class=\"headerlink\" title=\"多个节点\"></a>多个节点</h3><p>多如果在网页中只查找一个目标，那么完全可以用<code>find_element</code>方法。但如果有多个节点需要查找，再用<code>find_element</code>方法，就只能得到第1个节点了。如果要查找所有满足条件的节点，需要用<code>find_elements</code>这样的 方法。注意，在这个方法的名称中， 注<code>element</code>多了一个多<code>s</code>，注意区分。</p>\n<p>举个例子，假如要查找淘宝左侧导航条的所有条目，就可以这样来实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class=\"line\">lis = browser.find_elements_by_css_selector(<span class=\"string\">&#x27;.service-bd li&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br><span class=\"line\">browser.close()</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;01e78303-6103-4f1a-96dc-0386a755a9f4&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;7a4e764e-9a05-4dad-9188-636512591835&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;16219266-ff57-4f42-95ab-4b8dbb4b811a&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;4f23598b-3ca6-4b20-9192-3e06e98984df&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;d837e630-e546-4f8b-babd-e3fdc539d2a6&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;1da195c9-d959-4d47-b729-21d8eac2756f&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;175c2217-dbe6-4d27-997f-58fbe46cbf1a&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;4747359f-d93c-4a7a-976e-501087d96e5f&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;2537bb34-3a26-4ccd-8f53-4ebbef5c70b2&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;04210bc7-ebba-44ef-8757-d88dfd0d023f&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;7bd1b6e4-31e5-4120-8017-afc59ca56f48&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;930a7b6c-26ff-468c-896e-6204b0555747&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;81305b6e-0893-46d2-b7a7-89a85c00132c&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;763237aa-5925-426d-9a76-90b3567870eb&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;60ca3595-3f74-4f1d-9224-7beb9e381a4b&quot;</span>)&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>得到的内容变成了列表类型，列表中的每个节点都是<code>WebElement</code>类型。</p>\n<p>也就是说，如果用<code>find_element</code>方法，只能获取匹配的第一个节点，结果是<code>WebElement</code>类型。如果用<code>find_elements</code>方法，则结果是列表类型，列表中的每个节点是<code>WebElement</code>类型。</p>\n<p>这里列出所有获取多个节点的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_elements_by_id</span><br><span class=\"line\">find_elements_by_name</span><br><span class=\"line\">find_elements_by_xpath</span><br><span class=\"line\">find_elements_by_link_text</span><br><span class=\"line\">find_elements_by_partial_link_text</span><br><span class=\"line\">find_elements_by_tag_name</span><br><span class=\"line\">find_elements_by_class_name</span><br><span class=\"line\">find_elements_by_css_selector</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以直接用<code>find_elements</code>方法来选择，这时可以这样写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = browser.find_elements(By.CSS_SELECTOR, <span class=\"string\">&#x27;.service-bd li&#x27;</span>) </span><br></pre></td></tr></table></figure>\n\n<p>结果是完全一致的。</p>\n<h3 id=\"节点交互\"><a href=\"#节点交互\" class=\"headerlink\" title=\"节点交互\"></a>节点交互</h3><p><code>Selenium</code>可以驱动浏览器来执行一些操作，或者说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用<code>send_keys</code>方法，清空文字时用<code>clear</code>方法，点击按钮时用<code>click</code>方法。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span> = browser.find_element_by_id(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span>.send_keys(<span class=\"string\">&#x27;apple&#x27;</span>)</span><br><span class=\"line\">time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span>.clear()</span><br><span class=\"line\"><span class=\"built_in\">input</span>.send_keys(<span class=\"string\">&#x27;小米&#x27;</span>)</span><br><span class=\"line\">button = browser.find_element_by_class_name(<span class=\"string\">&#x27;btn-search&#x27;</span>)</span><br><span class=\"line\">button.click()</span><br></pre></td></tr></table></figure>\n\n<p>这里首先驱动浏览器打开淘宝，用<code>find_element_by_id</code>方法获取输入框，然后用<code>send_keys</code>方法输入<code>iPhone</code>文字，等待一秒后用<code>clear</code>方法清空输入框，接着再次调用<code>send_keys</code>方法输入<code>iPad</code>文字，之后再用<code>find_element_by_class_name</code>方法获取搜索按钮，最后调用<code>click</code>方法完成搜索动作。</p>\n<h3 id=\"动作链\"><a href=\"#动作链\" class=\"headerlink\" title=\"动作链\"></a>动作链</h3><p>在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，调用它的输入文字和清空文字方法；对于按钮，调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等，这些动作用另一种方式来执行，那就是动作链。</p>\n<p>比如，现在要实现一个节点的拖拽操作，将某个节点从一处拖拽到另外一处，可以这样实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver <span class=\"keyword\">import</span> ActionChains</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">browser.switch_to.frame(<span class=\"string\">&#x27;iframeResult&#x27;</span>)</span><br><span class=\"line\">source = browser.find_element_by_css_selector(<span class=\"string\">&quot;#draggable&quot;</span>)</span><br><span class=\"line\">target = browser.find_element_by_css_selector(<span class=\"string\">&quot;#droppable&quot;</span>)</span><br><span class=\"line\">actions = ActionChains(browser)</span><br><span class=\"line\">actions.drag_and_drop(source, target)</span><br><span class=\"line\">actions.perform()</span><br></pre></td></tr></table></figure>\n\n<p>打开网页中的一个拖拽实例，依次选中要拖拽的节点和拖拽到的目标节点，接着声明<code>ActionChains</code>对象并将其赋值为<code>actions</code>变量，然后通过调用<code>actions</code>变量的<code>drag_and_drop</code>方法，再调用<code>perform</code>方法执行动作，此时就完成了拖拽操作，如图所示：</p>\n<p><img src=\"Screenshot_7.webp\"></p>\n<p>拖拽前页面：</p>\n<p><img src=\"Screenshot_8.webp\"></p>\n<h3 id=\"执行执JavaScript\"><a href=\"#执行执JavaScript\" class=\"headerlink\" title=\"执行执JavaScript\"></a>执行执<code>JavaScript</code></h3><p><code>SeleniumAPI</code>并没有提供实现某些操作的方法，比如，下拉进度条。但它可以直接模拟运行<code>JavaScript</code>，此时使用<code>execute_script</code>方法即可实现，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class=\"line\">browser.execute_script(<span class=\"string\">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br><span class=\"line\">browser.execute_script(<span class=\"string\">&#x27;alert(&quot; To Bottom)&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里利用<code>execute_script</code>方法将进度条下拉到最底部，然后弹出<code>alert</code>提示框。</p>\n<p>有了这个方法，基本上<code>API</code>没有提供的所有功能都可以用执行<code>JavaScript</code>的方式来实现了。</p>\n<h2 id=\"获取节点信息\"><a href=\"#获取节点信息\" class=\"headerlink\" title=\"获取节点信息\"></a>获取节点信息</h2><p><code>Selenium</code>已经提供了选择节点的方法，并且返回的是<code>WebElement</code>类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，就可以不用通过解析源代码来提取信息了，非常方便。</p>\n<h3 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h3><p>可以使用<code>get_attribute</code>方法来获取节点的属性，但是前提是得先选中这个节点，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://www.baidu.com/&#x27;</span></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">logo = browser.find_element_by_class_name(<span class=\"string\">&#x27;index-logo-src&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行之后，程序便会驱动浏览器打开该页面，然后获取<code>class</code>为<code>logo-image</code>的节点，最后打印出它的<code>src</code>属性。</p>\n<p>返回结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;c90d6158ff9e3e6ba88d5f9b9358a358&quot;</span>, element=<span class=\"string\">&quot;c99170cd-b0c1-44b6-a0a0-f4ccf1105e91&quot;</span>)&gt;</span><br><span class=\"line\">https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>get_attribute</code>方法，只需要传入想要获取的属性名，就可以得到它的值了。</p>\n<h3 id=\"获取文本值\"><a href=\"#获取文本值\" class=\"headerlink\" title=\"获取文本值\"></a>获取文本值</h3><p>每个<code>WebElement</code>节点都有<code>text</code>属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于<code>pyquery</code>的<code>text</code>方法，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://holychan.ltd/archives/&#x27;</span></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">title = browser.find_element_by_class_name(<span class=\"string\">&#x27;title-h2&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(title)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(title.text)</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;79f97c0aa935723e276438a5fff2610c&quot;</span>, element=<span class=\"string\">&quot;b86ec344-cb00-4538-b9e9-8959a076bc75&quot;</span>)&gt;</span><br><span class=\"line\">文章归档</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取获ID、位置、标签名、大小\"><a href=\"#获取获ID、位置、标签名、大小\" class=\"headerlink\" title=\"获取获ID、位置、标签名、大小\"></a>获取获ID、位置、标签名、大小</h3><p><code>WebElement</code>节点还有一些其他属性，比如<code>id</code>属性可以获取节点<code>id</code>，<code>location</code>属性可以获取该节点在页面中的相对位置，<code>tag_name</code>属性可以获取标签名称，<code>size</code>属性可以获取节点的大小，也就是宽高，这些 属性有时候还是很有用的。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome() </span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span> </span><br><span class=\"line\">browser.get(url) </span><br><span class=\"line\"><span class=\"built_in\">input</span> = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo-title&#x27;</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.<span class=\"built_in\">id</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.location) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.tag_name) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.size) </span><br></pre></td></tr></table></figure>\n\n<p>这里首先获得<code>class</code>为<code>logo-title</code>这个节点，然后调用其<code>id</code>、<code>location</code>、<code>tag_name</code>、<code>size</code>属性来获取对应的属性值。</p>\n<h2 id=\"切换Frame\"><a href=\"#切换Frame\" class=\"headerlink\" title=\"切换Frame\"></a>切换Frame</h2><p>网页中有一种节点叫作<code>iframe</code>，也就是子<code>Frame</code>，相当于页面的子页面，它的结构和外部网页的结构完全一致。<code>Selenium</code>打开页面后，默认是在父级<code>Frame</code>里面操作，而此时如果页面中还有子<code>Frame</code>，<code>Selenium</code>是不能获取到子<code>Frame</code>里面的节点的。这时就需要使用<code>switch_to.frame</code>方法来切换<code>Frame</code>。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.common.exceptions <span class=\"keyword\">import</span> NoSuchElementException</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">browser.switch_to(<span class=\"string\">&#x27;iframeResult&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    logo = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> NoSuchElementException:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;No logo found&#x27;</span>)</span><br><span class=\"line\">browser.switch_to.parent_frame()</span><br><span class=\"line\">logo = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo.text)</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No logo found</span><br><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;ce74c2d83e0aca64c9ef8c4540b2fe16&quot;</span>, element=<span class=\"string\">&quot;1d2c3c25-bd01-4b9a-b11b-16b8534bf6c2&quot;</span>)&gt;</span><br><span class=\"line\">RUNOOB.COM</span><br></pre></td></tr></table></figure>\n\n<p>首先通过<code>switch_to.frame</code>方法切换到子<code>Frame</code>里面，然后尝试获取子<code>Frame</code>里的<code>logo</code>节点（这是不能找到的），如果找不到的话，就会抛出<code>NoSuchElementException</code>异常，异常被捕捉之后，就会输出<code>No logo found</code>。接下来，我们需要重新切换回父级<code>Frame</code>，然后再次重新获取节点，发现此时可以成功获取了。</p>\n<p>所以，当页面中包含子<code>Frame</code>时，如果想获取子<code>Frame</code>中的节点，需要先调用<code>switch_to.frame</code>方法切换到对应的<code>Frame</code>，然后再进行操作。</p>\n<h2 id=\"延时等待\"><a href=\"#延时等待\" class=\"headerlink\" title=\"延时等待\"></a>延时等待</h2><p>在<code>Selenium</code>中，<code>get</code>方法会在网页框架加载结束后结束执行，此时如果获取<code>page_source</code>，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的<code>Ajax</code>请求，在网页源代码中也不一定能成功获取 \\到。所以，这里需要延时等待一定时间，确保节点已经加载出来。</p>\n<p>这里等待的方式有两种：一种是隐式等待，一种是显式等待。</p>\n<h3 id=\"隐式等待\"><a href=\"#隐式等待\" class=\"headerlink\" title=\"隐式等待\"></a>隐式等待</h3><p>当使用隐式等待执行测试的时候，如果<code>Selenium</code>没有在<code>DOM</code>中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，隐式等待可以在我们查找节点而节点并没有立即出现的时候， 等待一段时间再查找<code>DOM</code>，默认的时间是<code>0</code>。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.implicitly_wait(<span class=\"number\">10</span>)</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://dynamic2. scrape.cuiqingcai.com/&#x27;</span>) </span><br><span class=\"line\"><span class=\"built_in\">input</span> = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo-image&#x27;</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>在很多情况下，<code>Ajax</code>请求的接口通常会包含加密的参数，如<code>token</code>、<code>sign</code>等，如：<a href=\"https://dynamic2.scrape.cuiqingcai.com/\">https://dynamic2.scrape.cuiqingcai.com/</a>，它的<code>Ajax</code>接口是包含一个<code>token</code>参数的，如图所示。</p>\n<p><img src=\"Screenshot_5.webp\"></p>\n<p>由于接口的请求加上了<code>token</code>参数，如果不深入分析并找到<code>token</code>的构造逻辑，是难以直接模拟这些<code>Ajax</code>请求的。</p>\n<p><code>Selenium</code>是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面源代码，做到可见即可爬。对于一些使用<code>JavaScript</code>动态渲染的页面来说，此种抓取方式非常有效。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>确保已经正确安装好了<code>Chrome</code>浏览器并配置好了<code>ChromeDriver</code>。另外，还需要正确安装好<code>Python</code>的<code>Selenium</code>库。</p>\n<h3 id=\"Selenium安装\"><a href=\"#Selenium安装\" class=\"headerlink\" title=\"Selenium安装\"></a>Selenium安装</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install selenium</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"chrome-driver安装\"><a href=\"#chrome-driver安装\" class=\"headerlink\" title=\"chrome driver安装\"></a>chrome driver安装</h3><p>查看安装的浏览器版本，在<code>chrome</code>搜索栏输入<code>chrome://version/</code>，会显示带当前浏览器的版本信息。</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>在<a href=\"https://npm.taobao.org/mirrors/chromedriver/\">https://npm.taobao.org/mirrors/chromedriver/</a>下载对应版本的<code>chrome driver</code>，一定要对应，否则不能使用。</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>下载到本地后，将<code>chromedriver.exe</code>分别拷贝到<code>chrome.exe</code>和<code>python</code>安装路径下。</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p><img src=\"Screenshot_4.webp\"></p>\n<p>以上，安装就完成了！</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>首先来看一下<code>Selenium</code>有一些怎样的功能。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.keys <span class=\"keyword\">import</span> Keys</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.wait <span class=\"keyword\">import</span> WebDriverWait</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    browser.get(<span class=\"string\">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">input</span> = browser.find_element_by_id(<span class=\"string\">&#x27;kw&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">input</span>.send_keys(<span class=\"string\">&#x27;Python&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">input</span>.send_keys(Keys.ENTER)</span><br><span class=\"line\">    wait = WebDriverWait(browser, <span class=\"number\">10</span>)</span><br><span class=\"line\">    wait.until(EC.presence_of_element_located((By.ID, <span class=\"string\">&#x27;content_left&#x27;</span>)))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(browser.current_url)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(browser.get_cookies())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(browser.page_source)</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    browser.close()</span><br></pre></td></tr></table></figure>\n\n<p>运行代码后会自动弹出一个<code>Chrome</code>浏览器，浏览器会跳转到百度，然后在搜索框中输入<code>Python</code>，接着跳转到搜索结果页，如图所示。</p>\n<p><img src=\"Screenshot_6.webp\"></p>\n<p>此时在控制台的输出结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">href=&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot; target=&quot;_blank&quot;&gt;你都用 &lt;em&gt;Python&lt;/em&gt; 来做什么? - 知乎&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;c-row c-gap-top-small&quot;&gt;&lt;div class=&quot;general_image_pic c-span3&quot; style=&quot;position:relative;top:2px;&quot;&gt;&lt;a class=&quot;c-img c-img3 c-img-radius-large&quot; style=&quot;height:85px&quot; href=&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;c-img c-img3 c-img-radius-large&quot; src=&quot;https://dss1.bdstatic.com/6OF1bjeh1BF3odCf/it/u=958012630,1445793633&amp;amp;fm=218&amp;amp;app=92&amp;amp;f=JPEG?w=121&amp;amp;h=75&amp;amp;s=44A638725CB7469C82F4FFF40200D025&quot; style=&quot;height:85px;&quot;&gt;&lt;span class=&quot;c-img-border c-img-radius-large&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;c-span9 c-span-last&quot;&gt;&lt;div class=&quot;c-abstract&quot;&gt;&lt;span class=&quot; newTimeFactor_before_abs c-color-gray2 m&quot;&gt;2019年10月17日&amp;nbsp;&lt;/span&gt;所有项目的代码和数据在Github:interesting-&lt;em&gt;python&lt;/em&gt; 如果你也想用&lt;em&gt;Python&lt;/em&gt;获取数据,进行有趣的 </span><br><span class=\"line\">数据分析,Alfred数据室应众多读者要求出品的《实战玩转&lt;em&gt;python&lt;/em&gt;爬虫》课程将会是你的好帮手...&lt;/div&gt;&lt;style&gt;.user-avatar &#123;</span><br><span class=\"line\">        display: flex;</span><br><span class=\"line\">        flex-direction: row;</span><br><span class=\"line\">        align-items: center;</span><br><span class=\"line\">        justify-content: flex-start;</span><br><span class=\"line\">&#125;&lt;/style&gt;&lt;div class=&quot;f13 c-gap-top-xsmall se_st_footer user-avatar&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&quot; class=&quot;c-showurl c-color-gray&quot; style=&quot;text-decoration:none;position:relative;&quot;&gt;&lt;div class=&quot;c-img c-img-circle c-gap-right-xsmall&quot; style=&quot;display: inline-block;width: 16px;height: 16px;position: relative;top: 3px;vertical-align:top;&quot;&gt;&lt;span class=&quot;c-img-border c-img-source-border c-img-radius-large&quot;&gt;&lt;/span&gt;&lt;img src=&quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=493147230,3096476255&amp;amp;fm=195&amp;amp;app=88&amp;amp;f=JPEG?w=200&amp;amp;h=200&quot;&gt;&lt;/div&gt;知乎&lt;/a&gt;&lt;div class=&quot;c-tools c-gap-left&quot; id=&quot;tools_9637258987948217910_8&quot; data-tools=&quot;&#123;&amp;quot;title&amp;quot;:&amp;quot;你都用 Python 来做什么? - 知乎&amp;quot;,&amp;quot;url&amp;quot;:&amp;quot;http://www.baidu.com/link?url=CYEq_OJxbiLcx5LothJSzfcQI9xeTzMYkPSFg2HYyceDRTQi8o6Fk8oLyRG5BTI8remsEFjvd4qN8vGLA-EBg_&amp;quot;&#125;&quot;&gt;&lt;i class=&quot;c-icon f13&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;span class=&quot;c-icons-outer&quot;&gt;&lt;span class=&quot;c-icons-inner&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;style&gt;.snapshoot, .snapshoot:visited &#123;</span><br><span class=\"line\">        color: #9195A3!important;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .snapshoot:active, .snapshoot:hover &#123;</span><br><span class=\"line\">        color: #626675!important;</span><br><span class=\"line\">    &#125;&lt;/style&gt;&lt;a data-click=&quot;&#123;&#x27;rsv_snapshot&#x27;:&#x27;1&#x27;&#125;&quot; href=&quot;http://cache.baiducontent.com/c?m=JgFgeas2iHrh6pppvD-MHkvHPj9DsOz-wd718JIlv_IJy7d0KdQ2HvVIYznaRWwGrKHLEtVbqjR4uoZg6X_h4g62yFf5FgBVDUBkRfcWrOG&amp;amp;p=8b2a9715d9c647f904aec5344f57&amp;amp;newp=8b2a9729c5df1bb508e291784f4a92695d0fc20e3ad0d001298ffe0cc4241a1a1a3aecbf2c261600d7c279650aab4a5feff336743d0034f1f689df08d2ecce7e439b3b6e6a&amp;amp;s=45c48cce2e2d7fbd&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=Python&amp;amp;qid=dc4c1a0300139b42&amp;amp;p1=8&quot; target=&quot;_blank&quot; class=&quot;m c-gap-left c-color-gray kuaizhao snapshoot&quot;&gt;百度快照&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>源代码过长，在此省略。可以看到，当前得到的<code>URL</code>、<code>Cookies</code>和源代码都是浏览器中的真实内容。所以说，如果用<code>Selenium</code>来驱动浏览器加载网页的话，就可以直接拿到<code>JavaScript</code>渲染的结果了，不用担心使用的是什么加密系统。</p>\n<p>了解一下<code>Selenium</code>的用法。</p>\n<h2 id=\"声明浏览器对象\"><a href=\"#声明浏览器对象\" class=\"headerlink\" title=\"声明浏览器对象\"></a>声明浏览器对象</h2><p><code>Selenium</code>支持非常多的浏览器，如<code>Chrome</code>、<code>Firefox</code>、<code>Edge</code>等，还有<code>Android</code>、<code>BlackBerry</code>等手机端的浏览器。</p>\n<p>可以用如下方式进行初始化：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser = webdriver.Firefox()</span><br><span class=\"line\">browser = webdriver.Edge()</span><br><span class=\"line\">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了浏览器对象的初始化并将其赋值为<code>browser</code>对象。接下来，要做的就是调用<code>browser</code>对象，让其执行各个动作以模拟浏览器操作。</p>\n<h2 id=\"访问页面\"><a href=\"#访问页面\" class=\"headerlink\" title=\"访问页面\"></a>访问页面</h2><p>可以用<code>get</code>方法请求页面，只需要把参数传入连接<code>URL</code>即可。比如，这里用<code>get</code>方法访问淘宝，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(browser.page_source)</span><br><span class=\"line\">browser.close()</span><br></pre></td></tr></table></figure>\n\n<p>运行后会弹出<code>Chrome</code>浏览器并且自动访问淘宝，然后控制台会输出淘宝页面的源代码，随后浏览器关闭。</p>\n<h2 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h2><p><code>Selenium</code>可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。举个例子，当想要完成向某个输入框输入文字的操作时，首先需要知道这个输入框在哪，而 <code>Selenium</code>提供了一系列查找节点的方法，可以用这些方法来获取想要的节点，以便执行下一步动作或者提取信息。</p>\n<h3 id=\"单个节点\"><a href=\"#单个节点\" class=\"headerlink\" title=\"单个节点\"></a>单个节点</h3><p>想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码。</p>\n<p>可以发现，它的<code>id</code>是<code>q</code>，<code>name</code>也是<code>q</code>，此外还有许多其他属性。此时就可以用多种方式获取它了。比如，<code>find_element_by_name</code>代表根据<code>name</code>值获取，<code>find_element_by_id</code>则是根据<code>id</code>获取，另外，还有根据<code>XPath</code>、<code>CSS</code>选择器等获取的方式。</p>\n<p>这里使用<code>3</code>种方式获取输入框，分别是根据<code>id</code>、<code>CSS</code>选择器和<code>XPath</code>获取，它们返回的结果完全一致。运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;fbca625cd8bb4eb98ae76bb68a23bd4f&quot;</span>,element=<span class=\"string\">&quot;de630823-02d3-409a-ba19-4e892a0fad15&quot;</span>)&gt; </span><br><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;fbca625cd8bb4eb98ae76bb68a23bd4f&quot;</span>, element=<span class=\"string\">&quot;de630823-02d3-409a-ba19-4e892a0fad15&quot;</span>)&gt; </span><br><span class=\"line\">[&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;fbca625cd8bb4eb98ae76bb68a23bd4f&quot;</span>, element=<span class=\"string\">&quot;de630823-02d3-409a-ba19-4e892a0fad15&quot;</span>)&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>这3个节点的类型是一致的，都是<code>WebElement</code>。</p>\n<p>这里列出所有获取单个节点的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_element_by_id </span><br><span class=\"line\">find_element_by_name </span><br><span class=\"line\">find_element_by_xpath </span><br><span class=\"line\">find_element_by_link_text </span><br><span class=\"line\">find_element_by_partial_link_text </span><br><span class=\"line\">find_element_by_tag_name </span><br><span class=\"line\">find_element_by_class_name </span><br><span class=\"line\">find_element_by_css_selector</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个节点\"><a href=\"#多个节点\" class=\"headerlink\" title=\"多个节点\"></a>多个节点</h3><p>多如果在网页中只查找一个目标，那么完全可以用<code>find_element</code>方法。但如果有多个节点需要查找，再用<code>find_element</code>方法，就只能得到第1个节点了。如果要查找所有满足条件的节点，需要用<code>find_elements</code>这样的 方法。注意，在这个方法的名称中， 注<code>element</code>多了一个多<code>s</code>，注意区分。</p>\n<p>举个例子，假如要查找淘宝左侧导航条的所有条目，就可以这样来实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class=\"line\">lis = browser.find_elements_by_css_selector(<span class=\"string\">&#x27;.service-bd li&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(lis)</span><br><span class=\"line\">browser.close()</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;01e78303-6103-4f1a-96dc-0386a755a9f4&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;7a4e764e-9a05-4dad-9188-636512591835&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;16219266-ff57-4f42-95ab-4b8dbb4b811a&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;4f23598b-3ca6-4b20-9192-3e06e98984df&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;d837e630-e546-4f8b-babd-e3fdc539d2a6&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;1da195c9-d959-4d47-b729-21d8eac2756f&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;175c2217-dbe6-4d27-997f-58fbe46cbf1a&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;4747359f-d93c-4a7a-976e-501087d96e5f&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;2537bb34-3a26-4ccd-8f53-4ebbef5c70b2&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;04210bc7-ebba-44ef-8757-d88dfd0d023f&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;7bd1b6e4-31e5-4120-8017-afc59ca56f48&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;930a7b6c-26ff-468c-896e-6204b0555747&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;81305b6e-0893-46d2-b7a7-89a85c00132c&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;763237aa-5925-426d-9a76-90b3567870eb&quot;</span>)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;f9550f7bf1204e4d481803cf7a69c736&quot;</span>, element=<span class=\"string\">&quot;60ca3595-3f74-4f1d-9224-7beb9e381a4b&quot;</span>)&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>得到的内容变成了列表类型，列表中的每个节点都是<code>WebElement</code>类型。</p>\n<p>也就是说，如果用<code>find_element</code>方法，只能获取匹配的第一个节点，结果是<code>WebElement</code>类型。如果用<code>find_elements</code>方法，则结果是列表类型，列表中的每个节点是<code>WebElement</code>类型。</p>\n<p>这里列出所有获取多个节点的方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_elements_by_id</span><br><span class=\"line\">find_elements_by_name</span><br><span class=\"line\">find_elements_by_xpath</span><br><span class=\"line\">find_elements_by_link_text</span><br><span class=\"line\">find_elements_by_partial_link_text</span><br><span class=\"line\">find_elements_by_tag_name</span><br><span class=\"line\">find_elements_by_class_name</span><br><span class=\"line\">find_elements_by_css_selector</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以直接用<code>find_elements</code>方法来选择，这时可以这样写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = browser.find_elements(By.CSS_SELECTOR, <span class=\"string\">&#x27;.service-bd li&#x27;</span>) </span><br></pre></td></tr></table></figure>\n\n<p>结果是完全一致的。</p>\n<h3 id=\"节点交互\"><a href=\"#节点交互\" class=\"headerlink\" title=\"节点交互\"></a>节点交互</h3><p><code>Selenium</code>可以驱动浏览器来执行一些操作，或者说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用<code>send_keys</code>方法，清空文字时用<code>clear</code>方法，点击按钮时用<code>click</code>方法。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span> = browser.find_element_by_id(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span>.send_keys(<span class=\"string\">&#x27;apple&#x27;</span>)</span><br><span class=\"line\">time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">input</span>.clear()</span><br><span class=\"line\"><span class=\"built_in\">input</span>.send_keys(<span class=\"string\">&#x27;小米&#x27;</span>)</span><br><span class=\"line\">button = browser.find_element_by_class_name(<span class=\"string\">&#x27;btn-search&#x27;</span>)</span><br><span class=\"line\">button.click()</span><br></pre></td></tr></table></figure>\n\n<p>这里首先驱动浏览器打开淘宝，用<code>find_element_by_id</code>方法获取输入框，然后用<code>send_keys</code>方法输入<code>iPhone</code>文字，等待一秒后用<code>clear</code>方法清空输入框，接着再次调用<code>send_keys</code>方法输入<code>iPad</code>文字，之后再用<code>find_element_by_class_name</code>方法获取搜索按钮，最后调用<code>click</code>方法完成搜索动作。</p>\n<h3 id=\"动作链\"><a href=\"#动作链\" class=\"headerlink\" title=\"动作链\"></a>动作链</h3><p>在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，调用它的输入文字和清空文字方法；对于按钮，调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等，这些动作用另一种方式来执行，那就是动作链。</p>\n<p>比如，现在要实现一个节点的拖拽操作，将某个节点从一处拖拽到另外一处，可以这样实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver <span class=\"keyword\">import</span> ActionChains</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">browser.switch_to.frame(<span class=\"string\">&#x27;iframeResult&#x27;</span>)</span><br><span class=\"line\">source = browser.find_element_by_css_selector(<span class=\"string\">&quot;#draggable&quot;</span>)</span><br><span class=\"line\">target = browser.find_element_by_css_selector(<span class=\"string\">&quot;#droppable&quot;</span>)</span><br><span class=\"line\">actions = ActionChains(browser)</span><br><span class=\"line\">actions.drag_and_drop(source, target)</span><br><span class=\"line\">actions.perform()</span><br></pre></td></tr></table></figure>\n\n<p>打开网页中的一个拖拽实例，依次选中要拖拽的节点和拖拽到的目标节点，接着声明<code>ActionChains</code>对象并将其赋值为<code>actions</code>变量，然后通过调用<code>actions</code>变量的<code>drag_and_drop</code>方法，再调用<code>perform</code>方法执行动作，此时就完成了拖拽操作，如图所示：</p>\n<p><img src=\"Screenshot_7.webp\"></p>\n<p>拖拽前页面：</p>\n<p><img src=\"Screenshot_8.webp\"></p>\n<h3 id=\"执行执JavaScript\"><a href=\"#执行执JavaScript\" class=\"headerlink\" title=\"执行执JavaScript\"></a>执行执<code>JavaScript</code></h3><p><code>SeleniumAPI</code>并没有提供实现某些操作的方法，比如，下拉进度条。但它可以直接模拟运行<code>JavaScript</code>，此时使用<code>execute_script</code>方法即可实现，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class=\"line\">browser.execute_script(<span class=\"string\">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br><span class=\"line\">browser.execute_script(<span class=\"string\">&#x27;alert(&quot; To Bottom)&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里利用<code>execute_script</code>方法将进度条下拉到最底部，然后弹出<code>alert</code>提示框。</p>\n<p>有了这个方法，基本上<code>API</code>没有提供的所有功能都可以用执行<code>JavaScript</code>的方式来实现了。</p>\n<h2 id=\"获取节点信息\"><a href=\"#获取节点信息\" class=\"headerlink\" title=\"获取节点信息\"></a>获取节点信息</h2><p><code>Selenium</code>已经提供了选择节点的方法，并且返回的是<code>WebElement</code>类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，就可以不用通过解析源代码来提取信息了，非常方便。</p>\n<h3 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h3><p>可以使用<code>get_attribute</code>方法来获取节点的属性，但是前提是得先选中这个节点，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://www.baidu.com/&#x27;</span></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">logo = browser.find_element_by_class_name(<span class=\"string\">&#x27;index-logo-src&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>运行之后，程序便会驱动浏览器打开该页面，然后获取<code>class</code>为<code>logo-image</code>的节点，最后打印出它的<code>src</code>属性。</p>\n<p>返回结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;c90d6158ff9e3e6ba88d5f9b9358a358&quot;</span>, element=<span class=\"string\">&quot;c99170cd-b0c1-44b6-a0a0-f4ccf1105e91&quot;</span>)&gt;</span><br><span class=\"line\">https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>get_attribute</code>方法，只需要传入想要获取的属性名，就可以得到它的值了。</p>\n<h3 id=\"获取文本值\"><a href=\"#获取文本值\" class=\"headerlink\" title=\"获取文本值\"></a>获取文本值</h3><p>每个<code>WebElement</code>节点都有<code>text</code>属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于<code>pyquery</code>的<code>text</code>方法，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://holychan.ltd/archives/&#x27;</span></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">title = browser.find_element_by_class_name(<span class=\"string\">&#x27;title-h2&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(title)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(title.text)</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;79f97c0aa935723e276438a5fff2610c&quot;</span>, element=<span class=\"string\">&quot;b86ec344-cb00-4538-b9e9-8959a076bc75&quot;</span>)&gt;</span><br><span class=\"line\">文章归档</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取获ID、位置、标签名、大小\"><a href=\"#获取获ID、位置、标签名、大小\" class=\"headerlink\" title=\"获取获ID、位置、标签名、大小\"></a>获取获ID、位置、标签名、大小</h3><p><code>WebElement</code>节点还有一些其他属性，比如<code>id</code>属性可以获取节点<code>id</code>，<code>location</code>属性可以获取该节点在页面中的相对位置，<code>tag_name</code>属性可以获取标签名称，<code>size</code>属性可以获取节点的大小，也就是宽高，这些 属性有时候还是很有用的。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\">browser = webdriver.Chrome() </span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span> </span><br><span class=\"line\">browser.get(url) </span><br><span class=\"line\"><span class=\"built_in\">input</span> = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo-title&#x27;</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.<span class=\"built_in\">id</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.location) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.tag_name) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>.size) </span><br></pre></td></tr></table></figure>\n\n<p>这里首先获得<code>class</code>为<code>logo-title</code>这个节点，然后调用其<code>id</code>、<code>location</code>、<code>tag_name</code>、<code>size</code>属性来获取对应的属性值。</p>\n<h2 id=\"切换Frame\"><a href=\"#切换Frame\" class=\"headerlink\" title=\"切换Frame\"></a>切换Frame</h2><p>网页中有一种节点叫作<code>iframe</code>，也就是子<code>Frame</code>，相当于页面的子页面，它的结构和外部网页的结构完全一致。<code>Selenium</code>打开页面后，默认是在父级<code>Frame</code>里面操作，而此时如果页面中还有子<code>Frame</code>，<code>Selenium</code>是不能获取到子<code>Frame</code>里面的节点的。这时就需要使用<code>switch_to.frame</code>方法来切换<code>Frame</code>。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.common.exceptions <span class=\"keyword\">import</span> NoSuchElementException</span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">url = <span class=\"string\">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class=\"line\">browser.get(url)</span><br><span class=\"line\">browser.switch_to(<span class=\"string\">&#x27;iframeResult&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    logo = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> NoSuchElementException:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;No logo found&#x27;</span>)</span><br><span class=\"line\">browser.switch_to.parent_frame()</span><br><span class=\"line\">logo = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(logo.text)</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No logo found</span><br><span class=\"line\">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class=\"string\">&quot;ce74c2d83e0aca64c9ef8c4540b2fe16&quot;</span>, element=<span class=\"string\">&quot;1d2c3c25-bd01-4b9a-b11b-16b8534bf6c2&quot;</span>)&gt;</span><br><span class=\"line\">RUNOOB.COM</span><br></pre></td></tr></table></figure>\n\n<p>首先通过<code>switch_to.frame</code>方法切换到子<code>Frame</code>里面，然后尝试获取子<code>Frame</code>里的<code>logo</code>节点（这是不能找到的），如果找不到的话，就会抛出<code>NoSuchElementException</code>异常，异常被捕捉之后，就会输出<code>No logo found</code>。接下来，我们需要重新切换回父级<code>Frame</code>，然后再次重新获取节点，发现此时可以成功获取了。</p>\n<p>所以，当页面中包含子<code>Frame</code>时，如果想获取子<code>Frame</code>中的节点，需要先调用<code>switch_to.frame</code>方法切换到对应的<code>Frame</code>，然后再进行操作。</p>\n<h2 id=\"延时等待\"><a href=\"#延时等待\" class=\"headerlink\" title=\"延时等待\"></a>延时等待</h2><p>在<code>Selenium</code>中，<code>get</code>方法会在网页框架加载结束后结束执行，此时如果获取<code>page_source</code>，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的<code>Ajax</code>请求，在网页源代码中也不一定能成功获取 \\到。所以，这里需要延时等待一定时间，确保节点已经加载出来。</p>\n<p>这里等待的方式有两种：一种是隐式等待，一种是显式等待。</p>\n<h3 id=\"隐式等待\"><a href=\"#隐式等待\" class=\"headerlink\" title=\"隐式等待\"></a>隐式等待</h3><p>当使用隐式等待执行测试的时候，如果<code>Selenium</code>没有在<code>DOM</code>中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，隐式等待可以在我们查找节点而节点并没有立即出现的时候， 等待一段时间再查找<code>DOM</code>，默认的时间是<code>0</code>。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">browser = webdriver.Chrome()</span><br><span class=\"line\">browser.implicitly_wait(<span class=\"number\">10</span>)</span><br><span class=\"line\">browser.get(<span class=\"string\">&#x27;https://dynamic2. scrape.cuiqingcai.com/&#x27;</span>) </span><br><span class=\"line\"><span class=\"built_in\">input</span> = browser.find_element_by_class_name(<span class=\"string\">&#x27;logo-image&#x27;</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">input</span>)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"python多进程基本原理","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-17T12:04:49.000Z","pic":null,"_content":"\n## 多进程的含义\n\n多进程（`Process`）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。\n\n顾名思义，多进程就是启用多个进程同时运行。由于进程是线程的集合，而且进程是由一个或多个线程构成的，所以多进程的运 行意味着有大于或等于进程数量的线程在运行。\n\n## Python多进程的优势\n\n由于进程中`GIL`的存在，`Python`中的多线程并不能很好地发挥多核优势，一个进程中的多个线程，在同一时刻只能有一个线程运行。\n\n对于多进程来说，每个进程都有属于自己的`GIL`，所以，在多核处理器下，多进程的运行是不会受`GIL`的影响的。因此，多进程能更好地发挥多核的优势。\n\n当然，对于爬虫这种`IO`密集型任务来说，多线程和多进程影响差别并不大。对于计算密集型任务来说，`Python`的多进程相比多线程，其多核运行效率会有成倍的提升。\n\n总的来说，`Python`的多进程整体来看是比多线程更有优势的。所以，在条件允许的情况下，能用多进程就尽量用多进程。\n\n不过值得注意的是，由于进程是系统进行资源分配和调度的一个独立单位，所以各个进程之间的数据是无法共享的，如多个进程无法共享一个全局变量，进程之间的数据共享需要有单独的机制来实现到。\n\n## 多进程的实现\n\n在`Python`中也有内置的库来实现多进程，它就是`multiprocessing`。\n\n`multiprocessing`提供了一系列的组件，如`Process（进程`、`Queue（队列）`、`Semaphore（信号量）`、`Pipe（管道）`、`Lock（锁）`、`Pool（进程池）`等，接下来让我们来了解下它们的使用方法。\n\n### 直接使用Process类\n\n在`multiprocessing`中，每一个进程都用一个`Process`类来表示。它的`API`调用如下：\n\n```python\nProcess([group [, target [, name [, args [, kwargs]]]]])\n```\n\n- `target`表示调用对象，你可以传入方法的名字。\n- `args`表示被调用对象的位置参数元组，比如`target`是函数`func`，他有两个参数`m`，`n`，那么`args`就传入`[m, n]`即可。\n- `kwargs`表示调用对象的字典。\n- `name`是别名，相当于给这个进程取一个名字。\n- `group`分组。\n  \n先用一个实例来感受一下：\n\n```python\nimport multiprocessing\n\ndef process(index):\n    print(f'process: {index}')\n\nif __name__ == '__main__':\n    for i in range(5):\n        p = multiprocessing.Process(target=process, args=(i,))\n        p.start()\n```\n\n这是一个实现多进程最基础的方式：通过创建`Process`来新建一个子进程，其中`target`参数传入方法名，`args`是方法的参数，是以 元组的形式传入，其和被调用的方法`process`的参数是一一对应的。\n\n> 注意：这里`args `必须要是一个元组，如果只有一个参数，那也要在元组第一个元素后面加一个逗号，如果没有逗号则和单个元素本身没有区别，无法构成元组，导致参数传递出现问题。\n\n创建完进程之后，我们通过调用`start`方法即可启动进程了。运行结果如下：\n\n```python\nprocess: 0\nprocess: 1\nprocess: 2\nprocess: 3\nprocess: 4\n```\n\n运行了`5`个子进程，每个进程都调用了`process`方法。`process`方法的`index`参数通过`Process`的`args`传入，分别是`0~4`这`5`个序号，最后打印出来，`5`个子进程运行结束。\n\n由于进程是`Python`中最小的资源分配单元，因此这些进程和线程不同，各个进程之间的数据是不会共享的，每启动一个进程，都会独立分配资源。\n\n在当前`CPU`核数足够的情况下，这些不同的进程会分配给不同的`CPU`核来运行，实现真正的并行执行。\n\n运行结果如下：\n\n```python\nCPU number: 4\nChild process name: Process-2 id: 12112\nChild process name: Process-3 id: 14708\nChild process name: Process-1 id: 11208\nChild process name: Process-5 id: 9968\nChild process name: Process-4 id: 11784\nProcess ended\nprocess: 0\nprocess: 1\nprocess: 2\nprocess: 3\nprocess: 4\n```\n\n通过`cpu_count`成功获取了`CPU`核心的数量：`4`个，不同的机器结果可能不同。通过 `active_children`获取到了当前正在活跃运行的进程列表。然后遍历每个进程，并将它们的*名称*和*进程号*打印出来了，这里进程号直接使用`pid`属性即可获取，进程名称直接通过`name`属性即可获取。\n\n## 继承继Process类\n\n在上面的例子中，创建进程是直接使用`Process`这个类来创建的，这是一种创建进程的方式。不过，创建进程的方式不止这一 种，同样，也可以像线程`Thread`一样来通过继承的方式创建一个进程类，进程的基本操作我们在子类的`run`方法中实现即可。\n\n通过一个实例来看一下：\n\n```python\nfrom multiprocessing import Process\nimport time\n\nclass MyProcess(Process):\n    def __init__(self, loop):\n        Process.__init__(self)\n        self.loop = loop\n\n    def run(self):\n        for count in range(self.loop):\n            time.sleep(1)\n            print(f'Pid: {self.pid} LoopCount: {count}')\n\nif __name__ == '__main__':\n    for i in range(2,5):\n        p = MyProcess(i)\n        p.start()\n```\n\n声明了一个构造方法，这个方法接收一个`loop`参数，代表循环次数，并将其设置为全局变量。在`run`方法中，又使用这个`loop`变量循环了`loop`次并打印了当前的进程号和循环次数。\n\n在调用时，用`range`方法得到了`2、3、4`三个数字，并把它们分别初始化了`MyProcess`进程，然后调用`start`方法将进程启动起来。\n\n> 注意：这里进程的执行逻辑需要在`run`方法中实现，启动进程需要调用`start`方法，调用之后`run`方法便会执行。\n\n运行结果如下：\n\n```python\nPid: 13728 LoopCount: 0\nPid: 13560 LoopCount: 0\nPid: 9908 LoopCount: 0 \nPid: 9908 LoopCount: 1\nPid: 13560 LoopCount: 1\nPid: 13728 LoopCount: 1\nPid: 13728 LoopCount: 2\nPid: 9908 LoopCount: 2\nPid: 13728 LoopCount: 3\n```\n\n三个进程分别打印出了`2、3、4`条结果，即进程`13560`打印了`2`次结果，进程`9908` 打印了`3`次结果，进程`13728`打印了`4`次结果。\n\n> 注意，这里的进程`pid`代表进程号，不同机器、不同时刻运行结果可能不同。 \n\n通过上面的方式，非常方便地实现了一个进程的定义。为了复用方便，可以把一些方法写在每个进程类里封装好，在使用时直接初始化一个进程类运行即可。\n\n## 守护进程\n\n在多进程中，同样存在守护进程的概念，如果一个进程被设置为守护进程，当父进程结束后，子进程会自动被终止，我们可以通过设置`daemon`属性来控制是否为守护进程。\n\n还是原来的例子，增加了`deamon`属性的设置：\n\n```python\nfrom multiprocessing import Process\nimport time\n\nclass MyProcess(Process):\n    def __init__(self, loop):\n        Process.__init__(self)\n        self.loop = loop\n\n    def run(self):\n        for count in range(self.loop):\n            time.sleep(1)\n            print(f'Pid: {self.pid} LoopCount: {count}')\n\nif __name__ == '__main__':\n    for i in range(2,5):\n        p = MyProcess(i)\n        p.daemon = True\n        p.start()\n    print('Main process is ended.')\n```\n\n运行结果如下：\n\n```python\nMain process is ended.\n```\n\n结果很简单，因为主进程没有做任何事情，直接输出一句话结束，所以在这时也直接终止了子进程的运行。\n\n这样可以有效防止无控制地生成子进程。这样的写法可以让我们在主进程运行结束后无需额外担心子进程是否关闭，避免了独立子进程的运行。\n\n## 进程等待\n\n上面的运行效果其实不太符合我们预期：主进程运行结束时，子进程（守护进程）也都退出了，子进程什么都没来得及执行。\n\n能不能让所有子进程都执行完了然后再结束呢？当然是可以的，只需要加入`join`方法即可，可以将代码改写如下：\n\n```python\n    process = []\n    for i in range(2,5):\n        p = MyProcess(i)\n        process.append(p)\n        p.daemon = True\n        p.start()\n    for p in process:\n        p.join()\n    print('Main process is ended.')\n```\n\n运行结果如下：\n\n```python\nPid: 13220 LoopCount: 0\nPid: 10488 LoopCount: 0\nPid: 4652 LoopCount: 0\nPid: 13220 LoopCount: 1\nPid: 10488 LoopCount: 1\nPid: 4652 LoopCount: 1\nPid: 10488 LoopCount: 2\nPid: 4652 LoopCount: 2\nPid: 4652 LoopCount: 3\nMain process is ended.\n```\n\n在调用`start`和`join`方法后，父进程就可以等待所有子进程都执行完毕后，再打印出结束的结果。\n\n默认情况下，`join`是无限期的。也就是说，如果有子进程没有运行完毕，主进程会一直等待。这种情况下，如果子进程出现问题陷入了死循环，主进程也会无限等待下去。怎么解决这个问题呢？可以给`join`方法传递一个超时参数，代表最长等待秒数。如果子进程没有在这个指定秒数之内完成，会被强制返回，主进程不再会等待。也就是说这个参数设置了主进程等待该子进程的最长时间。\n\n例如这里传入`1`，代表最长等待`1`秒，代码改写如下：\n\n```python\n    process = []\n    for i in range(2,5):\n        p = MyProcess(i)\n        process.append(p)\n        p.daemon = True\n        p.start()\n    for p in process:\n        p.join(1)\n```\n\n运行结果如下：\n\n```python\nPid: 11936 LoopCount: 0\nPid: 968 LoopCount: 0\nPid: 11572 LoopCount: 0\nPid: 11936 LoopCount: 1\nPid: 968 LoopCount: 1\nPid: 11572 LoopCount: 1\nMain process is ended.\n```\n\n可以看到，有的子进程本来要运行`3`秒，结果运行`1`秒就被强制返回了，由于是守护进程，该子进程被终止了。\n\n## 终止进程\n\n终止进程不止有守护进程这一种做法，我们也可以通过`terminate`方法来终止某个子进程，另外我们还可以通过`is_alive`方法判断进程是否还在运行。\n\n下面看一个实例：\n\n```python\nimport time\nimport multiprocessing\n\ndef process():\n    print('Starting')\n    time.sleep(5)\n    print('Finished')\n\nif __name__ == '__main__':\n    p = multiprocessing.Process(target=process)\n    print('Before:', p, p.is_alive())\n    \n    p.start()\n    print('During:', p, p.is_alive())\n\n    p.terminate()\n    print('Terminate:', p, p.is_alive())\n\n    p.join()\n    print('Joined:', p, p.is_alive())\n```\n\n用`Process`创建了一个进程，接着调用`start`方法启动这个进程，然后调用`terminate`方法将进程终止，最后调用`join`方法。\n\n另外，在进程运行不同的阶段，通过`is_alive`方法判断当前进程是否还在运行。\n\n运行结果如下：\n\n```python\nBefore: <Process(Process-1, initial)> False\nDuring: <Process(Process-1, started)> True\nTerminate: <Process(Process-1, started)> True       \nJoined: <Process(Process-1, stopped[SIGTERM])> False\n```\n\n这里有一个值得注意的地方，在调用`terminate`方法之后，我们用`is_alive`方法获取进程的状态发现依然还是运行状态。在调用`join`方法之后，`is_alive`方法获取进程的运行状态才变为终止状态。\n\n所以，在调用`terminate`方法之后，记得要调用一下`join`方法，这里调用`join`方法可以为进程提供时间来更新对象状态，用来反映出最终的进程终止效果。\n\n## 进程互斥锁\n\n```python\nfrom multiprocessing import Process, Lock\nimport time\n\nclass MyProcess(Process):\n    def __init__(self, loop, lock):\n        Process.__init__(self)\n        self.loop = loop\n        self.lock = lock\n    \n    def run(self):\n        for count in range(self.loop):\n            time.sleep(0.1)\n            self.lock.acquire()\n            print(f'Pid: {self.pid} LoopCount: {count}')\n            self.lock.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n    for i in range(10, 15):\n        p = MyProcess(i, lock)\n        p.start()\n```\n\n在访问一些临界区资源时，使用`Lock`可以有效避免进程同时占用资源而导致的一些问题。\n\n## 信号量\n\n｀multiprocessing`库中的`Semaphore`来实现信号量，实现多个进程共享资源，同时限制可访问的进程数量。\n\n## 道管\n\n管道（`Pipe`）用来实现进程之间的通讯，管道可以是单向的，即`half-duplex`：一个进程负责发消息，另一个进程负责收消息；也可以是双向的`duplex`，即互相收发消息。 默认声明`Pipe`对象是双向管道，如果要创建单向管道，可以在初始化的时候传入`deplex`参数为`False`。\n\n```python\nfrom multiprocessing import Process, Pipe\n\nclass Consumer(Process):\n    def __init__(self, pipe):\n        Process.__init__(self)\n        self.pipe = pipe\n    \n    def run(self):\n        self.pipe.send('Cosumer Worlds')\n        print(f'Consumer Received: {self.pipe.recv()}')\n\nclass Producer(Process):\n    def __init__(self, pipe):\n        Process.__init__(self)\n        self.pipe = pipe\n    \n    def run(self):\n        print(f'Producer Received: {self.pipe.recv()}')\n        self.pipe.send('Producer Words')\n\nif __name__ == '__main__':\n    pipe = Pipe()\n    p = Producer(pipe[0])\n    c = Consumer(pipe[1])\n    p.daemon = c.daemon = True\n    p.start()\n    c.start()\n    p.join()\n    c.join()\n    print('Main Process Ended')\n```\n\n声明了一个默认为双向的管道，然后将管道的两端分别传给两个进程。两个进程互相收发。观察一下结果：\n\n```python\nProducer Received: Cosumer Worlds\nConsumer Received: Producer Words\nMain Process Ended\n```\n\n**管道**`Pipe`就像进程之间搭建的桥梁，利用它可以很方便地实现进程间通信。\n\n## 进程池\n\n> 假如现在我们遇到这么一个问题，我有`10000`个任务，每个任务需要启动一个进程来执行，并且一个进程运行完毕之后要紧接着 启动下一个进程，同时我还需要控制进程的并发数量，不能并发太高，不然`CPU`处理不过来（如果同时运行的进程能维持在一个 最高恒定值当然利用率是最高的）。\n\n那么我们该如何来实现这个需求呢？\n\n用`Process`和`Semaphore`可以实现，但是实现起来比较烦琐。这种需求在平时又是非常常见的。此时，我们就可以派上进程池了，即`multiprocessing`中的`Pool`。 `Pool`可以提供指定数量的进程，供用户调用，当有新的请求提交到`pool`中时，如果池还没有满，就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。\n\n用一个实例来实现一下，代码如下：\n\n```python\nimport time\nfrom multiprocessing import Pool\n\ndef function(index):\n    print(f'Start process: {index}')\n    time.sleep(3)\n    print(f'End process {index}')\n\nif __name__ == '__main__':\n    pool = Pool(processes=3)\n    for i in range(4):\n        pool.apply_async(function, args=(i,))\n    print('Main Process started')\n    pool.close()\n    pool.join()\n    print('Main process ended')\n```\n\n声明了一个大小为`3`的进程池，通过`processes`参数来指定，如果不指定，那么会自动根据处理器内核来分配进程数。接着我们使用`apply_async`方法将进程添加进去，`args`可以用来传递参数。\n\n运行结果如下：\n\n```python\nMain Process started\nStart process: 0\nStart process: 1\nStart process: 2\nEnd process 0\nStart process: 3\nEnd process 1\nEnd process 2\nEnd process 3\nMain process ended\n```\n\n进程池大小为`3`，可以看到有`3`个进程同时执行，第4个进程在等待，在有进程运行完毕之后，第4个进程马上跟着运行，出现了如上的运行效果。\n\n最后，我们要记得调用`close`方法来关闭进程池，使其不再接受新的任务，然后调用`join`方法让主进程等待子进程的退出，等子进程运行完毕之后，主进程接着运行并结束。\n\n上面的写法多少有些烦琐，使用你进程池的`map`方法，可以将上述写法简化很多。\n\n`map`方法是怎么用的呢？第一个参数就是要启动的进程对应的执行方法，第`2`个参数是一个可迭代对象，其中的每个元素会被传递给这个执行方法。\n\n举个例子：现在有一个`list`，里面包含了很多`URL`，定义了一个方法用来抓取每个`URL`内容并解析，那么可以直接在`map`的第一个参数传入方法名，第`2`个参数传入`URL`数组。\n\n用一个实例来感受一下：\n\n```python\nfrom multiprocessing import Pool\nimport urllib.request\nimport urllib.error\n\ndef scrape(url):\n    try:\n        urllib.request.urlopen(url)\n        print(f'URL {url} scraped')\n    except (urllib.error.HTTPError, urllib.error.URLError):\n        print(f'URL {url} not scraped')\n\nif __name__ == '__main__':\n    pool = Pool(processes=3)\n    urls = [\n        'https://www.baidu.com',\n        'https://www.meituan.com',\n        'https://blog.csdn.net',\n        'https://xxxyxxx.net',\n    ]\n    pool.map(scrape, urls)\n    pool.close()\n```\n\n运行结果：\n\n```python\nURL https://www.baidu.com scraped\nURL https://xxxyxxx.net not scraped\nURL https://blog.csdn.net scraped\nURL https://www.meituan.com scraped\n```\n\n这样，就可以实现`3`个进程并行运行。不同的进程相互独立地输出了对应的爬取结果。\n","source":"_posts/python多进程基本原理.md","raw":"---\ntitle: python多进程基本原理\ntags:\n  - python\n  - multiprocessing\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-17 20:04:49\ncategories: Python\npic:\n---\n\n## 多进程的含义\n\n多进程（`Process`）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。\n\n顾名思义，多进程就是启用多个进程同时运行。由于进程是线程的集合，而且进程是由一个或多个线程构成的，所以多进程的运 行意味着有大于或等于进程数量的线程在运行。\n\n## Python多进程的优势\n\n由于进程中`GIL`的存在，`Python`中的多线程并不能很好地发挥多核优势，一个进程中的多个线程，在同一时刻只能有一个线程运行。\n\n对于多进程来说，每个进程都有属于自己的`GIL`，所以，在多核处理器下，多进程的运行是不会受`GIL`的影响的。因此，多进程能更好地发挥多核的优势。\n\n当然，对于爬虫这种`IO`密集型任务来说，多线程和多进程影响差别并不大。对于计算密集型任务来说，`Python`的多进程相比多线程，其多核运行效率会有成倍的提升。\n\n总的来说，`Python`的多进程整体来看是比多线程更有优势的。所以，在条件允许的情况下，能用多进程就尽量用多进程。\n\n不过值得注意的是，由于进程是系统进行资源分配和调度的一个独立单位，所以各个进程之间的数据是无法共享的，如多个进程无法共享一个全局变量，进程之间的数据共享需要有单独的机制来实现到。\n\n## 多进程的实现\n\n在`Python`中也有内置的库来实现多进程，它就是`multiprocessing`。\n\n`multiprocessing`提供了一系列的组件，如`Process（进程`、`Queue（队列）`、`Semaphore（信号量）`、`Pipe（管道）`、`Lock（锁）`、`Pool（进程池）`等，接下来让我们来了解下它们的使用方法。\n\n### 直接使用Process类\n\n在`multiprocessing`中，每一个进程都用一个`Process`类来表示。它的`API`调用如下：\n\n```python\nProcess([group [, target [, name [, args [, kwargs]]]]])\n```\n\n- `target`表示调用对象，你可以传入方法的名字。\n- `args`表示被调用对象的位置参数元组，比如`target`是函数`func`，他有两个参数`m`，`n`，那么`args`就传入`[m, n]`即可。\n- `kwargs`表示调用对象的字典。\n- `name`是别名，相当于给这个进程取一个名字。\n- `group`分组。\n  \n先用一个实例来感受一下：\n\n```python\nimport multiprocessing\n\ndef process(index):\n    print(f'process: {index}')\n\nif __name__ == '__main__':\n    for i in range(5):\n        p = multiprocessing.Process(target=process, args=(i,))\n        p.start()\n```\n\n这是一个实现多进程最基础的方式：通过创建`Process`来新建一个子进程，其中`target`参数传入方法名，`args`是方法的参数，是以 元组的形式传入，其和被调用的方法`process`的参数是一一对应的。\n\n> 注意：这里`args `必须要是一个元组，如果只有一个参数，那也要在元组第一个元素后面加一个逗号，如果没有逗号则和单个元素本身没有区别，无法构成元组，导致参数传递出现问题。\n\n创建完进程之后，我们通过调用`start`方法即可启动进程了。运行结果如下：\n\n```python\nprocess: 0\nprocess: 1\nprocess: 2\nprocess: 3\nprocess: 4\n```\n\n运行了`5`个子进程，每个进程都调用了`process`方法。`process`方法的`index`参数通过`Process`的`args`传入，分别是`0~4`这`5`个序号，最后打印出来，`5`个子进程运行结束。\n\n由于进程是`Python`中最小的资源分配单元，因此这些进程和线程不同，各个进程之间的数据是不会共享的，每启动一个进程，都会独立分配资源。\n\n在当前`CPU`核数足够的情况下，这些不同的进程会分配给不同的`CPU`核来运行，实现真正的并行执行。\n\n运行结果如下：\n\n```python\nCPU number: 4\nChild process name: Process-2 id: 12112\nChild process name: Process-3 id: 14708\nChild process name: Process-1 id: 11208\nChild process name: Process-5 id: 9968\nChild process name: Process-4 id: 11784\nProcess ended\nprocess: 0\nprocess: 1\nprocess: 2\nprocess: 3\nprocess: 4\n```\n\n通过`cpu_count`成功获取了`CPU`核心的数量：`4`个，不同的机器结果可能不同。通过 `active_children`获取到了当前正在活跃运行的进程列表。然后遍历每个进程，并将它们的*名称*和*进程号*打印出来了，这里进程号直接使用`pid`属性即可获取，进程名称直接通过`name`属性即可获取。\n\n## 继承继Process类\n\n在上面的例子中，创建进程是直接使用`Process`这个类来创建的，这是一种创建进程的方式。不过，创建进程的方式不止这一 种，同样，也可以像线程`Thread`一样来通过继承的方式创建一个进程类，进程的基本操作我们在子类的`run`方法中实现即可。\n\n通过一个实例来看一下：\n\n```python\nfrom multiprocessing import Process\nimport time\n\nclass MyProcess(Process):\n    def __init__(self, loop):\n        Process.__init__(self)\n        self.loop = loop\n\n    def run(self):\n        for count in range(self.loop):\n            time.sleep(1)\n            print(f'Pid: {self.pid} LoopCount: {count}')\n\nif __name__ == '__main__':\n    for i in range(2,5):\n        p = MyProcess(i)\n        p.start()\n```\n\n声明了一个构造方法，这个方法接收一个`loop`参数，代表循环次数，并将其设置为全局变量。在`run`方法中，又使用这个`loop`变量循环了`loop`次并打印了当前的进程号和循环次数。\n\n在调用时，用`range`方法得到了`2、3、4`三个数字，并把它们分别初始化了`MyProcess`进程，然后调用`start`方法将进程启动起来。\n\n> 注意：这里进程的执行逻辑需要在`run`方法中实现，启动进程需要调用`start`方法，调用之后`run`方法便会执行。\n\n运行结果如下：\n\n```python\nPid: 13728 LoopCount: 0\nPid: 13560 LoopCount: 0\nPid: 9908 LoopCount: 0 \nPid: 9908 LoopCount: 1\nPid: 13560 LoopCount: 1\nPid: 13728 LoopCount: 1\nPid: 13728 LoopCount: 2\nPid: 9908 LoopCount: 2\nPid: 13728 LoopCount: 3\n```\n\n三个进程分别打印出了`2、3、4`条结果，即进程`13560`打印了`2`次结果，进程`9908` 打印了`3`次结果，进程`13728`打印了`4`次结果。\n\n> 注意，这里的进程`pid`代表进程号，不同机器、不同时刻运行结果可能不同。 \n\n通过上面的方式，非常方便地实现了一个进程的定义。为了复用方便，可以把一些方法写在每个进程类里封装好，在使用时直接初始化一个进程类运行即可。\n\n## 守护进程\n\n在多进程中，同样存在守护进程的概念，如果一个进程被设置为守护进程，当父进程结束后，子进程会自动被终止，我们可以通过设置`daemon`属性来控制是否为守护进程。\n\n还是原来的例子，增加了`deamon`属性的设置：\n\n```python\nfrom multiprocessing import Process\nimport time\n\nclass MyProcess(Process):\n    def __init__(self, loop):\n        Process.__init__(self)\n        self.loop = loop\n\n    def run(self):\n        for count in range(self.loop):\n            time.sleep(1)\n            print(f'Pid: {self.pid} LoopCount: {count}')\n\nif __name__ == '__main__':\n    for i in range(2,5):\n        p = MyProcess(i)\n        p.daemon = True\n        p.start()\n    print('Main process is ended.')\n```\n\n运行结果如下：\n\n```python\nMain process is ended.\n```\n\n结果很简单，因为主进程没有做任何事情，直接输出一句话结束，所以在这时也直接终止了子进程的运行。\n\n这样可以有效防止无控制地生成子进程。这样的写法可以让我们在主进程运行结束后无需额外担心子进程是否关闭，避免了独立子进程的运行。\n\n## 进程等待\n\n上面的运行效果其实不太符合我们预期：主进程运行结束时，子进程（守护进程）也都退出了，子进程什么都没来得及执行。\n\n能不能让所有子进程都执行完了然后再结束呢？当然是可以的，只需要加入`join`方法即可，可以将代码改写如下：\n\n```python\n    process = []\n    for i in range(2,5):\n        p = MyProcess(i)\n        process.append(p)\n        p.daemon = True\n        p.start()\n    for p in process:\n        p.join()\n    print('Main process is ended.')\n```\n\n运行结果如下：\n\n```python\nPid: 13220 LoopCount: 0\nPid: 10488 LoopCount: 0\nPid: 4652 LoopCount: 0\nPid: 13220 LoopCount: 1\nPid: 10488 LoopCount: 1\nPid: 4652 LoopCount: 1\nPid: 10488 LoopCount: 2\nPid: 4652 LoopCount: 2\nPid: 4652 LoopCount: 3\nMain process is ended.\n```\n\n在调用`start`和`join`方法后，父进程就可以等待所有子进程都执行完毕后，再打印出结束的结果。\n\n默认情况下，`join`是无限期的。也就是说，如果有子进程没有运行完毕，主进程会一直等待。这种情况下，如果子进程出现问题陷入了死循环，主进程也会无限等待下去。怎么解决这个问题呢？可以给`join`方法传递一个超时参数，代表最长等待秒数。如果子进程没有在这个指定秒数之内完成，会被强制返回，主进程不再会等待。也就是说这个参数设置了主进程等待该子进程的最长时间。\n\n例如这里传入`1`，代表最长等待`1`秒，代码改写如下：\n\n```python\n    process = []\n    for i in range(2,5):\n        p = MyProcess(i)\n        process.append(p)\n        p.daemon = True\n        p.start()\n    for p in process:\n        p.join(1)\n```\n\n运行结果如下：\n\n```python\nPid: 11936 LoopCount: 0\nPid: 968 LoopCount: 0\nPid: 11572 LoopCount: 0\nPid: 11936 LoopCount: 1\nPid: 968 LoopCount: 1\nPid: 11572 LoopCount: 1\nMain process is ended.\n```\n\n可以看到，有的子进程本来要运行`3`秒，结果运行`1`秒就被强制返回了，由于是守护进程，该子进程被终止了。\n\n## 终止进程\n\n终止进程不止有守护进程这一种做法，我们也可以通过`terminate`方法来终止某个子进程，另外我们还可以通过`is_alive`方法判断进程是否还在运行。\n\n下面看一个实例：\n\n```python\nimport time\nimport multiprocessing\n\ndef process():\n    print('Starting')\n    time.sleep(5)\n    print('Finished')\n\nif __name__ == '__main__':\n    p = multiprocessing.Process(target=process)\n    print('Before:', p, p.is_alive())\n    \n    p.start()\n    print('During:', p, p.is_alive())\n\n    p.terminate()\n    print('Terminate:', p, p.is_alive())\n\n    p.join()\n    print('Joined:', p, p.is_alive())\n```\n\n用`Process`创建了一个进程，接着调用`start`方法启动这个进程，然后调用`terminate`方法将进程终止，最后调用`join`方法。\n\n另外，在进程运行不同的阶段，通过`is_alive`方法判断当前进程是否还在运行。\n\n运行结果如下：\n\n```python\nBefore: <Process(Process-1, initial)> False\nDuring: <Process(Process-1, started)> True\nTerminate: <Process(Process-1, started)> True       \nJoined: <Process(Process-1, stopped[SIGTERM])> False\n```\n\n这里有一个值得注意的地方，在调用`terminate`方法之后，我们用`is_alive`方法获取进程的状态发现依然还是运行状态。在调用`join`方法之后，`is_alive`方法获取进程的运行状态才变为终止状态。\n\n所以，在调用`terminate`方法之后，记得要调用一下`join`方法，这里调用`join`方法可以为进程提供时间来更新对象状态，用来反映出最终的进程终止效果。\n\n## 进程互斥锁\n\n```python\nfrom multiprocessing import Process, Lock\nimport time\n\nclass MyProcess(Process):\n    def __init__(self, loop, lock):\n        Process.__init__(self)\n        self.loop = loop\n        self.lock = lock\n    \n    def run(self):\n        for count in range(self.loop):\n            time.sleep(0.1)\n            self.lock.acquire()\n            print(f'Pid: {self.pid} LoopCount: {count}')\n            self.lock.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n    for i in range(10, 15):\n        p = MyProcess(i, lock)\n        p.start()\n```\n\n在访问一些临界区资源时，使用`Lock`可以有效避免进程同时占用资源而导致的一些问题。\n\n## 信号量\n\n｀multiprocessing`库中的`Semaphore`来实现信号量，实现多个进程共享资源，同时限制可访问的进程数量。\n\n## 道管\n\n管道（`Pipe`）用来实现进程之间的通讯，管道可以是单向的，即`half-duplex`：一个进程负责发消息，另一个进程负责收消息；也可以是双向的`duplex`，即互相收发消息。 默认声明`Pipe`对象是双向管道，如果要创建单向管道，可以在初始化的时候传入`deplex`参数为`False`。\n\n```python\nfrom multiprocessing import Process, Pipe\n\nclass Consumer(Process):\n    def __init__(self, pipe):\n        Process.__init__(self)\n        self.pipe = pipe\n    \n    def run(self):\n        self.pipe.send('Cosumer Worlds')\n        print(f'Consumer Received: {self.pipe.recv()}')\n\nclass Producer(Process):\n    def __init__(self, pipe):\n        Process.__init__(self)\n        self.pipe = pipe\n    \n    def run(self):\n        print(f'Producer Received: {self.pipe.recv()}')\n        self.pipe.send('Producer Words')\n\nif __name__ == '__main__':\n    pipe = Pipe()\n    p = Producer(pipe[0])\n    c = Consumer(pipe[1])\n    p.daemon = c.daemon = True\n    p.start()\n    c.start()\n    p.join()\n    c.join()\n    print('Main Process Ended')\n```\n\n声明了一个默认为双向的管道，然后将管道的两端分别传给两个进程。两个进程互相收发。观察一下结果：\n\n```python\nProducer Received: Cosumer Worlds\nConsumer Received: Producer Words\nMain Process Ended\n```\n\n**管道**`Pipe`就像进程之间搭建的桥梁，利用它可以很方便地实现进程间通信。\n\n## 进程池\n\n> 假如现在我们遇到这么一个问题，我有`10000`个任务，每个任务需要启动一个进程来执行，并且一个进程运行完毕之后要紧接着 启动下一个进程，同时我还需要控制进程的并发数量，不能并发太高，不然`CPU`处理不过来（如果同时运行的进程能维持在一个 最高恒定值当然利用率是最高的）。\n\n那么我们该如何来实现这个需求呢？\n\n用`Process`和`Semaphore`可以实现，但是实现起来比较烦琐。这种需求在平时又是非常常见的。此时，我们就可以派上进程池了，即`multiprocessing`中的`Pool`。 `Pool`可以提供指定数量的进程，供用户调用，当有新的请求提交到`pool`中时，如果池还没有满，就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。\n\n用一个实例来实现一下，代码如下：\n\n```python\nimport time\nfrom multiprocessing import Pool\n\ndef function(index):\n    print(f'Start process: {index}')\n    time.sleep(3)\n    print(f'End process {index}')\n\nif __name__ == '__main__':\n    pool = Pool(processes=3)\n    for i in range(4):\n        pool.apply_async(function, args=(i,))\n    print('Main Process started')\n    pool.close()\n    pool.join()\n    print('Main process ended')\n```\n\n声明了一个大小为`3`的进程池，通过`processes`参数来指定，如果不指定，那么会自动根据处理器内核来分配进程数。接着我们使用`apply_async`方法将进程添加进去，`args`可以用来传递参数。\n\n运行结果如下：\n\n```python\nMain Process started\nStart process: 0\nStart process: 1\nStart process: 2\nEnd process 0\nStart process: 3\nEnd process 1\nEnd process 2\nEnd process 3\nMain process ended\n```\n\n进程池大小为`3`，可以看到有`3`个进程同时执行，第4个进程在等待，在有进程运行完毕之后，第4个进程马上跟着运行，出现了如上的运行效果。\n\n最后，我们要记得调用`close`方法来关闭进程池，使其不再接受新的任务，然后调用`join`方法让主进程等待子进程的退出，等子进程运行完毕之后，主进程接着运行并结束。\n\n上面的写法多少有些烦琐，使用你进程池的`map`方法，可以将上述写法简化很多。\n\n`map`方法是怎么用的呢？第一个参数就是要启动的进程对应的执行方法，第`2`个参数是一个可迭代对象，其中的每个元素会被传递给这个执行方法。\n\n举个例子：现在有一个`list`，里面包含了很多`URL`，定义了一个方法用来抓取每个`URL`内容并解析，那么可以直接在`map`的第一个参数传入方法名，第`2`个参数传入`URL`数组。\n\n用一个实例来感受一下：\n\n```python\nfrom multiprocessing import Pool\nimport urllib.request\nimport urllib.error\n\ndef scrape(url):\n    try:\n        urllib.request.urlopen(url)\n        print(f'URL {url} scraped')\n    except (urllib.error.HTTPError, urllib.error.URLError):\n        print(f'URL {url} not scraped')\n\nif __name__ == '__main__':\n    pool = Pool(processes=3)\n    urls = [\n        'https://www.baidu.com',\n        'https://www.meituan.com',\n        'https://blog.csdn.net',\n        'https://xxxyxxx.net',\n    ]\n    pool.map(scrape, urls)\n    pool.close()\n```\n\n运行结果：\n\n```python\nURL https://www.baidu.com scraped\nURL https://xxxyxxx.net not scraped\nURL https://blog.csdn.net scraped\nURL https://www.meituan.com scraped\n```\n\n这样，就可以实现`3`个进程并行运行。不同的进程相互独立地输出了对应的爬取结果。\n","slug":"python多进程基本原理","published":1,"updated":"2021-06-15T03:24:11.492Z","_id":"ckpapu7kj003mlcxugvgy7fr7","layout":"post","photos":[],"link":"","content":"<h2 id=\"多进程的含义\"><a href=\"#多进程的含义\" class=\"headerlink\" title=\"多进程的含义\"></a>多进程的含义</h2><p>多进程（<code>Process</code>）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p>\n<p>顾名思义，多进程就是启用多个进程同时运行。由于进程是线程的集合，而且进程是由一个或多个线程构成的，所以多进程的运 行意味着有大于或等于进程数量的线程在运行。</p>\n<h2 id=\"Python多进程的优势\"><a href=\"#Python多进程的优势\" class=\"headerlink\" title=\"Python多进程的优势\"></a>Python多进程的优势</h2><p>由于进程中<code>GIL</code>的存在，<code>Python</code>中的多线程并不能很好地发挥多核优势，一个进程中的多个线程，在同一时刻只能有一个线程运行。</p>\n<p>对于多进程来说，每个进程都有属于自己的<code>GIL</code>，所以，在多核处理器下，多进程的运行是不会受<code>GIL</code>的影响的。因此，多进程能更好地发挥多核的优势。</p>\n<p>当然，对于爬虫这种<code>IO</code>密集型任务来说，多线程和多进程影响差别并不大。对于计算密集型任务来说，<code>Python</code>的多进程相比多线程，其多核运行效率会有成倍的提升。</p>\n<p>总的来说，<code>Python</code>的多进程整体来看是比多线程更有优势的。所以，在条件允许的情况下，能用多进程就尽量用多进程。</p>\n<p>不过值得注意的是，由于进程是系统进行资源分配和调度的一个独立单位，所以各个进程之间的数据是无法共享的，如多个进程无法共享一个全局变量，进程之间的数据共享需要有单独的机制来实现到。</p>\n<h2 id=\"多进程的实现\"><a href=\"#多进程的实现\" class=\"headerlink\" title=\"多进程的实现\"></a>多进程的实现</h2><p>在<code>Python</code>中也有内置的库来实现多进程，它就是<code>multiprocessing</code>。</p>\n<p><code>multiprocessing</code>提供了一系列的组件，如<code>Process（进程</code>、<code>Queue（队列）</code>、<code>Semaphore（信号量）</code>、<code>Pipe（管道）</code>、<code>Lock（锁）</code>、<code>Pool（进程池）</code>等，接下来让我们来了解下它们的使用方法。</p>\n<h3 id=\"直接使用Process类\"><a href=\"#直接使用Process类\" class=\"headerlink\" title=\"直接使用Process类\"></a>直接使用Process类</h3><p>在<code>multiprocessing</code>中，每一个进程都用一个<code>Process</code>类来表示。它的<code>API</code>调用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process([group [, target [, name [, args [, kwargs]]]]])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>target</code>表示调用对象，你可以传入方法的名字。</li>\n<li><code>args</code>表示被调用对象的位置参数元组，比如<code>target</code>是函数<code>func</code>，他有两个参数<code>m</code>，<code>n</code>，那么<code>args</code>就传入<code>[m, n]</code>即可。</li>\n<li><code>kwargs</code>表示调用对象的字典。</li>\n<li><code>name</code>是别名，相当于给这个进程取一个名字。</li>\n<li><code>group</code>分组。</li>\n</ul>\n<p>先用一个实例来感受一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process</span>(<span class=\"params\">index</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;process: <span class=\"subst\">&#123;index&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">        p = multiprocessing.Process(target=process, args=(i,))</span><br><span class=\"line\">        p.start()</span><br></pre></td></tr></table></figure>\n\n<p>这是一个实现多进程最基础的方式：通过创建<code>Process</code>来新建一个子进程，其中<code>target</code>参数传入方法名，<code>args</code>是方法的参数，是以 元组的形式传入，其和被调用的方法<code>process</code>的参数是一一对应的。</p>\n<blockquote>\n<p>注意：这里<code>args </code>必须要是一个元组，如果只有一个参数，那也要在元组第一个元素后面加一个逗号，如果没有逗号则和单个元素本身没有区别，无法构成元组，导致参数传递出现问题。</p>\n</blockquote>\n<p>创建完进程之后，我们通过调用<code>start</code>方法即可启动进程了。运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process: <span class=\"number\">0</span></span><br><span class=\"line\">process: <span class=\"number\">1</span></span><br><span class=\"line\">process: <span class=\"number\">2</span></span><br><span class=\"line\">process: <span class=\"number\">3</span></span><br><span class=\"line\">process: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>运行了<code>5</code>个子进程，每个进程都调用了<code>process</code>方法。<code>process</code>方法的<code>index</code>参数通过<code>Process</code>的<code>args</code>传入，分别是<code>0~4</code>这<code>5</code>个序号，最后打印出来，<code>5</code>个子进程运行结束。</p>\n<p>由于进程是<code>Python</code>中最小的资源分配单元，因此这些进程和线程不同，各个进程之间的数据是不会共享的，每启动一个进程，都会独立分配资源。</p>\n<p>在当前<code>CPU</code>核数足够的情况下，这些不同的进程会分配给不同的<code>CPU</code>核来运行，实现真正的并行执行。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CPU number: <span class=\"number\">4</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">2</span> <span class=\"built_in\">id</span>: <span class=\"number\">12112</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">3</span> <span class=\"built_in\">id</span>: <span class=\"number\">14708</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">1</span> <span class=\"built_in\">id</span>: <span class=\"number\">11208</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">5</span> <span class=\"built_in\">id</span>: <span class=\"number\">9968</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">4</span> <span class=\"built_in\">id</span>: <span class=\"number\">11784</span></span><br><span class=\"line\">Process ended</span><br><span class=\"line\">process: <span class=\"number\">0</span></span><br><span class=\"line\">process: <span class=\"number\">1</span></span><br><span class=\"line\">process: <span class=\"number\">2</span></span><br><span class=\"line\">process: <span class=\"number\">3</span></span><br><span class=\"line\">process: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>cpu_count</code>成功获取了<code>CPU</code>核心的数量：<code>4</code>个，不同的机器结果可能不同。通过 <code>active_children</code>获取到了当前正在活跃运行的进程列表。然后遍历每个进程，并将它们的<em>名称</em>和<em>进程号</em>打印出来了，这里进程号直接使用<code>pid</code>属性即可获取，进程名称直接通过<code>name</code>属性即可获取。</p>\n<h2 id=\"继承继Process类\"><a href=\"#继承继Process类\" class=\"headerlink\" title=\"继承继Process类\"></a>继承继Process类</h2><p>在上面的例子中，创建进程是直接使用<code>Process</code>这个类来创建的，这是一种创建进程的方式。不过，创建进程的方式不止这一 种，同样，也可以像线程<code>Thread</code>一样来通过继承的方式创建一个进程类，进程的基本操作我们在子类的<code>run</code>方法中实现即可。</p>\n<p>通过一个实例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcess</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, loop</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.loop = loop</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.loop):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Pid: <span class=\"subst\">&#123;self.pid&#125;</span> LoopCount: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">        p = MyProcess(i)</span><br><span class=\"line\">        p.start()</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个构造方法，这个方法接收一个<code>loop</code>参数，代表循环次数，并将其设置为全局变量。在<code>run</code>方法中，又使用这个<code>loop</code>变量循环了<code>loop</code>次并打印了当前的进程号和循环次数。</p>\n<p>在调用时，用<code>range</code>方法得到了<code>2、3、4</code>三个数字，并把它们分别初始化了<code>MyProcess</code>进程，然后调用<code>start</code>方法将进程启动起来。</p>\n<blockquote>\n<p>注意：这里进程的执行逻辑需要在<code>run</code>方法中实现，启动进程需要调用<code>start</code>方法，调用之后<code>run</code>方法便会执行。</p>\n</blockquote>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">13560</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">9908</span> LoopCount: <span class=\"number\">0</span> </span><br><span class=\"line\">Pid: <span class=\"number\">9908</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">13560</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">9908</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>三个进程分别打印出了<code>2、3、4</code>条结果，即进程<code>13560</code>打印了<code>2</code>次结果，进程<code>9908</code> 打印了<code>3</code>次结果，进程<code>13728</code>打印了<code>4</code>次结果。</p>\n<blockquote>\n<p>注意，这里的进程<code>pid</code>代表进程号，不同机器、不同时刻运行结果可能不同。 </p>\n</blockquote>\n<p>通过上面的方式，非常方便地实现了一个进程的定义。为了复用方便，可以把一些方法写在每个进程类里封装好，在使用时直接初始化一个进程类运行即可。</p>\n<h2 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h2><p>在多进程中，同样存在守护进程的概念，如果一个进程被设置为守护进程，当父进程结束后，子进程会自动被终止，我们可以通过设置<code>daemon</code>属性来控制是否为守护进程。</p>\n<p>还是原来的例子，增加了<code>deamon</code>属性的设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcess</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, loop</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.loop = loop</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.loop):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Pid: <span class=\"subst\">&#123;self.pid&#125;</span> LoopCount: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">        p = MyProcess(i)</span><br><span class=\"line\">        p.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main process is ended.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Main process <span class=\"keyword\">is</span> ended.</span><br></pre></td></tr></table></figure>\n\n<p>结果很简单，因为主进程没有做任何事情，直接输出一句话结束，所以在这时也直接终止了子进程的运行。</p>\n<p>这样可以有效防止无控制地生成子进程。这样的写法可以让我们在主进程运行结束后无需额外担心子进程是否关闭，避免了独立子进程的运行。</p>\n<h2 id=\"进程等待\"><a href=\"#进程等待\" class=\"headerlink\" title=\"进程等待\"></a>进程等待</h2><p>上面的运行效果其实不太符合我们预期：主进程运行结束时，子进程（守护进程）也都退出了，子进程什么都没来得及执行。</p>\n<p>能不能让所有子进程都执行完了然后再结束呢？当然是可以的，只需要加入<code>join</code>方法即可，可以将代码改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">    p = MyProcess(i)</span><br><span class=\"line\">    process.append(p)</span><br><span class=\"line\">    p.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process:</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main process is ended.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pid: <span class=\"number\">13220</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">10488</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">13220</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">10488</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">10488</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">3</span></span><br><span class=\"line\">Main process <span class=\"keyword\">is</span> ended.</span><br></pre></td></tr></table></figure>\n\n<p>在调用<code>start</code>和<code>join</code>方法后，父进程就可以等待所有子进程都执行完毕后，再打印出结束的结果。</p>\n<p>默认情况下，<code>join</code>是无限期的。也就是说，如果有子进程没有运行完毕，主进程会一直等待。这种情况下，如果子进程出现问题陷入了死循环，主进程也会无限等待下去。怎么解决这个问题呢？可以给<code>join</code>方法传递一个超时参数，代表最长等待秒数。如果子进程没有在这个指定秒数之内完成，会被强制返回，主进程不再会等待。也就是说这个参数设置了主进程等待该子进程的最长时间。</p>\n<p>例如这里传入<code>1</code>，代表最长等待<code>1</code>秒，代码改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">    p = MyProcess(i)</span><br><span class=\"line\">    process.append(p)</span><br><span class=\"line\">    p.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process:</span><br><span class=\"line\">    p.join(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pid: <span class=\"number\">11936</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">968</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">11572</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">11936</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">968</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">11572</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Main process <span class=\"keyword\">is</span> ended.</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，有的子进程本来要运行<code>3</code>秒，结果运行<code>1</code>秒就被强制返回了，由于是守护进程，该子进程被终止了。</p>\n<h2 id=\"终止进程\"><a href=\"#终止进程\" class=\"headerlink\" title=\"终止进程\"></a>终止进程</h2><p>终止进程不止有守护进程这一种做法，我们也可以通过<code>terminate</code>方法来终止某个子进程，另外我们还可以通过<code>is_alive</code>方法判断进程是否还在运行。</p>\n<p>下面看一个实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Starting&#x27;</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Finished&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    p = multiprocessing.Process(target=process)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Before:&#x27;</span>, p, p.is_alive())</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;During:&#x27;</span>, p, p.is_alive())</span><br><span class=\"line\"></span><br><span class=\"line\">    p.terminate()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Terminate:&#x27;</span>, p, p.is_alive())</span><br><span class=\"line\"></span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Joined:&#x27;</span>, p, p.is_alive())</span><br></pre></td></tr></table></figure>\n\n<p>用<code>Process</code>创建了一个进程，接着调用<code>start</code>方法启动这个进程，然后调用<code>terminate</code>方法将进程终止，最后调用<code>join</code>方法。</p>\n<p>另外，在进程运行不同的阶段，通过<code>is_alive</code>方法判断当前进程是否还在运行。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before: &lt;Process(Process-<span class=\"number\">1</span>, initial)&gt; <span class=\"literal\">False</span></span><br><span class=\"line\">During: &lt;Process(Process-<span class=\"number\">1</span>, started)&gt; <span class=\"literal\">True</span></span><br><span class=\"line\">Terminate: &lt;Process(Process-<span class=\"number\">1</span>, started)&gt; <span class=\"literal\">True</span>       </span><br><span class=\"line\">Joined: &lt;Process(Process-<span class=\"number\">1</span>, stopped[SIGTERM])&gt; <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有一个值得注意的地方，在调用<code>terminate</code>方法之后，我们用<code>is_alive</code>方法获取进程的状态发现依然还是运行状态。在调用<code>join</code>方法之后，<code>is_alive</code>方法获取进程的运行状态才变为终止状态。</p>\n<p>所以，在调用<code>terminate</code>方法之后，记得要调用一下<code>join</code>方法，这里调用<code>join</code>方法可以为进程提供时间来更新对象状态，用来反映出最终的进程终止效果。</p>\n<h2 id=\"进程互斥锁\"><a href=\"#进程互斥锁\" class=\"headerlink\" title=\"进程互斥锁\"></a>进程互斥锁</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Lock</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcess</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, loop, lock</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.loop = loop</span><br><span class=\"line\">        self.lock = lock</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.loop):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">            self.lock.acquire()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Pid: <span class=\"subst\">&#123;self.pid&#125;</span> LoopCount: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\">            self.lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    lock = Lock()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>, <span class=\"number\">15</span>):</span><br><span class=\"line\">        p = MyProcess(i, lock)</span><br><span class=\"line\">        p.start()</span><br></pre></td></tr></table></figure>\n\n<p>在访问一些临界区资源时，使用<code>Lock</code>可以有效避免进程同时占用资源而导致的一些问题。</p>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>｀multiprocessing<code>库中的</code>Semaphore`来实现信号量，实现多个进程共享资源，同时限制可访问的进程数量。</p>\n<h2 id=\"道管\"><a href=\"#道管\" class=\"headerlink\" title=\"道管\"></a>道管</h2><p>管道（<code>Pipe</code>）用来实现进程之间的通讯，管道可以是单向的，即<code>half-duplex</code>：一个进程负责发消息，另一个进程负责收消息；也可以是双向的<code>duplex</code>，即互相收发消息。 默认声明<code>Pipe</code>对象是双向管道，如果要创建单向管道，可以在初始化的时候传入<code>deplex</code>参数为<code>False</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Pipe</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, pipe</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.pipe = pipe</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.pipe.send(<span class=\"string\">&#x27;Cosumer Worlds&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Consumer Received: <span class=\"subst\">&#123;self.pipe.recv()&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, pipe</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.pipe = pipe</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Producer Received: <span class=\"subst\">&#123;self.pipe.recv()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">        self.pipe.send(<span class=\"string\">&#x27;Producer Words&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pipe = Pipe()</span><br><span class=\"line\">    p = Producer(pipe[<span class=\"number\">0</span>])</span><br><span class=\"line\">    c = Consumer(pipe[<span class=\"number\">1</span>])</span><br><span class=\"line\">    p.daemon = c.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    c.start()</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    c.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main Process Ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个默认为双向的管道，然后将管道的两端分别传给两个进程。两个进程互相收发。观察一下结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Producer Received: Cosumer Worlds</span><br><span class=\"line\">Consumer Received: Producer Words</span><br><span class=\"line\">Main Process Ended</span><br></pre></td></tr></table></figure>\n\n<p><strong>管道</strong><code>Pipe</code>就像进程之间搭建的桥梁，利用它可以很方便地实现进程间通信。</p>\n<h2 id=\"进程池\"><a href=\"#进程池\" class=\"headerlink\" title=\"进程池\"></a>进程池</h2><blockquote>\n<p>假如现在我们遇到这么一个问题，我有<code>10000</code>个任务，每个任务需要启动一个进程来执行，并且一个进程运行完毕之后要紧接着 启动下一个进程，同时我还需要控制进程的并发数量，不能并发太高，不然<code>CPU</code>处理不过来（如果同时运行的进程能维持在一个 最高恒定值当然利用率是最高的）。</p>\n</blockquote>\n<p>那么我们该如何来实现这个需求呢？</p>\n<p>用<code>Process</code>和<code>Semaphore</code>可以实现，但是实现起来比较烦琐。这种需求在平时又是非常常见的。此时，我们就可以派上进程池了，即<code>multiprocessing</code>中的<code>Pool</code>。 <code>Pool</code>可以提供指定数量的进程，供用户调用，当有新的请求提交到<code>pool</code>中时，如果池还没有满，就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。</p>\n<p>用一个实例来实现一下，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">function</span>(<span class=\"params\">index</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Start process: <span class=\"subst\">&#123;index&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;End process <span class=\"subst\">&#123;index&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pool = Pool(processes=<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>):</span><br><span class=\"line\">        pool.apply_async(function, args=(i,))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main Process started&#x27;</span>)</span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main process ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个大小为<code>3</code>的进程池，通过<code>processes</code>参数来指定，如果不指定，那么会自动根据处理器内核来分配进程数。接着我们使用<code>apply_async</code>方法将进程添加进去，<code>args</code>可以用来传递参数。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Main Process started</span><br><span class=\"line\">Start process: <span class=\"number\">0</span></span><br><span class=\"line\">Start process: <span class=\"number\">1</span></span><br><span class=\"line\">Start process: <span class=\"number\">2</span></span><br><span class=\"line\">End process <span class=\"number\">0</span></span><br><span class=\"line\">Start process: <span class=\"number\">3</span></span><br><span class=\"line\">End process <span class=\"number\">1</span></span><br><span class=\"line\">End process <span class=\"number\">2</span></span><br><span class=\"line\">End process <span class=\"number\">3</span></span><br><span class=\"line\">Main process ended</span><br></pre></td></tr></table></figure>\n\n<p>进程池大小为<code>3</code>，可以看到有<code>3</code>个进程同时执行，第4个进程在等待，在有进程运行完毕之后，第4个进程马上跟着运行，出现了如上的运行效果。</p>\n<p>最后，我们要记得调用<code>close</code>方法来关闭进程池，使其不再接受新的任务，然后调用<code>join</code>方法让主进程等待子进程的退出，等子进程运行完毕之后，主进程接着运行并结束。</p>\n<p>上面的写法多少有些烦琐，使用你进程池的<code>map</code>方法，可以将上述写法简化很多。</p>\n<p><code>map</code>方法是怎么用的呢？第一个参数就是要启动的进程对应的执行方法，第<code>2</code>个参数是一个可迭代对象，其中的每个元素会被传递给这个执行方法。</p>\n<p>举个例子：现在有一个<code>list</code>，里面包含了很多<code>URL</code>，定义了一个方法用来抓取每个<code>URL</code>内容并解析，那么可以直接在<code>map</code>的第一个参数传入方法名，第<code>2</code>个参数传入<code>URL</code>数组。</p>\n<p>用一个实例来感受一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        urllib.request.urlopen(url)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;URL <span class=\"subst\">&#123;url&#125;</span> scraped&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> (urllib.error.HTTPError, urllib.error.URLError):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;URL <span class=\"subst\">&#123;url&#125;</span> not scraped&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pool = Pool(processes=<span class=\"number\">3</span>)</span><br><span class=\"line\">    urls = [</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://www.meituan.com&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://blog.csdn.net&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://xxxyxxx.net&#x27;</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    pool.<span class=\"built_in\">map</span>(scrape, urls)</span><br><span class=\"line\">    pool.close()</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL https://www.baidu.com scraped</span><br><span class=\"line\">URL https://xxxyxxx.net <span class=\"keyword\">not</span> scraped</span><br><span class=\"line\">URL https://blog.csdn.net scraped</span><br><span class=\"line\">URL https://www.meituan.com scraped</span><br></pre></td></tr></table></figure>\n\n<p>这样，就可以实现<code>3</code>个进程并行运行。不同的进程相互独立地输出了对应的爬取结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"多进程的含义\"><a href=\"#多进程的含义\" class=\"headerlink\" title=\"多进程的含义\"></a>多进程的含义</h2><p>多进程（<code>Process</code>）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p>\n<p>顾名思义，多进程就是启用多个进程同时运行。由于进程是线程的集合，而且进程是由一个或多个线程构成的，所以多进程的运 行意味着有大于或等于进程数量的线程在运行。</p>\n<h2 id=\"Python多进程的优势\"><a href=\"#Python多进程的优势\" class=\"headerlink\" title=\"Python多进程的优势\"></a>Python多进程的优势</h2><p>由于进程中<code>GIL</code>的存在，<code>Python</code>中的多线程并不能很好地发挥多核优势，一个进程中的多个线程，在同一时刻只能有一个线程运行。</p>\n<p>对于多进程来说，每个进程都有属于自己的<code>GIL</code>，所以，在多核处理器下，多进程的运行是不会受<code>GIL</code>的影响的。因此，多进程能更好地发挥多核的优势。</p>\n<p>当然，对于爬虫这种<code>IO</code>密集型任务来说，多线程和多进程影响差别并不大。对于计算密集型任务来说，<code>Python</code>的多进程相比多线程，其多核运行效率会有成倍的提升。</p>\n<p>总的来说，<code>Python</code>的多进程整体来看是比多线程更有优势的。所以，在条件允许的情况下，能用多进程就尽量用多进程。</p>\n<p>不过值得注意的是，由于进程是系统进行资源分配和调度的一个独立单位，所以各个进程之间的数据是无法共享的，如多个进程无法共享一个全局变量，进程之间的数据共享需要有单独的机制来实现到。</p>\n<h2 id=\"多进程的实现\"><a href=\"#多进程的实现\" class=\"headerlink\" title=\"多进程的实现\"></a>多进程的实现</h2><p>在<code>Python</code>中也有内置的库来实现多进程，它就是<code>multiprocessing</code>。</p>\n<p><code>multiprocessing</code>提供了一系列的组件，如<code>Process（进程</code>、<code>Queue（队列）</code>、<code>Semaphore（信号量）</code>、<code>Pipe（管道）</code>、<code>Lock（锁）</code>、<code>Pool（进程池）</code>等，接下来让我们来了解下它们的使用方法。</p>\n<h3 id=\"直接使用Process类\"><a href=\"#直接使用Process类\" class=\"headerlink\" title=\"直接使用Process类\"></a>直接使用Process类</h3><p>在<code>multiprocessing</code>中，每一个进程都用一个<code>Process</code>类来表示。它的<code>API</code>调用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process([group [, target [, name [, args [, kwargs]]]]])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>target</code>表示调用对象，你可以传入方法的名字。</li>\n<li><code>args</code>表示被调用对象的位置参数元组，比如<code>target</code>是函数<code>func</code>，他有两个参数<code>m</code>，<code>n</code>，那么<code>args</code>就传入<code>[m, n]</code>即可。</li>\n<li><code>kwargs</code>表示调用对象的字典。</li>\n<li><code>name</code>是别名，相当于给这个进程取一个名字。</li>\n<li><code>group</code>分组。</li>\n</ul>\n<p>先用一个实例来感受一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process</span>(<span class=\"params\">index</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;process: <span class=\"subst\">&#123;index&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">        p = multiprocessing.Process(target=process, args=(i,))</span><br><span class=\"line\">        p.start()</span><br></pre></td></tr></table></figure>\n\n<p>这是一个实现多进程最基础的方式：通过创建<code>Process</code>来新建一个子进程，其中<code>target</code>参数传入方法名，<code>args</code>是方法的参数，是以 元组的形式传入，其和被调用的方法<code>process</code>的参数是一一对应的。</p>\n<blockquote>\n<p>注意：这里<code>args </code>必须要是一个元组，如果只有一个参数，那也要在元组第一个元素后面加一个逗号，如果没有逗号则和单个元素本身没有区别，无法构成元组，导致参数传递出现问题。</p>\n</blockquote>\n<p>创建完进程之后，我们通过调用<code>start</code>方法即可启动进程了。运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process: <span class=\"number\">0</span></span><br><span class=\"line\">process: <span class=\"number\">1</span></span><br><span class=\"line\">process: <span class=\"number\">2</span></span><br><span class=\"line\">process: <span class=\"number\">3</span></span><br><span class=\"line\">process: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>运行了<code>5</code>个子进程，每个进程都调用了<code>process</code>方法。<code>process</code>方法的<code>index</code>参数通过<code>Process</code>的<code>args</code>传入，分别是<code>0~4</code>这<code>5</code>个序号，最后打印出来，<code>5</code>个子进程运行结束。</p>\n<p>由于进程是<code>Python</code>中最小的资源分配单元，因此这些进程和线程不同，各个进程之间的数据是不会共享的，每启动一个进程，都会独立分配资源。</p>\n<p>在当前<code>CPU</code>核数足够的情况下，这些不同的进程会分配给不同的<code>CPU</code>核来运行，实现真正的并行执行。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CPU number: <span class=\"number\">4</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">2</span> <span class=\"built_in\">id</span>: <span class=\"number\">12112</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">3</span> <span class=\"built_in\">id</span>: <span class=\"number\">14708</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">1</span> <span class=\"built_in\">id</span>: <span class=\"number\">11208</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">5</span> <span class=\"built_in\">id</span>: <span class=\"number\">9968</span></span><br><span class=\"line\">Child process name: Process-<span class=\"number\">4</span> <span class=\"built_in\">id</span>: <span class=\"number\">11784</span></span><br><span class=\"line\">Process ended</span><br><span class=\"line\">process: <span class=\"number\">0</span></span><br><span class=\"line\">process: <span class=\"number\">1</span></span><br><span class=\"line\">process: <span class=\"number\">2</span></span><br><span class=\"line\">process: <span class=\"number\">3</span></span><br><span class=\"line\">process: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>cpu_count</code>成功获取了<code>CPU</code>核心的数量：<code>4</code>个，不同的机器结果可能不同。通过 <code>active_children</code>获取到了当前正在活跃运行的进程列表。然后遍历每个进程，并将它们的<em>名称</em>和<em>进程号</em>打印出来了，这里进程号直接使用<code>pid</code>属性即可获取，进程名称直接通过<code>name</code>属性即可获取。</p>\n<h2 id=\"继承继Process类\"><a href=\"#继承继Process类\" class=\"headerlink\" title=\"继承继Process类\"></a>继承继Process类</h2><p>在上面的例子中，创建进程是直接使用<code>Process</code>这个类来创建的，这是一种创建进程的方式。不过，创建进程的方式不止这一 种，同样，也可以像线程<code>Thread</code>一样来通过继承的方式创建一个进程类，进程的基本操作我们在子类的<code>run</code>方法中实现即可。</p>\n<p>通过一个实例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcess</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, loop</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.loop = loop</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.loop):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Pid: <span class=\"subst\">&#123;self.pid&#125;</span> LoopCount: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">        p = MyProcess(i)</span><br><span class=\"line\">        p.start()</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个构造方法，这个方法接收一个<code>loop</code>参数，代表循环次数，并将其设置为全局变量。在<code>run</code>方法中，又使用这个<code>loop</code>变量循环了<code>loop</code>次并打印了当前的进程号和循环次数。</p>\n<p>在调用时，用<code>range</code>方法得到了<code>2、3、4</code>三个数字，并把它们分别初始化了<code>MyProcess</code>进程，然后调用<code>start</code>方法将进程启动起来。</p>\n<blockquote>\n<p>注意：这里进程的执行逻辑需要在<code>run</code>方法中实现，启动进程需要调用<code>start</code>方法，调用之后<code>run</code>方法便会执行。</p>\n</blockquote>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">13560</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">9908</span> LoopCount: <span class=\"number\">0</span> </span><br><span class=\"line\">Pid: <span class=\"number\">9908</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">13560</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">9908</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">13728</span> LoopCount: <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>三个进程分别打印出了<code>2、3、4</code>条结果，即进程<code>13560</code>打印了<code>2</code>次结果，进程<code>9908</code> 打印了<code>3</code>次结果，进程<code>13728</code>打印了<code>4</code>次结果。</p>\n<blockquote>\n<p>注意，这里的进程<code>pid</code>代表进程号，不同机器、不同时刻运行结果可能不同。 </p>\n</blockquote>\n<p>通过上面的方式，非常方便地实现了一个进程的定义。为了复用方便，可以把一些方法写在每个进程类里封装好，在使用时直接初始化一个进程类运行即可。</p>\n<h2 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h2><p>在多进程中，同样存在守护进程的概念，如果一个进程被设置为守护进程，当父进程结束后，子进程会自动被终止，我们可以通过设置<code>daemon</code>属性来控制是否为守护进程。</p>\n<p>还是原来的例子，增加了<code>deamon</code>属性的设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcess</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, loop</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.loop = loop</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.loop):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Pid: <span class=\"subst\">&#123;self.pid&#125;</span> LoopCount: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">        p = MyProcess(i)</span><br><span class=\"line\">        p.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main process is ended.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Main process <span class=\"keyword\">is</span> ended.</span><br></pre></td></tr></table></figure>\n\n<p>结果很简单，因为主进程没有做任何事情，直接输出一句话结束，所以在这时也直接终止了子进程的运行。</p>\n<p>这样可以有效防止无控制地生成子进程。这样的写法可以让我们在主进程运行结束后无需额外担心子进程是否关闭，避免了独立子进程的运行。</p>\n<h2 id=\"进程等待\"><a href=\"#进程等待\" class=\"headerlink\" title=\"进程等待\"></a>进程等待</h2><p>上面的运行效果其实不太符合我们预期：主进程运行结束时，子进程（守护进程）也都退出了，子进程什么都没来得及执行。</p>\n<p>能不能让所有子进程都执行完了然后再结束呢？当然是可以的，只需要加入<code>join</code>方法即可，可以将代码改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">    p = MyProcess(i)</span><br><span class=\"line\">    process.append(p)</span><br><span class=\"line\">    p.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process:</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main process is ended.&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pid: <span class=\"number\">13220</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">10488</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">13220</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">10488</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">10488</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">2</span></span><br><span class=\"line\">Pid: <span class=\"number\">4652</span> LoopCount: <span class=\"number\">3</span></span><br><span class=\"line\">Main process <span class=\"keyword\">is</span> ended.</span><br></pre></td></tr></table></figure>\n\n<p>在调用<code>start</code>和<code>join</code>方法后，父进程就可以等待所有子进程都执行完毕后，再打印出结束的结果。</p>\n<p>默认情况下，<code>join</code>是无限期的。也就是说，如果有子进程没有运行完毕，主进程会一直等待。这种情况下，如果子进程出现问题陷入了死循环，主进程也会无限等待下去。怎么解决这个问题呢？可以给<code>join</code>方法传递一个超时参数，代表最长等待秒数。如果子进程没有在这个指定秒数之内完成，会被强制返回，主进程不再会等待。也就是说这个参数设置了主进程等待该子进程的最长时间。</p>\n<p>例如这里传入<code>1</code>，代表最长等待<code>1</code>秒，代码改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">    p = MyProcess(i)</span><br><span class=\"line\">    process.append(p)</span><br><span class=\"line\">    p.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process:</span><br><span class=\"line\">    p.join(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pid: <span class=\"number\">11936</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">968</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">11572</span> LoopCount: <span class=\"number\">0</span></span><br><span class=\"line\">Pid: <span class=\"number\">11936</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">968</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Pid: <span class=\"number\">11572</span> LoopCount: <span class=\"number\">1</span></span><br><span class=\"line\">Main process <span class=\"keyword\">is</span> ended.</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，有的子进程本来要运行<code>3</code>秒，结果运行<code>1</code>秒就被强制返回了，由于是守护进程，该子进程被终止了。</p>\n<h2 id=\"终止进程\"><a href=\"#终止进程\" class=\"headerlink\" title=\"终止进程\"></a>终止进程</h2><p>终止进程不止有守护进程这一种做法，我们也可以通过<code>terminate</code>方法来终止某个子进程，另外我们还可以通过<code>is_alive</code>方法判断进程是否还在运行。</p>\n<p>下面看一个实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Starting&#x27;</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Finished&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    p = multiprocessing.Process(target=process)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Before:&#x27;</span>, p, p.is_alive())</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;During:&#x27;</span>, p, p.is_alive())</span><br><span class=\"line\"></span><br><span class=\"line\">    p.terminate()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Terminate:&#x27;</span>, p, p.is_alive())</span><br><span class=\"line\"></span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Joined:&#x27;</span>, p, p.is_alive())</span><br></pre></td></tr></table></figure>\n\n<p>用<code>Process</code>创建了一个进程，接着调用<code>start</code>方法启动这个进程，然后调用<code>terminate</code>方法将进程终止，最后调用<code>join</code>方法。</p>\n<p>另外，在进程运行不同的阶段，通过<code>is_alive</code>方法判断当前进程是否还在运行。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before: &lt;Process(Process-<span class=\"number\">1</span>, initial)&gt; <span class=\"literal\">False</span></span><br><span class=\"line\">During: &lt;Process(Process-<span class=\"number\">1</span>, started)&gt; <span class=\"literal\">True</span></span><br><span class=\"line\">Terminate: &lt;Process(Process-<span class=\"number\">1</span>, started)&gt; <span class=\"literal\">True</span>       </span><br><span class=\"line\">Joined: &lt;Process(Process-<span class=\"number\">1</span>, stopped[SIGTERM])&gt; <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>这里有一个值得注意的地方，在调用<code>terminate</code>方法之后，我们用<code>is_alive</code>方法获取进程的状态发现依然还是运行状态。在调用<code>join</code>方法之后，<code>is_alive</code>方法获取进程的运行状态才变为终止状态。</p>\n<p>所以，在调用<code>terminate</code>方法之后，记得要调用一下<code>join</code>方法，这里调用<code>join</code>方法可以为进程提供时间来更新对象状态，用来反映出最终的进程终止效果。</p>\n<h2 id=\"进程互斥锁\"><a href=\"#进程互斥锁\" class=\"headerlink\" title=\"进程互斥锁\"></a>进程互斥锁</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Lock</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcess</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, loop, lock</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.loop = loop</span><br><span class=\"line\">        self.lock = lock</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> count <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.loop):</span><br><span class=\"line\">            time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">            self.lock.acquire()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Pid: <span class=\"subst\">&#123;self.pid&#125;</span> LoopCount: <span class=\"subst\">&#123;count&#125;</span>&#x27;</span>)</span><br><span class=\"line\">            self.lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    lock = Lock()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>, <span class=\"number\">15</span>):</span><br><span class=\"line\">        p = MyProcess(i, lock)</span><br><span class=\"line\">        p.start()</span><br></pre></td></tr></table></figure>\n\n<p>在访问一些临界区资源时，使用<code>Lock</code>可以有效避免进程同时占用资源而导致的一些问题。</p>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>｀multiprocessing<code>库中的</code>Semaphore`来实现信号量，实现多个进程共享资源，同时限制可访问的进程数量。</p>\n<h2 id=\"道管\"><a href=\"#道管\" class=\"headerlink\" title=\"道管\"></a>道管</h2><p>管道（<code>Pipe</code>）用来实现进程之间的通讯，管道可以是单向的，即<code>half-duplex</code>：一个进程负责发消息，另一个进程负责收消息；也可以是双向的<code>duplex</code>，即互相收发消息。 默认声明<code>Pipe</code>对象是双向管道，如果要创建单向管道，可以在初始化的时候传入<code>deplex</code>参数为<code>False</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Pipe</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, pipe</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.pipe = pipe</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.pipe.send(<span class=\"string\">&#x27;Cosumer Worlds&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Consumer Received: <span class=\"subst\">&#123;self.pipe.recv()&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span>(<span class=\"params\">Process</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, pipe</span>):</span></span><br><span class=\"line\">        Process.__init__(self)</span><br><span class=\"line\">        self.pipe = pipe</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Producer Received: <span class=\"subst\">&#123;self.pipe.recv()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">        self.pipe.send(<span class=\"string\">&#x27;Producer Words&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pipe = Pipe()</span><br><span class=\"line\">    p = Producer(pipe[<span class=\"number\">0</span>])</span><br><span class=\"line\">    c = Consumer(pipe[<span class=\"number\">1</span>])</span><br><span class=\"line\">    p.daemon = c.daemon = <span class=\"literal\">True</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    c.start()</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    c.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main Process Ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个默认为双向的管道，然后将管道的两端分别传给两个进程。两个进程互相收发。观察一下结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Producer Received: Cosumer Worlds</span><br><span class=\"line\">Consumer Received: Producer Words</span><br><span class=\"line\">Main Process Ended</span><br></pre></td></tr></table></figure>\n\n<p><strong>管道</strong><code>Pipe</code>就像进程之间搭建的桥梁，利用它可以很方便地实现进程间通信。</p>\n<h2 id=\"进程池\"><a href=\"#进程池\" class=\"headerlink\" title=\"进程池\"></a>进程池</h2><blockquote>\n<p>假如现在我们遇到这么一个问题，我有<code>10000</code>个任务，每个任务需要启动一个进程来执行，并且一个进程运行完毕之后要紧接着 启动下一个进程，同时我还需要控制进程的并发数量，不能并发太高，不然<code>CPU</code>处理不过来（如果同时运行的进程能维持在一个 最高恒定值当然利用率是最高的）。</p>\n</blockquote>\n<p>那么我们该如何来实现这个需求呢？</p>\n<p>用<code>Process</code>和<code>Semaphore</code>可以实现，但是实现起来比较烦琐。这种需求在平时又是非常常见的。此时，我们就可以派上进程池了，即<code>multiprocessing</code>中的<code>Pool</code>。 <code>Pool</code>可以提供指定数量的进程，供用户调用，当有新的请求提交到<code>pool</code>中时，如果池还没有满，就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。</p>\n<p>用一个实例来实现一下，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">function</span>(<span class=\"params\">index</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Start process: <span class=\"subst\">&#123;index&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;End process <span class=\"subst\">&#123;index&#125;</span>&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pool = Pool(processes=<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>):</span><br><span class=\"line\">        pool.apply_async(function, args=(i,))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main Process started&#x27;</span>)</span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Main process ended&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个大小为<code>3</code>的进程池，通过<code>processes</code>参数来指定，如果不指定，那么会自动根据处理器内核来分配进程数。接着我们使用<code>apply_async</code>方法将进程添加进去，<code>args</code>可以用来传递参数。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Main Process started</span><br><span class=\"line\">Start process: <span class=\"number\">0</span></span><br><span class=\"line\">Start process: <span class=\"number\">1</span></span><br><span class=\"line\">Start process: <span class=\"number\">2</span></span><br><span class=\"line\">End process <span class=\"number\">0</span></span><br><span class=\"line\">Start process: <span class=\"number\">3</span></span><br><span class=\"line\">End process <span class=\"number\">1</span></span><br><span class=\"line\">End process <span class=\"number\">2</span></span><br><span class=\"line\">End process <span class=\"number\">3</span></span><br><span class=\"line\">Main process ended</span><br></pre></td></tr></table></figure>\n\n<p>进程池大小为<code>3</code>，可以看到有<code>3</code>个进程同时执行，第4个进程在等待，在有进程运行完毕之后，第4个进程马上跟着运行，出现了如上的运行效果。</p>\n<p>最后，我们要记得调用<code>close</code>方法来关闭进程池，使其不再接受新的任务，然后调用<code>join</code>方法让主进程等待子进程的退出，等子进程运行完毕之后，主进程接着运行并结束。</p>\n<p>上面的写法多少有些烦琐，使用你进程池的<code>map</code>方法，可以将上述写法简化很多。</p>\n<p><code>map</code>方法是怎么用的呢？第一个参数就是要启动的进程对应的执行方法，第<code>2</code>个参数是一个可迭代对象，其中的每个元素会被传递给这个执行方法。</p>\n<p>举个例子：现在有一个<code>list</code>，里面包含了很多<code>URL</code>，定义了一个方法用来抓取每个<code>URL</code>内容并解析，那么可以直接在<code>map</code>的第一个参数传入方法名，第<code>2</code>个参数传入<code>URL</code>数组。</p>\n<p>用一个实例来感受一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        urllib.request.urlopen(url)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;URL <span class=\"subst\">&#123;url&#125;</span> scraped&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> (urllib.error.HTTPError, urllib.error.URLError):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;URL <span class=\"subst\">&#123;url&#125;</span> not scraped&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pool = Pool(processes=<span class=\"number\">3</span>)</span><br><span class=\"line\">    urls = [</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://www.meituan.com&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://blog.csdn.net&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;https://xxxyxxx.net&#x27;</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    pool.<span class=\"built_in\">map</span>(scrape, urls)</span><br><span class=\"line\">    pool.close()</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL https://www.baidu.com scraped</span><br><span class=\"line\">URL https://xxxyxxx.net <span class=\"keyword\">not</span> scraped</span><br><span class=\"line\">URL https://blog.csdn.net scraped</span><br><span class=\"line\">URL https://www.meituan.com scraped</span><br></pre></td></tr></table></figure>\n\n<p>这样，就可以实现<code>3</code>个进程并行运行。不同的进程相互独立地输出了对应的爬取结果。</p>\n"},{"title":"requests库的基本使用","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-18T07:44:10.000Z","pic":null,"_content":"\n## 安装\n\n`requests`是一个第三方库，使用`pip`下载安装。\n\n```python\npip3 install requests\n```\n\n## 实例引入\n\n用`Python`写爬虫的第一步就是模拟发起一个请求，把网页的源代码获取下来。\n\n在浏览器中输入一个`URL`并回车，实际上就是让浏览器帮我们发起一个`GET`类型的`HTTP`请求，浏览器得到源代码后，把它渲染出来就可以看到网页内容了。\n\n那如果想用`requests`来获取源代码，应该怎么办呢？很简单，`requests`这个库提供了一个`get`方法，调用这个方法，并传入对应的`URL`就能得到网页的源代码。\n\n比如这里有一个示例网站:[https://static1.scrape.cuiqingcai.com/](https://static1.scrape.cuiqingcai.com/)，其内容如下：\n\n![示列网站](Screenshot_2.webp)\n\n这个网站展示了一些电影数据，如果想要把这个网页里面的数据爬下来，比如获取各个电影的名称、上映时间等信息，然后把它存下来的话，该怎么做呢？\n\n第一步当然就是获取它的网页源代码了。\n\n可以用`requests`这个库轻松地完成这个过程，代码的写法是这样的：\n\n```python\nimport requests\n\nr = requests.get(url='https://static1.scrape.cuiqingcai.com/', verify=False)\nprint(r.text)\n```\n\n输出结果如下：\n\n```html\n<html lang=\"en\">\n<head>\n  \n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <link rel=\"icon\" href=\"/static/img/favicon.ico\">\n  <title>Scrape | Movie</title>\n  \n\n  <link href=\"/static/css/app.css\" type=\"text/css\" rel=\"stylesheet\">\n  \n<link href=\"/static/css/index.css\" type=\"text/css\" rel=\"stylesheet\">\n\n</head>\n<body>\n<div id=\"app\">\n  <div data-v-74e8b908=\"\" class=\"el-row\" id=\"header\">\n    <div data-v-74e8b908=\"\" class=\"container el-col el-col-18 el-col-offset-3\">\n      <div data-v-74e8b908=\"\" class=\"el-row\">\n        <div data-v-74e8b908=\"\" class=\"logo el-col el-col-4\">\n          <a data-v-74e8b908=\"\" href=\"/\" class=\"router-link-exact-active router-link-active\">\n            <img data-v-74e8b908=\"\" src=\"/static/img/logo.png\" class=\"logo-image\">\n            <span data-v-74e8b908=\"\" class=\"logo-title\">Scrape</span>\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n    \n...\n\n         <li class=\"number\">\n              <a href=\"/page/7\">7</a>\n            </li>\n            \n            \n            \n            <li class=\"number\">\n              <a href=\"/page/8\">8</a>\n            </li>\n            \n            \n            \n            <li class=\"number\">\n              <a href=\"/page/9\">9</a>\n            </li>\n            \n            \n            \n            <li class=\"number\">\n              <a href=\"/page/10\">10</a>\n            </li>\n            \n            \n          </ul>\n          \n          <a href=\"/page/2\" class=\"next\">\n            <button type=\"button\" class=\"btn-next\"><i class=\"el-icon el-icon-arrow-right\"></i></button>\n          </a>\n          \n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n</div>\n</body>\n\nProcess finished with exit code 0\n\n```\n\n由于网页内容比较多，这里省略了大部分内容。\n\n不过看运行结果，我们已经成功获取网页的`HTML`源代码，里面包含了电影的标题、类型、上映时间，等等。\n\n把网页源代码获取下来之后，下一步我们把想要的数据提取出来，数据的爬取就完成了。\n\n## 请求\n\n`HTTP`中最常见的请求之一就是`GET`请求。\n\n### `GET`请求\n\n换一个示例网站，其`URL`为[http://httpbin.org/get](http://httpbin.org/get)，如果客户端发起的是`GET`请求的话，该网站会判断并返回相应的请求信息，包括 `Headers`、`IP`等。 我们还是用相同的方法来发起一个`GET请求`，代码如下：\n\n```python\nimport requests\n\nr = requests.get(url='http://httpbin.org/get', verify=False)\nprint(r.text)\n```\n\n返回结果：\n\n```html\n{\n  \"args\": {}, \n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a3a8ad-070f8b95711f7821709e24ed\"\n  },\n  \"origin\": \"202.62.113.207\",\n  \"url\": \"http://httpbin.org/get\"\n}\n```\n\n可以发现，成功发起了`GET`请求，也通过这个网站的返回结果得到了请求所携带的信息，包括`Headers`、`URL`、`IP`，等等。\n\n对于`GET`请求，我们知道`URL`后面是可以跟上一些参数的，如果我们现在想添加两个参数，其中`name`是`germey`，`age`是`25`，`URL`就可以写成如下内容：\n\n```python\nhttp://httpbin.org/get?name=germey&age=25\n```\n\n要构造这个请求链接，是不是要直接写成这样呢？\n\n```python\nr = requests.get('http://httpbin.org/get?name=germey&age=25')\n```\n\n这样也可以，但如果这些参数还需要手动拼接，未免有点不人性化。\n\n一般情况下，这种信息我们利用`params`这个参数就可以直接传递了，示例如下：\n\n```python\nimport requests\n\ndata = {\n    'name': 'holy',\n    'age': 25\n}\n\nr = requests.get(url='http://httpbin.org/get', params=data, verify=False)\nprint(r.text)\n```\n\n返回结果：\n\n```html\n{\n  \"args\": {\n    \"age\": \"25\",\n    \"name\": \"holy\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a3ab05-51321f5c7eeb7b0573bb5510\"\n  },\n  \"origin\": \"202.62.113.207\",\n  \"url\": \"http://httpbin.org/get?name=holy&age=25\"\n}\n```\n\n把`URL`参数通过字典的形式传给`get`方法的`params`参数，通过返回信息可以判断，请求的链接自动被构造成了：*http://httpbin.org/get?age=22&name=germey*。\n\n网页的返回类型实际上是`str`类型，但是它很特殊，是`JSON`格式的。所以，如果想直接解析返回结果，得到一个`JSON`格式的数据的话，可以直接调用`json`方法。\n\n示例如下：\n\n```python\nimport requests\n\ndata = {\n    'name': 'holy',\n    'age': 25\n}\n\nr = requests.get(url='http://httpbin.org/get', params=data, verify=False)\nprint(type(r.text))\nprint(r.json())\nprint(type(r.json()))\n```\n\n结果如下：\n\n```shell\n<class 'str'>\n{'args': {'age': '25', 'name': 'holy'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.25.1', 'X-Amzn-Trace-Id': 'Root=1-60a3ac52-425e713a2907d0302f298070'}, 'origin': '202.62.113.207', 'url': 'http://httpbin.org/get?name=holy&age=25'}\n<class 'dict'>\n```\n\n调用`json`方法，就可以将返回结果是`JSON`格式的字符串转化为字典。 但需要注意的是，如果返回结果不是`JSON`格式，便会出现解析错误，抛出`json.decoder.JSONDecodeError`异常。\n\n### 抓取网页\n\n上面的请求链接返回的是`JSON`形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容。下面以本课时最初的实例页面为例，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：\n\n```python\nimport requests\nimport re\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', verify=False)\npattern = re.compile('<h2.*?>(.*?)</h2>', re.S)\ntitles = re.findall(pattern, r.text)\nprint(titles)\n```\n\n运行结果：\n\n```python\n['霸王别姬 - Farewell My Concubine', '这个杀手不太冷 - Léon', '肖申克的救赎 - The Shawshank Redemption', '泰坦尼克号 - Titanic', '罗马假日 - Roman Holiday', '唐伯虎点秋香 - Flirting Scholar', '乱世佳人 - Gone with the Wind', '喜剧之王 - The King of Comedy', ' 楚门的世界 - The Truman Show', '狮子王 - The Lion King']\n```\n\n### 抓取二进制数据\n\n抓取的是网站的一个页面，实际上它返回的是一个`HTML`文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？\n\n图片、音频、视频这些文件本质上都是由**二进制码**组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。\n\n下面以 GitHub 的站点图标为例来看一下：\n\n```python\nimport requests\n\nr = requests.get('https://github.com/favicon.ico')\nprint(r.text)\nprint(r.content)\n```\n\n这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标。\n\n前者出现了乱码，后者结果前带有一个`b`，这代表是`bytes`类型的数据。\n\n由于图片是二进制数据，所以前者在打印时转化为`str`类型，也就是图片直接转化为字符串，这当然会出现乱码。\n\n上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，将刚才提取到的信息保存下来就好了，代码如下：\n\n```python\nimport requests \n\nr = requests.get('https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png', verify=False) \n\nwith open('baidu.png', 'wb') as f: \n    f.write(r.content)\n```\n\n这里用了`open`方法，它的第一个参数是文件名称，第二个参数代表以二进制的形式打开，可以向文件里写入二进制数据。\n\n运行结束之后，可以发现在文件夹中出现了名为`baidu.png`的图标。\n\n### 添加添headers\n\n在发起一个`HTTP`请求的时候，会有一个请求头`Request Headers`，那么这个怎么来设置呢？\n\n很简单，使用`headers`参数就可以完成了。\n\n在刚才的实例中，是没有设置`Request Headers`信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。\n\n要添加`Headers`信息，比如添加一个`User-Agent`字段，可以这么写：\n\n```python\nimport requests\n\nheaders = { \n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'\n}\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', headers=headers, verify=False) \n\nprint(r.text)\n```\n\n当然，我们可以在`headers`这个参数中任意添加其他的字段信息。\n\n### POST请求\n\n使用`requests`实现`post`请求，示例如下：\n\n```python\nimport requests\n\ndata = {'name':'germey', 'age':'25'}\nr = requests.post(\"http://httpbin.org/post\", data=data)\n\nprint(r.text)\n```\n\n这里还是请求[http://httpbin.org/post](http://httpbin.org/post)，该网站可以判断如果请求是`POST`方式，就把相关请求信息返回。\n\n运行结果如下：\n\n```python\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {},\n  \"form\": {\n    \"age\": \"25\",\n    \"name\": \"germey\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Content-Length\": \"18\",\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a402c2-68a523624a9ca353207a3a5e\"\n  },\n  \"json\": null,\n  \"origin\": \"202.62.113.207\",\n  \"url\": \"http://httpbin.org/post\"\n}\n```\n\n### 响应\n\n发送请求后，得到的就是响应，即`Response`。\n\n在上面的实例中，使用`text`和`content`获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如`状态码`、`响应头`、`Cookies`等。示例如下:\n\n```python\nimport requests\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', verify=False)\n\nprint(type(r.status_code), r.status_code)\nprint(type(r.headers), r.headers)\nprint(type(r.cookies), r.cookies)\nprint(type(r.url), r.url)\nprint(type(r.history), r.history)\n```\n\n这里分别打印输出`status_code`属性得到状态码，输出`headers`属性得到响应头，输出`cookies`属性得到`Cookies`，输出`url`属性得到`URL`，输出`history`属性得到请求历史。\n\n运行结果如下：\n\n```python\n<class 'int'> 200\n<class 'requests.structures.CaseInsensitiveDict'> {'Date': 'Wed, 19 May 2021 12:52:03 GMT', 'Content-Type': 'text/html; charset=utf-8', 'Content-Length': '41538', 'Connection': 'keep-alive', 'X-Frame-Options': 'DENY', 'X-Content-Type-Options': 'nosniff', 'Expires': 'Wed, 19 May 2021 13:01:46 GMT', 'Cache-Control': 'max-age=600', 'Strict-Transport-Security': 'max-age=15724800; includeSubDomains'}\n<class 'requests.cookies.RequestsCookieJar'> <RequestsCookieJar[]>\n<class 'str'> https://static1.scrape.cuiqingcai.com/\n<class 'list'> []\n```\n\n`headers`和`cookies`这两个属性得到的结果分别是`CaseInsensitiveDict`和`RequestsCookieJar`类型。\n\n状态码是用来表示响应状态的，比如返回`200`代表我们得到的响应是没问题的，上面的例子正好输出的结果也是`200`，所以可以通过判断`Response`的状态码来确认是否爬取成功。\n\n`requests`还提供了一个内置的状态码查询对象`requests.codes`，用法示例如下：\n\n```python\nimport requests\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', verify=False)\nexit() if not r.status_code == requests.codes.ok else print('Request successfully')\n```\n\n这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用`requests.codes.ok`得到的是成功的状态码`200`。\n\n这样的话，我们就不用再在程序里面写状态码对应的数字了，用字符串表示状态码会显得更加直观。\n\n下面列出了返回码和相应的查询条件：\n\n```python\n# 信息性状态码\n100: ('continue',),\n101: ('switching_protocols',),\n102: ('processing',),\n103: ('checkpoint',),\n122: ('uri_too_long', 'request_uri_too_long'),\n\n# 成功状态码\n200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),\n201: ('created',),\n202: ('accepted',),\n203: ('non_authoritative_info', 'non_authoritative_information'),\n204: ('no_content',),\n205: ('reset_content', 'reset'),\n206: ('partial_content', 'partial'),\n207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),\n208: ('already_reported',),\n226: ('im_used',),\n\n# 重定向状态码\n300: ('multiple_choices',),\n301: ('moved_permanently', 'moved', '\\\\o-'),\n302: ('found',),\n303: ('see_other', 'other'),\n304: ('not_modified',),\n305: ('use_proxy',),\n306: ('switch_proxy',),\n307: ('temporary_redirect', 'temporary_moved', 'temporary'),\n308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0 \n\n# 客户端错误状态码 \n400: ('bad_request', 'bad'), \n401: ('unauthorized',), \n402: ('payment_required', 'payment'), \n403: ('forbidden',), \n404: ('not_found', '-o-'), \n405: ('method_not_allowed', 'not_allowed'), \n406: ('not_acceptable',), \n407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),\n408: ('request_timeout', 'timeout'), \n409: ('conflict',),\n410: ('gone',),\n411: ('length_required',),\n412: ('precondition_failed', 'precondition'),\n413: ('request_entity_too_large',),\n414: ('request_uri_too_large',),\n415: ('unsupported_media_type', 'unsupported_media', 'media_type'),\n416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),\n417: ('expectation_failed',),\n418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),\n421: ('misdirected_request',),\n422: ('unprocessable_entity', 'unprocessable'),\n423: ('locked',),\n424: ('failed_dependency', 'dependency'),\n425: ('unordered_collection', 'unordered'),\n426: ('upgrade_required', 'upgrade'),\n428: ('precondition_required', 'precondition'),\n429: ('too_many_requests', 'too_many'),\n431: ('header_fields_too_large', 'fields_too_large'),\n444: ('no_response', 'none'),\n449: ('retry_with', 'retry'),\n450: ('blocked_by_windows_parental_controls', 'parental_controls'),\n451: ('unavailable_for_legal_reasons', 'legal_reasons'),\n499: ('client_closed_request',), \n\n# 服务端错误状态码\n500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),\n501: ('not_implemented',),\n502: ('bad_gateway',),\n503: ('service_unavailable', 'unavailable'),\n504: ('gateway_timeout',),\n505: ('http_version_not_supported', 'http_version'),\n506: ('variant_also_negotiates',),\n507: ('insufficient_storage',),\n509: ('bandwidth_limit_exceeded', 'bandwidth'),\n510: ('not_extended',),\n511: ('network_authentication_required', 'network_auth', 'network_authentication')\n```\n\n比如，如果想判断结果是不是`404`状态，可以用`requests.codes.not_found`来比对。\n\n## 高级用法\n\n刚才，了解`requests`的基本用法，如基本的`GET、POST`请求以及`Response`对象。当然`requests`能做到的不仅这些，它几乎可以完成`HTTP`的所有操作。\n\n下面来了解下`requests`的一些高级用法，如文件上传、`Cookies`设置、代理设置等。\n\n### 文件上传\n\n`requests`可以模拟提交一些数据。假如有的网站需要上传文件，也可以用它来实现，示例如下：\n\n```python\nimport requests\n\nfiles = {'file':open('baidu.png', 'rb')}\nr = requests.post('http://httpbin.org/post', files=files)\nprint(r.text)\n```\n\n要注意的是，`baidu.png`需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。运行结果如下：\n\n```shell  \n{\n  \"args\": {}, \n  \"data\": \"\", \n  \"files\": {\n    \"file\": \"data:application/octet-stream;base64,iVBORw0KGgoAAAANSU......\"\n  },\n  \"form\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Content-Length\": \"15589\",\n    \"Content-Type\": \"multipart/form-data; boundary=7e0556b094615781fff3b0ed4316dccd\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a72501-36f606570785cb9d4356df71\"\n  },\n  \"json\": null,\n  \"origin\": \"202.62.112.143\",\n  \"url\": \"http://httpbin.org/post\"\n}\n```\n\n以上省略部分内容，这个网站会返回响应，里面包含`files`这个字段，而`form`字段是空的，这证明文件上传部分会单独有一个`files`字段来标识。\n\n### Cookies\n\n获取`Cookies`。\n\n```python\nimport requests\n\nr = requests.get('http://www.baidu.com')\nprint(r.cookies)\nfor key, value in r.cookies.items():\n    print(key + '=' + value)\n```\n\n运行结果如下：\n\n```shell\n<RequestsCookieJar[<Cookie BDORZ=27315 for .baidu.com/>]>\nBDORZ=27315\n```\n\n调用`cookies`属性即可成功得到`Cookies`，可以发现它是`RequestCookieJar`类型。然后用`items` 方法将其转化为元组组成的列表，遍历输出每一个`Cookie`的名称和值，实现`Cookie`的遍历解析。\n\n可以直接用`Cookie`来维持登录状态，下面我们以`GitHub`为例来说明一下，首先我们登录`GitHub`，然后将`Headers`中的`Cookie`内容复制下来，如图所示：\n\n![](Screenshot_1.webp)\n\n可以替换成你自己的`Cookie`，将其设置到`Headers`里面，然后发送请求。\n\n### Session维持\n\n在`requests`中，如果直接利用`get`或`post`等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的`Session`，相当于你用两个浏览器打开了不同的页面。\n\n设想这样一个场景，第一个请求利用`post`方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次`get`方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不相关的`Session`，能成功获取个人信息吗？当然不能。\n\n解决这个问题的主要方法就是维持同一个`Session`，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置`Cookies`，那该怎么办呢？这时候就有了新的利器——**`Session`对象**。 利用它，可以方便地维护一个`Session`，而且不用担心`Cookies`的问题，它会帮我们自动处理好。示例如下：\n\n```python\nimport requests\n\nrequests.get('http://httpbin.org/cookies/set/number/123456789', verify=False)\nr = requests.get('http://httpbin.org/cookies', verify=False)\n\nprint(r.text)\n```\n\n运行结果如下：\n\n```python\n{\n  \"cookies\": {}\n}\n```\n\n这并不行。再用 Session试试看：\n\n```python\nimport requests\n\ns = requests.Session()\ns.get('http://httpbin.org/cookies/set/number/123456789')\nr = s.get('http://httpbin.org/cookies')\n\nprint(r.text)\n```\n\n运行结果如下：\n\n```python\n{\n  \"cookies\": {\n    \"number\": \"123456789\"\n  }\n}\n```\n\n利用`Session`，可以做到模拟同一个`Session`而不用担心`Cookies`的问题。它通常用于模拟登录成功之后再进行下一步的操作。\n\n### SSL证书验证\n\n现在很多网站都要求使用`HTTPS`协议，但是有些网站可能并没有设置好`HTTPS`证书，或者网站的`HTTPS`证书不被`CA`机构认可，这时候，这些网站可能就会出现`SSL`证书错误的提示。\n\n比如示例网站：[https://static2.scrape.cuiqingcai.com/](https://static2.scrape.cuiqingcai.com/)。 用浏览器打开这个`URL`，则会提示**「您的连接不是私密连接」**这样的错误，如图所示：\n\n![示例网站](Screenshot_3.webp)\n\n那如果我们一定要爬取这个网站怎么办呢？我们可以使用`verify`参数控制是否验证证书，如果将其设置为`False`，在请求时就不会再验证证书是否有效。如果不加`verify`参数的话，默认值是`True`，会自动验证。\n\n改写代码如下：\n\n```python\nimport requests\nresponse = requests.get('https://static2.scrape.cuiqingcai.com/', verify=False) \nprint(response.status_code) \n```\n\n这样就会打印出请求成功的状态码：\n\n```python\n/usr/local/lib/python3.7/site-packages/urllib3/connectionpool.py:857: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html\nInsecureRequestWarning) 200 \n```\n\n不过发现报了一个警告，它建议我们给它指定证书。可以通过设置忽略警告的方式来屏蔽这个警告：\n\n```python\nimport requests from requests.packages \nimport urllib3 \n\nurllib3.disable_warnings() \nresponse = requests.get('https://static2.scrape.cuiqingcai.com/', verify=False) \nprint(response.status_code)\n```\n\n或者通过捕获警告到日志的方式忽略警告：\n\n```python\nimport logging \nimport requests \n\nlogging.captureWarnings(True) \nresponse = requests.get('https://static2.scrape.cuiqingcai.com/', verify=False) \nprint(response.status_code)\n```\n\n当然，也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组： \n\n```python\nimport requests response = requests.get('https://static2.scrape.cuiqingcai.com/', cert=('/path/server.crt', '/path/server.key')) \nprint(response.status_code)\n```\n\n上面的代码是演示实例，要有`crt`和`key`文件，并且指定它们的路径。另外注意，本地私有证书的`key`必须是解密状态，加密状态的`key`是不支持的。\n\n### 超时时间\n\n在本机网络状况不好或者服务器网络响应延迟甚至无响应时，可能会等待很久才能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到`timeout`参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：\n\n```python\nimport requests \nr = requests.get('https://httpbin.org/get', timeout=1) \nprint(r.status_code)\n```\n\n通过这样的方式将超时时间设置为`1`秒，如果`1`秒内没有响应，那就抛出异常。\n\n实际上，请求分为两个阶段，即连接`（connect）`和读取`（read）`。 上面设置的`timeout`将用作连接和读取这二者的`timeout`总和。\n\n如果要分别指定，就可以传入一个元组：\n\n```python\nr = requests.get('https://httpbin.org/get', timeout=(5, 30))\n```\n\n如果想永久等待，可以直接将`timeout`设置为`None`，或者不设置直接留空，因为默认是`None`。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：\n\n```python\nr = requests.get('https://httpbin.org/get', timeout=None) \n```\n\n或直接不加参数：\n\n```python\nr = requests.get('https://httpbin.org/get')\n```\n\n###　身份认证\n\n在访问某些设置了身份认证的网站时，例如：[https://static3.scrape.cuiqingcai.com/](https://static3.scrape.cuiqingcai.com/)，我们可能会遇到这样的认证窗口，如图所示：\n\n![认证](Screenshot_4.webp)\n\n如果遇到了这种情况，那就是这个网站启用了基本身份认证，英文叫作`HTTP Basic Access Authentication`，它是一种用来允许网页浏览器或其他客户端程序在请求时提供**用户名**和**口令形式**的身份凭证的一种登录验证方式。 如果遇到了这种情况，怎么用`reqeusts`来爬取呢，当然也有办法。\n\n可以使用`requests`自带的身份认证功能，通过`auth`参数即可设置，示例如下：\n\n```python\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nr = requests.get('https://static3.scrape.cuiqingcai.com/', auth=HTTPBasicAuth('admin', 'admin'), verify=False)\nprint(r.status_code)\n```\n\n成功的话，返回状态码`200`。\n\n如果参数都传一个`HTTPBasicAuth`类，就显得有点烦琐了，所以`requests`提供了一个更简单的写法，可以直接传一个元组，它会默认使用`HTTPBasicAuth`这个类来认证。\n\n上面的代码可以直接简写如下：\n\n```python\nimport requests\nr = requests.get('https://static3.scrape.cuiqingcai.com/', auth=('admin', 'admin'))\nprint(r.status_code)\n```\n\n此外，`requests`还提供了其他认证方式，如`OAuth`认证，不过此时需要安装`oauth`包，安装命令如下：\n\n```python\npip3 install requests_oauthlib\n```\n\n使用`OAuth1`认证的方法如下：\n\n```python\nimport requests from requests_oauthlib \nimport OAuth1 \nurl = 'https://api.twitter.com/1.1/account/verify_credentials.json' \nauth = OAuth1('YOUR_APP_KEY', 'YOUR_APP_SECRET', 'USER_OAUTH_TOKEN', 'USER_OAUTH_TOKEN_SECRET')\nrequests.get(url, auth=auth) \n```\n\n更多详细的功能就可以参考`requests_oauthlib`的官方文档：[https://requests-oauthlib.readthedocs.org/](https://requests-oauthlib.readthedocs.org/)，不再赘述。\n\n### 代理设置\n\n某些网站在测试的时候请求几次，能正常获取内容。但是对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的`IP`，导致一定时间段内无法访问。\n\n为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到`proxies`参数。可以用这样的方式设置：\n\n```python\nimport requests\nproxies = { \n  'http': 'http://10.10.10.10:1080', \n  'https': 'http://10.10.10.10:1080', \n}\nrequests.get('https://httpbin.org/get', proxies=proxies) \n```\n\n当然，直接运行这个实例或许行不通，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。\n\n若代理需要使用上文所述的身份认证，可以使用类似`ttp://user:password@host:port`这样的语法来设置代理，示例如下：\n\n```python\nimport requests\nproxies = {'https': 'http://user:password@10.10.10.10:1080/',} \nrequests.get('https://httpbin.org/get', proxies=proxies)\n```\n\n除了基本的`HTTP`代理外，`requests`还支持`SOCKS`协议的代理。\n\n首先，需要安装`socks`这个库：\n\n```python\npip3 install \"requests[socks]\"\n```\n\n然后就可以使用`SOCKS`协议代理了，示例如下：\n\n```python\nimport requests\nproxies = { \n  'http': 'socks5://user:password@host:port', \n  'https': 'socks5://user:password@host:port' \n}\nrequests.get('https://httpbin.org/get', proxies=proxies)\n```\n","source":"_posts/requests库的基本使用.md","raw":"---\ntitle: requests库的基本使用\ntags:\n  - python\n  - requests\n  - 爬虫\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-18 15:44:10\ncategories: 爬虫\npic:\n---\n\n## 安装\n\n`requests`是一个第三方库，使用`pip`下载安装。\n\n```python\npip3 install requests\n```\n\n## 实例引入\n\n用`Python`写爬虫的第一步就是模拟发起一个请求，把网页的源代码获取下来。\n\n在浏览器中输入一个`URL`并回车，实际上就是让浏览器帮我们发起一个`GET`类型的`HTTP`请求，浏览器得到源代码后，把它渲染出来就可以看到网页内容了。\n\n那如果想用`requests`来获取源代码，应该怎么办呢？很简单，`requests`这个库提供了一个`get`方法，调用这个方法，并传入对应的`URL`就能得到网页的源代码。\n\n比如这里有一个示例网站:[https://static1.scrape.cuiqingcai.com/](https://static1.scrape.cuiqingcai.com/)，其内容如下：\n\n![示列网站](Screenshot_2.webp)\n\n这个网站展示了一些电影数据，如果想要把这个网页里面的数据爬下来，比如获取各个电影的名称、上映时间等信息，然后把它存下来的话，该怎么做呢？\n\n第一步当然就是获取它的网页源代码了。\n\n可以用`requests`这个库轻松地完成这个过程，代码的写法是这样的：\n\n```python\nimport requests\n\nr = requests.get(url='https://static1.scrape.cuiqingcai.com/', verify=False)\nprint(r.text)\n```\n\n输出结果如下：\n\n```html\n<html lang=\"en\">\n<head>\n  \n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <link rel=\"icon\" href=\"/static/img/favicon.ico\">\n  <title>Scrape | Movie</title>\n  \n\n  <link href=\"/static/css/app.css\" type=\"text/css\" rel=\"stylesheet\">\n  \n<link href=\"/static/css/index.css\" type=\"text/css\" rel=\"stylesheet\">\n\n</head>\n<body>\n<div id=\"app\">\n  <div data-v-74e8b908=\"\" class=\"el-row\" id=\"header\">\n    <div data-v-74e8b908=\"\" class=\"container el-col el-col-18 el-col-offset-3\">\n      <div data-v-74e8b908=\"\" class=\"el-row\">\n        <div data-v-74e8b908=\"\" class=\"logo el-col el-col-4\">\n          <a data-v-74e8b908=\"\" href=\"/\" class=\"router-link-exact-active router-link-active\">\n            <img data-v-74e8b908=\"\" src=\"/static/img/logo.png\" class=\"logo-image\">\n            <span data-v-74e8b908=\"\" class=\"logo-title\">Scrape</span>\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n    \n...\n\n         <li class=\"number\">\n              <a href=\"/page/7\">7</a>\n            </li>\n            \n            \n            \n            <li class=\"number\">\n              <a href=\"/page/8\">8</a>\n            </li>\n            \n            \n            \n            <li class=\"number\">\n              <a href=\"/page/9\">9</a>\n            </li>\n            \n            \n            \n            <li class=\"number\">\n              <a href=\"/page/10\">10</a>\n            </li>\n            \n            \n          </ul>\n          \n          <a href=\"/page/2\" class=\"next\">\n            <button type=\"button\" class=\"btn-next\"><i class=\"el-icon el-icon-arrow-right\"></i></button>\n          </a>\n          \n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n</div>\n</body>\n\nProcess finished with exit code 0\n\n```\n\n由于网页内容比较多，这里省略了大部分内容。\n\n不过看运行结果，我们已经成功获取网页的`HTML`源代码，里面包含了电影的标题、类型、上映时间，等等。\n\n把网页源代码获取下来之后，下一步我们把想要的数据提取出来，数据的爬取就完成了。\n\n## 请求\n\n`HTTP`中最常见的请求之一就是`GET`请求。\n\n### `GET`请求\n\n换一个示例网站，其`URL`为[http://httpbin.org/get](http://httpbin.org/get)，如果客户端发起的是`GET`请求的话，该网站会判断并返回相应的请求信息，包括 `Headers`、`IP`等。 我们还是用相同的方法来发起一个`GET请求`，代码如下：\n\n```python\nimport requests\n\nr = requests.get(url='http://httpbin.org/get', verify=False)\nprint(r.text)\n```\n\n返回结果：\n\n```html\n{\n  \"args\": {}, \n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a3a8ad-070f8b95711f7821709e24ed\"\n  },\n  \"origin\": \"202.62.113.207\",\n  \"url\": \"http://httpbin.org/get\"\n}\n```\n\n可以发现，成功发起了`GET`请求，也通过这个网站的返回结果得到了请求所携带的信息，包括`Headers`、`URL`、`IP`，等等。\n\n对于`GET`请求，我们知道`URL`后面是可以跟上一些参数的，如果我们现在想添加两个参数，其中`name`是`germey`，`age`是`25`，`URL`就可以写成如下内容：\n\n```python\nhttp://httpbin.org/get?name=germey&age=25\n```\n\n要构造这个请求链接，是不是要直接写成这样呢？\n\n```python\nr = requests.get('http://httpbin.org/get?name=germey&age=25')\n```\n\n这样也可以，但如果这些参数还需要手动拼接，未免有点不人性化。\n\n一般情况下，这种信息我们利用`params`这个参数就可以直接传递了，示例如下：\n\n```python\nimport requests\n\ndata = {\n    'name': 'holy',\n    'age': 25\n}\n\nr = requests.get(url='http://httpbin.org/get', params=data, verify=False)\nprint(r.text)\n```\n\n返回结果：\n\n```html\n{\n  \"args\": {\n    \"age\": \"25\",\n    \"name\": \"holy\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a3ab05-51321f5c7eeb7b0573bb5510\"\n  },\n  \"origin\": \"202.62.113.207\",\n  \"url\": \"http://httpbin.org/get?name=holy&age=25\"\n}\n```\n\n把`URL`参数通过字典的形式传给`get`方法的`params`参数，通过返回信息可以判断，请求的链接自动被构造成了：*http://httpbin.org/get?age=22&name=germey*。\n\n网页的返回类型实际上是`str`类型，但是它很特殊，是`JSON`格式的。所以，如果想直接解析返回结果，得到一个`JSON`格式的数据的话，可以直接调用`json`方法。\n\n示例如下：\n\n```python\nimport requests\n\ndata = {\n    'name': 'holy',\n    'age': 25\n}\n\nr = requests.get(url='http://httpbin.org/get', params=data, verify=False)\nprint(type(r.text))\nprint(r.json())\nprint(type(r.json()))\n```\n\n结果如下：\n\n```shell\n<class 'str'>\n{'args': {'age': '25', 'name': 'holy'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.25.1', 'X-Amzn-Trace-Id': 'Root=1-60a3ac52-425e713a2907d0302f298070'}, 'origin': '202.62.113.207', 'url': 'http://httpbin.org/get?name=holy&age=25'}\n<class 'dict'>\n```\n\n调用`json`方法，就可以将返回结果是`JSON`格式的字符串转化为字典。 但需要注意的是，如果返回结果不是`JSON`格式，便会出现解析错误，抛出`json.decoder.JSONDecodeError`异常。\n\n### 抓取网页\n\n上面的请求链接返回的是`JSON`形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容。下面以本课时最初的实例页面为例，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：\n\n```python\nimport requests\nimport re\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', verify=False)\npattern = re.compile('<h2.*?>(.*?)</h2>', re.S)\ntitles = re.findall(pattern, r.text)\nprint(titles)\n```\n\n运行结果：\n\n```python\n['霸王别姬 - Farewell My Concubine', '这个杀手不太冷 - Léon', '肖申克的救赎 - The Shawshank Redemption', '泰坦尼克号 - Titanic', '罗马假日 - Roman Holiday', '唐伯虎点秋香 - Flirting Scholar', '乱世佳人 - Gone with the Wind', '喜剧之王 - The King of Comedy', ' 楚门的世界 - The Truman Show', '狮子王 - The Lion King']\n```\n\n### 抓取二进制数据\n\n抓取的是网站的一个页面，实际上它返回的是一个`HTML`文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？\n\n图片、音频、视频这些文件本质上都是由**二进制码**组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。\n\n下面以 GitHub 的站点图标为例来看一下：\n\n```python\nimport requests\n\nr = requests.get('https://github.com/favicon.ico')\nprint(r.text)\nprint(r.content)\n```\n\n这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标。\n\n前者出现了乱码，后者结果前带有一个`b`，这代表是`bytes`类型的数据。\n\n由于图片是二进制数据，所以前者在打印时转化为`str`类型，也就是图片直接转化为字符串，这当然会出现乱码。\n\n上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，将刚才提取到的信息保存下来就好了，代码如下：\n\n```python\nimport requests \n\nr = requests.get('https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png', verify=False) \n\nwith open('baidu.png', 'wb') as f: \n    f.write(r.content)\n```\n\n这里用了`open`方法，它的第一个参数是文件名称，第二个参数代表以二进制的形式打开，可以向文件里写入二进制数据。\n\n运行结束之后，可以发现在文件夹中出现了名为`baidu.png`的图标。\n\n### 添加添headers\n\n在发起一个`HTTP`请求的时候，会有一个请求头`Request Headers`，那么这个怎么来设置呢？\n\n很简单，使用`headers`参数就可以完成了。\n\n在刚才的实例中，是没有设置`Request Headers`信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。\n\n要添加`Headers`信息，比如添加一个`User-Agent`字段，可以这么写：\n\n```python\nimport requests\n\nheaders = { \n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'\n}\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', headers=headers, verify=False) \n\nprint(r.text)\n```\n\n当然，我们可以在`headers`这个参数中任意添加其他的字段信息。\n\n### POST请求\n\n使用`requests`实现`post`请求，示例如下：\n\n```python\nimport requests\n\ndata = {'name':'germey', 'age':'25'}\nr = requests.post(\"http://httpbin.org/post\", data=data)\n\nprint(r.text)\n```\n\n这里还是请求[http://httpbin.org/post](http://httpbin.org/post)，该网站可以判断如果请求是`POST`方式，就把相关请求信息返回。\n\n运行结果如下：\n\n```python\n{\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {},\n  \"form\": {\n    \"age\": \"25\",\n    \"name\": \"germey\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Content-Length\": \"18\",\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a402c2-68a523624a9ca353207a3a5e\"\n  },\n  \"json\": null,\n  \"origin\": \"202.62.113.207\",\n  \"url\": \"http://httpbin.org/post\"\n}\n```\n\n### 响应\n\n发送请求后，得到的就是响应，即`Response`。\n\n在上面的实例中，使用`text`和`content`获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如`状态码`、`响应头`、`Cookies`等。示例如下:\n\n```python\nimport requests\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', verify=False)\n\nprint(type(r.status_code), r.status_code)\nprint(type(r.headers), r.headers)\nprint(type(r.cookies), r.cookies)\nprint(type(r.url), r.url)\nprint(type(r.history), r.history)\n```\n\n这里分别打印输出`status_code`属性得到状态码，输出`headers`属性得到响应头，输出`cookies`属性得到`Cookies`，输出`url`属性得到`URL`，输出`history`属性得到请求历史。\n\n运行结果如下：\n\n```python\n<class 'int'> 200\n<class 'requests.structures.CaseInsensitiveDict'> {'Date': 'Wed, 19 May 2021 12:52:03 GMT', 'Content-Type': 'text/html; charset=utf-8', 'Content-Length': '41538', 'Connection': 'keep-alive', 'X-Frame-Options': 'DENY', 'X-Content-Type-Options': 'nosniff', 'Expires': 'Wed, 19 May 2021 13:01:46 GMT', 'Cache-Control': 'max-age=600', 'Strict-Transport-Security': 'max-age=15724800; includeSubDomains'}\n<class 'requests.cookies.RequestsCookieJar'> <RequestsCookieJar[]>\n<class 'str'> https://static1.scrape.cuiqingcai.com/\n<class 'list'> []\n```\n\n`headers`和`cookies`这两个属性得到的结果分别是`CaseInsensitiveDict`和`RequestsCookieJar`类型。\n\n状态码是用来表示响应状态的，比如返回`200`代表我们得到的响应是没问题的，上面的例子正好输出的结果也是`200`，所以可以通过判断`Response`的状态码来确认是否爬取成功。\n\n`requests`还提供了一个内置的状态码查询对象`requests.codes`，用法示例如下：\n\n```python\nimport requests\n\nr = requests.get('https://static1.scrape.cuiqingcai.com/', verify=False)\nexit() if not r.status_code == requests.codes.ok else print('Request successfully')\n```\n\n这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用`requests.codes.ok`得到的是成功的状态码`200`。\n\n这样的话，我们就不用再在程序里面写状态码对应的数字了，用字符串表示状态码会显得更加直观。\n\n下面列出了返回码和相应的查询条件：\n\n```python\n# 信息性状态码\n100: ('continue',),\n101: ('switching_protocols',),\n102: ('processing',),\n103: ('checkpoint',),\n122: ('uri_too_long', 'request_uri_too_long'),\n\n# 成功状态码\n200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'),\n201: ('created',),\n202: ('accepted',),\n203: ('non_authoritative_info', 'non_authoritative_information'),\n204: ('no_content',),\n205: ('reset_content', 'reset'),\n206: ('partial_content', 'partial'),\n207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),\n208: ('already_reported',),\n226: ('im_used',),\n\n# 重定向状态码\n300: ('multiple_choices',),\n301: ('moved_permanently', 'moved', '\\\\o-'),\n302: ('found',),\n303: ('see_other', 'other'),\n304: ('not_modified',),\n305: ('use_proxy',),\n306: ('switch_proxy',),\n307: ('temporary_redirect', 'temporary_moved', 'temporary'),\n308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0 \n\n# 客户端错误状态码 \n400: ('bad_request', 'bad'), \n401: ('unauthorized',), \n402: ('payment_required', 'payment'), \n403: ('forbidden',), \n404: ('not_found', '-o-'), \n405: ('method_not_allowed', 'not_allowed'), \n406: ('not_acceptable',), \n407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),\n408: ('request_timeout', 'timeout'), \n409: ('conflict',),\n410: ('gone',),\n411: ('length_required',),\n412: ('precondition_failed', 'precondition'),\n413: ('request_entity_too_large',),\n414: ('request_uri_too_large',),\n415: ('unsupported_media_type', 'unsupported_media', 'media_type'),\n416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),\n417: ('expectation_failed',),\n418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),\n421: ('misdirected_request',),\n422: ('unprocessable_entity', 'unprocessable'),\n423: ('locked',),\n424: ('failed_dependency', 'dependency'),\n425: ('unordered_collection', 'unordered'),\n426: ('upgrade_required', 'upgrade'),\n428: ('precondition_required', 'precondition'),\n429: ('too_many_requests', 'too_many'),\n431: ('header_fields_too_large', 'fields_too_large'),\n444: ('no_response', 'none'),\n449: ('retry_with', 'retry'),\n450: ('blocked_by_windows_parental_controls', 'parental_controls'),\n451: ('unavailable_for_legal_reasons', 'legal_reasons'),\n499: ('client_closed_request',), \n\n# 服务端错误状态码\n500: ('internal_server_error', 'server_error', '/o\\\\', '✗'),\n501: ('not_implemented',),\n502: ('bad_gateway',),\n503: ('service_unavailable', 'unavailable'),\n504: ('gateway_timeout',),\n505: ('http_version_not_supported', 'http_version'),\n506: ('variant_also_negotiates',),\n507: ('insufficient_storage',),\n509: ('bandwidth_limit_exceeded', 'bandwidth'),\n510: ('not_extended',),\n511: ('network_authentication_required', 'network_auth', 'network_authentication')\n```\n\n比如，如果想判断结果是不是`404`状态，可以用`requests.codes.not_found`来比对。\n\n## 高级用法\n\n刚才，了解`requests`的基本用法，如基本的`GET、POST`请求以及`Response`对象。当然`requests`能做到的不仅这些，它几乎可以完成`HTTP`的所有操作。\n\n下面来了解下`requests`的一些高级用法，如文件上传、`Cookies`设置、代理设置等。\n\n### 文件上传\n\n`requests`可以模拟提交一些数据。假如有的网站需要上传文件，也可以用它来实现，示例如下：\n\n```python\nimport requests\n\nfiles = {'file':open('baidu.png', 'rb')}\nr = requests.post('http://httpbin.org/post', files=files)\nprint(r.text)\n```\n\n要注意的是，`baidu.png`需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。运行结果如下：\n\n```shell  \n{\n  \"args\": {}, \n  \"data\": \"\", \n  \"files\": {\n    \"file\": \"data:application/octet-stream;base64,iVBORw0KGgoAAAANSU......\"\n  },\n  \"form\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Content-Length\": \"15589\",\n    \"Content-Type\": \"multipart/form-data; boundary=7e0556b094615781fff3b0ed4316dccd\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"python-requests/2.25.1\",\n    \"X-Amzn-Trace-Id\": \"Root=1-60a72501-36f606570785cb9d4356df71\"\n  },\n  \"json\": null,\n  \"origin\": \"202.62.112.143\",\n  \"url\": \"http://httpbin.org/post\"\n}\n```\n\n以上省略部分内容，这个网站会返回响应，里面包含`files`这个字段，而`form`字段是空的，这证明文件上传部分会单独有一个`files`字段来标识。\n\n### Cookies\n\n获取`Cookies`。\n\n```python\nimport requests\n\nr = requests.get('http://www.baidu.com')\nprint(r.cookies)\nfor key, value in r.cookies.items():\n    print(key + '=' + value)\n```\n\n运行结果如下：\n\n```shell\n<RequestsCookieJar[<Cookie BDORZ=27315 for .baidu.com/>]>\nBDORZ=27315\n```\n\n调用`cookies`属性即可成功得到`Cookies`，可以发现它是`RequestCookieJar`类型。然后用`items` 方法将其转化为元组组成的列表，遍历输出每一个`Cookie`的名称和值，实现`Cookie`的遍历解析。\n\n可以直接用`Cookie`来维持登录状态，下面我们以`GitHub`为例来说明一下，首先我们登录`GitHub`，然后将`Headers`中的`Cookie`内容复制下来，如图所示：\n\n![](Screenshot_1.webp)\n\n可以替换成你自己的`Cookie`，将其设置到`Headers`里面，然后发送请求。\n\n### Session维持\n\n在`requests`中，如果直接利用`get`或`post`等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的`Session`，相当于你用两个浏览器打开了不同的页面。\n\n设想这样一个场景，第一个请求利用`post`方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次`get`方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不相关的`Session`，能成功获取个人信息吗？当然不能。\n\n解决这个问题的主要方法就是维持同一个`Session`，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置`Cookies`，那该怎么办呢？这时候就有了新的利器——**`Session`对象**。 利用它，可以方便地维护一个`Session`，而且不用担心`Cookies`的问题，它会帮我们自动处理好。示例如下：\n\n```python\nimport requests\n\nrequests.get('http://httpbin.org/cookies/set/number/123456789', verify=False)\nr = requests.get('http://httpbin.org/cookies', verify=False)\n\nprint(r.text)\n```\n\n运行结果如下：\n\n```python\n{\n  \"cookies\": {}\n}\n```\n\n这并不行。再用 Session试试看：\n\n```python\nimport requests\n\ns = requests.Session()\ns.get('http://httpbin.org/cookies/set/number/123456789')\nr = s.get('http://httpbin.org/cookies')\n\nprint(r.text)\n```\n\n运行结果如下：\n\n```python\n{\n  \"cookies\": {\n    \"number\": \"123456789\"\n  }\n}\n```\n\n利用`Session`，可以做到模拟同一个`Session`而不用担心`Cookies`的问题。它通常用于模拟登录成功之后再进行下一步的操作。\n\n### SSL证书验证\n\n现在很多网站都要求使用`HTTPS`协议，但是有些网站可能并没有设置好`HTTPS`证书，或者网站的`HTTPS`证书不被`CA`机构认可，这时候，这些网站可能就会出现`SSL`证书错误的提示。\n\n比如示例网站：[https://static2.scrape.cuiqingcai.com/](https://static2.scrape.cuiqingcai.com/)。 用浏览器打开这个`URL`，则会提示**「您的连接不是私密连接」**这样的错误，如图所示：\n\n![示例网站](Screenshot_3.webp)\n\n那如果我们一定要爬取这个网站怎么办呢？我们可以使用`verify`参数控制是否验证证书，如果将其设置为`False`，在请求时就不会再验证证书是否有效。如果不加`verify`参数的话，默认值是`True`，会自动验证。\n\n改写代码如下：\n\n```python\nimport requests\nresponse = requests.get('https://static2.scrape.cuiqingcai.com/', verify=False) \nprint(response.status_code) \n```\n\n这样就会打印出请求成功的状态码：\n\n```python\n/usr/local/lib/python3.7/site-packages/urllib3/connectionpool.py:857: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html\nInsecureRequestWarning) 200 \n```\n\n不过发现报了一个警告，它建议我们给它指定证书。可以通过设置忽略警告的方式来屏蔽这个警告：\n\n```python\nimport requests from requests.packages \nimport urllib3 \n\nurllib3.disable_warnings() \nresponse = requests.get('https://static2.scrape.cuiqingcai.com/', verify=False) \nprint(response.status_code)\n```\n\n或者通过捕获警告到日志的方式忽略警告：\n\n```python\nimport logging \nimport requests \n\nlogging.captureWarnings(True) \nresponse = requests.get('https://static2.scrape.cuiqingcai.com/', verify=False) \nprint(response.status_code)\n```\n\n当然，也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组： \n\n```python\nimport requests response = requests.get('https://static2.scrape.cuiqingcai.com/', cert=('/path/server.crt', '/path/server.key')) \nprint(response.status_code)\n```\n\n上面的代码是演示实例，要有`crt`和`key`文件，并且指定它们的路径。另外注意，本地私有证书的`key`必须是解密状态，加密状态的`key`是不支持的。\n\n### 超时时间\n\n在本机网络状况不好或者服务器网络响应延迟甚至无响应时，可能会等待很久才能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到`timeout`参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：\n\n```python\nimport requests \nr = requests.get('https://httpbin.org/get', timeout=1) \nprint(r.status_code)\n```\n\n通过这样的方式将超时时间设置为`1`秒，如果`1`秒内没有响应，那就抛出异常。\n\n实际上，请求分为两个阶段，即连接`（connect）`和读取`（read）`。 上面设置的`timeout`将用作连接和读取这二者的`timeout`总和。\n\n如果要分别指定，就可以传入一个元组：\n\n```python\nr = requests.get('https://httpbin.org/get', timeout=(5, 30))\n```\n\n如果想永久等待，可以直接将`timeout`设置为`None`，或者不设置直接留空，因为默认是`None`。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：\n\n```python\nr = requests.get('https://httpbin.org/get', timeout=None) \n```\n\n或直接不加参数：\n\n```python\nr = requests.get('https://httpbin.org/get')\n```\n\n###　身份认证\n\n在访问某些设置了身份认证的网站时，例如：[https://static3.scrape.cuiqingcai.com/](https://static3.scrape.cuiqingcai.com/)，我们可能会遇到这样的认证窗口，如图所示：\n\n![认证](Screenshot_4.webp)\n\n如果遇到了这种情况，那就是这个网站启用了基本身份认证，英文叫作`HTTP Basic Access Authentication`，它是一种用来允许网页浏览器或其他客户端程序在请求时提供**用户名**和**口令形式**的身份凭证的一种登录验证方式。 如果遇到了这种情况，怎么用`reqeusts`来爬取呢，当然也有办法。\n\n可以使用`requests`自带的身份认证功能，通过`auth`参数即可设置，示例如下：\n\n```python\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nr = requests.get('https://static3.scrape.cuiqingcai.com/', auth=HTTPBasicAuth('admin', 'admin'), verify=False)\nprint(r.status_code)\n```\n\n成功的话，返回状态码`200`。\n\n如果参数都传一个`HTTPBasicAuth`类，就显得有点烦琐了，所以`requests`提供了一个更简单的写法，可以直接传一个元组，它会默认使用`HTTPBasicAuth`这个类来认证。\n\n上面的代码可以直接简写如下：\n\n```python\nimport requests\nr = requests.get('https://static3.scrape.cuiqingcai.com/', auth=('admin', 'admin'))\nprint(r.status_code)\n```\n\n此外，`requests`还提供了其他认证方式，如`OAuth`认证，不过此时需要安装`oauth`包，安装命令如下：\n\n```python\npip3 install requests_oauthlib\n```\n\n使用`OAuth1`认证的方法如下：\n\n```python\nimport requests from requests_oauthlib \nimport OAuth1 \nurl = 'https://api.twitter.com/1.1/account/verify_credentials.json' \nauth = OAuth1('YOUR_APP_KEY', 'YOUR_APP_SECRET', 'USER_OAUTH_TOKEN', 'USER_OAUTH_TOKEN_SECRET')\nrequests.get(url, auth=auth) \n```\n\n更多详细的功能就可以参考`requests_oauthlib`的官方文档：[https://requests-oauthlib.readthedocs.org/](https://requests-oauthlib.readthedocs.org/)，不再赘述。\n\n### 代理设置\n\n某些网站在测试的时候请求几次，能正常获取内容。但是对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的`IP`，导致一定时间段内无法访问。\n\n为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到`proxies`参数。可以用这样的方式设置：\n\n```python\nimport requests\nproxies = { \n  'http': 'http://10.10.10.10:1080', \n  'https': 'http://10.10.10.10:1080', \n}\nrequests.get('https://httpbin.org/get', proxies=proxies) \n```\n\n当然，直接运行这个实例或许行不通，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。\n\n若代理需要使用上文所述的身份认证，可以使用类似`ttp://user:password@host:port`这样的语法来设置代理，示例如下：\n\n```python\nimport requests\nproxies = {'https': 'http://user:password@10.10.10.10:1080/',} \nrequests.get('https://httpbin.org/get', proxies=proxies)\n```\n\n除了基本的`HTTP`代理外，`requests`还支持`SOCKS`协议的代理。\n\n首先，需要安装`socks`这个库：\n\n```python\npip3 install \"requests[socks]\"\n```\n\n然后就可以使用`SOCKS`协议代理了，示例如下：\n\n```python\nimport requests\nproxies = { \n  'http': 'socks5://user:password@host:port', \n  'https': 'socks5://user:password@host:port' \n}\nrequests.get('https://httpbin.org/get', proxies=proxies)\n```\n","slug":"requests库的基本使用","published":1,"updated":"2021-06-15T03:24:11.496Z","_id":"ckpapu7km003qlcxu77jh71ge","layout":"post","photos":[],"link":"","content":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>requests</code>是一个第三方库，使用<code>pip</code>下载安装。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install requests</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实例引入\"><a href=\"#实例引入\" class=\"headerlink\" title=\"实例引入\"></a>实例引入</h2><p>用<code>Python</code>写爬虫的第一步就是模拟发起一个请求，把网页的源代码获取下来。</p>\n<p>在浏览器中输入一个<code>URL</code>并回车，实际上就是让浏览器帮我们发起一个<code>GET</code>类型的<code>HTTP</code>请求，浏览器得到源代码后，把它渲染出来就可以看到网页内容了。</p>\n<p>那如果想用<code>requests</code>来获取源代码，应该怎么办呢？很简单，<code>requests</code>这个库提供了一个<code>get</code>方法，调用这个方法，并传入对应的<code>URL</code>就能得到网页的源代码。</p>\n<p>比如这里有一个示例网站:<a href=\"https://static1.scrape.cuiqingcai.com/\">https://static1.scrape.cuiqingcai.com/</a>，其内容如下：</p>\n<p><img src=\"Screenshot_2.webp\" alt=\"示列网站\"></p>\n<p>这个网站展示了一些电影数据，如果想要把这个网页里面的数据爬下来，比如获取各个电影的名称、上映时间等信息，然后把它存下来的话，该怎么做呢？</p>\n<p>第一步当然就是获取它的网页源代码了。</p>\n<p>可以用<code>requests</code>这个库轻松地完成这个过程，代码的写法是这样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;icon&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/static/img/favicon.ico&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Scrape | Movie<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/static/css/app.css&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/static/css/index.css&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;el-row&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;header&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container el-col el-col-18 el-col-offset-3&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;el-row&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;logo el-col el-col-4&quot;</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;router-link-exact-active router-link-active&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/static/img/logo.png&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;logo-image&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;logo-title&quot;</span>&gt;</span>Scrape<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/7&quot;</span>&gt;</span>7<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/8&quot;</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/9&quot;</span>&gt;</span>9<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/10&quot;</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;next&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn-next&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;el-icon el-icon-arrow-right&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于网页内容比较多，这里省略了大部分内容。</p>\n<p>不过看运行结果，我们已经成功获取网页的<code>HTML</code>源代码，里面包含了电影的标题、类型、上映时间，等等。</p>\n<p>把网页源代码获取下来之后，下一步我们把想要的数据提取出来，数据的爬取就完成了。</p>\n<h2 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h2><p><code>HTTP</code>中最常见的请求之一就是<code>GET</code>请求。</p>\n<h3 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a><code>GET</code>请求</h3><p>换一个示例网站，其<code>URL</code>为<a href=\"http://httpbin.org/get\">http://httpbin.org/get</a>，如果客户端发起的是<code>GET</code>请求的话，该网站会判断并返回相应的请求信息，包括 <code>Headers</code>、<code>IP</code>等。 我们还是用相同的方法来发起一个<code>GET请求</code>，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;http://httpbin.org/get&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;args&quot;: &#123;&#125;, </span><br><span class=\"line\">  &quot;headers&quot;: &#123;</span><br><span class=\"line\">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class=\"line\">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class=\"line\">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class=\"line\">    &quot;User-Agent&quot;: &quot;python-requests/2.25.1&quot;,</span><br><span class=\"line\">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60a3a8ad-070f8b95711f7821709e24ed&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;origin&quot;: &quot;202.62.113.207&quot;,</span><br><span class=\"line\">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，成功发起了<code>GET</code>请求，也通过这个网站的返回结果得到了请求所携带的信息，包括<code>Headers</code>、<code>URL</code>、<code>IP</code>，等等。</p>\n<p>对于<code>GET</code>请求，我们知道<code>URL</code>后面是可以跟上一些参数的，如果我们现在想添加两个参数，其中<code>name</code>是<code>germey</code>，<code>age</code>是<code>25</code>，<code>URL</code>就可以写成如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://httpbin.org/get?name=germey&amp;age=<span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>要构造这个请求链接，是不是要直接写成这样呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;http://httpbin.org/get?name=germey&amp;age=25&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这样也可以，但如果这些参数还需要手动拼接，未免有点不人性化。</p>\n<p>一般情况下，这种信息我们利用<code>params</code>这个参数就可以直接传递了，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;http://httpbin.org/get&#x27;</span>, params=data, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;args&quot;: &#123;</span><br><span class=\"line\">    &quot;age&quot;: &quot;25&quot;,</span><br><span class=\"line\">    &quot;name&quot;: &quot;holy&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;headers&quot;: &#123;</span><br><span class=\"line\">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class=\"line\">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class=\"line\">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class=\"line\">    &quot;User-Agent&quot;: &quot;python-requests/2.25.1&quot;,</span><br><span class=\"line\">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60a3ab05-51321f5c7eeb7b0573bb5510&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;origin&quot;: &quot;202.62.113.207&quot;,</span><br><span class=\"line\">  &quot;url&quot;: &quot;http://httpbin.org/get?name=holy&amp;age=25&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把<code>URL</code>参数通过字典的形式传给<code>get</code>方法的<code>params</code>参数，通过返回信息可以判断，请求的链接自动被构造成了：<em><a href=\"http://httpbin.org/get?age=22&amp;name=germey\">http://httpbin.org/get?age=22&amp;name=germey</a></em>。</p>\n<p>网页的返回类型实际上是<code>str</code>类型，但是它很特殊，是<code>JSON</code>格式的。所以，如果想直接解析返回结果，得到一个<code>JSON</code>格式的数据的话，可以直接调用<code>json</code>方法。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;http://httpbin.org/get&#x27;</span>, params=data, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.text))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.json())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.json()))</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;str&#x27;&gt;</span><br><span class=\"line\">&#123;&#x27;args&#x27;: &#123;&#x27;age&#x27;: &#x27;25&#x27;, &#x27;name&#x27;: &#x27;holy&#x27;&#125;, &#x27;headers&#x27;: &#123;&#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Host&#x27;: &#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;: &#x27;python-requests/2.25.1&#x27;, &#x27;X-Amzn-Trace-Id&#x27;: &#x27;Root=1-60a3ac52-425e713a2907d0302f298070&#x27;&#125;, &#x27;origin&#x27;: &#x27;202.62.113.207&#x27;, &#x27;url&#x27;: &#x27;http://httpbin.org/get?name=holy&amp;age=25&#x27;&#125;</span><br><span class=\"line\">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>json</code>方法，就可以将返回结果是<code>JSON</code>格式的字符串转化为字典。 但需要注意的是，如果返回结果不是<code>JSON</code>格式，便会出现解析错误，抛出<code>json.decoder.JSONDecodeError</code>异常。</p>\n<h3 id=\"抓取网页\"><a href=\"#抓取网页\" class=\"headerlink\" title=\"抓取网页\"></a>抓取网页</h3><p>上面的请求链接返回的是<code>JSON</code>形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容。下面以本课时最初的实例页面为例，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>, re.S)</span><br><span class=\"line\">titles = re.findall(pattern, r.text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(titles)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;霸王别姬 - Farewell My Concubine&#x27;</span>, <span class=\"string\">&#x27;这个杀手不太冷 - Léon&#x27;</span>, <span class=\"string\">&#x27;肖申克的救赎 - The Shawshank Redemption&#x27;</span>, <span class=\"string\">&#x27;泰坦尼克号 - Titanic&#x27;</span>, <span class=\"string\">&#x27;罗马假日 - Roman Holiday&#x27;</span>, <span class=\"string\">&#x27;唐伯虎点秋香 - Flirting Scholar&#x27;</span>, <span class=\"string\">&#x27;乱世佳人 - Gone with the Wind&#x27;</span>, <span class=\"string\">&#x27;喜剧之王 - The King of Comedy&#x27;</span>, <span class=\"string\">&#x27; 楚门的世界 - The Truman Show&#x27;</span>, <span class=\"string\">&#x27;狮子王 - The Lion King&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抓取二进制数据\"><a href=\"#抓取二进制数据\" class=\"headerlink\" title=\"抓取二进制数据\"></a>抓取二进制数据</h3><p>抓取的是网站的一个页面，实际上它返回的是一个<code>HTML</code>文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？</p>\n<p>图片、音频、视频这些文件本质上都是由<strong>二进制码</strong>组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。</p>\n<p>下面以 GitHub 的站点图标为例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://github.com/favicon.ico&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.content)</span><br></pre></td></tr></table></figure>\n\n<p>这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标。</p>\n<p>前者出现了乱码，后者结果前带有一个<code>b</code>，这代表是<code>bytes</code>类型的数据。</p>\n<p>由于图片是二进制数据，所以前者在打印时转化为<code>str</code>类型，也就是图片直接转化为字符串，这当然会出现乱码。</p>\n<p>上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，将刚才提取到的信息保存下来就好了，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;baidu.png&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f: </span><br><span class=\"line\">    f.write(r.content)</span><br></pre></td></tr></table></figure>\n\n<p>这里用了<code>open</code>方法，它的第一个参数是文件名称，第二个参数代表以二进制的形式打开，可以向文件里写入二进制数据。</p>\n<p>运行结束之后，可以发现在文件夹中出现了名为<code>baidu.png</code>的图标。</p>\n<h3 id=\"添加添headers\"><a href=\"#添加添headers\" class=\"headerlink\" title=\"添加添headers\"></a>添加添headers</h3><p>在发起一个<code>HTTP</code>请求的时候，会有一个请求头<code>Request Headers</code>，那么这个怎么来设置呢？</p>\n<p>很简单，使用<code>headers</code>参数就可以完成了。</p>\n<p>在刚才的实例中，是没有设置<code>Request Headers</code>信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p>\n<p>要添加<code>Headers</code>信息，比如添加一个<code>User-Agent</code>字段，可以这么写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123; </span><br><span class=\"line\">    <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, headers=headers, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>当然，我们可以在<code>headers</code>这个参数中任意添加其他的字段信息。</p>\n<h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3><p>使用<code>requests</code>实现<code>post</code>请求，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;germey&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;25&#x27;</span>&#125;</span><br><span class=\"line\">r = requests.post(<span class=\"string\">&quot;http://httpbin.org/post&quot;</span>, data=data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>这里还是请求<a href=\"http://httpbin.org/post\">http://httpbin.org/post</a>，该网站可以判断如果请求是<code>POST</code>方式，就把相关请求信息返回。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;args&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;data&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;files&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;form&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;age&quot;</span>: <span class=\"string\">&quot;25&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;germey&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;headers&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Accept&quot;</span>: <span class=\"string\">&quot;*/*&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Accept-Encoding&quot;</span>: <span class=\"string\">&quot;gzip, deflate&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Content-Length&quot;</span>: <span class=\"string\">&quot;18&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Host&quot;</span>: <span class=\"string\">&quot;httpbin.org&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;User-Agent&quot;</span>: <span class=\"string\">&quot;python-requests/2.25.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;X-Amzn-Trace-Id&quot;</span>: <span class=\"string\">&quot;Root=1-60a402c2-68a523624a9ca353207a3a5e&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;json&quot;</span>: null,</span><br><span class=\"line\">  <span class=\"string\">&quot;origin&quot;</span>: <span class=\"string\">&quot;202.62.113.207&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;url&quot;</span>: <span class=\"string\">&quot;http://httpbin.org/post&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p>发送请求后，得到的就是响应，即<code>Response</code>。</p>\n<p>在上面的实例中，使用<code>text</code>和<code>content</code>获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如<code>状态码</code>、<code>响应头</code>、<code>Cookies</code>等。示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.status_code), r.status_code)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.headers), r.headers)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.cookies), r.cookies)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.url), r.url)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.history), r.history)</span><br></pre></td></tr></table></figure>\n\n<p>这里分别打印输出<code>status_code</code>属性得到状态码，输出<code>headers</code>属性得到响应头，输出<code>cookies</code>属性得到<code>Cookies</code>，输出<code>url</code>属性得到<code>URL</code>，输出<code>history</code>属性得到请求历史。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">int</span>&#x27;&gt; 200</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">requests</span>.<span class=\"title\">structures</span>.<span class=\"title\">CaseInsensitiveDict</span>&#x27;&gt; &#123;&#x27;<span class=\"title\">Date</span>&#x27;:</span> <span class=\"string\">&#x27;Wed, 19 May 2021 12:52:03 GMT&#x27;</span>, <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;text/html; charset=utf-8&#x27;</span>, <span class=\"string\">&#x27;Content-Length&#x27;</span>: <span class=\"string\">&#x27;41538&#x27;</span>, <span class=\"string\">&#x27;Connection&#x27;</span>: <span class=\"string\">&#x27;keep-alive&#x27;</span>, <span class=\"string\">&#x27;X-Frame-Options&#x27;</span>: <span class=\"string\">&#x27;DENY&#x27;</span>, <span class=\"string\">&#x27;X-Content-Type-Options&#x27;</span>: <span class=\"string\">&#x27;nosniff&#x27;</span>, <span class=\"string\">&#x27;Expires&#x27;</span>: <span class=\"string\">&#x27;Wed, 19 May 2021 13:01:46 GMT&#x27;</span>, <span class=\"string\">&#x27;Cache-Control&#x27;</span>: <span class=\"string\">&#x27;max-age=600&#x27;</span>, <span class=\"string\">&#x27;Strict-Transport-Security&#x27;</span>: <span class=\"string\">&#x27;max-age=15724800; includeSubDomains&#x27;</span>&#125;</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">requests</span>.<span class=\"title\">cookies</span>.<span class=\"title\">RequestsCookieJar</span>&#x27;&gt; &lt;<span class=\"title\">RequestsCookieJar</span>[]&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">str</span>&#x27;&gt; <span class=\"title\">https</span>:</span>//static1.scrape.cuiqingcai.com/</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">list</span>&#x27;&gt; []</span></span><br></pre></td></tr></table></figure>\n\n<p><code>headers</code>和<code>cookies</code>这两个属性得到的结果分别是<code>CaseInsensitiveDict</code>和<code>RequestsCookieJar</code>类型。</p>\n<p>状态码是用来表示响应状态的，比如返回<code>200</code>代表我们得到的响应是没问题的，上面的例子正好输出的结果也是<code>200</code>，所以可以通过判断<code>Response</code>的状态码来确认是否爬取成功。</p>\n<p><code>requests</code>还提供了一个内置的状态码查询对象<code>requests.codes</code>，用法示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">exit() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> r.status_code == requests.codes.ok <span class=\"keyword\">else</span> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Request successfully&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用<code>requests.codes.ok</code>得到的是成功的状态码<code>200</code>。</p>\n<p>这样的话，我们就不用再在程序里面写状态码对应的数字了，用字符串表示状态码会显得更加直观。</p>\n<p>下面列出了返回码和相应的查询条件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 信息性状态码</span></span><br><span class=\"line\"><span class=\"number\">100</span>: (<span class=\"string\">&#x27;continue&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">101</span>: (<span class=\"string\">&#x27;switching_protocols&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">102</span>: (<span class=\"string\">&#x27;processing&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">103</span>: (<span class=\"string\">&#x27;checkpoint&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">122</span>: (<span class=\"string\">&#x27;uri_too_long&#x27;</span>, <span class=\"string\">&#x27;request_uri_too_long&#x27;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 成功状态码</span></span><br><span class=\"line\"><span class=\"number\">200</span>: (<span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;okay&#x27;</span>, <span class=\"string\">&#x27;all_ok&#x27;</span>, <span class=\"string\">&#x27;all_okay&#x27;</span>, <span class=\"string\">&#x27;all_good&#x27;</span>, <span class=\"string\">&#x27;\\\\o/&#x27;</span>, <span class=\"string\">&#x27;✓&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">201</span>: (<span class=\"string\">&#x27;created&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">202</span>: (<span class=\"string\">&#x27;accepted&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">203</span>: (<span class=\"string\">&#x27;non_authoritative_info&#x27;</span>, <span class=\"string\">&#x27;non_authoritative_information&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">204</span>: (<span class=\"string\">&#x27;no_content&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">205</span>: (<span class=\"string\">&#x27;reset_content&#x27;</span>, <span class=\"string\">&#x27;reset&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">206</span>: (<span class=\"string\">&#x27;partial_content&#x27;</span>, <span class=\"string\">&#x27;partial&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">207</span>: (<span class=\"string\">&#x27;multi_status&#x27;</span>, <span class=\"string\">&#x27;multiple_status&#x27;</span>, <span class=\"string\">&#x27;multi_stati&#x27;</span>, <span class=\"string\">&#x27;multiple_stati&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">208</span>: (<span class=\"string\">&#x27;already_reported&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">226</span>: (<span class=\"string\">&#x27;im_used&#x27;</span>,),</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重定向状态码</span></span><br><span class=\"line\"><span class=\"number\">300</span>: (<span class=\"string\">&#x27;multiple_choices&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">301</span>: (<span class=\"string\">&#x27;moved_permanently&#x27;</span>, <span class=\"string\">&#x27;moved&#x27;</span>, <span class=\"string\">&#x27;\\\\o-&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">302</span>: (<span class=\"string\">&#x27;found&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">303</span>: (<span class=\"string\">&#x27;see_other&#x27;</span>, <span class=\"string\">&#x27;other&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">304</span>: (<span class=\"string\">&#x27;not_modified&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">305</span>: (<span class=\"string\">&#x27;use_proxy&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">306</span>: (<span class=\"string\">&#x27;switch_proxy&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">307</span>: (<span class=\"string\">&#x27;temporary_redirect&#x27;</span>, <span class=\"string\">&#x27;temporary_moved&#x27;</span>, <span class=\"string\">&#x27;temporary&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">308</span>: (<span class=\"string\">&#x27;permanent_redirect&#x27;</span>, <span class=\"string\">&#x27;resume_incomplete&#x27;</span>, <span class=\"string\">&#x27;resume&#x27;</span>,), <span class=\"comment\"># These 2 to be removed in 3.0 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 客户端错误状态码 </span></span><br><span class=\"line\"><span class=\"number\">400</span>: (<span class=\"string\">&#x27;bad_request&#x27;</span>, <span class=\"string\">&#x27;bad&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">401</span>: (<span class=\"string\">&#x27;unauthorized&#x27;</span>,), </span><br><span class=\"line\"><span class=\"number\">402</span>: (<span class=\"string\">&#x27;payment_required&#x27;</span>, <span class=\"string\">&#x27;payment&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">403</span>: (<span class=\"string\">&#x27;forbidden&#x27;</span>,), </span><br><span class=\"line\"><span class=\"number\">404</span>: (<span class=\"string\">&#x27;not_found&#x27;</span>, <span class=\"string\">&#x27;-o-&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">405</span>: (<span class=\"string\">&#x27;method_not_allowed&#x27;</span>, <span class=\"string\">&#x27;not_allowed&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">406</span>: (<span class=\"string\">&#x27;not_acceptable&#x27;</span>,), </span><br><span class=\"line\"><span class=\"number\">407</span>: (<span class=\"string\">&#x27;proxy_authentication_required&#x27;</span>, <span class=\"string\">&#x27;proxy_auth&#x27;</span>, <span class=\"string\">&#x27;proxy_authentication&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">408</span>: (<span class=\"string\">&#x27;request_timeout&#x27;</span>, <span class=\"string\">&#x27;timeout&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">409</span>: (<span class=\"string\">&#x27;conflict&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">410</span>: (<span class=\"string\">&#x27;gone&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">411</span>: (<span class=\"string\">&#x27;length_required&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">412</span>: (<span class=\"string\">&#x27;precondition_failed&#x27;</span>, <span class=\"string\">&#x27;precondition&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">413</span>: (<span class=\"string\">&#x27;request_entity_too_large&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">414</span>: (<span class=\"string\">&#x27;request_uri_too_large&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">415</span>: (<span class=\"string\">&#x27;unsupported_media_type&#x27;</span>, <span class=\"string\">&#x27;unsupported_media&#x27;</span>, <span class=\"string\">&#x27;media_type&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">416</span>: (<span class=\"string\">&#x27;requested_range_not_satisfiable&#x27;</span>, <span class=\"string\">&#x27;requested_range&#x27;</span>, <span class=\"string\">&#x27;range_not_satisfiable&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">417</span>: (<span class=\"string\">&#x27;expectation_failed&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">418</span>: (<span class=\"string\">&#x27;im_a_teapot&#x27;</span>, <span class=\"string\">&#x27;teapot&#x27;</span>, <span class=\"string\">&#x27;i_am_a_teapot&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">421</span>: (<span class=\"string\">&#x27;misdirected_request&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">422</span>: (<span class=\"string\">&#x27;unprocessable_entity&#x27;</span>, <span class=\"string\">&#x27;unprocessable&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">423</span>: (<span class=\"string\">&#x27;locked&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">424</span>: (<span class=\"string\">&#x27;failed_dependency&#x27;</span>, <span class=\"string\">&#x27;dependency&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">425</span>: (<span class=\"string\">&#x27;unordered_collection&#x27;</span>, <span class=\"string\">&#x27;unordered&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">426</span>: (<span class=\"string\">&#x27;upgrade_required&#x27;</span>, <span class=\"string\">&#x27;upgrade&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">428</span>: (<span class=\"string\">&#x27;precondition_required&#x27;</span>, <span class=\"string\">&#x27;precondition&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">429</span>: (<span class=\"string\">&#x27;too_many_requests&#x27;</span>, <span class=\"string\">&#x27;too_many&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">431</span>: (<span class=\"string\">&#x27;header_fields_too_large&#x27;</span>, <span class=\"string\">&#x27;fields_too_large&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">444</span>: (<span class=\"string\">&#x27;no_response&#x27;</span>, <span class=\"string\">&#x27;none&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">449</span>: (<span class=\"string\">&#x27;retry_with&#x27;</span>, <span class=\"string\">&#x27;retry&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">450</span>: (<span class=\"string\">&#x27;blocked_by_windows_parental_controls&#x27;</span>, <span class=\"string\">&#x27;parental_controls&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">451</span>: (<span class=\"string\">&#x27;unavailable_for_legal_reasons&#x27;</span>, <span class=\"string\">&#x27;legal_reasons&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">499</span>: (<span class=\"string\">&#x27;client_closed_request&#x27;</span>,), </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 服务端错误状态码</span></span><br><span class=\"line\"><span class=\"number\">500</span>: (<span class=\"string\">&#x27;internal_server_error&#x27;</span>, <span class=\"string\">&#x27;server_error&#x27;</span>, <span class=\"string\">&#x27;/o\\\\&#x27;</span>, <span class=\"string\">&#x27;✗&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">501</span>: (<span class=\"string\">&#x27;not_implemented&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">502</span>: (<span class=\"string\">&#x27;bad_gateway&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">503</span>: (<span class=\"string\">&#x27;service_unavailable&#x27;</span>, <span class=\"string\">&#x27;unavailable&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">504</span>: (<span class=\"string\">&#x27;gateway_timeout&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">505</span>: (<span class=\"string\">&#x27;http_version_not_supported&#x27;</span>, <span class=\"string\">&#x27;http_version&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">506</span>: (<span class=\"string\">&#x27;variant_also_negotiates&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">507</span>: (<span class=\"string\">&#x27;insufficient_storage&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">509</span>: (<span class=\"string\">&#x27;bandwidth_limit_exceeded&#x27;</span>, <span class=\"string\">&#x27;bandwidth&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">510</span>: (<span class=\"string\">&#x27;not_extended&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">511</span>: (<span class=\"string\">&#x27;network_authentication_required&#x27;</span>, <span class=\"string\">&#x27;network_auth&#x27;</span>, <span class=\"string\">&#x27;network_authentication&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>比如，如果想判断结果是不是<code>404</code>状态，可以用<code>requests.codes.not_found</code>来比对。</p>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><p>刚才，了解<code>requests</code>的基本用法，如基本的<code>GET、POST</code>请求以及<code>Response</code>对象。当然<code>requests</code>能做到的不仅这些，它几乎可以完成<code>HTTP</code>的所有操作。</p>\n<p>下面来了解下<code>requests</code>的一些高级用法，如文件上传、<code>Cookies</code>设置、代理设置等。</p>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><p><code>requests</code>可以模拟提交一些数据。假如有的网站需要上传文件，也可以用它来实现，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">files = &#123;<span class=\"string\">&#x27;file&#x27;</span>:<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;baidu.png&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>)&#125;</span><br><span class=\"line\">r = requests.post(<span class=\"string\">&#x27;http://httpbin.org/post&#x27;</span>, files=files)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是，<code>baidu.png</code>需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;args&quot;: &#123;&#125;, </span><br><span class=\"line\">  &quot;data&quot;: &quot;&quot;, </span><br><span class=\"line\">  &quot;files&quot;: &#123;</span><br><span class=\"line\">    &quot;file&quot;: &quot;data:application/octet-stream;base64,iVBORw0KGgoAAAANSU......&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;form&quot;: &#123;&#125;,</span><br><span class=\"line\">  &quot;headers&quot;: &#123;</span><br><span class=\"line\">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class=\"line\">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class=\"line\">    &quot;Content-Length&quot;: &quot;15589&quot;,</span><br><span class=\"line\">    &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=7e0556b094615781fff3b0ed4316dccd&quot;,</span><br><span class=\"line\">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class=\"line\">    &quot;User-Agent&quot;: &quot;python-requests/2.25.1&quot;,</span><br><span class=\"line\">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60a72501-36f606570785cb9d4356df71&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;json&quot;: null,</span><br><span class=\"line\">  &quot;origin&quot;: &quot;202.62.112.143&quot;,</span><br><span class=\"line\">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上省略部分内容，这个网站会返回响应，里面包含<code>files</code>这个字段，而<code>form</code>字段是空的，这证明文件上传部分会单独有一个<code>files</code>字段来标识。</p>\n<h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><p>获取<code>Cookies</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.cookies)</span><br><span class=\"line\"><span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> r.cookies.items():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(key + <span class=\"string\">&#x27;=&#x27;</span> + value)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span><br><span class=\"line\">BDORZ=27315</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>cookies</code>属性即可成功得到<code>Cookies</code>，可以发现它是<code>RequestCookieJar</code>类型。然后用<code>items</code> 方法将其转化为元组组成的列表，遍历输出每一个<code>Cookie</code>的名称和值，实现<code>Cookie</code>的遍历解析。</p>\n<p>可以直接用<code>Cookie</code>来维持登录状态，下面我们以<code>GitHub</code>为例来说明一下，首先我们登录<code>GitHub</code>，然后将<code>Headers</code>中的<code>Cookie</code>内容复制下来，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>可以替换成你自己的<code>Cookie</code>，将其设置到<code>Headers</code>里面，然后发送请求。</p>\n<h3 id=\"Session维持\"><a href=\"#Session维持\" class=\"headerlink\" title=\"Session维持\"></a>Session维持</h3><p>在<code>requests</code>中，如果直接利用<code>get</code>或<code>post</code>等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的<code>Session</code>，相当于你用两个浏览器打开了不同的页面。</p>\n<p>设想这样一个场景，第一个请求利用<code>post</code>方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次<code>get</code>方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不相关的<code>Session</code>，能成功获取个人信息吗？当然不能。</p>\n<p>解决这个问题的主要方法就是维持同一个<code>Session</code>，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置<code>Cookies</code>，那该怎么办呢？这时候就有了新的利器——**<code>Session</code>对象**。 利用它，可以方便地维护一个<code>Session</code>，而且不用担心<code>Cookies</code>的问题，它会帮我们自动处理好。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;http://httpbin.org/cookies&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;cookies&quot;</span>: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这并不行。再用 Session试试看：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">s = requests.Session()</span><br><span class=\"line\">s.get(<span class=\"string\">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>)</span><br><span class=\"line\">r = s.get(<span class=\"string\">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;cookies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;number&quot;</span>: <span class=\"string\">&quot;123456789&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>Session</code>，可以做到模拟同一个<code>Session</code>而不用担心<code>Cookies</code>的问题。它通常用于模拟登录成功之后再进行下一步的操作。</p>\n<h3 id=\"SSL证书验证\"><a href=\"#SSL证书验证\" class=\"headerlink\" title=\"SSL证书验证\"></a>SSL证书验证</h3><p>现在很多网站都要求使用<code>HTTPS</code>协议，但是有些网站可能并没有设置好<code>HTTPS</code>证书，或者网站的<code>HTTPS</code>证书不被<code>CA</code>机构认可，这时候，这些网站可能就会出现<code>SSL</code>证书错误的提示。</p>\n<p>比如示例网站：<a href=\"https://static2.scrape.cuiqingcai.com/\">https://static2.scrape.cuiqingcai.com/</a>。 用浏览器打开这个<code>URL</code>，则会提示<strong>「您的连接不是私密连接」</strong>这样的错误，如图所示：</p>\n<p><img src=\"Screenshot_3.webp\" alt=\"示例网站\"></p>\n<p>那如果我们一定要爬取这个网站怎么办呢？我们可以使用<code>verify</code>参数控制是否验证证书，如果将其设置为<code>False</code>，在请求时就不会再验证证书是否有效。如果不加<code>verify</code>参数的话，默认值是<code>True</code>，会自动验证。</p>\n<p>改写代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code) </span><br></pre></td></tr></table></figure>\n\n<p>这样就会打印出请求成功的状态码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/lib/python3<span class=\"number\">.7</span>/site-packages/urllib3/connectionpool.py:<span class=\"number\">857</span>: InsecureRequestWarning: Unverified HTTPS request <span class=\"keyword\">is</span> being made. Adding certificate verification <span class=\"keyword\">is</span> strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html</span><br><span class=\"line\">InsecureRequestWarning) <span class=\"number\">200</span> </span><br></pre></td></tr></table></figure>\n\n<p>不过发现报了一个警告，它建议我们给它指定证书。可以通过设置忽略警告的方式来屏蔽这个警告：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests <span class=\"keyword\">from</span> requests.packages </span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib3 </span><br><span class=\"line\"></span><br><span class=\"line\">urllib3.disable_warnings() </span><br><span class=\"line\">response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>或者通过捕获警告到日志的方式忽略警告：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging </span><br><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">logging.captureWarnings(<span class=\"literal\">True</span>) </span><br><span class=\"line\">response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组： </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, cert=(<span class=\"string\">&#x27;/path/server.crt&#x27;</span>, <span class=\"string\">&#x27;/path/server.key&#x27;</span>)) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码是演示实例，要有<code>crt</code>和<code>key</code>文件，并且指定它们的路径。另外注意，本地私有证书的<code>key</code>必须是解密状态，加密状态的<code>key</code>是不支持的。</p>\n<h3 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h3><p>在本机网络状况不好或者服务器网络响应延迟甚至无响应时，可能会等待很久才能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到<code>timeout</code>参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, timeout=<span class=\"number\">1</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>通过这样的方式将超时时间设置为<code>1</code>秒，如果<code>1</code>秒内没有响应，那就抛出异常。</p>\n<p>实际上，请求分为两个阶段，即连接<code>（connect）</code>和读取<code>（read）</code>。 上面设置的<code>timeout</code>将用作连接和读取这二者的<code>timeout</code>总和。</p>\n<p>如果要分别指定，就可以传入一个元组：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, timeout=(<span class=\"number\">5</span>, <span class=\"number\">30</span>))</span><br></pre></td></tr></table></figure>\n\n<p>如果想永久等待，可以直接将<code>timeout</code>设置为<code>None</code>，或者不设置直接留空，因为默认是<code>None</code>。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, timeout=<span class=\"literal\">None</span>) </span><br></pre></td></tr></table></figure>\n\n<p>或直接不加参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"身份认证\"><a href=\"#身份认证\" class=\"headerlink\" title=\"身份认证\"></a>身份认证</h3><p>在访问某些设置了身份认证的网站时，例如：<a href=\"https://static3.scrape.cuiqingcai.com/\">https://static3.scrape.cuiqingcai.com/</a>，我们可能会遇到这样的认证窗口，如图所示：</p>\n<p><img src=\"Screenshot_4.webp\" alt=\"认证\"></p>\n<p>如果遇到了这种情况，那就是这个网站启用了基本身份认证，英文叫作<code>HTTP Basic Access Authentication</code>，它是一种用来允许网页浏览器或其他客户端程序在请求时提供<strong>用户名</strong>和<strong>口令形式</strong>的身份凭证的一种登录验证方式。 如果遇到了这种情况，怎么用<code>reqeusts</code>来爬取呢，当然也有办法。</p>\n<p>可以使用<code>requests</code>自带的身份认证功能，通过<code>auth</code>参数即可设置，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.auth <span class=\"keyword\">import</span> HTTPBasicAuth</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static3.scrape.cuiqingcai.com/&#x27;</span>, auth=HTTPBasicAuth(<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>), verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>成功的话，返回状态码<code>200</code>。</p>\n<p>如果参数都传一个<code>HTTPBasicAuth</code>类，就显得有点烦琐了，所以<code>requests</code>提供了一个更简单的写法，可以直接传一个元组，它会默认使用<code>HTTPBasicAuth</code>这个类来认证。</p>\n<p>上面的代码可以直接简写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static3.scrape.cuiqingcai.com/&#x27;</span>, auth=(<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>此外，<code>requests</code>还提供了其他认证方式，如<code>OAuth</code>认证，不过此时需要安装<code>oauth</code>包，安装命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install requests_oauthlib</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>OAuth1</code>认证的方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests <span class=\"keyword\">from</span> requests_oauthlib </span><br><span class=\"line\"><span class=\"keyword\">import</span> OAuth1 </span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://api.twitter.com/1.1/account/verify_credentials.json&#x27;</span> </span><br><span class=\"line\">auth = OAuth1(<span class=\"string\">&#x27;YOUR_APP_KEY&#x27;</span>, <span class=\"string\">&#x27;YOUR_APP_SECRET&#x27;</span>, <span class=\"string\">&#x27;USER_OAUTH_TOKEN&#x27;</span>, <span class=\"string\">&#x27;USER_OAUTH_TOKEN_SECRET&#x27;</span>)</span><br><span class=\"line\">requests.get(url, auth=auth) </span><br></pre></td></tr></table></figure>\n\n<p>更多详细的功能就可以参考<code>requests_oauthlib</code>的官方文档：<a href=\"https://requests-oauthlib.readthedocs.org/\">https://requests-oauthlib.readthedocs.org/</a>，不再赘述。</p>\n<h3 id=\"代理设置\"><a href=\"#代理设置\" class=\"headerlink\" title=\"代理设置\"></a>代理设置</h3><p>某些网站在测试的时候请求几次，能正常获取内容。但是对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的<code>IP</code>，导致一定时间段内无法访问。</p>\n<p>为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到<code>proxies</code>参数。可以用这样的方式设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">proxies = &#123; </span><br><span class=\"line\">  <span class=\"string\">&#x27;http&#x27;</span>: <span class=\"string\">&#x27;http://10.10.10.10:1080&#x27;</span>, </span><br><span class=\"line\">  <span class=\"string\">&#x27;https&#x27;</span>: <span class=\"string\">&#x27;http://10.10.10.10:1080&#x27;</span>, </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies) </span><br></pre></td></tr></table></figure>\n\n<p>当然，直接运行这个实例或许行不通，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。</p>\n<p>若代理需要使用上文所述的身份认证，可以使用类似<code>ttp://user:password@host:port</code>这样的语法来设置代理，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">proxies = &#123;<span class=\"string\">&#x27;https&#x27;</span>: <span class=\"string\">&#x27;http://user:password@10.10.10.10:1080/&#x27;</span>,&#125; </span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>\n\n<p>除了基本的<code>HTTP</code>代理外，<code>requests</code>还支持<code>SOCKS</code>协议的代理。</p>\n<p>首先，需要安装<code>socks</code>这个库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install <span class=\"string\">&quot;requests[socks]&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后就可以使用<code>SOCKS</code>协议代理了，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">proxies = &#123; </span><br><span class=\"line\">  <span class=\"string\">&#x27;http&#x27;</span>: <span class=\"string\">&#x27;socks5://user:password@host:port&#x27;</span>, </span><br><span class=\"line\">  <span class=\"string\">&#x27;https&#x27;</span>: <span class=\"string\">&#x27;socks5://user:password@host:port&#x27;</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>requests</code>是一个第三方库，使用<code>pip</code>下载安装。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install requests</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实例引入\"><a href=\"#实例引入\" class=\"headerlink\" title=\"实例引入\"></a>实例引入</h2><p>用<code>Python</code>写爬虫的第一步就是模拟发起一个请求，把网页的源代码获取下来。</p>\n<p>在浏览器中输入一个<code>URL</code>并回车，实际上就是让浏览器帮我们发起一个<code>GET</code>类型的<code>HTTP</code>请求，浏览器得到源代码后，把它渲染出来就可以看到网页内容了。</p>\n<p>那如果想用<code>requests</code>来获取源代码，应该怎么办呢？很简单，<code>requests</code>这个库提供了一个<code>get</code>方法，调用这个方法，并传入对应的<code>URL</code>就能得到网页的源代码。</p>\n<p>比如这里有一个示例网站:<a href=\"https://static1.scrape.cuiqingcai.com/\">https://static1.scrape.cuiqingcai.com/</a>，其内容如下：</p>\n<p><img src=\"Screenshot_2.webp\" alt=\"示列网站\"></p>\n<p>这个网站展示了一些电影数据，如果想要把这个网页里面的数据爬下来，比如获取各个电影的名称、上映时间等信息，然后把它存下来的话，该怎么做呢？</p>\n<p>第一步当然就是获取它的网页源代码了。</p>\n<p>可以用<code>requests</code>这个库轻松地完成这个过程，代码的写法是这样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;icon&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/static/img/favicon.ico&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Scrape | Movie<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/static/css/app.css&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/static/css/index.css&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;el-row&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;header&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container el-col el-col-18 el-col-offset-3&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;el-row&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;logo el-col el-col-4&quot;</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;router-link-exact-active router-link-active&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/static/img/logo.png&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;logo-image&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-v-74e8b908</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;logo-title&quot;</span>&gt;</span>Scrape<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/7&quot;</span>&gt;</span>7<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/8&quot;</span>&gt;</span>8<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/9&quot;</span>&gt;</span>9<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/10&quot;</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/page/2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;next&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn-next&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;el-icon el-icon-arrow-right&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于网页内容比较多，这里省略了大部分内容。</p>\n<p>不过看运行结果，我们已经成功获取网页的<code>HTML</code>源代码，里面包含了电影的标题、类型、上映时间，等等。</p>\n<p>把网页源代码获取下来之后，下一步我们把想要的数据提取出来，数据的爬取就完成了。</p>\n<h2 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h2><p><code>HTTP</code>中最常见的请求之一就是<code>GET</code>请求。</p>\n<h3 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a><code>GET</code>请求</h3><p>换一个示例网站，其<code>URL</code>为<a href=\"http://httpbin.org/get\">http://httpbin.org/get</a>，如果客户端发起的是<code>GET</code>请求的话，该网站会判断并返回相应的请求信息，包括 <code>Headers</code>、<code>IP</code>等。 我们还是用相同的方法来发起一个<code>GET请求</code>，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;http://httpbin.org/get&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;args&quot;: &#123;&#125;, </span><br><span class=\"line\">  &quot;headers&quot;: &#123;</span><br><span class=\"line\">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class=\"line\">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class=\"line\">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class=\"line\">    &quot;User-Agent&quot;: &quot;python-requests/2.25.1&quot;,</span><br><span class=\"line\">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60a3a8ad-070f8b95711f7821709e24ed&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;origin&quot;: &quot;202.62.113.207&quot;,</span><br><span class=\"line\">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，成功发起了<code>GET</code>请求，也通过这个网站的返回结果得到了请求所携带的信息，包括<code>Headers</code>、<code>URL</code>、<code>IP</code>，等等。</p>\n<p>对于<code>GET</code>请求，我们知道<code>URL</code>后面是可以跟上一些参数的，如果我们现在想添加两个参数，其中<code>name</code>是<code>germey</code>，<code>age</code>是<code>25</code>，<code>URL</code>就可以写成如下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://httpbin.org/get?name=germey&amp;age=<span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>要构造这个请求链接，是不是要直接写成这样呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;http://httpbin.org/get?name=germey&amp;age=25&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这样也可以，但如果这些参数还需要手动拼接，未免有点不人性化。</p>\n<p>一般情况下，这种信息我们利用<code>params</code>这个参数就可以直接传递了，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;http://httpbin.org/get&#x27;</span>, params=data, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>返回结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;args&quot;: &#123;</span><br><span class=\"line\">    &quot;age&quot;: &quot;25&quot;,</span><br><span class=\"line\">    &quot;name&quot;: &quot;holy&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;headers&quot;: &#123;</span><br><span class=\"line\">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class=\"line\">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class=\"line\">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class=\"line\">    &quot;User-Agent&quot;: &quot;python-requests/2.25.1&quot;,</span><br><span class=\"line\">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60a3ab05-51321f5c7eeb7b0573bb5510&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;origin&quot;: &quot;202.62.113.207&quot;,</span><br><span class=\"line\">  &quot;url&quot;: &quot;http://httpbin.org/get?name=holy&amp;age=25&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把<code>URL</code>参数通过字典的形式传给<code>get</code>方法的<code>params</code>参数，通过返回信息可以判断，请求的链接自动被构造成了：<em><a href=\"http://httpbin.org/get?age=22&amp;name=germey\">http://httpbin.org/get?age=22&amp;name=germey</a></em>。</p>\n<p>网页的返回类型实际上是<code>str</code>类型，但是它很特殊，是<code>JSON</code>格式的。所以，如果想直接解析返回结果，得到一个<code>JSON</code>格式的数据的话，可以直接调用<code>json</code>方法。</p>\n<p>示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;holy&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(url=<span class=\"string\">&#x27;http://httpbin.org/get&#x27;</span>, params=data, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.text))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.json())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.json()))</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;str&#x27;&gt;</span><br><span class=\"line\">&#123;&#x27;args&#x27;: &#123;&#x27;age&#x27;: &#x27;25&#x27;, &#x27;name&#x27;: &#x27;holy&#x27;&#125;, &#x27;headers&#x27;: &#123;&#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Host&#x27;: &#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;: &#x27;python-requests/2.25.1&#x27;, &#x27;X-Amzn-Trace-Id&#x27;: &#x27;Root=1-60a3ac52-425e713a2907d0302f298070&#x27;&#125;, &#x27;origin&#x27;: &#x27;202.62.113.207&#x27;, &#x27;url&#x27;: &#x27;http://httpbin.org/get?name=holy&amp;age=25&#x27;&#125;</span><br><span class=\"line\">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>json</code>方法，就可以将返回结果是<code>JSON</code>格式的字符串转化为字典。 但需要注意的是，如果返回结果不是<code>JSON</code>格式，便会出现解析错误，抛出<code>json.decoder.JSONDecodeError</code>异常。</p>\n<h3 id=\"抓取网页\"><a href=\"#抓取网页\" class=\"headerlink\" title=\"抓取网页\"></a>抓取网页</h3><p>上面的请求链接返回的是<code>JSON</code>形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容。下面以本课时最初的实例页面为例，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>, re.S)</span><br><span class=\"line\">titles = re.findall(pattern, r.text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(titles)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;霸王别姬 - Farewell My Concubine&#x27;</span>, <span class=\"string\">&#x27;这个杀手不太冷 - Léon&#x27;</span>, <span class=\"string\">&#x27;肖申克的救赎 - The Shawshank Redemption&#x27;</span>, <span class=\"string\">&#x27;泰坦尼克号 - Titanic&#x27;</span>, <span class=\"string\">&#x27;罗马假日 - Roman Holiday&#x27;</span>, <span class=\"string\">&#x27;唐伯虎点秋香 - Flirting Scholar&#x27;</span>, <span class=\"string\">&#x27;乱世佳人 - Gone with the Wind&#x27;</span>, <span class=\"string\">&#x27;喜剧之王 - The King of Comedy&#x27;</span>, <span class=\"string\">&#x27; 楚门的世界 - The Truman Show&#x27;</span>, <span class=\"string\">&#x27;狮子王 - The Lion King&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抓取二进制数据\"><a href=\"#抓取二进制数据\" class=\"headerlink\" title=\"抓取二进制数据\"></a>抓取二进制数据</h3><p>抓取的是网站的一个页面，实际上它返回的是一个<code>HTML</code>文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？</p>\n<p>图片、音频、视频这些文件本质上都是由<strong>二进制码</strong>组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。</p>\n<p>下面以 GitHub 的站点图标为例来看一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://github.com/favicon.ico&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.content)</span><br></pre></td></tr></table></figure>\n\n<p>这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标。</p>\n<p>前者出现了乱码，后者结果前带有一个<code>b</code>，这代表是<code>bytes</code>类型的数据。</p>\n<p>由于图片是二进制数据，所以前者在打印时转化为<code>str</code>类型，也就是图片直接转化为字符串，这当然会出现乱码。</p>\n<p>上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，将刚才提取到的信息保存下来就好了，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;baidu.png&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f: </span><br><span class=\"line\">    f.write(r.content)</span><br></pre></td></tr></table></figure>\n\n<p>这里用了<code>open</code>方法，它的第一个参数是文件名称，第二个参数代表以二进制的形式打开，可以向文件里写入二进制数据。</p>\n<p>运行结束之后，可以发现在文件夹中出现了名为<code>baidu.png</code>的图标。</p>\n<h3 id=\"添加添headers\"><a href=\"#添加添headers\" class=\"headerlink\" title=\"添加添headers\"></a>添加添headers</h3><p>在发起一个<code>HTTP</code>请求的时候，会有一个请求头<code>Request Headers</code>，那么这个怎么来设置呢？</p>\n<p>很简单，使用<code>headers</code>参数就可以完成了。</p>\n<p>在刚才的实例中，是没有设置<code>Request Headers</code>信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p>\n<p>要添加<code>Headers</code>信息，比如添加一个<code>User-Agent</code>字段，可以这么写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123; </span><br><span class=\"line\">    <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, headers=headers, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>当然，我们可以在<code>headers</code>这个参数中任意添加其他的字段信息。</p>\n<h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3><p>使用<code>requests</code>实现<code>post</code>请求，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">data = &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;germey&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"string\">&#x27;25&#x27;</span>&#125;</span><br><span class=\"line\">r = requests.post(<span class=\"string\">&quot;http://httpbin.org/post&quot;</span>, data=data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>这里还是请求<a href=\"http://httpbin.org/post\">http://httpbin.org/post</a>，该网站可以判断如果请求是<code>POST</code>方式，就把相关请求信息返回。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;args&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;data&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;files&quot;</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;form&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;age&quot;</span>: <span class=\"string\">&quot;25&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;germey&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;headers&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Accept&quot;</span>: <span class=\"string\">&quot;*/*&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Accept-Encoding&quot;</span>: <span class=\"string\">&quot;gzip, deflate&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Content-Length&quot;</span>: <span class=\"string\">&quot;18&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Host&quot;</span>: <span class=\"string\">&quot;httpbin.org&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;User-Agent&quot;</span>: <span class=\"string\">&quot;python-requests/2.25.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;X-Amzn-Trace-Id&quot;</span>: <span class=\"string\">&quot;Root=1-60a402c2-68a523624a9ca353207a3a5e&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;json&quot;</span>: null,</span><br><span class=\"line\">  <span class=\"string\">&quot;origin&quot;</span>: <span class=\"string\">&quot;202.62.113.207&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;url&quot;</span>: <span class=\"string\">&quot;http://httpbin.org/post&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h3><p>发送请求后，得到的就是响应，即<code>Response</code>。</p>\n<p>在上面的实例中，使用<code>text</code>和<code>content</code>获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如<code>状态码</code>、<code>响应头</code>、<code>Cookies</code>等。示例如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.status_code), r.status_code)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.headers), r.headers)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.cookies), r.cookies)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.url), r.url)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(r.history), r.history)</span><br></pre></td></tr></table></figure>\n\n<p>这里分别打印输出<code>status_code</code>属性得到状态码，输出<code>headers</code>属性得到响应头，输出<code>cookies</code>属性得到<code>Cookies</code>，输出<code>url</code>属性得到<code>URL</code>，输出<code>history</code>属性得到请求历史。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">int</span>&#x27;&gt; 200</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">requests</span>.<span class=\"title\">structures</span>.<span class=\"title\">CaseInsensitiveDict</span>&#x27;&gt; &#123;&#x27;<span class=\"title\">Date</span>&#x27;:</span> <span class=\"string\">&#x27;Wed, 19 May 2021 12:52:03 GMT&#x27;</span>, <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;text/html; charset=utf-8&#x27;</span>, <span class=\"string\">&#x27;Content-Length&#x27;</span>: <span class=\"string\">&#x27;41538&#x27;</span>, <span class=\"string\">&#x27;Connection&#x27;</span>: <span class=\"string\">&#x27;keep-alive&#x27;</span>, <span class=\"string\">&#x27;X-Frame-Options&#x27;</span>: <span class=\"string\">&#x27;DENY&#x27;</span>, <span class=\"string\">&#x27;X-Content-Type-Options&#x27;</span>: <span class=\"string\">&#x27;nosniff&#x27;</span>, <span class=\"string\">&#x27;Expires&#x27;</span>: <span class=\"string\">&#x27;Wed, 19 May 2021 13:01:46 GMT&#x27;</span>, <span class=\"string\">&#x27;Cache-Control&#x27;</span>: <span class=\"string\">&#x27;max-age=600&#x27;</span>, <span class=\"string\">&#x27;Strict-Transport-Security&#x27;</span>: <span class=\"string\">&#x27;max-age=15724800; includeSubDomains&#x27;</span>&#125;</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">requests</span>.<span class=\"title\">cookies</span>.<span class=\"title\">RequestsCookieJar</span>&#x27;&gt; &lt;<span class=\"title\">RequestsCookieJar</span>[]&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">str</span>&#x27;&gt; <span class=\"title\">https</span>:</span>//static1.scrape.cuiqingcai.com/</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">list</span>&#x27;&gt; []</span></span><br></pre></td></tr></table></figure>\n\n<p><code>headers</code>和<code>cookies</code>这两个属性得到的结果分别是<code>CaseInsensitiveDict</code>和<code>RequestsCookieJar</code>类型。</p>\n<p>状态码是用来表示响应状态的，比如返回<code>200</code>代表我们得到的响应是没问题的，上面的例子正好输出的结果也是<code>200</code>，所以可以通过判断<code>Response</code>的状态码来确认是否爬取成功。</p>\n<p><code>requests</code>还提供了一个内置的状态码查询对象<code>requests.codes</code>，用法示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">exit() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> r.status_code == requests.codes.ok <span class=\"keyword\">else</span> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Request successfully&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用<code>requests.codes.ok</code>得到的是成功的状态码<code>200</code>。</p>\n<p>这样的话，我们就不用再在程序里面写状态码对应的数字了，用字符串表示状态码会显得更加直观。</p>\n<p>下面列出了返回码和相应的查询条件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 信息性状态码</span></span><br><span class=\"line\"><span class=\"number\">100</span>: (<span class=\"string\">&#x27;continue&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">101</span>: (<span class=\"string\">&#x27;switching_protocols&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">102</span>: (<span class=\"string\">&#x27;processing&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">103</span>: (<span class=\"string\">&#x27;checkpoint&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">122</span>: (<span class=\"string\">&#x27;uri_too_long&#x27;</span>, <span class=\"string\">&#x27;request_uri_too_long&#x27;</span>),</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 成功状态码</span></span><br><span class=\"line\"><span class=\"number\">200</span>: (<span class=\"string\">&#x27;ok&#x27;</span>, <span class=\"string\">&#x27;okay&#x27;</span>, <span class=\"string\">&#x27;all_ok&#x27;</span>, <span class=\"string\">&#x27;all_okay&#x27;</span>, <span class=\"string\">&#x27;all_good&#x27;</span>, <span class=\"string\">&#x27;\\\\o/&#x27;</span>, <span class=\"string\">&#x27;✓&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">201</span>: (<span class=\"string\">&#x27;created&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">202</span>: (<span class=\"string\">&#x27;accepted&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">203</span>: (<span class=\"string\">&#x27;non_authoritative_info&#x27;</span>, <span class=\"string\">&#x27;non_authoritative_information&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">204</span>: (<span class=\"string\">&#x27;no_content&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">205</span>: (<span class=\"string\">&#x27;reset_content&#x27;</span>, <span class=\"string\">&#x27;reset&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">206</span>: (<span class=\"string\">&#x27;partial_content&#x27;</span>, <span class=\"string\">&#x27;partial&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">207</span>: (<span class=\"string\">&#x27;multi_status&#x27;</span>, <span class=\"string\">&#x27;multiple_status&#x27;</span>, <span class=\"string\">&#x27;multi_stati&#x27;</span>, <span class=\"string\">&#x27;multiple_stati&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">208</span>: (<span class=\"string\">&#x27;already_reported&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">226</span>: (<span class=\"string\">&#x27;im_used&#x27;</span>,),</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重定向状态码</span></span><br><span class=\"line\"><span class=\"number\">300</span>: (<span class=\"string\">&#x27;multiple_choices&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">301</span>: (<span class=\"string\">&#x27;moved_permanently&#x27;</span>, <span class=\"string\">&#x27;moved&#x27;</span>, <span class=\"string\">&#x27;\\\\o-&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">302</span>: (<span class=\"string\">&#x27;found&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">303</span>: (<span class=\"string\">&#x27;see_other&#x27;</span>, <span class=\"string\">&#x27;other&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">304</span>: (<span class=\"string\">&#x27;not_modified&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">305</span>: (<span class=\"string\">&#x27;use_proxy&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">306</span>: (<span class=\"string\">&#x27;switch_proxy&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">307</span>: (<span class=\"string\">&#x27;temporary_redirect&#x27;</span>, <span class=\"string\">&#x27;temporary_moved&#x27;</span>, <span class=\"string\">&#x27;temporary&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">308</span>: (<span class=\"string\">&#x27;permanent_redirect&#x27;</span>, <span class=\"string\">&#x27;resume_incomplete&#x27;</span>, <span class=\"string\">&#x27;resume&#x27;</span>,), <span class=\"comment\"># These 2 to be removed in 3.0 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 客户端错误状态码 </span></span><br><span class=\"line\"><span class=\"number\">400</span>: (<span class=\"string\">&#x27;bad_request&#x27;</span>, <span class=\"string\">&#x27;bad&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">401</span>: (<span class=\"string\">&#x27;unauthorized&#x27;</span>,), </span><br><span class=\"line\"><span class=\"number\">402</span>: (<span class=\"string\">&#x27;payment_required&#x27;</span>, <span class=\"string\">&#x27;payment&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">403</span>: (<span class=\"string\">&#x27;forbidden&#x27;</span>,), </span><br><span class=\"line\"><span class=\"number\">404</span>: (<span class=\"string\">&#x27;not_found&#x27;</span>, <span class=\"string\">&#x27;-o-&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">405</span>: (<span class=\"string\">&#x27;method_not_allowed&#x27;</span>, <span class=\"string\">&#x27;not_allowed&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">406</span>: (<span class=\"string\">&#x27;not_acceptable&#x27;</span>,), </span><br><span class=\"line\"><span class=\"number\">407</span>: (<span class=\"string\">&#x27;proxy_authentication_required&#x27;</span>, <span class=\"string\">&#x27;proxy_auth&#x27;</span>, <span class=\"string\">&#x27;proxy_authentication&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">408</span>: (<span class=\"string\">&#x27;request_timeout&#x27;</span>, <span class=\"string\">&#x27;timeout&#x27;</span>), </span><br><span class=\"line\"><span class=\"number\">409</span>: (<span class=\"string\">&#x27;conflict&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">410</span>: (<span class=\"string\">&#x27;gone&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">411</span>: (<span class=\"string\">&#x27;length_required&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">412</span>: (<span class=\"string\">&#x27;precondition_failed&#x27;</span>, <span class=\"string\">&#x27;precondition&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">413</span>: (<span class=\"string\">&#x27;request_entity_too_large&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">414</span>: (<span class=\"string\">&#x27;request_uri_too_large&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">415</span>: (<span class=\"string\">&#x27;unsupported_media_type&#x27;</span>, <span class=\"string\">&#x27;unsupported_media&#x27;</span>, <span class=\"string\">&#x27;media_type&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">416</span>: (<span class=\"string\">&#x27;requested_range_not_satisfiable&#x27;</span>, <span class=\"string\">&#x27;requested_range&#x27;</span>, <span class=\"string\">&#x27;range_not_satisfiable&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">417</span>: (<span class=\"string\">&#x27;expectation_failed&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">418</span>: (<span class=\"string\">&#x27;im_a_teapot&#x27;</span>, <span class=\"string\">&#x27;teapot&#x27;</span>, <span class=\"string\">&#x27;i_am_a_teapot&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">421</span>: (<span class=\"string\">&#x27;misdirected_request&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">422</span>: (<span class=\"string\">&#x27;unprocessable_entity&#x27;</span>, <span class=\"string\">&#x27;unprocessable&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">423</span>: (<span class=\"string\">&#x27;locked&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">424</span>: (<span class=\"string\">&#x27;failed_dependency&#x27;</span>, <span class=\"string\">&#x27;dependency&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">425</span>: (<span class=\"string\">&#x27;unordered_collection&#x27;</span>, <span class=\"string\">&#x27;unordered&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">426</span>: (<span class=\"string\">&#x27;upgrade_required&#x27;</span>, <span class=\"string\">&#x27;upgrade&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">428</span>: (<span class=\"string\">&#x27;precondition_required&#x27;</span>, <span class=\"string\">&#x27;precondition&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">429</span>: (<span class=\"string\">&#x27;too_many_requests&#x27;</span>, <span class=\"string\">&#x27;too_many&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">431</span>: (<span class=\"string\">&#x27;header_fields_too_large&#x27;</span>, <span class=\"string\">&#x27;fields_too_large&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">444</span>: (<span class=\"string\">&#x27;no_response&#x27;</span>, <span class=\"string\">&#x27;none&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">449</span>: (<span class=\"string\">&#x27;retry_with&#x27;</span>, <span class=\"string\">&#x27;retry&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">450</span>: (<span class=\"string\">&#x27;blocked_by_windows_parental_controls&#x27;</span>, <span class=\"string\">&#x27;parental_controls&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">451</span>: (<span class=\"string\">&#x27;unavailable_for_legal_reasons&#x27;</span>, <span class=\"string\">&#x27;legal_reasons&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">499</span>: (<span class=\"string\">&#x27;client_closed_request&#x27;</span>,), </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 服务端错误状态码</span></span><br><span class=\"line\"><span class=\"number\">500</span>: (<span class=\"string\">&#x27;internal_server_error&#x27;</span>, <span class=\"string\">&#x27;server_error&#x27;</span>, <span class=\"string\">&#x27;/o\\\\&#x27;</span>, <span class=\"string\">&#x27;✗&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">501</span>: (<span class=\"string\">&#x27;not_implemented&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">502</span>: (<span class=\"string\">&#x27;bad_gateway&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">503</span>: (<span class=\"string\">&#x27;service_unavailable&#x27;</span>, <span class=\"string\">&#x27;unavailable&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">504</span>: (<span class=\"string\">&#x27;gateway_timeout&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">505</span>: (<span class=\"string\">&#x27;http_version_not_supported&#x27;</span>, <span class=\"string\">&#x27;http_version&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">506</span>: (<span class=\"string\">&#x27;variant_also_negotiates&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">507</span>: (<span class=\"string\">&#x27;insufficient_storage&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">509</span>: (<span class=\"string\">&#x27;bandwidth_limit_exceeded&#x27;</span>, <span class=\"string\">&#x27;bandwidth&#x27;</span>),</span><br><span class=\"line\"><span class=\"number\">510</span>: (<span class=\"string\">&#x27;not_extended&#x27;</span>,),</span><br><span class=\"line\"><span class=\"number\">511</span>: (<span class=\"string\">&#x27;network_authentication_required&#x27;</span>, <span class=\"string\">&#x27;network_auth&#x27;</span>, <span class=\"string\">&#x27;network_authentication&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>比如，如果想判断结果是不是<code>404</code>状态，可以用<code>requests.codes.not_found</code>来比对。</p>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><p>刚才，了解<code>requests</code>的基本用法，如基本的<code>GET、POST</code>请求以及<code>Response</code>对象。当然<code>requests</code>能做到的不仅这些，它几乎可以完成<code>HTTP</code>的所有操作。</p>\n<p>下面来了解下<code>requests</code>的一些高级用法，如文件上传、<code>Cookies</code>设置、代理设置等。</p>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><p><code>requests</code>可以模拟提交一些数据。假如有的网站需要上传文件，也可以用它来实现，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">files = &#123;<span class=\"string\">&#x27;file&#x27;</span>:<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;baidu.png&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>)&#125;</span><br><span class=\"line\">r = requests.post(<span class=\"string\">&#x27;http://httpbin.org/post&#x27;</span>, files=files)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是，<code>baidu.png</code>需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;args&quot;: &#123;&#125;, </span><br><span class=\"line\">  &quot;data&quot;: &quot;&quot;, </span><br><span class=\"line\">  &quot;files&quot;: &#123;</span><br><span class=\"line\">    &quot;file&quot;: &quot;data:application/octet-stream;base64,iVBORw0KGgoAAAANSU......&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;form&quot;: &#123;&#125;,</span><br><span class=\"line\">  &quot;headers&quot;: &#123;</span><br><span class=\"line\">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class=\"line\">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class=\"line\">    &quot;Content-Length&quot;: &quot;15589&quot;,</span><br><span class=\"line\">    &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=7e0556b094615781fff3b0ed4316dccd&quot;,</span><br><span class=\"line\">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class=\"line\">    &quot;User-Agent&quot;: &quot;python-requests/2.25.1&quot;,</span><br><span class=\"line\">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60a72501-36f606570785cb9d4356df71&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;json&quot;: null,</span><br><span class=\"line\">  &quot;origin&quot;: &quot;202.62.112.143&quot;,</span><br><span class=\"line\">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上省略部分内容，这个网站会返回响应，里面包含<code>files</code>这个字段，而<code>form</code>字段是空的，这证明文件上传部分会单独有一个<code>files</code>字段来标识。</p>\n<h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><p>获取<code>Cookies</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.cookies)</span><br><span class=\"line\"><span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> r.cookies.items():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(key + <span class=\"string\">&#x27;=&#x27;</span> + value)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span><br><span class=\"line\">BDORZ=27315</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>cookies</code>属性即可成功得到<code>Cookies</code>，可以发现它是<code>RequestCookieJar</code>类型。然后用<code>items</code> 方法将其转化为元组组成的列表，遍历输出每一个<code>Cookie</code>的名称和值，实现<code>Cookie</code>的遍历解析。</p>\n<p>可以直接用<code>Cookie</code>来维持登录状态，下面我们以<code>GitHub</code>为例来说明一下，首先我们登录<code>GitHub</code>，然后将<code>Headers</code>中的<code>Cookie</code>内容复制下来，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>可以替换成你自己的<code>Cookie</code>，将其设置到<code>Headers</code>里面，然后发送请求。</p>\n<h3 id=\"Session维持\"><a href=\"#Session维持\" class=\"headerlink\" title=\"Session维持\"></a>Session维持</h3><p>在<code>requests</code>中，如果直接利用<code>get</code>或<code>post</code>等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的<code>Session</code>，相当于你用两个浏览器打开了不同的页面。</p>\n<p>设想这样一个场景，第一个请求利用<code>post</code>方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次<code>get</code>方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不相关的<code>Session</code>，能成功获取个人信息吗？当然不能。</p>\n<p>解决这个问题的主要方法就是维持同一个<code>Session</code>，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置<code>Cookies</code>，那该怎么办呢？这时候就有了新的利器——**<code>Session</code>对象**。 利用它，可以方便地维护一个<code>Session</code>，而且不用担心<code>Cookies</code>的问题，它会帮我们自动处理好。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;http://httpbin.org/cookies&#x27;</span>, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;cookies&quot;</span>: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这并不行。再用 Session试试看：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">s = requests.Session()</span><br><span class=\"line\">s.get(<span class=\"string\">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>)</span><br><span class=\"line\">r = s.get(<span class=\"string\">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.text)</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;cookies&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;number&quot;</span>: <span class=\"string\">&quot;123456789&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>Session</code>，可以做到模拟同一个<code>Session</code>而不用担心<code>Cookies</code>的问题。它通常用于模拟登录成功之后再进行下一步的操作。</p>\n<h3 id=\"SSL证书验证\"><a href=\"#SSL证书验证\" class=\"headerlink\" title=\"SSL证书验证\"></a>SSL证书验证</h3><p>现在很多网站都要求使用<code>HTTPS</code>协议，但是有些网站可能并没有设置好<code>HTTPS</code>证书，或者网站的<code>HTTPS</code>证书不被<code>CA</code>机构认可，这时候，这些网站可能就会出现<code>SSL</code>证书错误的提示。</p>\n<p>比如示例网站：<a href=\"https://static2.scrape.cuiqingcai.com/\">https://static2.scrape.cuiqingcai.com/</a>。 用浏览器打开这个<code>URL</code>，则会提示<strong>「您的连接不是私密连接」</strong>这样的错误，如图所示：</p>\n<p><img src=\"Screenshot_3.webp\" alt=\"示例网站\"></p>\n<p>那如果我们一定要爬取这个网站怎么办呢？我们可以使用<code>verify</code>参数控制是否验证证书，如果将其设置为<code>False</code>，在请求时就不会再验证证书是否有效。如果不加<code>verify</code>参数的话，默认值是<code>True</code>，会自动验证。</p>\n<p>改写代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code) </span><br></pre></td></tr></table></figure>\n\n<p>这样就会打印出请求成功的状态码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/lib/python3<span class=\"number\">.7</span>/site-packages/urllib3/connectionpool.py:<span class=\"number\">857</span>: InsecureRequestWarning: Unverified HTTPS request <span class=\"keyword\">is</span> being made. Adding certificate verification <span class=\"keyword\">is</span> strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html</span><br><span class=\"line\">InsecureRequestWarning) <span class=\"number\">200</span> </span><br></pre></td></tr></table></figure>\n\n<p>不过发现报了一个警告，它建议我们给它指定证书。可以通过设置忽略警告的方式来屏蔽这个警告：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests <span class=\"keyword\">from</span> requests.packages </span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib3 </span><br><span class=\"line\"></span><br><span class=\"line\">urllib3.disable_warnings() </span><br><span class=\"line\">response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>或者通过捕获警告到日志的方式忽略警告：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging </span><br><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">logging.captureWarnings(<span class=\"literal\">True</span>) </span><br><span class=\"line\">response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, verify=<span class=\"literal\">False</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组： </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests response = requests.get(<span class=\"string\">&#x27;https://static2.scrape.cuiqingcai.com/&#x27;</span>, cert=(<span class=\"string\">&#x27;/path/server.crt&#x27;</span>, <span class=\"string\">&#x27;/path/server.key&#x27;</span>)) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码是演示实例，要有<code>crt</code>和<code>key</code>文件，并且指定它们的路径。另外注意，本地私有证书的<code>key</code>必须是解密状态，加密状态的<code>key</code>是不支持的。</p>\n<h3 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h3><p>在本机网络状况不好或者服务器网络响应延迟甚至无响应时，可能会等待很久才能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到<code>timeout</code>参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, timeout=<span class=\"number\">1</span>) </span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>通过这样的方式将超时时间设置为<code>1</code>秒，如果<code>1</code>秒内没有响应，那就抛出异常。</p>\n<p>实际上，请求分为两个阶段，即连接<code>（connect）</code>和读取<code>（read）</code>。 上面设置的<code>timeout</code>将用作连接和读取这二者的<code>timeout</code>总和。</p>\n<p>如果要分别指定，就可以传入一个元组：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, timeout=(<span class=\"number\">5</span>, <span class=\"number\">30</span>))</span><br></pre></td></tr></table></figure>\n\n<p>如果想永久等待，可以直接将<code>timeout</code>设置为<code>None</code>，或者不设置直接留空，因为默认是<code>None</code>。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, timeout=<span class=\"literal\">None</span>) </span><br></pre></td></tr></table></figure>\n\n<p>或直接不加参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"身份认证\"><a href=\"#身份认证\" class=\"headerlink\" title=\"身份认证\"></a>身份认证</h3><p>在访问某些设置了身份认证的网站时，例如：<a href=\"https://static3.scrape.cuiqingcai.com/\">https://static3.scrape.cuiqingcai.com/</a>，我们可能会遇到这样的认证窗口，如图所示：</p>\n<p><img src=\"Screenshot_4.webp\" alt=\"认证\"></p>\n<p>如果遇到了这种情况，那就是这个网站启用了基本身份认证，英文叫作<code>HTTP Basic Access Authentication</code>，它是一种用来允许网页浏览器或其他客户端程序在请求时提供<strong>用户名</strong>和<strong>口令形式</strong>的身份凭证的一种登录验证方式。 如果遇到了这种情况，怎么用<code>reqeusts</code>来爬取呢，当然也有办法。</p>\n<p>可以使用<code>requests</code>自带的身份认证功能，通过<code>auth</code>参数即可设置，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests.auth <span class=\"keyword\">import</span> HTTPBasicAuth</span><br><span class=\"line\"></span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static3.scrape.cuiqingcai.com/&#x27;</span>, auth=HTTPBasicAuth(<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>), verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>成功的话，返回状态码<code>200</code>。</p>\n<p>如果参数都传一个<code>HTTPBasicAuth</code>类，就显得有点烦琐了，所以<code>requests</code>提供了一个更简单的写法，可以直接传一个元组，它会默认使用<code>HTTPBasicAuth</code>这个类来认证。</p>\n<p>上面的代码可以直接简写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">r = requests.get(<span class=\"string\">&#x27;https://static3.scrape.cuiqingcai.com/&#x27;</span>, auth=(<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>\n\n<p>此外，<code>requests</code>还提供了其他认证方式，如<code>OAuth</code>认证，不过此时需要安装<code>oauth</code>包，安装命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install requests_oauthlib</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>OAuth1</code>认证的方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests <span class=\"keyword\">from</span> requests_oauthlib </span><br><span class=\"line\"><span class=\"keyword\">import</span> OAuth1 </span><br><span class=\"line\">url = <span class=\"string\">&#x27;https://api.twitter.com/1.1/account/verify_credentials.json&#x27;</span> </span><br><span class=\"line\">auth = OAuth1(<span class=\"string\">&#x27;YOUR_APP_KEY&#x27;</span>, <span class=\"string\">&#x27;YOUR_APP_SECRET&#x27;</span>, <span class=\"string\">&#x27;USER_OAUTH_TOKEN&#x27;</span>, <span class=\"string\">&#x27;USER_OAUTH_TOKEN_SECRET&#x27;</span>)</span><br><span class=\"line\">requests.get(url, auth=auth) </span><br></pre></td></tr></table></figure>\n\n<p>更多详细的功能就可以参考<code>requests_oauthlib</code>的官方文档：<a href=\"https://requests-oauthlib.readthedocs.org/\">https://requests-oauthlib.readthedocs.org/</a>，不再赘述。</p>\n<h3 id=\"代理设置\"><a href=\"#代理设置\" class=\"headerlink\" title=\"代理设置\"></a>代理设置</h3><p>某些网站在测试的时候请求几次，能正常获取内容。但是对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的<code>IP</code>，导致一定时间段内无法访问。</p>\n<p>为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到<code>proxies</code>参数。可以用这样的方式设置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">proxies = &#123; </span><br><span class=\"line\">  <span class=\"string\">&#x27;http&#x27;</span>: <span class=\"string\">&#x27;http://10.10.10.10:1080&#x27;</span>, </span><br><span class=\"line\">  <span class=\"string\">&#x27;https&#x27;</span>: <span class=\"string\">&#x27;http://10.10.10.10:1080&#x27;</span>, </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies) </span><br></pre></td></tr></table></figure>\n\n<p>当然，直接运行这个实例或许行不通，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。</p>\n<p>若代理需要使用上文所述的身份认证，可以使用类似<code>ttp://user:password@host:port</code>这样的语法来设置代理，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">proxies = &#123;<span class=\"string\">&#x27;https&#x27;</span>: <span class=\"string\">&#x27;http://user:password@10.10.10.10:1080/&#x27;</span>,&#125; </span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>\n\n<p>除了基本的<code>HTTP</code>代理外，<code>requests</code>还支持<code>SOCKS</code>协议的代理。</p>\n<p>首先，需要安装<code>socks</code>这个库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install <span class=\"string\">&quot;requests[socks]&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后就可以使用<code>SOCKS</code>协议代理了，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\">proxies = &#123; </span><br><span class=\"line\">  <span class=\"string\">&#x27;http&#x27;</span>: <span class=\"string\">&#x27;socks5://user:password@host:port&#x27;</span>, </span><br><span class=\"line\">  <span class=\"string\">&#x27;https&#x27;</span>: <span class=\"string\">&#x27;socks5://user:password@host:port&#x27;</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">requests.get(<span class=\"string\">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>\n"},{"title":"request、pyquest和pymongodb案例实战","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-23T13:12:36.000Z","pic":null,"_content":"\n## 准备工作\n\n在本节课开始之前，我们需要做好如下的准备工作：\n\n- 安装好`Python3`（最低为 3.6 版本），并能成功运行`Python3`程序。\n- 了解`Python`多进程的基本原理。\n- 了解`PythonHTTP`请求库`requests`的基本用法。\n- 了解正则表达式的用法和`Python`中正则表达式库`re`的基本用法。\n- 了解`PythonHTML`解析库`pyquery`的基本用法。\n- 了解`MongoDB`并安装和启动`MongoDB`服务。\n- 了解`Python`的`MongoDB`操作库`PyMongo`的基本用法。\n\n## 爬虫目标\n\n一个基本的静态网站作为案例进行爬取，需要爬取的链接为：[https://static1.scrape.cuiqingcai.com/](https://static1.scrape.cuiqingcai.com/)，这个网站里面包含了一些电影信息。\n\n要完成的目标是：\n\n- 用`requests`爬取这个站点每一页的电影列表，顺着列表再爬取每个电影的详情页。\n- 用`pyquery`和正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等内容。\n- 把以上爬取的内容存入`MongoDB`数据库。\n- 使用多进程实现爬取的加速。\n\n### 爬取列表页\n\n爬取的第一步肯定要从列表页入手，首先观察一下列表页的结构和翻页规则。在浏览器中访问[](https://static1.scrape.cuiqingcai.com/)，然后打开浏览器开发者工具，观察每一个电影信息区块对应的`HTML`，以及进入到详情页的`URL`是怎样的，如图所示：\n\n![](Screenshot_1.webp)\n\n每部电影对应的区块都是一个`div`节点，它的`class`属性都有`el-card`这个值。每个列表页有10个这样的`div`节点，也就对应着10部电影的信息。\n\n再分析下从列表页是怎么进入到详情页的，选中电影的名称，看下结果：\n\n![](Screenshot_2.webp)\n\n这个名称实际上是一个`h2`节点，其内部的文字就是电影的标题。`h2`节点的外面包含了一个`a`节点，这个`a`节点带有`href`属性，这就是一个超链接，其中`href`的值为`/detail/1`，这是一个相对网站的根`URL`[https://static1.scrape.cuiqingcai.com/](https://static1.scrape.cuiqingcai.com/)路径，加上网站的根`URL`就构成了[https://static1.scrape.cuiqingcai.com/detail/1](https://static1.scrape.cuiqingcai.com/detail/1)，也就是这部电影详情页的`URL`。这样只需要提取这个`href`属性就能构造出详情页的`URL`并接着爬取了。\n\n接下来分析下翻页的逻辑，拉到页面的最下方，可以看到分页页码，如图所示：\n\n![](Screenshot_3.webp)\n\n页面显示一共有`100`条数据，10页的内容，因此页码最多是10。接着我们点击第2页，如图所示：\n\n![](Screenshot_4.webp)\n\n可以看到网页的`URL`变成了`https://static1.scrape.cuiqingcai.com/page/2`，相比根`URL`多了`/page/2`这部分内容。网页的结构还是和原来一模一样，所以我们可以和第1页一样处理。\n\n接着查看第3页、第4页等内容，可以发现有这么一个规律，每一页的`URL`最后分别变成了`/page/3`、`/page/4`。所以，`/page`后面跟的就是列表页的页码，当然第1页也是一样，在根`URL`后面加上`/page/1`也是能访问的，只不过网站做了一下处理，默认的页码是1，所以显示第1页的内容。\n\n分析到这里，逻辑基本就清晰了。\n\n如果要完成列表页的爬取，可以这么实现：\n\n- 遍历页码构造`10`页的索引页`URL`。\n- 从每个索引页分析提取出每个电影的详情页`URL`。\n\n先定义一些基础的变量，并引入一些必要的库，写法如下：\n\n```python\nimport requests\nimport logging\nimport re\nimport pymongo\nfrom pyquery import PyQuery as pq\nfrom urllib.parse import urljoin\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s')\n\nBASE_URL = 'https://static1.scrape.cuiqingcai.com'\nTOTAL_PAGE = 10\n```\n\n引入`requests`用来爬取页面，`logging`用来输出信息，`re`用来实现正则表达式解析，`pyquery`用来直接解析网页，`pymongo`用来实现`MongoDB`存储，`urljoin`用来做`URL`的拼接。\n\n接着定义日志输出级别和输出格式，完成之后再定义`BASE_URL`为当前站点的根`URL`，`TOTAL_PAGE`为需要爬取的总页码数量。\n\n定义好了之后，来实现一个页面爬取的方法，实现如下：\n\n```python\ndef scrape_page(url):\n    logging.info('scraping %s...', url)\n    try:\n        response = requests.get(url, verify=False)\n        if response.status_code == 200:\n            return response.text\n        logging.error('get invalid status code %s while scraping %s', response.status_code, url)\n    except requests.RequestException:\n        logging.error('error occurred while scraping %s', url, exc_info=True)\n```\n\n考虑到不仅要爬取列表页，还要爬取详情页，在这里定义一个较通用的爬取页面的方法，叫作`scrape_page`，它接收一个`url`参数，返回页面的`html`代码。\n\n首先判断状态码是不是`200`，如果是，则直接返回页面的`HTML`代码，如果不是，则会输出错误日志信息。另外，这里实现了`requests`的异常处理，如果出现了爬取异常，则会输出对应的错误日志信息。这时将`logging`的`error`方法的`exc_info`参数设置为`True`则可以打印出`Traceback`错误堆栈信息。 \n\n有了`scrape_page`方法之后，给这个方法传入一个`url`，正常情况下它就可以返回页面的`HTML`代码。\n\n在这个基础上，来定义列表页的爬取方法吧，实现如下：\n\n```python\ndef scrape_index(page):\n    index_url = f'{BASE_URL}/page/{page}'\n    return scrape_page(index_url)\n```\n\n方法名称叫作`scrape_index`，这个方法会接收一个`page`参数，即列表页的页码，在方法里面实现列表页的`URL`拼接，然后调用`scrape_page`方法爬取即可得到列表页的`HTML`代码了。\n\n获取了`HTML`代码后，下一步就是解析列表页，并得到每部电影的详情页的`URL`了，实现如下：\n\n```python\ndef parse_index(html):\n    doc = pq(html)\n    links = doc('.el-card .name')\n    for link in links.items():\n        href = link.attr('href')\n        detail_url = urljoin(BASE_URL, href)\n        logging.info('get detail info %s', detail_url)\n        yield detail_url\n```\n\n这里我们定义了`parse_index`方法，它接收一个`html`参数，即列表页的`HTML`代码。接着用`pyquery`新建一个`PyQuery`对象，完成之后再用`.el-card .name`选择器选出来每个电影名称对应的超链接节点。遍历这些节点，通过调用`attr`方法并传入`href`获得详情页的`URL`路径，得到的`href`就是上文所说的类似`/detail/1`这样的结果。这并不是一个完整的`URL`，所以需要借助`urljoin`方法把`BASE_URL`和`href`拼接起来，获得详情页的完整`URL`，得到的结果就是类似`https://static1.scrape.cuiqingcai.com/detail/1`这样完整的`URL`了，最后`yield`返回即可。\n\n通过调用`parse_index`方法传入列表页的`HTML`代码就可以获得该列表页所有电影的详情页`URL`了，接下来把上面的方法串联调用一下，实现如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        logging.info('detail urls %s', list(detail_urls))\n\nif __name__ == '__main__':\n    main()\n```\n\n定义了`main`方法来完成上面所有方法的调用，首先使用`range`方法遍历一下页码，得到的`page`是`1~10`，接着把`page`变量传给`scrape_index`方法，得到列表页的`HTML`，赋值为`index_html`变量。接下来再将`index_html`变量传给`parse_index`方法，得到列表页所有电影的详情页`URL`，赋值为`detail_urls`，结果是一个生成器，调用`list`方法就可以将其输出出来。\n\n```python\n2021-05-23 23:23:04,059 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/1\n2021-05-23 23:23:04,060 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/2\n2021-05-23 23:23:04,061 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/3\n2021-05-23 23:23:04,062 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/4\n2021-05-23 23:23:04,063 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/5\n2021-05-23 23:23:04,064 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/6\n2021-05-23 23:23:04,065 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/7\n2021-05-23 23:23:04,067 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/8\n2021-05-23 23:23:04,070 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/9\n2021-05-23 23:23:04,072 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/10\n2021-05-23 23:23:04,074 - INFO: detail urls ['https://static1.scrape.cuiqingcai.com/detail/1', 'https://static1.scrape.cuiqingcai.com/detail/2', 'https://static1.scrape.cuiqingcai.com/detail/3', 'https://static1.scrape.cuiqingcai.com/detail/4', 'https://static1.scrape.cuiqingcai.com/detail/5', 'https://static1.scrape.cuiqingcai.com/detail/6', 'https://static1.scrape.cuiqingcai.com/detail/7', 'https://static1.scrape.cuiqingcai.com/detail/8', 'https://static1.scrape.cuiqingcai.com/detail/9', 'https://static1.scrape.cuiqingcai.com/detail/10']\n2021-05-23 23:23:04,076 - INFO: scraping https://static1.scrape.cuiqingcai.com/page/2...\n....\n```\n\n由于输出内容比较多，这里只贴了一部分。可以看到，在这个过程中程序首先爬取了第`1`页列表页，然后得到了对应详情页的每个`URL`，接着再接着爬第2页、第3页，一直到第10页，依次输出了每一页的详情页`URL`。这样，就成功获取到所有电影详情页`URL`。\n\n### 爬取详情页\n\n首先观察一下详情页的`HTML`代码，如图所示：\n\n![](Screenshot_5.webp)\n\n经过分析，要提取的内容和对应的节点信息如下：\n\n- 封面：是一个`img`节点，其`class`属性为`cover`。\n- 名称：是一个`h2`节点，其内容便是名称。\n- 类别：是`span`节点，其内容便是类别\n- 内容，其外侧是`button`节点，再外侧则是`class`为`categories`的`div`节点。\n- 上映时间：是`span`节点，其内容包含了上映时间，其外侧是包含了`class`为`info`的`div`节点。但注意这个`div`前面还有一个`class`为`info`的`div`节点，可以使用其内容来区分，也可以使用`nth-child`或`nth- of-type`这样的选择器来区分。另外提取结果中还多了「上映」二字，可以用正则表达式把日期提取出来。\n- 评分：是一个`p`节点，其内容便是评分，`p`节点的`class`属性为`score`。\n- 剧情简介：是一个`p`节点，其内容便是\n- 剧情简介，其外侧是`class`为`drama`的`div`节点。\n\n刚才已经成功获取了详情页的`URL`，接下来要定义一个详情页的爬取方法，实现如下：\n\n```python\ndef scrape_detail(url): \n    return scrape_page(url)\n```\n\n定义了一个`scrape_detail`方法，它接收一个`url`参数，并通过调用`scrape_page`方法获得网页源代码。由于刚才已经实现了`scrape_page`方法，所以在这里不用再写一遍页面爬取的逻辑，直接调用即可，这就做到了代码复用。\n\n单独定义一个`scrape_detail`方法在逻辑上会显得更清晰，而且以后如果想要对`scrape_detail`方法进行改动，比如添加日志输出或是增加预处理，都可以在 `scrape_detail`里面实现，而不用改动`scrape_page`方法，灵活性会更好。\n\n详情页的爬取方法已经实现了，接着就是详情页的解析了，实现如下：\n\n```python\ndef parse_detail(html):\n    \"\"\"详情页的解析\"\"\"\n    doc = pq(html)\n    cover = doc('img.cover').attr('src')\n    name = doc('a > h2').text()\n    categories = [item.text() for item in doc('.categories button span').items()]\n    published_at = doc('.info:contains(上映)').text()\n    published_at = re.search('(\\d{4}-\\d{2}-\\d{2})', published_at).group(1) \\\n        if published_at and re.search('\\d{4}-\\d{2}-\\d{2}', published_at) else None\n    drama = doc('.drama p').text()\n    score = doc('p.score').text()\n    score = float(score) if score else None\n    return{\n        'cover': cover,\n        'name': name,\n        'categories': categories,\n        'published_at': published_at,\n        'drama': drama,\n        'score': score\n    }\n```\n\n定义了`parse_detail`方法用于解析详情页，它接收一个`html`参数，解析其中的内容，并以字典的形式返回结果。每个字段的解析情况如下所述：\n\n- `cove`r：封面，直接选取`class`为`cover`的`img`节点，并调用`attr`方法获取`src`属性的内容即可。\n- `name`：名称，直接选取`a`节点的直接子节点`h2`节点，并调用`text`方法提取其文本内容即可得到名称。\n- `categories`：类别，由于类别是多个，所以这里首先用`.categories button span`选取了`class`为`categories`的节点内部的`span`节点，其结果是多个，所以这里进行了遍历，取出了每个`span`节点的文本内容，得到的便是列表形式的类别。\n- `published_at`：上映时间，由于`pyquery`支持使用`:contains`直接指定包含的文本内容并进行提取，且每个上映时间信息都包含了「上映」二字，所以这里就直接使用`:contains(上映)`提取了`class`为`info`的`div`节点。提取之后，得到的结果类似「1993-07-26 上映」这样，并不想要「上映」这两个字，所以又调用了正则表达式把日期单独提取出来了。当然这里也可以直接使用`strip`或`replace`方法把多余的文字去掉。\n- `drama`：直接提取`class`为`drama`的节点内部的`p`节点的文本即可。\n- `score`：直接提取`class`为`score`的`p`节点的文本即可，由于提取结果是字符串，所以我们需要把它转成浮点数，即``float`类型。\n\n上述字段提取完毕之后，构造一个字典返回。这样，成功完成了详情页的提取和分析了。\n\n将main方法稍微改写一下，增加这两个方法的调用，改写如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        for detail_url in detail_urls:\n            detail_html = scrape_detail(detail_url)\n            data = parse_detail(detail_html)\n            logging.info('get detail data %s', data)\n```\n\n首先遍历了`detail_urls`，获取了每个详情页的`URL`，然后依次调用了`scrape_detail`和`parse_detail`方法，最后得到了每个详情页的提取结果，赋值为`data`并输出。\n\n运行结果如下：\n\n```python\n2021-05-24 12:46:31,432 - INFO: get detail data {'cover': 'https://p0.meituan.net/movie/b0d986a8bf89278afbb19f6abaef70f31206570.jpg@464w_644h_1e_1c', 'name': \"辛德勒的名单 - Schindler's List\", 'categories': ['剧情', '历史', '战争'], 'published_at': '1993-11-30', 'drama': '1939年，波兰在纳粹德国的统治下，党卫军对犹太人进行了隔离统治。德国商人奥斯卡·辛德勒（连姆·尼森 饰）来到德军统治下的克拉科夫，开设了一间搪瓷厂，生产军需用品。凭着出众的社交能力和大量的金钱，辛德勒和德军建立了良好 的关系，他的工厂雇用犹太人工作，大发战争财。1943年，克拉科夫的犹太人遭到了惨绝人寰的大屠杀，辛德勒目睹这一切，受到了极大的震撼，他贿赂军官，让自己的工厂成为集中营的附属劳役营，在那些疯狂屠杀的日子里，他的工厂也成为了犹太人的避难所。1944年，德国战败前夕，屠杀犹太人的行动越发疯狂，辛德勒向德军军官开出了1200人的名单，倾家荡产买下了这些犹太人的生命。在那些暗无天日的岁月里，拯救一个人，就是拯救全世界。', 'score': 9.5}\n```\n\n可以看到，已经成功提取出每部电影的基本信息，包括封面、名称、类别，等等。\n\n## 保存到MongoDB\n\n请确保现在有一个可以正常连接和使用的`MongoDB`数据库。 将数据导入`MongoDB`需要用到`PyMongo`这个库，这个在最开始已经引入过了。那么接下来我们定义一下 `MongoDB`的连接配置，实现如下：\n\n```python\nMONGO_CONNECTION_STRING = 'mongodb://localhost:27017'\nMONGO_DB_NAME = 'movies'\nMONGO_COLLECTIONS_NAME = 'movies'\n\nclient = pymongo.MongoClient(MONGO_CONNECTION_STRING)\ndb = client['movies']\ncollection = db['movies']\n```\n\n在这里声明了几个变量，介绍如下：\n\n- `MONGO_CONNECTION_STRING`：`MongoDB`的连接字符串，里面定义了`MongoDB`的基本连接信息，如`host`、`port`，还可以定义用户名密码等内容。\n- `MONGO_DB_NAME`：`MongoDB`数据库的名称。\n- `MONGO_COLLECTION_NAME`：`MongoDB`的集合名称。\n\n这里用`MongoClient`声明了一个连接对象，然后依次声明了存储的数据库和集合。接下来，再实现一个将数据保存到`MongoDB`的方法，实现如下：\n\n```python\ndef save_data(data):\n    collection.update_one({\n        'name': data.get('name')\n    },{\n        '$set': data\n    }, upsert=True)\n```\n\n声明了一个`save_data`方法，它接收一个`data`参数，也就是我们刚才提取的电影详情信息。在方法里面，调用了`update_one`方法，第1个参数是**查询条件**，即根据`name`进行查询；第2个参数是`data`对象本身，也就是所有的数据，这里用`$set`操作符表示更新操作；第3个参数很关键，这里实际上是`upsert`参数，如果把这个设置为 `True`，则可以做到存在即更新，不存在即插入的功能，更新会根据第一个参数设置的`name`字段，所以这样可以防止数据库中出现同名的电影数据。\n\n> 注：实际上电影可能有同名，但该场景下的爬取数据没有同名情况，当然这里更重要的是实现`MongoDB`的去重操作。\n\n接下来将`main`方法稍微改写一下就好了，改写如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        for detail_url in detail_urls:\n            detail_html = scrape_detail(detail_url)\n            data = parse_detail(detail_html)\n            logging.info('get detail data %s\\n', data)\n            logging.info('saving data to mongodb')\n            save_data(data)\n            logging.info('data saved successfully\\n')\n```\n\n重新运行，输出结果：\n\n```python\n......\n2021-05-24 13:16:46,882 - INFO: get detail data {'cover': 'https://p0.meituan.net/movie/58782fa5439c25d764713f711ebecd1e201941.jpg@464w_644h_1e_1c', 'name': '魂断蓝桥 - Waterloo Bridge', 'categories': ['剧情', '爱情', '战争'], 'published_at': '1940-05-17', 'drama': '第一次世界大战期间，回国度假的陆军中 \n尉罗伊（罗伯特·泰勒 饰）在滑铁卢桥上邂逅了舞蹈演员玛拉（费雯·丽 饰），两人彼此倾心，爱情迅速升温。就在两人决定结婚之时，罗伊应招回营地，两人被迫分离。由\n于错过剧团演出，玛拉被开除，只能和好友相依为命。不久玛拉得知罗伊阵亡的消息，几欲崩溃，备受打击。失去爱情的玛拉感到一切都失去了意义，为了生存，她和好友不\n得不沦为妓女。然而命运弄人，就在此时玛拉竟然再次遇到了罗伊。虽然为罗伊的生还兴奋不已，玛拉却因自己的失身陷入痛苦之中。感到一切难以挽回的玛拉潸然离开，独\n自来到两人最初相遇的地点——滑铁卢桥上…', 'score': 9.5}\n\n2021-05-24 13:16:46,885 - INFO: saving data to mongodb\n2021-05-24 13:16:46,889 - INFO: data saved successfully\n```\n\n运行完毕之后我们可以使用`MongoDB`客户端工具可视化查看已经爬取到的数据，结果如下：\n\n![](Screenshot_6.webp)\n\n## 多进程加速\n\n由于整个的爬取是单进程的，而且只能逐条爬取，速度稍微有点慢，有没有方法来对整个爬取过程进行加速呢？\n\n在前面学习了多进程的基本原理和使用方法，下面就来实践一下多进程的爬取。\n\n由于一共有`10`页详情页，并且这`10`页内容是互不干扰的，所以可以一页开一个进程来爬取。由于这`10`个列表页页码正好可以提前构造成一个列表，所以可以选用多进程里面的进程池`Pool`来实现这个过程。\n\n这里需要改写下`main`方法的调用，实现如下：\n\n```python\ndef main(page):\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        for detail_url in detail_urls:\n            detail_html = scrape_detail(detail_url)\n            data = parse_detail(detail_html)\n            logging.info('get detail data %s\\n', data)\n            logging.info('saving data to mongodb')\n            save_data(data)\n            logging.info('data saved successfully\\n')\n\n\nif __name__ == '__main__':\n    pool = multiprocessing.Pool()\n    pages = range(1, TOTAL_PAGE + 1)\n    pool.map(main, pages)\n    pool.close()\n    pool.join()\n```\n\n这里首先给`main`方法添加一个参数`page`，用以表示列表页的页码。接着声明了一个进程池，并声明`pages`为所有需要遍历的页码，即`1~10`。最后调用`map`方法，第1个参数就是需要被调用的方法，第2个参数就是`pages`，即需要遍历的页码。\n\n这样`pages`就会被依次遍历。把`1~10`这10个页码分别传递给`main`方法，并把每次的调用变成一个进程，加入到进程池中执行，进程池会根据当前运行环境来决定运行多少进程。\n\n运行输出结果和之前类似，但是可以明显看到加了多进程执行之后，爬取速度快了非常多。可以清空一下之前的`MongoDB`数据，可以发现数据依然可以被正常保存到`MongoDB`数据库中。\n","source":"_posts/request、pyquest和pymongodb案例实战.md","raw":"---\ntitle: request、pyquest和pymongodb案例实战\ntags:\n  - request\n  - pyquest\n  - pymongodb\ncomments: true\ntoc: true\nonly:\n  - home\n  - category\n  - tag\ndate: 2021-05-23 21:12:36\ncategories: 爬虫\npic:\n---\n\n## 准备工作\n\n在本节课开始之前，我们需要做好如下的准备工作：\n\n- 安装好`Python3`（最低为 3.6 版本），并能成功运行`Python3`程序。\n- 了解`Python`多进程的基本原理。\n- 了解`PythonHTTP`请求库`requests`的基本用法。\n- 了解正则表达式的用法和`Python`中正则表达式库`re`的基本用法。\n- 了解`PythonHTML`解析库`pyquery`的基本用法。\n- 了解`MongoDB`并安装和启动`MongoDB`服务。\n- 了解`Python`的`MongoDB`操作库`PyMongo`的基本用法。\n\n## 爬虫目标\n\n一个基本的静态网站作为案例进行爬取，需要爬取的链接为：[https://static1.scrape.cuiqingcai.com/](https://static1.scrape.cuiqingcai.com/)，这个网站里面包含了一些电影信息。\n\n要完成的目标是：\n\n- 用`requests`爬取这个站点每一页的电影列表，顺着列表再爬取每个电影的详情页。\n- 用`pyquery`和正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等内容。\n- 把以上爬取的内容存入`MongoDB`数据库。\n- 使用多进程实现爬取的加速。\n\n### 爬取列表页\n\n爬取的第一步肯定要从列表页入手，首先观察一下列表页的结构和翻页规则。在浏览器中访问[](https://static1.scrape.cuiqingcai.com/)，然后打开浏览器开发者工具，观察每一个电影信息区块对应的`HTML`，以及进入到详情页的`URL`是怎样的，如图所示：\n\n![](Screenshot_1.webp)\n\n每部电影对应的区块都是一个`div`节点，它的`class`属性都有`el-card`这个值。每个列表页有10个这样的`div`节点，也就对应着10部电影的信息。\n\n再分析下从列表页是怎么进入到详情页的，选中电影的名称，看下结果：\n\n![](Screenshot_2.webp)\n\n这个名称实际上是一个`h2`节点，其内部的文字就是电影的标题。`h2`节点的外面包含了一个`a`节点，这个`a`节点带有`href`属性，这就是一个超链接，其中`href`的值为`/detail/1`，这是一个相对网站的根`URL`[https://static1.scrape.cuiqingcai.com/](https://static1.scrape.cuiqingcai.com/)路径，加上网站的根`URL`就构成了[https://static1.scrape.cuiqingcai.com/detail/1](https://static1.scrape.cuiqingcai.com/detail/1)，也就是这部电影详情页的`URL`。这样只需要提取这个`href`属性就能构造出详情页的`URL`并接着爬取了。\n\n接下来分析下翻页的逻辑，拉到页面的最下方，可以看到分页页码，如图所示：\n\n![](Screenshot_3.webp)\n\n页面显示一共有`100`条数据，10页的内容，因此页码最多是10。接着我们点击第2页，如图所示：\n\n![](Screenshot_4.webp)\n\n可以看到网页的`URL`变成了`https://static1.scrape.cuiqingcai.com/page/2`，相比根`URL`多了`/page/2`这部分内容。网页的结构还是和原来一模一样，所以我们可以和第1页一样处理。\n\n接着查看第3页、第4页等内容，可以发现有这么一个规律，每一页的`URL`最后分别变成了`/page/3`、`/page/4`。所以，`/page`后面跟的就是列表页的页码，当然第1页也是一样，在根`URL`后面加上`/page/1`也是能访问的，只不过网站做了一下处理，默认的页码是1，所以显示第1页的内容。\n\n分析到这里，逻辑基本就清晰了。\n\n如果要完成列表页的爬取，可以这么实现：\n\n- 遍历页码构造`10`页的索引页`URL`。\n- 从每个索引页分析提取出每个电影的详情页`URL`。\n\n先定义一些基础的变量，并引入一些必要的库，写法如下：\n\n```python\nimport requests\nimport logging\nimport re\nimport pymongo\nfrom pyquery import PyQuery as pq\nfrom urllib.parse import urljoin\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s')\n\nBASE_URL = 'https://static1.scrape.cuiqingcai.com'\nTOTAL_PAGE = 10\n```\n\n引入`requests`用来爬取页面，`logging`用来输出信息，`re`用来实现正则表达式解析，`pyquery`用来直接解析网页，`pymongo`用来实现`MongoDB`存储，`urljoin`用来做`URL`的拼接。\n\n接着定义日志输出级别和输出格式，完成之后再定义`BASE_URL`为当前站点的根`URL`，`TOTAL_PAGE`为需要爬取的总页码数量。\n\n定义好了之后，来实现一个页面爬取的方法，实现如下：\n\n```python\ndef scrape_page(url):\n    logging.info('scraping %s...', url)\n    try:\n        response = requests.get(url, verify=False)\n        if response.status_code == 200:\n            return response.text\n        logging.error('get invalid status code %s while scraping %s', response.status_code, url)\n    except requests.RequestException:\n        logging.error('error occurred while scraping %s', url, exc_info=True)\n```\n\n考虑到不仅要爬取列表页，还要爬取详情页，在这里定义一个较通用的爬取页面的方法，叫作`scrape_page`，它接收一个`url`参数，返回页面的`html`代码。\n\n首先判断状态码是不是`200`，如果是，则直接返回页面的`HTML`代码，如果不是，则会输出错误日志信息。另外，这里实现了`requests`的异常处理，如果出现了爬取异常，则会输出对应的错误日志信息。这时将`logging`的`error`方法的`exc_info`参数设置为`True`则可以打印出`Traceback`错误堆栈信息。 \n\n有了`scrape_page`方法之后，给这个方法传入一个`url`，正常情况下它就可以返回页面的`HTML`代码。\n\n在这个基础上，来定义列表页的爬取方法吧，实现如下：\n\n```python\ndef scrape_index(page):\n    index_url = f'{BASE_URL}/page/{page}'\n    return scrape_page(index_url)\n```\n\n方法名称叫作`scrape_index`，这个方法会接收一个`page`参数，即列表页的页码，在方法里面实现列表页的`URL`拼接，然后调用`scrape_page`方法爬取即可得到列表页的`HTML`代码了。\n\n获取了`HTML`代码后，下一步就是解析列表页，并得到每部电影的详情页的`URL`了，实现如下：\n\n```python\ndef parse_index(html):\n    doc = pq(html)\n    links = doc('.el-card .name')\n    for link in links.items():\n        href = link.attr('href')\n        detail_url = urljoin(BASE_URL, href)\n        logging.info('get detail info %s', detail_url)\n        yield detail_url\n```\n\n这里我们定义了`parse_index`方法，它接收一个`html`参数，即列表页的`HTML`代码。接着用`pyquery`新建一个`PyQuery`对象，完成之后再用`.el-card .name`选择器选出来每个电影名称对应的超链接节点。遍历这些节点，通过调用`attr`方法并传入`href`获得详情页的`URL`路径，得到的`href`就是上文所说的类似`/detail/1`这样的结果。这并不是一个完整的`URL`，所以需要借助`urljoin`方法把`BASE_URL`和`href`拼接起来，获得详情页的完整`URL`，得到的结果就是类似`https://static1.scrape.cuiqingcai.com/detail/1`这样完整的`URL`了，最后`yield`返回即可。\n\n通过调用`parse_index`方法传入列表页的`HTML`代码就可以获得该列表页所有电影的详情页`URL`了，接下来把上面的方法串联调用一下，实现如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        logging.info('detail urls %s', list(detail_urls))\n\nif __name__ == '__main__':\n    main()\n```\n\n定义了`main`方法来完成上面所有方法的调用，首先使用`range`方法遍历一下页码，得到的`page`是`1~10`，接着把`page`变量传给`scrape_index`方法，得到列表页的`HTML`，赋值为`index_html`变量。接下来再将`index_html`变量传给`parse_index`方法，得到列表页所有电影的详情页`URL`，赋值为`detail_urls`，结果是一个生成器，调用`list`方法就可以将其输出出来。\n\n```python\n2021-05-23 23:23:04,059 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/1\n2021-05-23 23:23:04,060 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/2\n2021-05-23 23:23:04,061 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/3\n2021-05-23 23:23:04,062 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/4\n2021-05-23 23:23:04,063 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/5\n2021-05-23 23:23:04,064 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/6\n2021-05-23 23:23:04,065 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/7\n2021-05-23 23:23:04,067 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/8\n2021-05-23 23:23:04,070 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/9\n2021-05-23 23:23:04,072 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/10\n2021-05-23 23:23:04,074 - INFO: detail urls ['https://static1.scrape.cuiqingcai.com/detail/1', 'https://static1.scrape.cuiqingcai.com/detail/2', 'https://static1.scrape.cuiqingcai.com/detail/3', 'https://static1.scrape.cuiqingcai.com/detail/4', 'https://static1.scrape.cuiqingcai.com/detail/5', 'https://static1.scrape.cuiqingcai.com/detail/6', 'https://static1.scrape.cuiqingcai.com/detail/7', 'https://static1.scrape.cuiqingcai.com/detail/8', 'https://static1.scrape.cuiqingcai.com/detail/9', 'https://static1.scrape.cuiqingcai.com/detail/10']\n2021-05-23 23:23:04,076 - INFO: scraping https://static1.scrape.cuiqingcai.com/page/2...\n....\n```\n\n由于输出内容比较多，这里只贴了一部分。可以看到，在这个过程中程序首先爬取了第`1`页列表页，然后得到了对应详情页的每个`URL`，接着再接着爬第2页、第3页，一直到第10页，依次输出了每一页的详情页`URL`。这样，就成功获取到所有电影详情页`URL`。\n\n### 爬取详情页\n\n首先观察一下详情页的`HTML`代码，如图所示：\n\n![](Screenshot_5.webp)\n\n经过分析，要提取的内容和对应的节点信息如下：\n\n- 封面：是一个`img`节点，其`class`属性为`cover`。\n- 名称：是一个`h2`节点，其内容便是名称。\n- 类别：是`span`节点，其内容便是类别\n- 内容，其外侧是`button`节点，再外侧则是`class`为`categories`的`div`节点。\n- 上映时间：是`span`节点，其内容包含了上映时间，其外侧是包含了`class`为`info`的`div`节点。但注意这个`div`前面还有一个`class`为`info`的`div`节点，可以使用其内容来区分，也可以使用`nth-child`或`nth- of-type`这样的选择器来区分。另外提取结果中还多了「上映」二字，可以用正则表达式把日期提取出来。\n- 评分：是一个`p`节点，其内容便是评分，`p`节点的`class`属性为`score`。\n- 剧情简介：是一个`p`节点，其内容便是\n- 剧情简介，其外侧是`class`为`drama`的`div`节点。\n\n刚才已经成功获取了详情页的`URL`，接下来要定义一个详情页的爬取方法，实现如下：\n\n```python\ndef scrape_detail(url): \n    return scrape_page(url)\n```\n\n定义了一个`scrape_detail`方法，它接收一个`url`参数，并通过调用`scrape_page`方法获得网页源代码。由于刚才已经实现了`scrape_page`方法，所以在这里不用再写一遍页面爬取的逻辑，直接调用即可，这就做到了代码复用。\n\n单独定义一个`scrape_detail`方法在逻辑上会显得更清晰，而且以后如果想要对`scrape_detail`方法进行改动，比如添加日志输出或是增加预处理，都可以在 `scrape_detail`里面实现，而不用改动`scrape_page`方法，灵活性会更好。\n\n详情页的爬取方法已经实现了，接着就是详情页的解析了，实现如下：\n\n```python\ndef parse_detail(html):\n    \"\"\"详情页的解析\"\"\"\n    doc = pq(html)\n    cover = doc('img.cover').attr('src')\n    name = doc('a > h2').text()\n    categories = [item.text() for item in doc('.categories button span').items()]\n    published_at = doc('.info:contains(上映)').text()\n    published_at = re.search('(\\d{4}-\\d{2}-\\d{2})', published_at).group(1) \\\n        if published_at and re.search('\\d{4}-\\d{2}-\\d{2}', published_at) else None\n    drama = doc('.drama p').text()\n    score = doc('p.score').text()\n    score = float(score) if score else None\n    return{\n        'cover': cover,\n        'name': name,\n        'categories': categories,\n        'published_at': published_at,\n        'drama': drama,\n        'score': score\n    }\n```\n\n定义了`parse_detail`方法用于解析详情页，它接收一个`html`参数，解析其中的内容，并以字典的形式返回结果。每个字段的解析情况如下所述：\n\n- `cove`r：封面，直接选取`class`为`cover`的`img`节点，并调用`attr`方法获取`src`属性的内容即可。\n- `name`：名称，直接选取`a`节点的直接子节点`h2`节点，并调用`text`方法提取其文本内容即可得到名称。\n- `categories`：类别，由于类别是多个，所以这里首先用`.categories button span`选取了`class`为`categories`的节点内部的`span`节点，其结果是多个，所以这里进行了遍历，取出了每个`span`节点的文本内容，得到的便是列表形式的类别。\n- `published_at`：上映时间，由于`pyquery`支持使用`:contains`直接指定包含的文本内容并进行提取，且每个上映时间信息都包含了「上映」二字，所以这里就直接使用`:contains(上映)`提取了`class`为`info`的`div`节点。提取之后，得到的结果类似「1993-07-26 上映」这样，并不想要「上映」这两个字，所以又调用了正则表达式把日期单独提取出来了。当然这里也可以直接使用`strip`或`replace`方法把多余的文字去掉。\n- `drama`：直接提取`class`为`drama`的节点内部的`p`节点的文本即可。\n- `score`：直接提取`class`为`score`的`p`节点的文本即可，由于提取结果是字符串，所以我们需要把它转成浮点数，即``float`类型。\n\n上述字段提取完毕之后，构造一个字典返回。这样，成功完成了详情页的提取和分析了。\n\n将main方法稍微改写一下，增加这两个方法的调用，改写如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        for detail_url in detail_urls:\n            detail_html = scrape_detail(detail_url)\n            data = parse_detail(detail_html)\n            logging.info('get detail data %s', data)\n```\n\n首先遍历了`detail_urls`，获取了每个详情页的`URL`，然后依次调用了`scrape_detail`和`parse_detail`方法，最后得到了每个详情页的提取结果，赋值为`data`并输出。\n\n运行结果如下：\n\n```python\n2021-05-24 12:46:31,432 - INFO: get detail data {'cover': 'https://p0.meituan.net/movie/b0d986a8bf89278afbb19f6abaef70f31206570.jpg@464w_644h_1e_1c', 'name': \"辛德勒的名单 - Schindler's List\", 'categories': ['剧情', '历史', '战争'], 'published_at': '1993-11-30', 'drama': '1939年，波兰在纳粹德国的统治下，党卫军对犹太人进行了隔离统治。德国商人奥斯卡·辛德勒（连姆·尼森 饰）来到德军统治下的克拉科夫，开设了一间搪瓷厂，生产军需用品。凭着出众的社交能力和大量的金钱，辛德勒和德军建立了良好 的关系，他的工厂雇用犹太人工作，大发战争财。1943年，克拉科夫的犹太人遭到了惨绝人寰的大屠杀，辛德勒目睹这一切，受到了极大的震撼，他贿赂军官，让自己的工厂成为集中营的附属劳役营，在那些疯狂屠杀的日子里，他的工厂也成为了犹太人的避难所。1944年，德国战败前夕，屠杀犹太人的行动越发疯狂，辛德勒向德军军官开出了1200人的名单，倾家荡产买下了这些犹太人的生命。在那些暗无天日的岁月里，拯救一个人，就是拯救全世界。', 'score': 9.5}\n```\n\n可以看到，已经成功提取出每部电影的基本信息，包括封面、名称、类别，等等。\n\n## 保存到MongoDB\n\n请确保现在有一个可以正常连接和使用的`MongoDB`数据库。 将数据导入`MongoDB`需要用到`PyMongo`这个库，这个在最开始已经引入过了。那么接下来我们定义一下 `MongoDB`的连接配置，实现如下：\n\n```python\nMONGO_CONNECTION_STRING = 'mongodb://localhost:27017'\nMONGO_DB_NAME = 'movies'\nMONGO_COLLECTIONS_NAME = 'movies'\n\nclient = pymongo.MongoClient(MONGO_CONNECTION_STRING)\ndb = client['movies']\ncollection = db['movies']\n```\n\n在这里声明了几个变量，介绍如下：\n\n- `MONGO_CONNECTION_STRING`：`MongoDB`的连接字符串，里面定义了`MongoDB`的基本连接信息，如`host`、`port`，还可以定义用户名密码等内容。\n- `MONGO_DB_NAME`：`MongoDB`数据库的名称。\n- `MONGO_COLLECTION_NAME`：`MongoDB`的集合名称。\n\n这里用`MongoClient`声明了一个连接对象，然后依次声明了存储的数据库和集合。接下来，再实现一个将数据保存到`MongoDB`的方法，实现如下：\n\n```python\ndef save_data(data):\n    collection.update_one({\n        'name': data.get('name')\n    },{\n        '$set': data\n    }, upsert=True)\n```\n\n声明了一个`save_data`方法，它接收一个`data`参数，也就是我们刚才提取的电影详情信息。在方法里面，调用了`update_one`方法，第1个参数是**查询条件**，即根据`name`进行查询；第2个参数是`data`对象本身，也就是所有的数据，这里用`$set`操作符表示更新操作；第3个参数很关键，这里实际上是`upsert`参数，如果把这个设置为 `True`，则可以做到存在即更新，不存在即插入的功能，更新会根据第一个参数设置的`name`字段，所以这样可以防止数据库中出现同名的电影数据。\n\n> 注：实际上电影可能有同名，但该场景下的爬取数据没有同名情况，当然这里更重要的是实现`MongoDB`的去重操作。\n\n接下来将`main`方法稍微改写一下就好了，改写如下：\n\n```python\ndef main():\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        for detail_url in detail_urls:\n            detail_html = scrape_detail(detail_url)\n            data = parse_detail(detail_html)\n            logging.info('get detail data %s\\n', data)\n            logging.info('saving data to mongodb')\n            save_data(data)\n            logging.info('data saved successfully\\n')\n```\n\n重新运行，输出结果：\n\n```python\n......\n2021-05-24 13:16:46,882 - INFO: get detail data {'cover': 'https://p0.meituan.net/movie/58782fa5439c25d764713f711ebecd1e201941.jpg@464w_644h_1e_1c', 'name': '魂断蓝桥 - Waterloo Bridge', 'categories': ['剧情', '爱情', '战争'], 'published_at': '1940-05-17', 'drama': '第一次世界大战期间，回国度假的陆军中 \n尉罗伊（罗伯特·泰勒 饰）在滑铁卢桥上邂逅了舞蹈演员玛拉（费雯·丽 饰），两人彼此倾心，爱情迅速升温。就在两人决定结婚之时，罗伊应招回营地，两人被迫分离。由\n于错过剧团演出，玛拉被开除，只能和好友相依为命。不久玛拉得知罗伊阵亡的消息，几欲崩溃，备受打击。失去爱情的玛拉感到一切都失去了意义，为了生存，她和好友不\n得不沦为妓女。然而命运弄人，就在此时玛拉竟然再次遇到了罗伊。虽然为罗伊的生还兴奋不已，玛拉却因自己的失身陷入痛苦之中。感到一切难以挽回的玛拉潸然离开，独\n自来到两人最初相遇的地点——滑铁卢桥上…', 'score': 9.5}\n\n2021-05-24 13:16:46,885 - INFO: saving data to mongodb\n2021-05-24 13:16:46,889 - INFO: data saved successfully\n```\n\n运行完毕之后我们可以使用`MongoDB`客户端工具可视化查看已经爬取到的数据，结果如下：\n\n![](Screenshot_6.webp)\n\n## 多进程加速\n\n由于整个的爬取是单进程的，而且只能逐条爬取，速度稍微有点慢，有没有方法来对整个爬取过程进行加速呢？\n\n在前面学习了多进程的基本原理和使用方法，下面就来实践一下多进程的爬取。\n\n由于一共有`10`页详情页，并且这`10`页内容是互不干扰的，所以可以一页开一个进程来爬取。由于这`10`个列表页页码正好可以提前构造成一个列表，所以可以选用多进程里面的进程池`Pool`来实现这个过程。\n\n这里需要改写下`main`方法的调用，实现如下：\n\n```python\ndef main(page):\n    for page in range(1, TOTAL_PAGE+1):\n        index_html = scrape_index(page)\n        detail_urls = parse_index((index_html))\n        for detail_url in detail_urls:\n            detail_html = scrape_detail(detail_url)\n            data = parse_detail(detail_html)\n            logging.info('get detail data %s\\n', data)\n            logging.info('saving data to mongodb')\n            save_data(data)\n            logging.info('data saved successfully\\n')\n\n\nif __name__ == '__main__':\n    pool = multiprocessing.Pool()\n    pages = range(1, TOTAL_PAGE + 1)\n    pool.map(main, pages)\n    pool.close()\n    pool.join()\n```\n\n这里首先给`main`方法添加一个参数`page`，用以表示列表页的页码。接着声明了一个进程池，并声明`pages`为所有需要遍历的页码，即`1~10`。最后调用`map`方法，第1个参数就是需要被调用的方法，第2个参数就是`pages`，即需要遍历的页码。\n\n这样`pages`就会被依次遍历。把`1~10`这10个页码分别传递给`main`方法，并把每次的调用变成一个进程，加入到进程池中执行，进程池会根据当前运行环境来决定运行多少进程。\n\n运行输出结果和之前类似，但是可以明显看到加了多进程执行之后，爬取速度快了非常多。可以清空一下之前的`MongoDB`数据，可以发现数据依然可以被正常保存到`MongoDB`数据库中。\n","slug":"request、pyquest和pymongodb案例实战","published":1,"updated":"2021-06-15T03:24:11.503Z","_id":"ckpapu7ko003tlcxu496acsnf","layout":"post","photos":[],"link":"","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>在本节课开始之前，我们需要做好如下的准备工作：</p>\n<ul>\n<li>安装好<code>Python3</code>（最低为 3.6 版本），并能成功运行<code>Python3</code>程序。</li>\n<li>了解<code>Python</code>多进程的基本原理。</li>\n<li>了解<code>PythonHTTP</code>请求库<code>requests</code>的基本用法。</li>\n<li>了解正则表达式的用法和<code>Python</code>中正则表达式库<code>re</code>的基本用法。</li>\n<li>了解<code>PythonHTML</code>解析库<code>pyquery</code>的基本用法。</li>\n<li>了解<code>MongoDB</code>并安装和启动<code>MongoDB</code>服务。</li>\n<li>了解<code>Python</code>的<code>MongoDB</code>操作库<code>PyMongo</code>的基本用法。</li>\n</ul>\n<h2 id=\"爬虫目标\"><a href=\"#爬虫目标\" class=\"headerlink\" title=\"爬虫目标\"></a>爬虫目标</h2><p>一个基本的静态网站作为案例进行爬取，需要爬取的链接为：<a href=\"https://static1.scrape.cuiqingcai.com/\">https://static1.scrape.cuiqingcai.com/</a>，这个网站里面包含了一些电影信息。</p>\n<p>要完成的目标是：</p>\n<ul>\n<li>用<code>requests</code>爬取这个站点每一页的电影列表，顺着列表再爬取每个电影的详情页。</li>\n<li>用<code>pyquery</code>和正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等内容。</li>\n<li>把以上爬取的内容存入<code>MongoDB</code>数据库。</li>\n<li>使用多进程实现爬取的加速。</li>\n</ul>\n<h3 id=\"爬取列表页\"><a href=\"#爬取列表页\" class=\"headerlink\" title=\"爬取列表页\"></a>爬取列表页</h3><p>爬取的第一步肯定要从列表页入手，首先观察一下列表页的结构和翻页规则。在浏览器中访问<a href=\"https://static1.scrape.cuiqingcai.com/\"></a>，然后打开浏览器开发者工具，观察每一个电影信息区块对应的<code>HTML</code>，以及进入到详情页的<code>URL</code>是怎样的，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>每部电影对应的区块都是一个<code>div</code>节点，它的<code>class</code>属性都有<code>el-card</code>这个值。每个列表页有10个这样的<code>div</code>节点，也就对应着10部电影的信息。</p>\n<p>再分析下从列表页是怎么进入到详情页的，选中电影的名称，看下结果：</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>这个名称实际上是一个<code>h2</code>节点，其内部的文字就是电影的标题。<code>h2</code>节点的外面包含了一个<code>a</code>节点，这个<code>a</code>节点带有<code>href</code>属性，这就是一个超链接，其中<code>href</code>的值为<code>/detail/1</code>，这是一个相对网站的根<code>URL</code><a href=\"https://static1.scrape.cuiqingcai.com/\">https://static1.scrape.cuiqingcai.com/</a>路径，加上网站的根<code>URL</code>就构成了<a href=\"https://static1.scrape.cuiqingcai.com/detail/1\">https://static1.scrape.cuiqingcai.com/detail/1</a>，也就是这部电影详情页的<code>URL</code>。这样只需要提取这个<code>href</code>属性就能构造出详情页的<code>URL</code>并接着爬取了。</p>\n<p>接下来分析下翻页的逻辑，拉到页面的最下方，可以看到分页页码，如图所示：</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p>页面显示一共有<code>100</code>条数据，10页的内容，因此页码最多是10。接着我们点击第2页，如图所示：</p>\n<p><img src=\"Screenshot_4.webp\"></p>\n<p>可以看到网页的<code>URL</code>变成了<code>https://static1.scrape.cuiqingcai.com/page/2</code>，相比根<code>URL</code>多了<code>/page/2</code>这部分内容。网页的结构还是和原来一模一样，所以我们可以和第1页一样处理。</p>\n<p>接着查看第3页、第4页等内容，可以发现有这么一个规律，每一页的<code>URL</code>最后分别变成了<code>/page/3</code>、<code>/page/4</code>。所以，<code>/page</code>后面跟的就是列表页的页码，当然第1页也是一样，在根<code>URL</code>后面加上<code>/page/1</code>也是能访问的，只不过网站做了一下处理，默认的页码是1，所以显示第1页的内容。</p>\n<p>分析到这里，逻辑基本就清晰了。</p>\n<p>如果要完成列表页的爬取，可以这么实现：</p>\n<ul>\n<li>遍历页码构造<code>10</code>页的索引页<code>URL</code>。</li>\n<li>从每个索引页分析提取出每个电影的详情页<code>URL</code>。</li>\n</ul>\n<p>先定义一些基础的变量，并引入一些必要的库，写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymongo</span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib.parse <span class=\"keyword\">import</span> urljoin</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(level=logging.INFO, <span class=\"built_in\">format</span>=<span class=\"string\">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">BASE_URL = <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com&#x27;</span></span><br><span class=\"line\">TOTAL_PAGE = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>引入<code>requests</code>用来爬取页面，<code>logging</code>用来输出信息，<code>re</code>用来实现正则表达式解析，<code>pyquery</code>用来直接解析网页，<code>pymongo</code>用来实现<code>MongoDB</code>存储，<code>urljoin</code>用来做<code>URL</code>的拼接。</p>\n<p>接着定义日志输出级别和输出格式，完成之后再定义<code>BASE_URL</code>为当前站点的根<code>URL</code>，<code>TOTAL_PAGE</code>为需要爬取的总页码数量。</p>\n<p>定义好了之后，来实现一个页面爬取的方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_page</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    logging.info(<span class=\"string\">&#x27;scraping %s...&#x27;</span>, url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = requests.get(url, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> response.status_code == <span class=\"number\">200</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response.text</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;get invalid status code %s while scraping %s&#x27;</span>, response.status_code, url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.RequestException:</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>考虑到不仅要爬取列表页，还要爬取详情页，在这里定义一个较通用的爬取页面的方法，叫作<code>scrape_page</code>，它接收一个<code>url</code>参数，返回页面的<code>html</code>代码。</p>\n<p>首先判断状态码是不是<code>200</code>，如果是，则直接返回页面的<code>HTML</code>代码，如果不是，则会输出错误日志信息。另外，这里实现了<code>requests</code>的异常处理，如果出现了爬取异常，则会输出对应的错误日志信息。这时将<code>logging</code>的<code>error</code>方法的<code>exc_info</code>参数设置为<code>True</code>则可以打印出<code>Traceback</code>错误堆栈信息。 </p>\n<p>有了<code>scrape_page</code>方法之后，给这个方法传入一个<code>url</code>，正常情况下它就可以返回页面的<code>HTML</code>代码。</p>\n<p>在这个基础上，来定义列表页的爬取方法吧，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_index</span>(<span class=\"params\">page</span>):</span></span><br><span class=\"line\">    index_url = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;BASE_URL&#125;</span>/page/<span class=\"subst\">&#123;page&#125;</span>&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_page(index_url)</span><br></pre></td></tr></table></figure>\n\n<p>方法名称叫作<code>scrape_index</code>，这个方法会接收一个<code>page</code>参数，即列表页的页码，在方法里面实现列表页的<code>URL</code>拼接，然后调用<code>scrape_page</code>方法爬取即可得到列表页的<code>HTML</code>代码了。</p>\n<p>获取了<code>HTML</code>代码后，下一步就是解析列表页，并得到每部电影的详情页的<code>URL</code>了，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_index</span>(<span class=\"params\">html</span>):</span></span><br><span class=\"line\">    doc = pq(html)</span><br><span class=\"line\">    links = doc(<span class=\"string\">&#x27;.el-card .name&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> link <span class=\"keyword\">in</span> links.items():</span><br><span class=\"line\">        href = link.attr(<span class=\"string\">&#x27;href&#x27;</span>)</span><br><span class=\"line\">        detail_url = urljoin(BASE_URL, href)</span><br><span class=\"line\">        logging.info(<span class=\"string\">&#x27;get detail info %s&#x27;</span>, detail_url)</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> detail_url</span><br></pre></td></tr></table></figure>\n\n<p>这里我们定义了<code>parse_index</code>方法，它接收一个<code>html</code>参数，即列表页的<code>HTML</code>代码。接着用<code>pyquery</code>新建一个<code>PyQuery</code>对象，完成之后再用<code>.el-card .name</code>选择器选出来每个电影名称对应的超链接节点。遍历这些节点，通过调用<code>attr</code>方法并传入<code>href</code>获得详情页的<code>URL</code>路径，得到的<code>href</code>就是上文所说的类似<code>/detail/1</code>这样的结果。这并不是一个完整的<code>URL</code>，所以需要借助<code>urljoin</code>方法把<code>BASE_URL</code>和<code>href</code>拼接起来，获得详情页的完整<code>URL</code>，得到的结果就是类似<code>https://static1.scrape.cuiqingcai.com/detail/1</code>这样完整的<code>URL</code>了，最后<code>yield</code>返回即可。</p>\n<p>通过调用<code>parse_index</code>方法传入列表页的<code>HTML</code>代码就可以获得该列表页所有电影的详情页<code>URL</code>了，接下来把上面的方法串联调用一下，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        logging.info(<span class=\"string\">&#x27;detail urls %s&#x27;</span>, <span class=\"built_in\">list</span>(detail_urls))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>定义了<code>main</code>方法来完成上面所有方法的调用，首先使用<code>range</code>方法遍历一下页码，得到的<code>page</code>是<code>1~10</code>，接着把<code>page</code>变量传给<code>scrape_index</code>方法，得到列表页的<code>HTML</code>，赋值为<code>index_html</code>变量。接下来再将<code>index_html</code>变量传给<code>parse_index</code>方法，得到列表页所有电影的详情页<code>URL</code>，赋值为<code>detail_urls</code>，结果是一个生成器，调用<code>list</code>方法就可以将其输出出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,059 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,060 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,061 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,062 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,063 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,064 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,065 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,067 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,070 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,072 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,074 - INFO: detail urls [<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/1&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/2&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/3&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/4&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/5&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/6&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/7&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/8&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/9&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/10&#x27;</span>]</span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,076 - INFO: scraping https://static1.scrape.cuiqingcai.com/page/<span class=\"number\">2.</span>..</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n\n<p>由于输出内容比较多，这里只贴了一部分。可以看到，在这个过程中程序首先爬取了第<code>1</code>页列表页，然后得到了对应详情页的每个<code>URL</code>，接着再接着爬第2页、第3页，一直到第10页，依次输出了每一页的详情页<code>URL</code>。这样，就成功获取到所有电影详情页<code>URL</code>。</p>\n<h3 id=\"爬取详情页\"><a href=\"#爬取详情页\" class=\"headerlink\" title=\"爬取详情页\"></a>爬取详情页</h3><p>首先观察一下详情页的<code>HTML</code>代码，如图所示：</p>\n<p><img src=\"Screenshot_5.webp\"></p>\n<p>经过分析，要提取的内容和对应的节点信息如下：</p>\n<ul>\n<li>封面：是一个<code>img</code>节点，其<code>class</code>属性为<code>cover</code>。</li>\n<li>名称：是一个<code>h2</code>节点，其内容便是名称。</li>\n<li>类别：是<code>span</code>节点，其内容便是类别</li>\n<li>内容，其外侧是<code>button</code>节点，再外侧则是<code>class</code>为<code>categories</code>的<code>div</code>节点。</li>\n<li>上映时间：是<code>span</code>节点，其内容包含了上映时间，其外侧是包含了<code>class</code>为<code>info</code>的<code>div</code>节点。但注意这个<code>div</code>前面还有一个<code>class</code>为<code>info</code>的<code>div</code>节点，可以使用其内容来区分，也可以使用<code>nth-child</code>或<code>nth- of-type</code>这样的选择器来区分。另外提取结果中还多了「上映」二字，可以用正则表达式把日期提取出来。</li>\n<li>评分：是一个<code>p</code>节点，其内容便是评分，<code>p</code>节点的<code>class</code>属性为<code>score</code>。</li>\n<li>剧情简介：是一个<code>p</code>节点，其内容便是</li>\n<li>剧情简介，其外侧是<code>class</code>为<code>drama</code>的<code>div</code>节点。</li>\n</ul>\n<p>刚才已经成功获取了详情页的<code>URL</code>，接下来要定义一个详情页的爬取方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_detail</span>(<span class=\"params\">url</span>):</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_page(url)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>scrape_detail</code>方法，它接收一个<code>url</code>参数，并通过调用<code>scrape_page</code>方法获得网页源代码。由于刚才已经实现了<code>scrape_page</code>方法，所以在这里不用再写一遍页面爬取的逻辑，直接调用即可，这就做到了代码复用。</p>\n<p>单独定义一个<code>scrape_detail</code>方法在逻辑上会显得更清晰，而且以后如果想要对<code>scrape_detail</code>方法进行改动，比如添加日志输出或是增加预处理，都可以在 <code>scrape_detail</code>里面实现，而不用改动<code>scrape_page</code>方法，灵活性会更好。</p>\n<p>详情页的爬取方法已经实现了，接着就是详情页的解析了，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_detail</span>(<span class=\"params\">html</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;详情页的解析&quot;&quot;&quot;</span></span><br><span class=\"line\">    doc = pq(html)</span><br><span class=\"line\">    cover = doc(<span class=\"string\">&#x27;img.cover&#x27;</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">    name = doc(<span class=\"string\">&#x27;a &gt; h2&#x27;</span>).text()</span><br><span class=\"line\">    categories = [item.text() <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> doc(<span class=\"string\">&#x27;.categories button span&#x27;</span>).items()]</span><br><span class=\"line\">    published_at = doc(<span class=\"string\">&#x27;.info:contains(上映)&#x27;</span>).text()</span><br><span class=\"line\">    published_at = re.search(<span class=\"string\">&#x27;(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&#x27;</span>, published_at).group(<span class=\"number\">1</span>) \\</span><br><span class=\"line\">        <span class=\"keyword\">if</span> published_at <span class=\"keyword\">and</span> re.search(<span class=\"string\">&#x27;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;&#x27;</span>, published_at) <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    drama = doc(<span class=\"string\">&#x27;.drama p&#x27;</span>).text()</span><br><span class=\"line\">    score = doc(<span class=\"string\">&#x27;p.score&#x27;</span>).text()</span><br><span class=\"line\">    score = <span class=\"built_in\">float</span>(score) <span class=\"keyword\">if</span> score <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;cover&#x27;</span>: cover,</span><br><span class=\"line\">        <span class=\"string\">&#x27;name&#x27;</span>: name,</span><br><span class=\"line\">        <span class=\"string\">&#x27;categories&#x27;</span>: categories,</span><br><span class=\"line\">        <span class=\"string\">&#x27;published_at&#x27;</span>: published_at,</span><br><span class=\"line\">        <span class=\"string\">&#x27;drama&#x27;</span>: drama,</span><br><span class=\"line\">        <span class=\"string\">&#x27;score&#x27;</span>: score</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义了<code>parse_detail</code>方法用于解析详情页，它接收一个<code>html</code>参数，解析其中的内容，并以字典的形式返回结果。每个字段的解析情况如下所述：</p>\n<ul>\n<li><code>cove</code>r：封面，直接选取<code>class</code>为<code>cover</code>的<code>img</code>节点，并调用<code>attr</code>方法获取<code>src</code>属性的内容即可。</li>\n<li><code>name</code>：名称，直接选取<code>a</code>节点的直接子节点<code>h2</code>节点，并调用<code>text</code>方法提取其文本内容即可得到名称。</li>\n<li><code>categories</code>：类别，由于类别是多个，所以这里首先用<code>.categories button span</code>选取了<code>class</code>为<code>categories</code>的节点内部的<code>span</code>节点，其结果是多个，所以这里进行了遍历，取出了每个<code>span</code>节点的文本内容，得到的便是列表形式的类别。</li>\n<li><code>published_at</code>：上映时间，由于<code>pyquery</code>支持使用<code>:contains</code>直接指定包含的文本内容并进行提取，且每个上映时间信息都包含了「上映」二字，所以这里就直接使用<code>:contains(上映)</code>提取了<code>class</code>为<code>info</code>的<code>div</code>节点。提取之后，得到的结果类似「1993-07-26 上映」这样，并不想要「上映」这两个字，所以又调用了正则表达式把日期单独提取出来了。当然这里也可以直接使用<code>strip</code>或<code>replace</code>方法把多余的文字去掉。</li>\n<li><code>drama</code>：直接提取<code>class</code>为<code>drama</code>的节点内部的<code>p</code>节点的文本即可。</li>\n<li><code>score</code>：直接提取<code>class</code>为<code>score</code>的<code>p</code>节点的文本即可，由于提取结果是字符串，所以我们需要把它转成浮点数，即``float`类型。</li>\n</ul>\n<p>上述字段提取完毕之后，构造一个字典返回。这样，成功完成了详情页的提取和分析了。</p>\n<p>将main方法稍微改写一下，增加这两个方法的调用，改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> detail_url <span class=\"keyword\">in</span> detail_urls:</span><br><span class=\"line\">            detail_html = scrape_detail(detail_url)</span><br><span class=\"line\">            data = parse_detail(detail_html)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;get detail data %s&#x27;</span>, data)</span><br></pre></td></tr></table></figure>\n\n<p>首先遍历了<code>detail_urls</code>，获取了每个详情页的<code>URL</code>，然后依次调用了<code>scrape_detail</code>和<code>parse_detail</code>方法，最后得到了每个详情页的提取结果，赋值为<code>data</code>并输出。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">12</span>:<span class=\"number\">46</span>:<span class=\"number\">31</span>,<span class=\"number\">432</span> - INFO: get detail data &#123;<span class=\"string\">&#x27;cover&#x27;</span>: <span class=\"string\">&#x27;https://p0.meituan.net/movie/b0d986a8bf89278afbb19f6abaef70f31206570.jpg@464w_644h_1e_1c&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&quot;辛德勒的名单 - Schindler&#x27;s List&quot;</span>, <span class=\"string\">&#x27;categories&#x27;</span>: [<span class=\"string\">&#x27;剧情&#x27;</span>, <span class=\"string\">&#x27;历史&#x27;</span>, <span class=\"string\">&#x27;战争&#x27;</span>], <span class=\"string\">&#x27;published_at&#x27;</span>: <span class=\"string\">&#x27;1993-11-30&#x27;</span>, <span class=\"string\">&#x27;drama&#x27;</span>: <span class=\"string\">&#x27;1939年，波兰在纳粹德国的统治下，党卫军对犹太人进行了隔离统治。德国商人奥斯卡·辛德勒（连姆·尼森 饰）来到德军统治下的克拉科夫，开设了一间搪瓷厂，生产军需用品。凭着出众的社交能力和大量的金钱，辛德勒和德军建立了良好 的关系，他的工厂雇用犹太人工作，大发战争财。1943年，克拉科夫的犹太人遭到了惨绝人寰的大屠杀，辛德勒目睹这一切，受到了极大的震撼，他贿赂军官，让自己的工厂成为集中营的附属劳役营，在那些疯狂屠杀的日子里，他的工厂也成为了犹太人的避难所。1944年，德国战败前夕，屠杀犹太人的行动越发疯狂，辛德勒向德军军官开出了1200人的名单，倾家荡产买下了这些犹太人的生命。在那些暗无天日的岁月里，拯救一个人，就是拯救全世界。&#x27;</span>, <span class=\"string\">&#x27;score&#x27;</span>: <span class=\"number\">9.5</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，已经成功提取出每部电影的基本信息，包括封面、名称、类别，等等。</p>\n<h2 id=\"保存到MongoDB\"><a href=\"#保存到MongoDB\" class=\"headerlink\" title=\"保存到MongoDB\"></a>保存到MongoDB</h2><p>请确保现在有一个可以正常连接和使用的<code>MongoDB</code>数据库。 将数据导入<code>MongoDB</code>需要用到<code>PyMongo</code>这个库，这个在最开始已经引入过了。那么接下来我们定义一下 <code>MongoDB</code>的连接配置，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MONGO_CONNECTION_STRING = <span class=\"string\">&#x27;mongodb://localhost:27017&#x27;</span></span><br><span class=\"line\">MONGO_DB_NAME = <span class=\"string\">&#x27;movies&#x27;</span></span><br><span class=\"line\">MONGO_COLLECTIONS_NAME = <span class=\"string\">&#x27;movies&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">client = pymongo.MongoClient(MONGO_CONNECTION_STRING)</span><br><span class=\"line\">db = client[<span class=\"string\">&#x27;movies&#x27;</span>]</span><br><span class=\"line\">collection = db[<span class=\"string\">&#x27;movies&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在这里声明了几个变量，介绍如下：</p>\n<ul>\n<li><code>MONGO_CONNECTION_STRING</code>：<code>MongoDB</code>的连接字符串，里面定义了<code>MongoDB</code>的基本连接信息，如<code>host</code>、<code>port</code>，还可以定义用户名密码等内容。</li>\n<li><code>MONGO_DB_NAME</code>：<code>MongoDB</code>数据库的名称。</li>\n<li><code>MONGO_COLLECTION_NAME</code>：<code>MongoDB</code>的集合名称。</li>\n</ul>\n<p>这里用<code>MongoClient</code>声明了一个连接对象，然后依次声明了存储的数据库和集合。接下来，再实现一个将数据保存到<code>MongoDB</code>的方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_data</span>(<span class=\"params\">data</span>):</span></span><br><span class=\"line\">    collection.update_one(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;name&#x27;</span>: data.get(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;$set&#x27;</span>: data</span><br><span class=\"line\">    &#125;, upsert=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个<code>save_data</code>方法，它接收一个<code>data</code>参数，也就是我们刚才提取的电影详情信息。在方法里面，调用了<code>update_one</code>方法，第1个参数是<strong>查询条件</strong>，即根据<code>name</code>进行查询；第2个参数是<code>data</code>对象本身，也就是所有的数据，这里用<code>$set</code>操作符表示更新操作；第3个参数很关键，这里实际上是<code>upsert</code>参数，如果把这个设置为 <code>True</code>，则可以做到存在即更新，不存在即插入的功能，更新会根据第一个参数设置的<code>name</code>字段，所以这样可以防止数据库中出现同名的电影数据。</p>\n<blockquote>\n<p>注：实际上电影可能有同名，但该场景下的爬取数据没有同名情况，当然这里更重要的是实现<code>MongoDB</code>的去重操作。</p>\n</blockquote>\n<p>接下来将<code>main</code>方法稍微改写一下就好了，改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> detail_url <span class=\"keyword\">in</span> detail_urls:</span><br><span class=\"line\">            detail_html = scrape_detail(detail_url)</span><br><span class=\"line\">            data = parse_detail(detail_html)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;get detail data %s\\n&#x27;</span>, data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;saving data to mongodb&#x27;</span>)</span><br><span class=\"line\">            save_data(data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;data saved successfully\\n&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>重新运行，输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">13</span>:<span class=\"number\">16</span>:<span class=\"number\">46</span>,<span class=\"number\">882</span> - INFO: get detail data &#123;<span class=\"string\">&#x27;cover&#x27;</span>: <span class=\"string\">&#x27;https://p0.meituan.net/movie/58782fa5439c25d764713f711ebecd1e201941.jpg@464w_644h_1e_1c&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;魂断蓝桥 - Waterloo Bridge&#x27;</span>, <span class=\"string\">&#x27;categories&#x27;</span>: [<span class=\"string\">&#x27;剧情&#x27;</span>, <span class=\"string\">&#x27;爱情&#x27;</span>, <span class=\"string\">&#x27;战争&#x27;</span>], <span class=\"string\">&#x27;published_at&#x27;</span>: <span class=\"string\">&#x27;1940-05-17&#x27;</span>, <span class=\"string\">&#x27;drama&#x27;</span>: <span class=\"string\">&#x27;第一次世界大战期间，回国度假的陆军中 </span></span><br><span class=\"line\"><span class=\"string\">尉罗伊（罗伯特·泰勒 饰）在滑铁卢桥上邂逅了舞蹈演员玛拉（费雯·丽 饰），两人彼此倾心，爱情迅速升温。就在两人决定结婚之时，罗伊应招回营地，两人被迫分离。由</span></span><br><span class=\"line\"><span class=\"string\">于错过剧团演出，玛拉被开除，只能和好友相依为命。不久玛拉得知罗伊阵亡的消息，几欲崩溃，备受打击。失去爱情的玛拉感到一切都失去了意义，为了生存，她和好友不</span></span><br><span class=\"line\"><span class=\"string\">得不沦为妓女。然而命运弄人，就在此时玛拉竟然再次遇到了罗伊。虽然为罗伊的生还兴奋不已，玛拉却因自己的失身陷入痛苦之中。感到一切难以挽回的玛拉潸然离开，独</span></span><br><span class=\"line\"><span class=\"string\">自来到两人最初相遇的地点——滑铁卢桥上…&#x27;</span>, <span class=\"string\">&#x27;score&#x27;</span>: <span class=\"number\">9.5</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">13</span>:<span class=\"number\">16</span>:<span class=\"number\">46</span>,<span class=\"number\">885</span> - INFO: saving data to mongodb</span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">13</span>:<span class=\"number\">16</span>:<span class=\"number\">46</span>,<span class=\"number\">889</span> - INFO: data saved successfully</span><br></pre></td></tr></table></figure>\n\n<p>运行完毕之后我们可以使用<code>MongoDB</code>客户端工具可视化查看已经爬取到的数据，结果如下：</p>\n<p><img src=\"Screenshot_6.webp\"></p>\n<h2 id=\"多进程加速\"><a href=\"#多进程加速\" class=\"headerlink\" title=\"多进程加速\"></a>多进程加速</h2><p>由于整个的爬取是单进程的，而且只能逐条爬取，速度稍微有点慢，有没有方法来对整个爬取过程进行加速呢？</p>\n<p>在前面学习了多进程的基本原理和使用方法，下面就来实践一下多进程的爬取。</p>\n<p>由于一共有<code>10</code>页详情页，并且这<code>10</code>页内容是互不干扰的，所以可以一页开一个进程来爬取。由于这<code>10</code>个列表页页码正好可以提前构造成一个列表，所以可以选用多进程里面的进程池<code>Pool</code>来实现这个过程。</p>\n<p>这里需要改写下<code>main</code>方法的调用，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>(<span class=\"params\">page</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> detail_url <span class=\"keyword\">in</span> detail_urls:</span><br><span class=\"line\">            detail_html = scrape_detail(detail_url)</span><br><span class=\"line\">            data = parse_detail(detail_html)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;get detail data %s\\n&#x27;</span>, data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;saving data to mongodb&#x27;</span>)</span><br><span class=\"line\">            save_data(data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;data saved successfully\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pool = multiprocessing.Pool()</span><br><span class=\"line\">    pages = <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE + <span class=\"number\">1</span>)</span><br><span class=\"line\">    pool.<span class=\"built_in\">map</span>(main, pages)</span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br></pre></td></tr></table></figure>\n\n<p>这里首先给<code>main</code>方法添加一个参数<code>page</code>，用以表示列表页的页码。接着声明了一个进程池，并声明<code>pages</code>为所有需要遍历的页码，即<code>1~10</code>。最后调用<code>map</code>方法，第1个参数就是需要被调用的方法，第2个参数就是<code>pages</code>，即需要遍历的页码。</p>\n<p>这样<code>pages</code>就会被依次遍历。把<code>1~10</code>这10个页码分别传递给<code>main</code>方法，并把每次的调用变成一个进程，加入到进程池中执行，进程池会根据当前运行环境来决定运行多少进程。</p>\n<p>运行输出结果和之前类似，但是可以明显看到加了多进程执行之后，爬取速度快了非常多。可以清空一下之前的<code>MongoDB</code>数据，可以发现数据依然可以被正常保存到<code>MongoDB</code>数据库中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>在本节课开始之前，我们需要做好如下的准备工作：</p>\n<ul>\n<li>安装好<code>Python3</code>（最低为 3.6 版本），并能成功运行<code>Python3</code>程序。</li>\n<li>了解<code>Python</code>多进程的基本原理。</li>\n<li>了解<code>PythonHTTP</code>请求库<code>requests</code>的基本用法。</li>\n<li>了解正则表达式的用法和<code>Python</code>中正则表达式库<code>re</code>的基本用法。</li>\n<li>了解<code>PythonHTML</code>解析库<code>pyquery</code>的基本用法。</li>\n<li>了解<code>MongoDB</code>并安装和启动<code>MongoDB</code>服务。</li>\n<li>了解<code>Python</code>的<code>MongoDB</code>操作库<code>PyMongo</code>的基本用法。</li>\n</ul>\n<h2 id=\"爬虫目标\"><a href=\"#爬虫目标\" class=\"headerlink\" title=\"爬虫目标\"></a>爬虫目标</h2><p>一个基本的静态网站作为案例进行爬取，需要爬取的链接为：<a href=\"https://static1.scrape.cuiqingcai.com/\">https://static1.scrape.cuiqingcai.com/</a>，这个网站里面包含了一些电影信息。</p>\n<p>要完成的目标是：</p>\n<ul>\n<li>用<code>requests</code>爬取这个站点每一页的电影列表，顺着列表再爬取每个电影的详情页。</li>\n<li>用<code>pyquery</code>和正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等内容。</li>\n<li>把以上爬取的内容存入<code>MongoDB</code>数据库。</li>\n<li>使用多进程实现爬取的加速。</li>\n</ul>\n<h3 id=\"爬取列表页\"><a href=\"#爬取列表页\" class=\"headerlink\" title=\"爬取列表页\"></a>爬取列表页</h3><p>爬取的第一步肯定要从列表页入手，首先观察一下列表页的结构和翻页规则。在浏览器中访问<a href=\"https://static1.scrape.cuiqingcai.com/\"></a>，然后打开浏览器开发者工具，观察每一个电影信息区块对应的<code>HTML</code>，以及进入到详情页的<code>URL</code>是怎样的，如图所示：</p>\n<p><img src=\"Screenshot_1.webp\"></p>\n<p>每部电影对应的区块都是一个<code>div</code>节点，它的<code>class</code>属性都有<code>el-card</code>这个值。每个列表页有10个这样的<code>div</code>节点，也就对应着10部电影的信息。</p>\n<p>再分析下从列表页是怎么进入到详情页的，选中电影的名称，看下结果：</p>\n<p><img src=\"Screenshot_2.webp\"></p>\n<p>这个名称实际上是一个<code>h2</code>节点，其内部的文字就是电影的标题。<code>h2</code>节点的外面包含了一个<code>a</code>节点，这个<code>a</code>节点带有<code>href</code>属性，这就是一个超链接，其中<code>href</code>的值为<code>/detail/1</code>，这是一个相对网站的根<code>URL</code><a href=\"https://static1.scrape.cuiqingcai.com/\">https://static1.scrape.cuiqingcai.com/</a>路径，加上网站的根<code>URL</code>就构成了<a href=\"https://static1.scrape.cuiqingcai.com/detail/1\">https://static1.scrape.cuiqingcai.com/detail/1</a>，也就是这部电影详情页的<code>URL</code>。这样只需要提取这个<code>href</code>属性就能构造出详情页的<code>URL</code>并接着爬取了。</p>\n<p>接下来分析下翻页的逻辑，拉到页面的最下方，可以看到分页页码，如图所示：</p>\n<p><img src=\"Screenshot_3.webp\"></p>\n<p>页面显示一共有<code>100</code>条数据，10页的内容，因此页码最多是10。接着我们点击第2页，如图所示：</p>\n<p><img src=\"Screenshot_4.webp\"></p>\n<p>可以看到网页的<code>URL</code>变成了<code>https://static1.scrape.cuiqingcai.com/page/2</code>，相比根<code>URL</code>多了<code>/page/2</code>这部分内容。网页的结构还是和原来一模一样，所以我们可以和第1页一样处理。</p>\n<p>接着查看第3页、第4页等内容，可以发现有这么一个规律，每一页的<code>URL</code>最后分别变成了<code>/page/3</code>、<code>/page/4</code>。所以，<code>/page</code>后面跟的就是列表页的页码，当然第1页也是一样，在根<code>URL</code>后面加上<code>/page/1</code>也是能访问的，只不过网站做了一下处理，默认的页码是1，所以显示第1页的内容。</p>\n<p>分析到这里，逻辑基本就清晰了。</p>\n<p>如果要完成列表页的爬取，可以这么实现：</p>\n<ul>\n<li>遍历页码构造<code>10</code>页的索引页<code>URL</code>。</li>\n<li>从每个索引页分析提取出每个电影的详情页<code>URL</code>。</li>\n</ul>\n<p>先定义一些基础的变量，并引入一些必要的库，写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymongo</span><br><span class=\"line\"><span class=\"keyword\">from</span> pyquery <span class=\"keyword\">import</span> PyQuery <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib.parse <span class=\"keyword\">import</span> urljoin</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(level=logging.INFO, <span class=\"built_in\">format</span>=<span class=\"string\">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">BASE_URL = <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com&#x27;</span></span><br><span class=\"line\">TOTAL_PAGE = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>引入<code>requests</code>用来爬取页面，<code>logging</code>用来输出信息，<code>re</code>用来实现正则表达式解析，<code>pyquery</code>用来直接解析网页，<code>pymongo</code>用来实现<code>MongoDB</code>存储，<code>urljoin</code>用来做<code>URL</code>的拼接。</p>\n<p>接着定义日志输出级别和输出格式，完成之后再定义<code>BASE_URL</code>为当前站点的根<code>URL</code>，<code>TOTAL_PAGE</code>为需要爬取的总页码数量。</p>\n<p>定义好了之后，来实现一个页面爬取的方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_page</span>(<span class=\"params\">url</span>):</span></span><br><span class=\"line\">    logging.info(<span class=\"string\">&#x27;scraping %s...&#x27;</span>, url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = requests.get(url, verify=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> response.status_code == <span class=\"number\">200</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response.text</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;get invalid status code %s while scraping %s&#x27;</span>, response.status_code, url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.RequestException:</span><br><span class=\"line\">        logging.error(<span class=\"string\">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>考虑到不仅要爬取列表页，还要爬取详情页，在这里定义一个较通用的爬取页面的方法，叫作<code>scrape_page</code>，它接收一个<code>url</code>参数，返回页面的<code>html</code>代码。</p>\n<p>首先判断状态码是不是<code>200</code>，如果是，则直接返回页面的<code>HTML</code>代码，如果不是，则会输出错误日志信息。另外，这里实现了<code>requests</code>的异常处理，如果出现了爬取异常，则会输出对应的错误日志信息。这时将<code>logging</code>的<code>error</code>方法的<code>exc_info</code>参数设置为<code>True</code>则可以打印出<code>Traceback</code>错误堆栈信息。 </p>\n<p>有了<code>scrape_page</code>方法之后，给这个方法传入一个<code>url</code>，正常情况下它就可以返回页面的<code>HTML</code>代码。</p>\n<p>在这个基础上，来定义列表页的爬取方法吧，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_index</span>(<span class=\"params\">page</span>):</span></span><br><span class=\"line\">    index_url = <span class=\"string\">f&#x27;<span class=\"subst\">&#123;BASE_URL&#125;</span>/page/<span class=\"subst\">&#123;page&#125;</span>&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_page(index_url)</span><br></pre></td></tr></table></figure>\n\n<p>方法名称叫作<code>scrape_index</code>，这个方法会接收一个<code>page</code>参数，即列表页的页码，在方法里面实现列表页的<code>URL</code>拼接，然后调用<code>scrape_page</code>方法爬取即可得到列表页的<code>HTML</code>代码了。</p>\n<p>获取了<code>HTML</code>代码后，下一步就是解析列表页，并得到每部电影的详情页的<code>URL</code>了，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_index</span>(<span class=\"params\">html</span>):</span></span><br><span class=\"line\">    doc = pq(html)</span><br><span class=\"line\">    links = doc(<span class=\"string\">&#x27;.el-card .name&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> link <span class=\"keyword\">in</span> links.items():</span><br><span class=\"line\">        href = link.attr(<span class=\"string\">&#x27;href&#x27;</span>)</span><br><span class=\"line\">        detail_url = urljoin(BASE_URL, href)</span><br><span class=\"line\">        logging.info(<span class=\"string\">&#x27;get detail info %s&#x27;</span>, detail_url)</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> detail_url</span><br></pre></td></tr></table></figure>\n\n<p>这里我们定义了<code>parse_index</code>方法，它接收一个<code>html</code>参数，即列表页的<code>HTML</code>代码。接着用<code>pyquery</code>新建一个<code>PyQuery</code>对象，完成之后再用<code>.el-card .name</code>选择器选出来每个电影名称对应的超链接节点。遍历这些节点，通过调用<code>attr</code>方法并传入<code>href</code>获得详情页的<code>URL</code>路径，得到的<code>href</code>就是上文所说的类似<code>/detail/1</code>这样的结果。这并不是一个完整的<code>URL</code>，所以需要借助<code>urljoin</code>方法把<code>BASE_URL</code>和<code>href</code>拼接起来，获得详情页的完整<code>URL</code>，得到的结果就是类似<code>https://static1.scrape.cuiqingcai.com/detail/1</code>这样完整的<code>URL</code>了，最后<code>yield</code>返回即可。</p>\n<p>通过调用<code>parse_index</code>方法传入列表页的<code>HTML</code>代码就可以获得该列表页所有电影的详情页<code>URL</code>了，接下来把上面的方法串联调用一下，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        logging.info(<span class=\"string\">&#x27;detail urls %s&#x27;</span>, <span class=\"built_in\">list</span>(detail_urls))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>定义了<code>main</code>方法来完成上面所有方法的调用，首先使用<code>range</code>方法遍历一下页码，得到的<code>page</code>是<code>1~10</code>，接着把<code>page</code>变量传给<code>scrape_index</code>方法，得到列表页的<code>HTML</code>，赋值为<code>index_html</code>变量。接下来再将<code>index_html</code>变量传给<code>parse_index</code>方法，得到列表页所有电影的详情页<code>URL</code>，赋值为<code>detail_urls</code>，结果是一个生成器，调用<code>list</code>方法就可以将其输出出来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,059 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,060 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,061 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,062 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,063 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,064 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,065 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,067 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,070 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,072 - INFO: get detail info https://static1.scrape.cuiqingcai.com/detail/<span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,074 - INFO: detail urls [<span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/1&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/2&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/3&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/4&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/5&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/6&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/7&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/8&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/9&#x27;</span>, <span class=\"string\">&#x27;https://static1.scrape.cuiqingcai.com/detail/10&#x27;</span>]</span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">23</span> <span class=\"number\">23</span>:<span class=\"number\">23</span>:04,076 - INFO: scraping https://static1.scrape.cuiqingcai.com/page/<span class=\"number\">2.</span>..</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n\n<p>由于输出内容比较多，这里只贴了一部分。可以看到，在这个过程中程序首先爬取了第<code>1</code>页列表页，然后得到了对应详情页的每个<code>URL</code>，接着再接着爬第2页、第3页，一直到第10页，依次输出了每一页的详情页<code>URL</code>。这样，就成功获取到所有电影详情页<code>URL</code>。</p>\n<h3 id=\"爬取详情页\"><a href=\"#爬取详情页\" class=\"headerlink\" title=\"爬取详情页\"></a>爬取详情页</h3><p>首先观察一下详情页的<code>HTML</code>代码，如图所示：</p>\n<p><img src=\"Screenshot_5.webp\"></p>\n<p>经过分析，要提取的内容和对应的节点信息如下：</p>\n<ul>\n<li>封面：是一个<code>img</code>节点，其<code>class</code>属性为<code>cover</code>。</li>\n<li>名称：是一个<code>h2</code>节点，其内容便是名称。</li>\n<li>类别：是<code>span</code>节点，其内容便是类别</li>\n<li>内容，其外侧是<code>button</code>节点，再外侧则是<code>class</code>为<code>categories</code>的<code>div</code>节点。</li>\n<li>上映时间：是<code>span</code>节点，其内容包含了上映时间，其外侧是包含了<code>class</code>为<code>info</code>的<code>div</code>节点。但注意这个<code>div</code>前面还有一个<code>class</code>为<code>info</code>的<code>div</code>节点，可以使用其内容来区分，也可以使用<code>nth-child</code>或<code>nth- of-type</code>这样的选择器来区分。另外提取结果中还多了「上映」二字，可以用正则表达式把日期提取出来。</li>\n<li>评分：是一个<code>p</code>节点，其内容便是评分，<code>p</code>节点的<code>class</code>属性为<code>score</code>。</li>\n<li>剧情简介：是一个<code>p</code>节点，其内容便是</li>\n<li>剧情简介，其外侧是<code>class</code>为<code>drama</code>的<code>div</code>节点。</li>\n</ul>\n<p>刚才已经成功获取了详情页的<code>URL</code>，接下来要定义一个详情页的爬取方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">scrape_detail</span>(<span class=\"params\">url</span>):</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrape_page(url)</span><br></pre></td></tr></table></figure>\n\n<p>定义了一个<code>scrape_detail</code>方法，它接收一个<code>url</code>参数，并通过调用<code>scrape_page</code>方法获得网页源代码。由于刚才已经实现了<code>scrape_page</code>方法，所以在这里不用再写一遍页面爬取的逻辑，直接调用即可，这就做到了代码复用。</p>\n<p>单独定义一个<code>scrape_detail</code>方法在逻辑上会显得更清晰，而且以后如果想要对<code>scrape_detail</code>方法进行改动，比如添加日志输出或是增加预处理，都可以在 <code>scrape_detail</code>里面实现，而不用改动<code>scrape_page</code>方法，灵活性会更好。</p>\n<p>详情页的爬取方法已经实现了，接着就是详情页的解析了，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_detail</span>(<span class=\"params\">html</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;详情页的解析&quot;&quot;&quot;</span></span><br><span class=\"line\">    doc = pq(html)</span><br><span class=\"line\">    cover = doc(<span class=\"string\">&#x27;img.cover&#x27;</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">    name = doc(<span class=\"string\">&#x27;a &gt; h2&#x27;</span>).text()</span><br><span class=\"line\">    categories = [item.text() <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> doc(<span class=\"string\">&#x27;.categories button span&#x27;</span>).items()]</span><br><span class=\"line\">    published_at = doc(<span class=\"string\">&#x27;.info:contains(上映)&#x27;</span>).text()</span><br><span class=\"line\">    published_at = re.search(<span class=\"string\">&#x27;(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&#x27;</span>, published_at).group(<span class=\"number\">1</span>) \\</span><br><span class=\"line\">        <span class=\"keyword\">if</span> published_at <span class=\"keyword\">and</span> re.search(<span class=\"string\">&#x27;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;&#x27;</span>, published_at) <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    drama = doc(<span class=\"string\">&#x27;.drama p&#x27;</span>).text()</span><br><span class=\"line\">    score = doc(<span class=\"string\">&#x27;p.score&#x27;</span>).text()</span><br><span class=\"line\">    score = <span class=\"built_in\">float</span>(score) <span class=\"keyword\">if</span> score <span class=\"keyword\">else</span> <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;cover&#x27;</span>: cover,</span><br><span class=\"line\">        <span class=\"string\">&#x27;name&#x27;</span>: name,</span><br><span class=\"line\">        <span class=\"string\">&#x27;categories&#x27;</span>: categories,</span><br><span class=\"line\">        <span class=\"string\">&#x27;published_at&#x27;</span>: published_at,</span><br><span class=\"line\">        <span class=\"string\">&#x27;drama&#x27;</span>: drama,</span><br><span class=\"line\">        <span class=\"string\">&#x27;score&#x27;</span>: score</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义了<code>parse_detail</code>方法用于解析详情页，它接收一个<code>html</code>参数，解析其中的内容，并以字典的形式返回结果。每个字段的解析情况如下所述：</p>\n<ul>\n<li><code>cove</code>r：封面，直接选取<code>class</code>为<code>cover</code>的<code>img</code>节点，并调用<code>attr</code>方法获取<code>src</code>属性的内容即可。</li>\n<li><code>name</code>：名称，直接选取<code>a</code>节点的直接子节点<code>h2</code>节点，并调用<code>text</code>方法提取其文本内容即可得到名称。</li>\n<li><code>categories</code>：类别，由于类别是多个，所以这里首先用<code>.categories button span</code>选取了<code>class</code>为<code>categories</code>的节点内部的<code>span</code>节点，其结果是多个，所以这里进行了遍历，取出了每个<code>span</code>节点的文本内容，得到的便是列表形式的类别。</li>\n<li><code>published_at</code>：上映时间，由于<code>pyquery</code>支持使用<code>:contains</code>直接指定包含的文本内容并进行提取，且每个上映时间信息都包含了「上映」二字，所以这里就直接使用<code>:contains(上映)</code>提取了<code>class</code>为<code>info</code>的<code>div</code>节点。提取之后，得到的结果类似「1993-07-26 上映」这样，并不想要「上映」这两个字，所以又调用了正则表达式把日期单独提取出来了。当然这里也可以直接使用<code>strip</code>或<code>replace</code>方法把多余的文字去掉。</li>\n<li><code>drama</code>：直接提取<code>class</code>为<code>drama</code>的节点内部的<code>p</code>节点的文本即可。</li>\n<li><code>score</code>：直接提取<code>class</code>为<code>score</code>的<code>p</code>节点的文本即可，由于提取结果是字符串，所以我们需要把它转成浮点数，即``float`类型。</li>\n</ul>\n<p>上述字段提取完毕之后，构造一个字典返回。这样，成功完成了详情页的提取和分析了。</p>\n<p>将main方法稍微改写一下，增加这两个方法的调用，改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> detail_url <span class=\"keyword\">in</span> detail_urls:</span><br><span class=\"line\">            detail_html = scrape_detail(detail_url)</span><br><span class=\"line\">            data = parse_detail(detail_html)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;get detail data %s&#x27;</span>, data)</span><br></pre></td></tr></table></figure>\n\n<p>首先遍历了<code>detail_urls</code>，获取了每个详情页的<code>URL</code>，然后依次调用了<code>scrape_detail</code>和<code>parse_detail</code>方法，最后得到了每个详情页的提取结果，赋值为<code>data</code>并输出。</p>\n<p>运行结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">12</span>:<span class=\"number\">46</span>:<span class=\"number\">31</span>,<span class=\"number\">432</span> - INFO: get detail data &#123;<span class=\"string\">&#x27;cover&#x27;</span>: <span class=\"string\">&#x27;https://p0.meituan.net/movie/b0d986a8bf89278afbb19f6abaef70f31206570.jpg@464w_644h_1e_1c&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&quot;辛德勒的名单 - Schindler&#x27;s List&quot;</span>, <span class=\"string\">&#x27;categories&#x27;</span>: [<span class=\"string\">&#x27;剧情&#x27;</span>, <span class=\"string\">&#x27;历史&#x27;</span>, <span class=\"string\">&#x27;战争&#x27;</span>], <span class=\"string\">&#x27;published_at&#x27;</span>: <span class=\"string\">&#x27;1993-11-30&#x27;</span>, <span class=\"string\">&#x27;drama&#x27;</span>: <span class=\"string\">&#x27;1939年，波兰在纳粹德国的统治下，党卫军对犹太人进行了隔离统治。德国商人奥斯卡·辛德勒（连姆·尼森 饰）来到德军统治下的克拉科夫，开设了一间搪瓷厂，生产军需用品。凭着出众的社交能力和大量的金钱，辛德勒和德军建立了良好 的关系，他的工厂雇用犹太人工作，大发战争财。1943年，克拉科夫的犹太人遭到了惨绝人寰的大屠杀，辛德勒目睹这一切，受到了极大的震撼，他贿赂军官，让自己的工厂成为集中营的附属劳役营，在那些疯狂屠杀的日子里，他的工厂也成为了犹太人的避难所。1944年，德国战败前夕，屠杀犹太人的行动越发疯狂，辛德勒向德军军官开出了1200人的名单，倾家荡产买下了这些犹太人的生命。在那些暗无天日的岁月里，拯救一个人，就是拯救全世界。&#x27;</span>, <span class=\"string\">&#x27;score&#x27;</span>: <span class=\"number\">9.5</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，已经成功提取出每部电影的基本信息，包括封面、名称、类别，等等。</p>\n<h2 id=\"保存到MongoDB\"><a href=\"#保存到MongoDB\" class=\"headerlink\" title=\"保存到MongoDB\"></a>保存到MongoDB</h2><p>请确保现在有一个可以正常连接和使用的<code>MongoDB</code>数据库。 将数据导入<code>MongoDB</code>需要用到<code>PyMongo</code>这个库，这个在最开始已经引入过了。那么接下来我们定义一下 <code>MongoDB</code>的连接配置，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MONGO_CONNECTION_STRING = <span class=\"string\">&#x27;mongodb://localhost:27017&#x27;</span></span><br><span class=\"line\">MONGO_DB_NAME = <span class=\"string\">&#x27;movies&#x27;</span></span><br><span class=\"line\">MONGO_COLLECTIONS_NAME = <span class=\"string\">&#x27;movies&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">client = pymongo.MongoClient(MONGO_CONNECTION_STRING)</span><br><span class=\"line\">db = client[<span class=\"string\">&#x27;movies&#x27;</span>]</span><br><span class=\"line\">collection = db[<span class=\"string\">&#x27;movies&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在这里声明了几个变量，介绍如下：</p>\n<ul>\n<li><code>MONGO_CONNECTION_STRING</code>：<code>MongoDB</code>的连接字符串，里面定义了<code>MongoDB</code>的基本连接信息，如<code>host</code>、<code>port</code>，还可以定义用户名密码等内容。</li>\n<li><code>MONGO_DB_NAME</code>：<code>MongoDB</code>数据库的名称。</li>\n<li><code>MONGO_COLLECTION_NAME</code>：<code>MongoDB</code>的集合名称。</li>\n</ul>\n<p>这里用<code>MongoClient</code>声明了一个连接对象，然后依次声明了存储的数据库和集合。接下来，再实现一个将数据保存到<code>MongoDB</code>的方法，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_data</span>(<span class=\"params\">data</span>):</span></span><br><span class=\"line\">    collection.update_one(&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;name&#x27;</span>: data.get(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;$set&#x27;</span>: data</span><br><span class=\"line\">    &#125;, upsert=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>声明了一个<code>save_data</code>方法，它接收一个<code>data</code>参数，也就是我们刚才提取的电影详情信息。在方法里面，调用了<code>update_one</code>方法，第1个参数是<strong>查询条件</strong>，即根据<code>name</code>进行查询；第2个参数是<code>data</code>对象本身，也就是所有的数据，这里用<code>$set</code>操作符表示更新操作；第3个参数很关键，这里实际上是<code>upsert</code>参数，如果把这个设置为 <code>True</code>，则可以做到存在即更新，不存在即插入的功能，更新会根据第一个参数设置的<code>name</code>字段，所以这样可以防止数据库中出现同名的电影数据。</p>\n<blockquote>\n<p>注：实际上电影可能有同名，但该场景下的爬取数据没有同名情况，当然这里更重要的是实现<code>MongoDB</code>的去重操作。</p>\n</blockquote>\n<p>接下来将<code>main</code>方法稍微改写一下就好了，改写如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> detail_url <span class=\"keyword\">in</span> detail_urls:</span><br><span class=\"line\">            detail_html = scrape_detail(detail_url)</span><br><span class=\"line\">            data = parse_detail(detail_html)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;get detail data %s\\n&#x27;</span>, data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;saving data to mongodb&#x27;</span>)</span><br><span class=\"line\">            save_data(data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;data saved successfully\\n&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>重新运行，输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">13</span>:<span class=\"number\">16</span>:<span class=\"number\">46</span>,<span class=\"number\">882</span> - INFO: get detail data &#123;<span class=\"string\">&#x27;cover&#x27;</span>: <span class=\"string\">&#x27;https://p0.meituan.net/movie/58782fa5439c25d764713f711ebecd1e201941.jpg@464w_644h_1e_1c&#x27;</span>, <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;魂断蓝桥 - Waterloo Bridge&#x27;</span>, <span class=\"string\">&#x27;categories&#x27;</span>: [<span class=\"string\">&#x27;剧情&#x27;</span>, <span class=\"string\">&#x27;爱情&#x27;</span>, <span class=\"string\">&#x27;战争&#x27;</span>], <span class=\"string\">&#x27;published_at&#x27;</span>: <span class=\"string\">&#x27;1940-05-17&#x27;</span>, <span class=\"string\">&#x27;drama&#x27;</span>: <span class=\"string\">&#x27;第一次世界大战期间，回国度假的陆军中 </span></span><br><span class=\"line\"><span class=\"string\">尉罗伊（罗伯特·泰勒 饰）在滑铁卢桥上邂逅了舞蹈演员玛拉（费雯·丽 饰），两人彼此倾心，爱情迅速升温。就在两人决定结婚之时，罗伊应招回营地，两人被迫分离。由</span></span><br><span class=\"line\"><span class=\"string\">于错过剧团演出，玛拉被开除，只能和好友相依为命。不久玛拉得知罗伊阵亡的消息，几欲崩溃，备受打击。失去爱情的玛拉感到一切都失去了意义，为了生存，她和好友不</span></span><br><span class=\"line\"><span class=\"string\">得不沦为妓女。然而命运弄人，就在此时玛拉竟然再次遇到了罗伊。虽然为罗伊的生还兴奋不已，玛拉却因自己的失身陷入痛苦之中。感到一切难以挽回的玛拉潸然离开，独</span></span><br><span class=\"line\"><span class=\"string\">自来到两人最初相遇的地点——滑铁卢桥上…&#x27;</span>, <span class=\"string\">&#x27;score&#x27;</span>: <span class=\"number\">9.5</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">13</span>:<span class=\"number\">16</span>:<span class=\"number\">46</span>,<span class=\"number\">885</span> - INFO: saving data to mongodb</span><br><span class=\"line\"><span class=\"number\">2021</span>-05-<span class=\"number\">24</span> <span class=\"number\">13</span>:<span class=\"number\">16</span>:<span class=\"number\">46</span>,<span class=\"number\">889</span> - INFO: data saved successfully</span><br></pre></td></tr></table></figure>\n\n<p>运行完毕之后我们可以使用<code>MongoDB</code>客户端工具可视化查看已经爬取到的数据，结果如下：</p>\n<p><img src=\"Screenshot_6.webp\"></p>\n<h2 id=\"多进程加速\"><a href=\"#多进程加速\" class=\"headerlink\" title=\"多进程加速\"></a>多进程加速</h2><p>由于整个的爬取是单进程的，而且只能逐条爬取，速度稍微有点慢，有没有方法来对整个爬取过程进行加速呢？</p>\n<p>在前面学习了多进程的基本原理和使用方法，下面就来实践一下多进程的爬取。</p>\n<p>由于一共有<code>10</code>页详情页，并且这<code>10</code>页内容是互不干扰的，所以可以一页开一个进程来爬取。由于这<code>10</code>个列表页页码正好可以提前构造成一个列表，所以可以选用多进程里面的进程池<code>Pool</code>来实现这个过程。</p>\n<p>这里需要改写下<code>main</code>方法的调用，实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>(<span class=\"params\">page</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE+<span class=\"number\">1</span>):</span><br><span class=\"line\">        index_html = scrape_index(page)</span><br><span class=\"line\">        detail_urls = parse_index((index_html))</span><br><span class=\"line\">        <span class=\"keyword\">for</span> detail_url <span class=\"keyword\">in</span> detail_urls:</span><br><span class=\"line\">            detail_html = scrape_detail(detail_url)</span><br><span class=\"line\">            data = parse_detail(detail_html)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;get detail data %s\\n&#x27;</span>, data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;saving data to mongodb&#x27;</span>)</span><br><span class=\"line\">            save_data(data)</span><br><span class=\"line\">            logging.info(<span class=\"string\">&#x27;data saved successfully\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pool = multiprocessing.Pool()</span><br><span class=\"line\">    pages = <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, TOTAL_PAGE + <span class=\"number\">1</span>)</span><br><span class=\"line\">    pool.<span class=\"built_in\">map</span>(main, pages)</span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br></pre></td></tr></table></figure>\n\n<p>这里首先给<code>main</code>方法添加一个参数<code>page</code>，用以表示列表页的页码。接着声明了一个进程池，并声明<code>pages</code>为所有需要遍历的页码，即<code>1~10</code>。最后调用<code>map</code>方法，第1个参数就是需要被调用的方法，第2个参数就是<code>pages</code>，即需要遍历的页码。</p>\n<p>这样<code>pages</code>就会被依次遍历。把<code>1~10</code>这10个页码分别传递给<code>main</code>方法，并把每次的调用变成一个进程，加入到进程池中执行，进程池会根据当前运行环境来决定运行多少进程。</p>\n<p>运行输出结果和之前类似，但是可以明显看到加了多进程执行之后，爬取速度快了非常多。可以清空一下之前的<code>MongoDB</code>数据，可以发现数据依然可以被正常保存到<code>MongoDB</code>数据库中。</p>\n"},{"title":"内篇（二）——齐物论","comments":1,"toc":true,"only":["home","category","tag"],"date":"2021-05-29T05:12:36.000Z","pic":null,"_content":"\n\n>**南郭子綦隐机而坐，仰天而嘘，荅焉似丧其耦。颜成子游立侍乎前，曰：“何居乎？形固可使如槁木，而心固可使如死灰乎？今之隐机者，非昔之隐机者也？”子綦曰：“偃，不亦善乎，而问之也！今者吾丧我，汝知之乎？汝闻人籁而未闻地籁，汝闻地籁而不闻天籁夫！”**\n\n南郭子綦靠几静坐，仰面朝天缓缓地吐气，茫然若失，就像魂魄离开了躯体。南郭子綦的学生颜成子游见状马上前来侍候，问南郭子綦说：“您刚才是处于一种什么样的境界呢？一个人的肢体形貌在打坐时固然可以使它像枯槁之木一样毫无生气，难道一个人的心神在打坐时也可以使它像死灰一样毫无生气吗？您在今天所表现出来的安稳境界，跟以前的安稳境界绝对不一样。”南郭子綦回答说：“偃，你问此事，不是问得很好吗？今天我遗忘了形体之我，你知道这一点吗？你只听到人吹箫管发出的声音，而没听听风吹众窍所发出的声音，你只听到风吹众窍所发出的声音，而没有听到天地间万物的自鸣之声！”\n\n>**子游曰：“敢问其方。”子綦曰：“夫大块噫气，其名为风。是唯无作，作则万窍怒呺。而独不闻之翏翏乎？山林之畏隹，大木百围之窍穴，似鼻，似口，似耳，似枅，似圈，似臼，似洼者，似污者。激者、謞者、叱者、吸者、叫者、譹者、宎者，咬者，前者唱于而随者唱喁，泠风则小和，飘风则大和，厉风济则众窍为虚。而独不见之调调之刁刁乎？”**\n\n子游说：“能不能问一问大地的声音与天的声音是怎么回事呢？”南郭子綦回答说：“那个地籁就是无边无际的造物之作用所发出的能量之气息啊，发出来之后就被叫作风。这种能量要么就是内在蕴含着不发出来，一旦发出来就会万窍怒号，难道你耳边就没有听到过这种‘呼呼’的风声吗！山林的险峻、大树周身的窍穴，有的形状像鼻子，有的形状像张开的嘴，有的形状像耳朵，有的形状”像扁长的发簪，有的形状像凸出来的圈筒，有的形状像凹下去的浅坑，有的浅一些，有的深一些；于是所发的声响就有的快促，有的像响箭，有的刺耳，有的发自往里吸，有的发自往外出，有的像嚎哭声，有的像狗叫，有的像悲哀声。能量流的运动原本就很舒缓动听，怪就怪哉随着各种物体所发出的众口乱叫而嘈杂了；当徐徐之风时万物就会轻微地唱和，当风大时万物就会大点儿地唱和，当劲风厉厉时反而所有能发响者皆欲发而无声了，难道你没有从风响的音调中听出来各种声响的发声原因、从风的响声上听出其后面的那个不发声的东西吗？”\n\n>**子游曰：“地籁则众窍是已，人籁则比竹是已，敢问天籁。”子綦曰：“夫吹万不同，为而使其自己也。咸其自取，怒者其谁邪？”**\n\n子游又问：“大地的本意可以借助万物之窍所发出的唱和声中表达出来，人所的本意也可以从清悠、消沉、谐美的各种丝竹的或条畅或激昂的声中表达出来，那么天的本意是怎么表达出来的呢？”南郭子綦说：“所谓天籁的音响万变，而又能使其自行息止，这完全都是出于自然，有什么东西主使着它呢？”\n\n>**<font color=red>大知闲闲，小知閒閒。大言炎炎，小言詹詹。</font>其寐也魂交，其觉也形开。与接为构，日以心斗。缦者、窖者、密者。小恐惴惴，大恐缦缦。其发若机栝，其司是非之谓也；其留如诅盟，其守胜之谓也；其杀如秋冬，以言其日消也；其溺之所为之，不可使复之也；其厌也如缄，以言其老洫也；近死之心，莫使复阳也。喜怒哀乐，虑叹变慹[zhé]，姚佚启态。乐出虚，蒸成菌。日夜相代乎前而莫知其所萌。已乎，已乎！旦暮得此，其所由以生乎！**\n\n大智者看上去显得非常广博，小智者却十分琐细；高论者盛气凌人，争论者小辩不休。辩士睡时，精神与梦境交错在一起，醒后疲于与外物接触纠缠。每天与外物相接，其心有如经历了一场又一场的战斗一样疲惫。有的心机柔奸，有的善设陷阱，有的潜机不露。小的惧怕表现为忧惧不安，大的惧怕表现为惊恐失神。三灾八难的降临就像箭在弦上一样地随时而发，这全是由于行为人的心机所伺机行是非之行径所造成的；三灾八难的不降临也可以像发愿一样的通过履践其愿誓而消失，那就要看行为人是否践履自己的愿誓而坚持无思无为的行径来决定了。神情衰沮就像秋风冬雪肃杀万木一样无情，这就说明道心逍遥之本性的消亡是渐进的过程；如果行为人沉迷于自己之心机的经营里而不醒悟的话，也就很难再回到那个逍遥的本性去了。然而行为人对恢复道心的修行却厌恶得像自行封闭起来的蚕子一样的听不进去，这就说明行为人的执着意识的积习太严重了；像这样的几乎等于死亡的心，实在是没法使它再恢复生气。所谓的喜怒哀乐，都是认取了事物对自己所引发的感受而逐步形成多忧惧的意识，正在这个意识之执着的支配下才形成了轻狂而放任的或喜或怒或哀或乐的情绪了。喜怒哀乐发出来之后就过去了，接着而来的就是又孕育出了无明之烦恼，如此的一天到晚的不是喜乐就是烦恼的交替着出现在眼前，而从来不知道它们是怎么产生的。不可救药啊，不可救药！一天到晚地如此活着，三灾八难也就由此产生了啊！\n\n>**非彼无我，非我无所取。是亦近矣，而不知其所为使。若有真宰，而特不得其眹。可行己信，而不见其形，有情而无形。百骸、九窍、六藏、赅而存焉，吾谁与为亲？汝皆说之乎？其有私焉？如是皆有为臣妾乎？其臣妾不足以相治乎？其递相为君臣乎？其有真君存焉！如求得其情与不得，无益损乎其真。一受其成形，不亡以待尽。<font color=red>与物相刃相靡，其行尽如驰而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？</font>**\n\n*如果没有了我之内外的任何对立面的观念也就没有我的观念了，如果没有了我的观念也就没有了博取之心了*，如此也就基本上接近于那个道心的行径了，然而却不知道是什么东西在支配着这个道心的行径。好像其中有一个迫使万物循势而动的主宰在，然而偏偏找不到那个主宰的迹象在什么地方，当你恢复了道心之后就会彻底明了那个迫使万物循势而动的主宰了，但它却又没有一个具体的形状可见，它仅仅是道心的广大无缘之悲性而没有具体形状而已。一个人身上有百骸、九窍、六脏，当这些脏器都完备了之后才能决定一个人的生存，那么你认为哪一个脏器最重要而倍加爱护呢？还不是都喜欢而都倍加爱护吗？这个问题的背后岂不牵扯到一个“私我”的观念了吗？如果有一个“私我”之观念的话，那么各脏器岂不就成了分别为“私我”提供专职服务的臣下与妻妾了吗？这种势必缺乏协调性的臣下与妻妾岂不就不足以担当全面治理整个机体的重任了吗？难道它们是逐个轮流着担当君的职责而协调各位臣妾的工作吗？这就证明里面有一个真正的主宰在后面起着决定作用吗？如果实证到了那个广大无缘之慈悲性的道心原来是没有具体形状可得的时候，那时候就会明白这个真宰的作用无论怎么做都既不会益于也不会损于那个真宰者的不生不灭、不增不减、不垢不净性了。然而自从那个人人都有的真主秉承了执着之意识以投胎成人之后，还没有到该死的寿数时就在哪里等着寿尽的一天了，这是因为内外界事物所诱发的爱、恶、欲、的心行在相争斗以至于相消耗的缘故；<font color=red>明明知道生命的寿终就像飞驰一样，但却不知道如何止住这种迈向寿终的步伐，对于自许聪明的人们来说难道不是一种悲哀吗！只知道一辈子地役使自己的心身去赴爱、恶、欲的劳役但对于恢复道心却毫无一点儿进展，整天精神不振地疲于劳役但却不知道究竟是为了什么，对于自许聪明的人们来说难道不是一种痛心吗！即使能够达到人们所说的千万岁的长生不老，对于道心的恢复又有什么益处呢？即使其形体逐渐衰败枯萎，也只是其执着心使其具有了这种变化而已，对于那个真宰的不生不死、不增不减、不垢不净性而言怎能不是最大的痛心呢！人生在世，本来就如此糊涂吗？</font>\n\n>**夫随其成心而师之，谁独且无师乎？<font color=red>奚必知代而心自取者有之？</font>愚者与有焉！未成乎心而有是非，是今日适越而昔至也。是以无有为有。无有为有，虽有神禹且不能知，吾独且奈何哉！**\n\n还是只有我糊涂，而别人也有不糊涂的呢？<font color=red>世人如果都以自己的偏见作为判别是非的标准，那么谁没有一个标准呢？</font>何必是懂得事物更替而心有见地的人才有是非标准呢？即使愚蠢的人也是有的。在未有成见存于心中之前已经就因自己的好恶之感受而得出对与错的心得了，这个心得之现象的得出就像今天刚到了越国而实际上原本就在越国一样地早就待在那个地方了。所以才从道心里凭空产生出心得乃至执着了。对于通过作意而产生出神奇的事物来的行为而言，即使有着禹王那样的神通，也不能有一点儿故意去知道的心在，客观世界的任何事物又怎能奈何于超然物外的那个道心之吾的神奇作用呢！\n\n>**夫言非吹也，言者有言。其所言者特未定也。果有言邪？其未尝有言邪？其以为异于鷇音，亦有辩乎？其无辩乎？道恶乎隐而有真伪？言恶乎隐而有是非？道恶乎往而不存？言恶乎存而不可？<font color=red>道隐于小成，言隐于荣华</font>。故有儒墨之是非，<font color=red>以是其所非而非其所是。欲是其所非而非其所是，则莫若以明。</font>**\n\n言论出于机心，与无心而吹的“天籁”是不同的。发言者知持一端，他们的话并不能作为衡量是非的标准。为了表述某事物果真就需要言辞吗？人们最初始时的思想交流并没有使用言辞啊！人们的言辞之所以能听得懂而雏鸟的叫声却听不懂，这个能听懂的背后是有一个思辨的审明作用在呢？还是没有思辨的审明作用在呢？那个大道为什么未被真正地认识到而产生了见解上的真与假呢？言辞所表述的意义为什么未被真正地认识到而产生了判断上的是与非呢？那个大道为什么必须去参悟才能实证到它而不能通过想象去找到它呢？言辞所表述的意义为什么必须通过思辨才能听懂而不能一听就能确定其真意呢？<font color=red>原因就在于那个大道被不深刻、不全面的小见解给遮蔽住了，就在于言辞所表述的意义被言辞本身的巧妙之比喻或夸张给遮蔽住了。</font>所以才产生了儒墨两家之学术思想的我对你错的争鸣，<font color=red>世人都是用自己所认定的正确去评判人家的不正确，都是用自己所认定的人家的不正确来宣扬自己的正确。与其想用自己所认为的正确去推定人家的不正确，与其想用人家的不正确来证明自己所认为的正确，那就不如静下心来认认真真地修身以达到内明为好。</font>\n\n>**物无非彼，物无非是。自彼则不见，自知则知之。故曰：彼出于是，是亦因彼。彼是方生之说也。虽然，方生方死，方死方生；方可方不可，方不可方可；因是因非，因非因是。是以圣人不由而照之于天，亦因是也。是亦彼也，彼亦是也。彼亦一是非，此亦一是非，果且有彼是乎哉？果且无彼是乎哉？彼是莫得其偶，谓之道枢。枢始得其环中，以应无穷。是亦一无穷，非亦一无穷也。故曰：莫若以明。**\n\n天地万物在道体上不存在你我它的分别，天地万物在道体上也不存在你对及它错的差别。如果从万物存在的现象去看就不会认识到万物是道体之妙用的那个本质，只有从内明的大智慧上去看才能认识到万物同是道体之妙用的那个本质。所以说人们之所以会有万物的个体皆有差异以及你对而它错的分别心乃是从没有分别心的物我同胞的实相中产生的，于是那个没有分别心的物我同胞之实相的提法也就对应于人们的分别心而提出来了。人们之所以会产生分别心，乃是由于当下一念的喜爱心所造成的虽然都是因为当下一念的喜爱心所造成，但当下一念的喜爱心刚刚生起便又马上消失了，前念刚刚消失便又马上生起了后念的喜爱心；于是人们的分别心刚刚形成执着又紧接着遇到新的事物而须要去分别了，于是对新事物的分别心又形成另一个新的执著心了；因为先前的执着心而产生了对新遇到之事物的不认同，对新遇到之事物的不认同经过喜爱心的分别又形成了新的另一个执着。所以每一位恢复了道心的圣人无不鉴于当下之一念的迁流不断而不由得时刻注意着当下一念的似起未起之时，也就是因为这个道理啊！在先前的那个执着的作用下产生了新的另一个执着，新的另一个执着又变成了产生新执着的旧执着。先前的执着是喜爱心所认为的对与错而形成的，新执着也是喜爱心所认为的对与错而形成的。果真存在着执着心所认为的那个正确吗，果真存在着执着心所认为的那个不正确吗？无论是执着心所认为的正确还是所认为的不正确皆是失去了道心中庸之用的结果，这就是所说的形成执着的关键之所在。正是由于形成执着的整个关键作用发生在旧执着与新执着的环环相产生的现象中，于是无始劫以来所形成的无穷的执着也就变成了遮蔽道心的“五蕴”了。道心的中庸之大用是无穷无尽的，意识心的执着之妄用也是无穷无尽的。所以说要想了知道心的全体之大用还是静下心来认认真真地修身以达到内明为好。\n\n>**以指喻指之非指，不若以非指喻指之非指也；以马喻马之非马，不若以非马喻马之非马也。天地一指也，万物一马也。**\n\n用自己的手指来说明人家的手指不是手指，不如不用自己的手指来说明人家的手指不是手指为好；用马来说明白马不是马，不如不用马来说明白马不是马为好。从道通为一的观点看，天地与一指，万物与一马，都是没有区别的。\n\n>**可乎可，不可乎不可。道行之而成，物谓之而然。恶乎然？然于然。恶乎不然？不然于不然。物固有所然，物固有所可。无物不然，无物不可。故为是举莛与楹，厉与西施，恢诡谲怪，道通为一。**\n\n人家认为可，我也跟着认为可；人家认为不可，我也跟着认为不可。于是那个道的生发万物的妙用也就在因缘聚合而生的条件下形成了，于是万物也就在遇到了所对应的因缘聚合的条件下而形成了各具特色的形物了。有的万物之个体能适应因缘聚合而生的各种不同的环境条件而生，有的万物之个体不能适应因缘聚合而生的各种不同的环境条件而只能待其适应的环境条件时而生；所以有的万物之个体也就顺势而形成了具有新特色的形体了，有的万物之个体则未能顺势形成新特色的形体而是保持了始祖的面目乃至被淘汰。为什么有的万物之个体能顺势而形成具有新特色的形体呢？那是因为它具有能顺势而生的适应性所以才形成了具有新特色的形体。为什么有的万物之个体不能顺势而形成具有新特色的形体呢？那是因为它不具有能顺势而生的适应性所以才不能形成具有新特色的形体。为什么有的万物之个体能具有顺势而生的适应性呢？那是因为它具有适应因缘聚合而生的各种不同环境条件的天性。为什么有的万物之个体不具有顺势而生的适应性呢？那是因为它不具有适应因缘聚合而生的各种不同环境条件的天性。万物原本就具有顺势而形成的具有新特色的适应性，万物原本就具有适应因缘聚合而生的各种不同环境的天性。没有哪一个万物之个体不是因为这种适应性而生，也没有哪一个万物之个体不是因为这种天性而生。所以才产生了诸如轻空的莚秆或坚实的楹柱之类的各种不同物类，才产生了诸如丑陋或美丽之类的各种不同形色，才产生了诸如中正、阴险、诡秘、古怪之类的各种不同性格，当你通达了那个道心的大用后就会明白它们都是无二无别的实相了。\n\n>**其分也，成也；其成也，毁也。凡物无成与毁，复通为一。唯达者知通为一，为是不用而寓诸庸。庸也者，用也；用也者，通也；通也者，得也；适得而几矣。因是已。已而不知其然，谓之道。劳神明为一而不知其同也，谓之“朝三”。何谓“朝三”？狙公赋芧，曰：“朝三而暮四。”众狙皆怒。曰：“然则朝四而暮三。”众狙皆悦。名实未亏而喜怒为用，亦因是也。是以圣人和之以是非而休乎天钧，是之谓两行。**\n\n万物之生命的死亡与分解的过程，就是又形成新的生命的过程；形成新的生命的过程，就是其生命的下一次死亡与分解的过程。万物根本就没有什么生与死的截然不同，或生活死的现象也只是同时发生着的道心之大用而已；正是由于实证到了道境界的人彻底明白了或生活死的现象都是同时发生着的，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。当一切行为都隐含在恰到好处的无之用中了的时候，才能遵循道心的全体之大用；当能遵循道心的全体之大用的时候，才能通达一切现象皆是无二无别的实相；当通达了一切现象皆是无二无别之实相的时候，才能驾驭道心的全体之大用；当驾驭了道心的全体之大用的时候，也就差不多恢复了那个道心了。遵循这个过程也就恢复那个道心了。恢复了那个道心也就凡事只是无为地去做而不去问为什么了，这才叫作真正的道境界。被喜怒爱恶欲所驱使的心意之妄动与其内在的思辨觉知之作用是一个本原，然而却不知道此二者都是一个本原，这就叫作只知朝四而不知暮三的猴子意识。为什么叫作只知朝四而不知暮三的猴子意识呢？管理猴子的人给猴子喂食橡实时说：“早晨喂三个晚上喂四个。”众猴子闻之则大怒；管理猴子的人又说：“既然大家都不同意，那就还按早晨喂四个晚上喂三个的老法子。”众猴子们则闻之则大喜。名字之类的名相与名相所代表的那个实物的本性原本就没有什么不同，然而在人们的喜怒哀乐恶欲的心理作用下却变成了各种不同的理解，这就是因为那个只知朝四而不知暮三的意识在作怪啊。所以恢复了道心的圣人们既能在外行上将各种矛盾对立的意识调节控制在中和的状态，又能在内行上安闲自在于道心大用之遍行的无二无别的精神境界中，这就叫作一个道心境界而同时有着内外两种行径的圣行。\n\n>**古之人，其知有所至矣。恶乎至？有以为未始有物者，至矣，尽矣，不可以加矣！其次以为有物矣，而未始有封也。其次以为有封焉，而未始有是非也。是非之彰也，道之所以亏也。道之所以亏，爱之所以成。果且有成与亏乎哉？果且无成与亏乎哉？有成与亏，故昭氏之鼓琴也；无成与亏，故昭氏之不鼓琴也。昭文之鼓琴也，师旷之枝策也，惠子之据梧也，三者之知几乎！皆其盛者也，故载之末年。唯其好之也，以异于彼，其好之也，欲以明之。彼非所明而明之，故以坚白之昧终。而其子又以文之纶终，终身无成。若是而可谓成乎，虽我亦成也；若是而不可谓成乎，物与我无成也。是故滑疑之耀，圣人之所图也。为是不用而寓诸庸，此之谓“以明”。**\n\n古时候的人，他们所具足的大智慧任何地方都能无所不至啊！都是打倒了什么样的无所不至呢？凡所做出的任何行为从根本上就没有做事之动机的存在，就是具足了无所不至的大智慧的境界了，当具足了这种无所不至的大智慧后，就再也不会被喜怒爱恶欲的习气所污染了。差一点的境界则仅仅才有了做事的动机，但却没有达到“这是我的，那是你的”的私我意识；再差一点的境界也只是有了“这是我的，那是你的”的私我意识，但却没有形成以我见而划分对错是非的唯我意识。后来我人便有了对错是非之心而且越来越严重了，于是道心也就亏失了；道心之所以亏失了，完全是心里的那个喜欢之所用所导致的。难道那个道心果真会圆满也会亏失吗，还是果真不会圆满也不会亏失呢？那个道心确实会圆满也会亏失，所以当大琴师昭氏鼓琴时便能激荡起人们心神的喜悦而造成道心之静的亏失了啊；那个道心确实不会圆满也不会亏失，所以当大琴师昭氏不鼓琴时人们的心神便恢复了道心之静的常态了。大琴师昭文的鼓琴之技艺，大乐师师旷持策以击乐器，大逻辑家惠子的诡辩之造诣，就这三个人对于各自爱好之事所达到的极其微妙的程度而言，都是各自领域里的顶尖高手，所以才能千古流传下来。由此三人在琴、诊、论上有着超乎寻常的爱好心，所以才使得在琴、诊、论的成就上大大超出了其他方面的技能；他们之所以爱好其所好的东西，其目的就是为了彻底研究明白所爱好之东西的内在机制。所爱好之东西的内在机制本来就不是靠研究所能研究明白的事反而执意地要去研究明白它，所以才犯了坚石非坚、白马非马之逻辑式的错误以至于愚昧终生。像他们那样地达到了极其微妙的程度就算是真正的最高成就了吗？那么我们每一个意识心用事的人也就可以说是成道的圣人了。像他们那样地达到了极其微妙的程度不算是真正的最高成就吗？那么万物与我人也就不会成为个别的个体了。所以，只有这样地将那个大道的玄机深究到大生疑惑的境地才能不知不觉地过渡到恍然大悟的境界，这正是圣人所希望的啊！只有达到了恍然大悟的境界才能没有是非对错之意识而一切行为都隐含在道心的无为之大用中，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。\n\n>**今且有言于此，不知其与是类乎？其与是不类乎？类与不类，相与为类，则与彼无以异矣。虽然，请尝言之：有始也者，有未始有始也者，有未始有夫未始有始也者；有有也者，有无也者，有未始有无也者，有未始有夫未始有无也者。俄而有无矣，而未知有无之果孰有孰无也。今我则已有有谓矣，而未知吾所谓之其果有谓乎？其果无谓乎？**\n\n刚才已将“是非之彰也，道之所以亏也”的道理说过了，那么它与“为是不用而寓诸庸”的道理是一回事呢，还是与“为是不用而寓诸庸”的道理不是一回事呢？就以人们所认为的是一回事与不是一回事的那个认识而言，认识本身的那个思维所产生的心行就是同一回事，如此也就理解“是非之彰也，道之所以亏也”的道理与“为是不用而寓诸庸”的道理没有什么不同了。尽管如此，也需要试着将其道理说明如下。有的心行是从意识中突然产生的，有的心行是从末那识中迁流过来的，有的心行是从藏识中迁流过来的。来源于意识中的心行有的正存在着，有的已经过去了，来源于末那识的心行有的出于旧有的执着、有的出于最近才有的心得，来源于藏识中的心行乃是既没有形成执着，又没有形成心得的无为之举。心行就是这样地一会儿是从意识中产生出来，一会儿是从藏识中迁流出来，却不知道这两张心行的现象，它是不是真实的存在呢？现在用哪个会思会想的意识心反思一下自己就会发现所谓的“我”是不真实的假象了，而那个不会思不会想的道心之吾则是真实存在的了。道心之吾果真是真实的存在啊！意识心之假我果真是不真实的存在啊！\n\n>**夫天下莫大于秋毫之末，而太山为小；莫寿乎殇子，而彭祖为夭。天地与我并生，而万物与我为一。既已为一矣，且得有言乎？既已谓之一矣，且得无言乎？一与言为二，二与一为三。自此以往，巧历不能得，而况其凡乎！故自无适有，以至于三，而况自有适有乎！无适焉，因是已！**\n\n整个的天下在实相上不会比秋毫的尖头大，相形之下那有形的大山却是渺小得很；我们的寿命在实相上不会比夭折的小儿寿长，相形之下那八百寿的彭祖却是夭亡的小儿；这就证明天地与我们都是道心之大用的妙用所生，万物与我们都是一个本体而没有人我万物之别。既然天地人我万物都是一个本体的“一”而没有差别，为什么会有天地人我万物之不同的认识存在呢？既然认为它们都是一个一个的个体而有差别，又怎会没有天地人我万物之不同的认识存在呢？道之实相用言辞说出来就变成第二重的言辞之比喻象了，将道的比喻象再用言辞说出来就变成第三重的意识之妄见象了。自从道之实相变成言辞之比喻象再变成意识之妄见象以来所代代递增的妄见象，即使技术最高超的人来推算也不能计算清楚它，更何况还有以后所必然会形成的意识之妄见象呢！从道的不可言说的实相上就能变成言辞之比喻象以至于再变成意识之妄见象，更何况将意识之妄见象再变成妄见的言辞之比喻象呢！由此而知，意识之妄见再变成意识之妄见的沿流永远没有一个尽头，原因就在于妄见的沿流层出不穷。\n\n>**夫道未始有封，言未始有常，为是而有畛也。请言其畛：有左有右，有伦有义，有分有辩，有竞有争，此之谓八德。六合之外，圣人存而不论；六合之内，圣人论而不议；春秋经世先王之志，圣人议而不辩。**\n\n对于那个道心的大用而言在最初并没有“这是我的，那是你的”的私我之意识，对于言辞而言却从一开始便不存在永久不变，正是因为意识之妄见的沿流永远没有一个尽头而从道心之大用中形成了人我万物的各个个体及各种思想意识了。请让我说说这些界限：有上下、尊卑之序，有亲疏之理、贵贱之仪，有剖析万物、分别彼此，有角逐胜负、对辩是非，这就是儒、墨等派所争辩的八种界限。对于宇宙之外的不可知，圣人只是保留其说而不加以讲解；对于宇宙之内的事物，圣人只是讲解而不加以评说；对于以天道中正为喻的《春秋》所记载的经纶天下的先王的济世之道，圣人只是评说而不加以争辩。\n\n>**故分也者，有不分也；辩也者，有不辩也。曰：“何也？”“圣人怀之，众人辩之以相示也。故曰：辩也者，有不见也。”夫大道不称，大辩不言，大仁不仁，大廉不嗛，大勇不忮。道昭而不道，言辩而不及，仁常而不成，廉清而不信，勇忮而不成。五者圆而几向方矣！故知止其所不知，至矣。孰知不言之辩，不道之道？若有能知，此之谓天府。注焉而不满，酌焉而不竭，而不知其所由来，此之谓葆光。**\n\n由圣人的做法可知，既然有了是非对错的认识之分别，这本身就说明道心原本就是一而没有认识之分别；既然有了是非对错的争辩，这本身就说明道心原本就是一而没有争辩之实质。这证明了什么呢？证明了圣人是思虑于心，而众人是妄议于言为了将这个道理开示出来。所以告诉大家，“之所以存在着争辩的现象，乃是还没有达到内明的缘故。”真正的大道没有任何名相之称谓，真正的大辩没有任何说道之言辞，真正的大仁没有任何仁慈之目的，真正的大廉是不自需锋芒的，大勇是不自逞血气之勇的。如果还有有道的样子显现出来则恰恰证明没有道，言语过于辩察，就不能达到真理，仁者滞于一偏之爱就不能周遍，过分表示廉洁就不够真实，自逞血气之勇就不成器大勇。不称、不言、不仁、不嗛、不忮这五个方面，本来是圆通混成的；如果涉及昭、辩、常、清、忮等形迹，就变成四方之物了。所以道心之知的明了作用若能停留在只管去做而不去动其心的境界上，那么修心的境界也就到家了。怎能又去管它什么没有言辞才是真正的论辩，不认为有道才是真正的有道呢？如果保持住了那个能知而又不去动心的境界，也就叫作修心阶段的最高成就了。只有达到了像大海一样地诸如多少也不会满溢，舀取多少也不会枯竭，而且也不去思考为什么会这样的境界时，这才叫作包藏光亮而不露。\n\n>**故昔者尧问于舜曰：“吾欲伐宗脍、胥、敖，南面而不释然。其故何也？”舜曰：“夫三子者，犹存乎蓬艾之间。若不释然何哉！昔者十日并出，万物皆照，而况德之进乎日者乎！”**\n\n在过去的时候尧帝曾考问于大位的接班人舜帝说：“我真想消灭宗、脍、胥这三个屡犯边庭的小国，但是朕想到天子的责任又放不下对他们的牵挂，这个原因是什么呢？”舜帝回答说：“这三个小国的国君，竟然还能够在偏小卑微之地生存下来也真是不容易，你感到心情不怡悦。这说明了什么呢？过去曾有十个太阳同时普照大地，万物皆能普受恩惠，更何况您的道德境界胜过十个太阳的普照呢？”\n\n>**啮缺问乎王倪曰：“子知物之所同是乎？”曰：“吾恶乎知之！”“子知子之所不知邪？”曰：“吾恶乎知之！”“然则物无知邪？”曰：“吾恶乎知之！虽然，尝试言之：庸讵知吾所谓知之非不知邪？庸讵知吾所谓不知之非知邪？且吾尝试问乎女：民湿寝则腰疾偏死，鳅然乎哉？木处则惴栗恂惧，猨猴然乎哉？三者孰知正处？民食刍豢，麋鹿食荐，蝍蛆甘带，鸱鸦耆鼠，四者孰知正味？猨猵狙以为雌，麋与鹿交，鳅与鱼游。毛嫱丽姬，人之所美也；鱼见之深入，鸟见之高飞，麋鹿见之决骤，四者孰知天下之正色哉？自我观之，仁义之端，是非之涂，樊然淆乱，吾恶能知其辩！”啮缺曰：“子不利害，则至人固不知利害乎？”王倪曰：“至人神矣！大泽焚而不能热，河汉冱而不能寒，疾雷破山、飘风振海而不能惊。若然者，乘云气，骑日月，而游乎四海之外，死生无变于己，而况利害之端乎！”**\n\n啮缺问于王倪说：“先生知道万物所共同的那个根本吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺又问道：“先生知道您那个为什么不去知道吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺进一步问道：“那么万物是否也都是一样的什么也不去知道吗？”王倪回答道：道心之吾为什么要去知道呢！尽管如此，也需要试着将其道理说明。怎么能知道我所说的道心的大用止于“知”，也就是道心之吾的那个“知”并不是不能知道啊？道心的大用止于“知”，则正是道心之吾的那个“知”明明就在却不去知啊！现在吾且试着问于你：我们如果在潮湿的地方安歇就会腰痛乃至偏瘫，泥鳅会这样吗？我们如果在树木上安歇就会担心掉下来而心惊恐惧，猿猴会这样吗？对于人、泥鳅、猿猴这三种动物的安歇方式而言哪一种是正确的呢？我人喜欢食食草的及喂养的动物，麋鹿喜欢食草类植物，蜈蚣喜欢食蛇之类的爬行动物，鹞鹰喜欢食鼠类动物，对于人、麋鹿、蜈蚣、鹞鹰这四种动物的口味而言哪一种是正确的呢？濑猴与猴子互相吸引，狍子与鹿互相倾情，泥鳅与鱼互相交欢。毛嫱与丽姬，在我们眼里都是最具吸引力的大美女；然而鱼见了她们却恶心地躲入深水中，飞鸟见到她们却鄙视地高飞而去，麋鹿见到她们却厌恶地急速地跑走。对于猿狙、麋鹿、鳅鱼、人这四种动物的审美观点而言哪一种是正确的呢？从我们的意识心上分析，讲究仁义的开始，便是是非涂抹道心的开始，像这样互相缠绕得杂乱的意识行为，道心之吾又怎能分清仁义与是非的观念是谁对谁错呢！啮缺又问道：“看来现实您是不知道凡事对自己的利与害了，难道心身行为最完美的人也是原本就不知道凡事对自己的利与害吗？”王倪回答道：“心身行为最完美的人可就神通广大了，即使四大海都变得干涸而燃烧起来他也不会感到热，即使宇宙都冻得成冰了他也不会感到冷，即使霹雳能击破山岳、狂风能掀起海啸也不会吓着他。如果达到了这种境界的话，就能够乘云气、骑日月而逍遥地游乎环宇之内了；即使人们所认为的死生也不会改变自己的道心之大用了，更何况是人们所认为的利与害的小事呢！”\n\n>**瞿鹊子问乎长梧子曰：“吾闻诸夫子：圣人不从事于务，不就利，不违害，不喜求，不缘道，无谓有谓，有谓无谓，而游乎尘垢之外。夫子以为孟浪之言，而我以为妙道之行也。吾子以为奚若？”**\n\n瞿鹊子问于长梧子说：我听孔子说：“圣人在对待立身处世之心身行为的培养上没有必须要如何如何的想法，既没有获取利益之心，也没有躲避害处之心，既没有必得的执着之心，也没有等待外缘具备时再去做的懒散之心，只有心里真正达到了无所谓时才算是有了道心的成就了，若是心里有一点儿所谓的影子那就还没有真正达到道心的境界，如此才能使自己的心行既在世俗中生活又不受各种世俗之心对道心的污染。”先生您却认为这是好高骛远之言，而我却认为是最好的修道宗旨，作为得道的先生您认为咱俩的看法谁对呢？\n\n>**长梧子曰：“是黄帝之所听荧也，而丘也何足以知之！且女亦大早计，见卵而求时夜，见弹而求鸮炙。予尝为女妄言之，女以妄听之。奚旁日月，挟宇宙，为其脗合，置其滑涽，以隶相尊？众人役役，圣人愚芚，参万岁而一成纯。万物尽然，而以是相蕴。予恶乎知说生之非惑邪！予恶乎知恶死之非弱丧而不知归者邪！**\n\n长梧子回答说：孔子所说的境界，恰恰是轩辕皇帝毫无意识心地任由那个道心的作用慢慢地明亮后的境界，单凭听了孔丘所说的几句道理又何足以真正地知道那个境界呢！而且你也太过于听风即是雨了，似乎见到鸡蛋就得到了会即时报更的公鸡了，见到弹弓就得到了香喷喷的烤鸮了。我试着为你妄言之，你也妄听之。如何才能与日月为邻，驾驭宇宙呢，唯一的办法就是必须完全做到与孔子所说的道理相吻合，对当下的心念不管是明白地知道还是糊里糊涂都不去管它，这才能符合孔子所说的道理。不要像众人役使自己的身心为自己的欲望服劳役那样地往外求，要像圣人傻傻地待在葆光的境界里那样，如此才能参究透一万年也只不过纯属当下的一念所变现而已；万物也都是如此，也都是以这个当下一念的作用在积蓄着生命的能量。我怎么知道喜欢活着的心理并不是内心不明之迷惑呢？我怎么知道厌恶死亡的心理并不是不害怕死亡呢？我怎么知道人们害怕死亡就像弱孩迷失在他乡而不知回归故乡呢！\n\n>**丽之姬，艾封人之子也。晋国之始得之也，涕泣沾襟。及其至于王所，与王同匡床，食刍豢，而后悔其泣也。予恶乎知夫死者不悔其始之蕲生乎？梦饮酒者，旦而哭泣；梦哭泣者，旦而田猎。方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。且有大觉而后知此其大梦也，而愚者自以为觉，窃窃然知之。“君乎！牧乎！”固哉！丘也与女皆梦也，予谓女梦亦梦也。是其言也，其名为吊诡。万世之后而一遇大圣知其解者，是旦暮遇之也。**\n\n丽这个地方的美女丽姬，原是丽地一个名叫“艾”的城邑之长官的女儿；晋国的国君刚选她入宫时，她不知道这是好运气来了反而吓得哭成了泪人儿，等到她到了王宫之后，没想到竟然是与国君同吃同住，而且餐餐都是食草的及喂养的动物肉，于是就后悔当初的无知而暗自落泪。从这类事上难道我们还不明白“那些怕死的人岂不应该后悔当初怕死”的无知之心理吗！夜里梦到席间饮宴娱乐的梦，第二天往往会遇到伤心而哭泣的事；夜里梦到伤心而哭泣的梦，第二天往往会遇到驰骋田猎而心旷神怡的事。当时再梦中的时候，并不知道自己是在做梦。而且还在梦中将所梦达成了真实的事，只到醒了之后才知道那是虚幻的梦境而非真实。还有一种情况是，彻底恢复了道心之内明而后明白了夜里的梦境与白天的所作所为，它们都是非常虚幻的。然而我们未恢复道心的所有凡夫却自以为所捞到的财官名利皆是自己最聪明的结果，且暗自为自己的聪明而高兴，真不知道自己是人生的主人，还是被人生所放牧的犟牛，这可是多累劫以来所形成的根深蒂固的虚妄习气所致使的啊！孔子给你所讲的那些道理，皆都是梦话；就连我所说的“孔子给你所讲的那些道理都是梦话”的话，也同样是梦话啊！我刚才的说法，名字就叫作为了归于道用之实相而截断各种妄见的接引后学的吊诡之法。假若万世之后能够遇到一位恢复了道心的大圣人，那也是在这种接引之法的接引下，起到了早晨听了道而晚上也就明白了的作用而已。\n\n>**既使我与若辩矣，若胜我，我不若胜，若果是也？我果非也邪？我胜若，若不吾胜，我果是也？而果非也邪？其或是也？其或非也邪？其俱是也？其俱非也邪？我与若不能相知也。则人固受其黮暗，吾谁使正之？使同乎若者正之，既与若同矣，恶能正之？使同乎我者正之，既同乎我矣，恶能正之？使异乎我与若者正之，既异乎我与若矣，恶能正之？使同乎我与若者正之，既同乎我与若矣，恶能正之？然则我与若与人俱不能相知也，而待彼也邪？”**\n\n假使我与你再论辩，如果你胜了我，那么我就胜不了你，难道你就果真对了，我就果真错了吗？如果我胜了你，那么你就胜不了我，难道我就果真对了，你就果真错了吗？无论你认为是你果真对了还是我果真对了，岂不皆证明你的认为是出于意识心的了吗？如果你认为你与我的论辩都是对的，岂不证明你与我的论辩皆是出于意识的了吗？既然你与我之间不能论辩得明白，那么我人就会一直处于自己所证得的绝非道心内明的黑暗之中，那么我人的道心又怎能通过纠正自己的虚妄性而得到恢复呢？如果用与你的见地相同的人来纠正你的虚妄性，既然与你的见地相同，又怎能纠正得了呢？如果用与我的见地相同的人来纠正你的虚妄性，既然与我的见地相同，又怎能纠正得了你呢？如果用与你我的见地皆不相同的人来纠正你的虚妄性，既然与你我的见地皆不相同，又怎能纠正你的虚妄性呢？如果用与你我的见地皆相同的人来纠正你的虚妄性，既然与你我的意见皆相同，又怎能纠正你的虚妄性呢？然而反过来看我与你，也像世人一样的都是不明白自己的人，还必须有赖于吊诡之辩才能最终明白自己啊！\n\n>**化声之相待，若其不相待。和之以天倪，因之以曼衍，所以穷年也。“何谓和之以天倪？”曰：“是不是，然不然。是若果是也，则是之异乎不是也亦无辩；然若果然也，则然之异乎不然也亦无辩。忘年忘义，振于无竟，故寓诸无竟。”**\n\n怎能将极细微的起心动念控制在中和的程度呢？长梧子回答道：主观上所认定的对了，与道用上的客观事实一定是不相符的；主观上所认定的模样，与道用上的客观模样一定是相矛盾的。主观上所认定的对了，如果与道用上的客观事实是相符的，这个主观上所认定的也就达到非思维、言语所能辩的道用之实相的境界了。主观上所认定的模样，如果与道用上的客观模样是一致的，这个主观上所认定的模样也就达到非思维、言语所能辩的道用之实相的境界了。是与非纠缠在一起，如果那个审明辨知不起作用了，那就必须将起审明辨知之作用的那个极微细的起心动念时控制在中和的程度了，如果让那个极微的起心动念游衍自得，那就永远也不会恢复道心的明性而丧失审明辨知的作用了。当自己的心理上没有了时间及情义的概念时，才能像大鹏怒而飞一样地振作于不可预料的尘世生活环境中，于是也就能在各种各样的尘世生活中燕处超然了。\n\n>**罔两问景曰：“曩子行，今子止；曩子坐，今子起。何其无特操与？”景曰：“吾有待而然者邪？吾所待又有待而然者邪？吾待蛇蚹蜩翼邪？恶识所以然？恶识所以不然？”**\n\n影子的影子问影子说：“正当我刚刚跟着你走的时候，你却突然又停了下来；正当我刚刚跟着你坐下来的时候，你却突然又站了起来；你怎么就如此地没有独立的志操呢？”影子回答说：“我后面还有一个对应地管束我的东西在如此地做吗？我后面的那个对应地管束我的东西的后面还有一个对应地管束它的东西在如此地做吗？对应的我只是像蛇腹下的横鳞或蝉的翼一样地被动地随之而动而已吗？我怎么能知道我为什么会一会儿被这样？又怎么能知道为什么一会儿会不被这样呢？”\n\n>**昔者庄周梦为胡蝶，栩栩然胡蝶也。自喻适志与！不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与？胡蝶之梦为周与？周与胡蝶则必有分矣。此之谓物化。**\n\n过去庄周我曾经梦到自己变成了蝴蝶，活灵活现的一只真蝴蝶的样子，当时自己心里很明白自己就是这只蝴蝶而且非常惬意啊，已经完全不知道自己原本是庄周了；一会儿梦醒了，也就又恢复成了现实中的庄周我了。真不知道是庄周我在梦里化为了蝴蝶呢，还是蝴蝶在梦里化为了庄周我呢！对于庄周我与蝴蝶在梦中互化的现象而言，必然是在不同的心力下所产生的不同的物类及个体而已，这就是形身在心力的作用下从一个物类个体又转化为另一个物类个体的物化现象。\n","source":"_posts/内篇（二）——齐物论.md","raw":"---\ntitle: 内篇（二）——齐物论\ntags:\n - 读书\ncomments: true\ntoc: true\nonly:\n - home\n - category\n - tag\ndate: 2021-05-29 13:12:36\ncategories: 庄子\npic:\n---\n\n\n>**南郭子綦隐机而坐，仰天而嘘，荅焉似丧其耦。颜成子游立侍乎前，曰：“何居乎？形固可使如槁木，而心固可使如死灰乎？今之隐机者，非昔之隐机者也？”子綦曰：“偃，不亦善乎，而问之也！今者吾丧我，汝知之乎？汝闻人籁而未闻地籁，汝闻地籁而不闻天籁夫！”**\n\n南郭子綦靠几静坐，仰面朝天缓缓地吐气，茫然若失，就像魂魄离开了躯体。南郭子綦的学生颜成子游见状马上前来侍候，问南郭子綦说：“您刚才是处于一种什么样的境界呢？一个人的肢体形貌在打坐时固然可以使它像枯槁之木一样毫无生气，难道一个人的心神在打坐时也可以使它像死灰一样毫无生气吗？您在今天所表现出来的安稳境界，跟以前的安稳境界绝对不一样。”南郭子綦回答说：“偃，你问此事，不是问得很好吗？今天我遗忘了形体之我，你知道这一点吗？你只听到人吹箫管发出的声音，而没听听风吹众窍所发出的声音，你只听到风吹众窍所发出的声音，而没有听到天地间万物的自鸣之声！”\n\n>**子游曰：“敢问其方。”子綦曰：“夫大块噫气，其名为风。是唯无作，作则万窍怒呺。而独不闻之翏翏乎？山林之畏隹，大木百围之窍穴，似鼻，似口，似耳，似枅，似圈，似臼，似洼者，似污者。激者、謞者、叱者、吸者、叫者、譹者、宎者，咬者，前者唱于而随者唱喁，泠风则小和，飘风则大和，厉风济则众窍为虚。而独不见之调调之刁刁乎？”**\n\n子游说：“能不能问一问大地的声音与天的声音是怎么回事呢？”南郭子綦回答说：“那个地籁就是无边无际的造物之作用所发出的能量之气息啊，发出来之后就被叫作风。这种能量要么就是内在蕴含着不发出来，一旦发出来就会万窍怒号，难道你耳边就没有听到过这种‘呼呼’的风声吗！山林的险峻、大树周身的窍穴，有的形状像鼻子，有的形状像张开的嘴，有的形状像耳朵，有的形状”像扁长的发簪，有的形状像凸出来的圈筒，有的形状像凹下去的浅坑，有的浅一些，有的深一些；于是所发的声响就有的快促，有的像响箭，有的刺耳，有的发自往里吸，有的发自往外出，有的像嚎哭声，有的像狗叫，有的像悲哀声。能量流的运动原本就很舒缓动听，怪就怪哉随着各种物体所发出的众口乱叫而嘈杂了；当徐徐之风时万物就会轻微地唱和，当风大时万物就会大点儿地唱和，当劲风厉厉时反而所有能发响者皆欲发而无声了，难道你没有从风响的音调中听出来各种声响的发声原因、从风的响声上听出其后面的那个不发声的东西吗？”\n\n>**子游曰：“地籁则众窍是已，人籁则比竹是已，敢问天籁。”子綦曰：“夫吹万不同，为而使其自己也。咸其自取，怒者其谁邪？”**\n\n子游又问：“大地的本意可以借助万物之窍所发出的唱和声中表达出来，人所的本意也可以从清悠、消沉、谐美的各种丝竹的或条畅或激昂的声中表达出来，那么天的本意是怎么表达出来的呢？”南郭子綦说：“所谓天籁的音响万变，而又能使其自行息止，这完全都是出于自然，有什么东西主使着它呢？”\n\n>**<font color=red>大知闲闲，小知閒閒。大言炎炎，小言詹詹。</font>其寐也魂交，其觉也形开。与接为构，日以心斗。缦者、窖者、密者。小恐惴惴，大恐缦缦。其发若机栝，其司是非之谓也；其留如诅盟，其守胜之谓也；其杀如秋冬，以言其日消也；其溺之所为之，不可使复之也；其厌也如缄，以言其老洫也；近死之心，莫使复阳也。喜怒哀乐，虑叹变慹[zhé]，姚佚启态。乐出虚，蒸成菌。日夜相代乎前而莫知其所萌。已乎，已乎！旦暮得此，其所由以生乎！**\n\n大智者看上去显得非常广博，小智者却十分琐细；高论者盛气凌人，争论者小辩不休。辩士睡时，精神与梦境交错在一起，醒后疲于与外物接触纠缠。每天与外物相接，其心有如经历了一场又一场的战斗一样疲惫。有的心机柔奸，有的善设陷阱，有的潜机不露。小的惧怕表现为忧惧不安，大的惧怕表现为惊恐失神。三灾八难的降临就像箭在弦上一样地随时而发，这全是由于行为人的心机所伺机行是非之行径所造成的；三灾八难的不降临也可以像发愿一样的通过履践其愿誓而消失，那就要看行为人是否践履自己的愿誓而坚持无思无为的行径来决定了。神情衰沮就像秋风冬雪肃杀万木一样无情，这就说明道心逍遥之本性的消亡是渐进的过程；如果行为人沉迷于自己之心机的经营里而不醒悟的话，也就很难再回到那个逍遥的本性去了。然而行为人对恢复道心的修行却厌恶得像自行封闭起来的蚕子一样的听不进去，这就说明行为人的执着意识的积习太严重了；像这样的几乎等于死亡的心，实在是没法使它再恢复生气。所谓的喜怒哀乐，都是认取了事物对自己所引发的感受而逐步形成多忧惧的意识，正在这个意识之执着的支配下才形成了轻狂而放任的或喜或怒或哀或乐的情绪了。喜怒哀乐发出来之后就过去了，接着而来的就是又孕育出了无明之烦恼，如此的一天到晚的不是喜乐就是烦恼的交替着出现在眼前，而从来不知道它们是怎么产生的。不可救药啊，不可救药！一天到晚地如此活着，三灾八难也就由此产生了啊！\n\n>**非彼无我，非我无所取。是亦近矣，而不知其所为使。若有真宰，而特不得其眹。可行己信，而不见其形，有情而无形。百骸、九窍、六藏、赅而存焉，吾谁与为亲？汝皆说之乎？其有私焉？如是皆有为臣妾乎？其臣妾不足以相治乎？其递相为君臣乎？其有真君存焉！如求得其情与不得，无益损乎其真。一受其成形，不亡以待尽。<font color=red>与物相刃相靡，其行尽如驰而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？</font>**\n\n*如果没有了我之内外的任何对立面的观念也就没有我的观念了，如果没有了我的观念也就没有了博取之心了*，如此也就基本上接近于那个道心的行径了，然而却不知道是什么东西在支配着这个道心的行径。好像其中有一个迫使万物循势而动的主宰在，然而偏偏找不到那个主宰的迹象在什么地方，当你恢复了道心之后就会彻底明了那个迫使万物循势而动的主宰了，但它却又没有一个具体的形状可见，它仅仅是道心的广大无缘之悲性而没有具体形状而已。一个人身上有百骸、九窍、六脏，当这些脏器都完备了之后才能决定一个人的生存，那么你认为哪一个脏器最重要而倍加爱护呢？还不是都喜欢而都倍加爱护吗？这个问题的背后岂不牵扯到一个“私我”的观念了吗？如果有一个“私我”之观念的话，那么各脏器岂不就成了分别为“私我”提供专职服务的臣下与妻妾了吗？这种势必缺乏协调性的臣下与妻妾岂不就不足以担当全面治理整个机体的重任了吗？难道它们是逐个轮流着担当君的职责而协调各位臣妾的工作吗？这就证明里面有一个真正的主宰在后面起着决定作用吗？如果实证到了那个广大无缘之慈悲性的道心原来是没有具体形状可得的时候，那时候就会明白这个真宰的作用无论怎么做都既不会益于也不会损于那个真宰者的不生不灭、不增不减、不垢不净性了。然而自从那个人人都有的真主秉承了执着之意识以投胎成人之后，还没有到该死的寿数时就在哪里等着寿尽的一天了，这是因为内外界事物所诱发的爱、恶、欲、的心行在相争斗以至于相消耗的缘故；<font color=red>明明知道生命的寿终就像飞驰一样，但却不知道如何止住这种迈向寿终的步伐，对于自许聪明的人们来说难道不是一种悲哀吗！只知道一辈子地役使自己的心身去赴爱、恶、欲的劳役但对于恢复道心却毫无一点儿进展，整天精神不振地疲于劳役但却不知道究竟是为了什么，对于自许聪明的人们来说难道不是一种痛心吗！即使能够达到人们所说的千万岁的长生不老，对于道心的恢复又有什么益处呢？即使其形体逐渐衰败枯萎，也只是其执着心使其具有了这种变化而已，对于那个真宰的不生不死、不增不减、不垢不净性而言怎能不是最大的痛心呢！人生在世，本来就如此糊涂吗？</font>\n\n>**夫随其成心而师之，谁独且无师乎？<font color=red>奚必知代而心自取者有之？</font>愚者与有焉！未成乎心而有是非，是今日适越而昔至也。是以无有为有。无有为有，虽有神禹且不能知，吾独且奈何哉！**\n\n还是只有我糊涂，而别人也有不糊涂的呢？<font color=red>世人如果都以自己的偏见作为判别是非的标准，那么谁没有一个标准呢？</font>何必是懂得事物更替而心有见地的人才有是非标准呢？即使愚蠢的人也是有的。在未有成见存于心中之前已经就因自己的好恶之感受而得出对与错的心得了，这个心得之现象的得出就像今天刚到了越国而实际上原本就在越国一样地早就待在那个地方了。所以才从道心里凭空产生出心得乃至执着了。对于通过作意而产生出神奇的事物来的行为而言，即使有着禹王那样的神通，也不能有一点儿故意去知道的心在，客观世界的任何事物又怎能奈何于超然物外的那个道心之吾的神奇作用呢！\n\n>**夫言非吹也，言者有言。其所言者特未定也。果有言邪？其未尝有言邪？其以为异于鷇音，亦有辩乎？其无辩乎？道恶乎隐而有真伪？言恶乎隐而有是非？道恶乎往而不存？言恶乎存而不可？<font color=red>道隐于小成，言隐于荣华</font>。故有儒墨之是非，<font color=red>以是其所非而非其所是。欲是其所非而非其所是，则莫若以明。</font>**\n\n言论出于机心，与无心而吹的“天籁”是不同的。发言者知持一端，他们的话并不能作为衡量是非的标准。为了表述某事物果真就需要言辞吗？人们最初始时的思想交流并没有使用言辞啊！人们的言辞之所以能听得懂而雏鸟的叫声却听不懂，这个能听懂的背后是有一个思辨的审明作用在呢？还是没有思辨的审明作用在呢？那个大道为什么未被真正地认识到而产生了见解上的真与假呢？言辞所表述的意义为什么未被真正地认识到而产生了判断上的是与非呢？那个大道为什么必须去参悟才能实证到它而不能通过想象去找到它呢？言辞所表述的意义为什么必须通过思辨才能听懂而不能一听就能确定其真意呢？<font color=red>原因就在于那个大道被不深刻、不全面的小见解给遮蔽住了，就在于言辞所表述的意义被言辞本身的巧妙之比喻或夸张给遮蔽住了。</font>所以才产生了儒墨两家之学术思想的我对你错的争鸣，<font color=red>世人都是用自己所认定的正确去评判人家的不正确，都是用自己所认定的人家的不正确来宣扬自己的正确。与其想用自己所认为的正确去推定人家的不正确，与其想用人家的不正确来证明自己所认为的正确，那就不如静下心来认认真真地修身以达到内明为好。</font>\n\n>**物无非彼，物无非是。自彼则不见，自知则知之。故曰：彼出于是，是亦因彼。彼是方生之说也。虽然，方生方死，方死方生；方可方不可，方不可方可；因是因非，因非因是。是以圣人不由而照之于天，亦因是也。是亦彼也，彼亦是也。彼亦一是非，此亦一是非，果且有彼是乎哉？果且无彼是乎哉？彼是莫得其偶，谓之道枢。枢始得其环中，以应无穷。是亦一无穷，非亦一无穷也。故曰：莫若以明。**\n\n天地万物在道体上不存在你我它的分别，天地万物在道体上也不存在你对及它错的差别。如果从万物存在的现象去看就不会认识到万物是道体之妙用的那个本质，只有从内明的大智慧上去看才能认识到万物同是道体之妙用的那个本质。所以说人们之所以会有万物的个体皆有差异以及你对而它错的分别心乃是从没有分别心的物我同胞的实相中产生的，于是那个没有分别心的物我同胞之实相的提法也就对应于人们的分别心而提出来了。人们之所以会产生分别心，乃是由于当下一念的喜爱心所造成的虽然都是因为当下一念的喜爱心所造成，但当下一念的喜爱心刚刚生起便又马上消失了，前念刚刚消失便又马上生起了后念的喜爱心；于是人们的分别心刚刚形成执着又紧接着遇到新的事物而须要去分别了，于是对新事物的分别心又形成另一个新的执著心了；因为先前的执着心而产生了对新遇到之事物的不认同，对新遇到之事物的不认同经过喜爱心的分别又形成了新的另一个执着。所以每一位恢复了道心的圣人无不鉴于当下之一念的迁流不断而不由得时刻注意着当下一念的似起未起之时，也就是因为这个道理啊！在先前的那个执着的作用下产生了新的另一个执着，新的另一个执着又变成了产生新执着的旧执着。先前的执着是喜爱心所认为的对与错而形成的，新执着也是喜爱心所认为的对与错而形成的。果真存在着执着心所认为的那个正确吗，果真存在着执着心所认为的那个不正确吗？无论是执着心所认为的正确还是所认为的不正确皆是失去了道心中庸之用的结果，这就是所说的形成执着的关键之所在。正是由于形成执着的整个关键作用发生在旧执着与新执着的环环相产生的现象中，于是无始劫以来所形成的无穷的执着也就变成了遮蔽道心的“五蕴”了。道心的中庸之大用是无穷无尽的，意识心的执着之妄用也是无穷无尽的。所以说要想了知道心的全体之大用还是静下心来认认真真地修身以达到内明为好。\n\n>**以指喻指之非指，不若以非指喻指之非指也；以马喻马之非马，不若以非马喻马之非马也。天地一指也，万物一马也。**\n\n用自己的手指来说明人家的手指不是手指，不如不用自己的手指来说明人家的手指不是手指为好；用马来说明白马不是马，不如不用马来说明白马不是马为好。从道通为一的观点看，天地与一指，万物与一马，都是没有区别的。\n\n>**可乎可，不可乎不可。道行之而成，物谓之而然。恶乎然？然于然。恶乎不然？不然于不然。物固有所然，物固有所可。无物不然，无物不可。故为是举莛与楹，厉与西施，恢诡谲怪，道通为一。**\n\n人家认为可，我也跟着认为可；人家认为不可，我也跟着认为不可。于是那个道的生发万物的妙用也就在因缘聚合而生的条件下形成了，于是万物也就在遇到了所对应的因缘聚合的条件下而形成了各具特色的形物了。有的万物之个体能适应因缘聚合而生的各种不同的环境条件而生，有的万物之个体不能适应因缘聚合而生的各种不同的环境条件而只能待其适应的环境条件时而生；所以有的万物之个体也就顺势而形成了具有新特色的形体了，有的万物之个体则未能顺势形成新特色的形体而是保持了始祖的面目乃至被淘汰。为什么有的万物之个体能顺势而形成具有新特色的形体呢？那是因为它具有能顺势而生的适应性所以才形成了具有新特色的形体。为什么有的万物之个体不能顺势而形成具有新特色的形体呢？那是因为它不具有能顺势而生的适应性所以才不能形成具有新特色的形体。为什么有的万物之个体能具有顺势而生的适应性呢？那是因为它具有适应因缘聚合而生的各种不同环境条件的天性。为什么有的万物之个体不具有顺势而生的适应性呢？那是因为它不具有适应因缘聚合而生的各种不同环境条件的天性。万物原本就具有顺势而形成的具有新特色的适应性，万物原本就具有适应因缘聚合而生的各种不同环境的天性。没有哪一个万物之个体不是因为这种适应性而生，也没有哪一个万物之个体不是因为这种天性而生。所以才产生了诸如轻空的莚秆或坚实的楹柱之类的各种不同物类，才产生了诸如丑陋或美丽之类的各种不同形色，才产生了诸如中正、阴险、诡秘、古怪之类的各种不同性格，当你通达了那个道心的大用后就会明白它们都是无二无别的实相了。\n\n>**其分也，成也；其成也，毁也。凡物无成与毁，复通为一。唯达者知通为一，为是不用而寓诸庸。庸也者，用也；用也者，通也；通也者，得也；适得而几矣。因是已。已而不知其然，谓之道。劳神明为一而不知其同也，谓之“朝三”。何谓“朝三”？狙公赋芧，曰：“朝三而暮四。”众狙皆怒。曰：“然则朝四而暮三。”众狙皆悦。名实未亏而喜怒为用，亦因是也。是以圣人和之以是非而休乎天钧，是之谓两行。**\n\n万物之生命的死亡与分解的过程，就是又形成新的生命的过程；形成新的生命的过程，就是其生命的下一次死亡与分解的过程。万物根本就没有什么生与死的截然不同，或生活死的现象也只是同时发生着的道心之大用而已；正是由于实证到了道境界的人彻底明白了或生活死的现象都是同时发生着的，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。当一切行为都隐含在恰到好处的无之用中了的时候，才能遵循道心的全体之大用；当能遵循道心的全体之大用的时候，才能通达一切现象皆是无二无别的实相；当通达了一切现象皆是无二无别之实相的时候，才能驾驭道心的全体之大用；当驾驭了道心的全体之大用的时候，也就差不多恢复了那个道心了。遵循这个过程也就恢复那个道心了。恢复了那个道心也就凡事只是无为地去做而不去问为什么了，这才叫作真正的道境界。被喜怒爱恶欲所驱使的心意之妄动与其内在的思辨觉知之作用是一个本原，然而却不知道此二者都是一个本原，这就叫作只知朝四而不知暮三的猴子意识。为什么叫作只知朝四而不知暮三的猴子意识呢？管理猴子的人给猴子喂食橡实时说：“早晨喂三个晚上喂四个。”众猴子闻之则大怒；管理猴子的人又说：“既然大家都不同意，那就还按早晨喂四个晚上喂三个的老法子。”众猴子们则闻之则大喜。名字之类的名相与名相所代表的那个实物的本性原本就没有什么不同，然而在人们的喜怒哀乐恶欲的心理作用下却变成了各种不同的理解，这就是因为那个只知朝四而不知暮三的意识在作怪啊。所以恢复了道心的圣人们既能在外行上将各种矛盾对立的意识调节控制在中和的状态，又能在内行上安闲自在于道心大用之遍行的无二无别的精神境界中，这就叫作一个道心境界而同时有着内外两种行径的圣行。\n\n>**古之人，其知有所至矣。恶乎至？有以为未始有物者，至矣，尽矣，不可以加矣！其次以为有物矣，而未始有封也。其次以为有封焉，而未始有是非也。是非之彰也，道之所以亏也。道之所以亏，爱之所以成。果且有成与亏乎哉？果且无成与亏乎哉？有成与亏，故昭氏之鼓琴也；无成与亏，故昭氏之不鼓琴也。昭文之鼓琴也，师旷之枝策也，惠子之据梧也，三者之知几乎！皆其盛者也，故载之末年。唯其好之也，以异于彼，其好之也，欲以明之。彼非所明而明之，故以坚白之昧终。而其子又以文之纶终，终身无成。若是而可谓成乎，虽我亦成也；若是而不可谓成乎，物与我无成也。是故滑疑之耀，圣人之所图也。为是不用而寓诸庸，此之谓“以明”。**\n\n古时候的人，他们所具足的大智慧任何地方都能无所不至啊！都是打倒了什么样的无所不至呢？凡所做出的任何行为从根本上就没有做事之动机的存在，就是具足了无所不至的大智慧的境界了，当具足了这种无所不至的大智慧后，就再也不会被喜怒爱恶欲的习气所污染了。差一点的境界则仅仅才有了做事的动机，但却没有达到“这是我的，那是你的”的私我意识；再差一点的境界也只是有了“这是我的，那是你的”的私我意识，但却没有形成以我见而划分对错是非的唯我意识。后来我人便有了对错是非之心而且越来越严重了，于是道心也就亏失了；道心之所以亏失了，完全是心里的那个喜欢之所用所导致的。难道那个道心果真会圆满也会亏失吗，还是果真不会圆满也不会亏失呢？那个道心确实会圆满也会亏失，所以当大琴师昭氏鼓琴时便能激荡起人们心神的喜悦而造成道心之静的亏失了啊；那个道心确实不会圆满也不会亏失，所以当大琴师昭氏不鼓琴时人们的心神便恢复了道心之静的常态了。大琴师昭文的鼓琴之技艺，大乐师师旷持策以击乐器，大逻辑家惠子的诡辩之造诣，就这三个人对于各自爱好之事所达到的极其微妙的程度而言，都是各自领域里的顶尖高手，所以才能千古流传下来。由此三人在琴、诊、论上有着超乎寻常的爱好心，所以才使得在琴、诊、论的成就上大大超出了其他方面的技能；他们之所以爱好其所好的东西，其目的就是为了彻底研究明白所爱好之东西的内在机制。所爱好之东西的内在机制本来就不是靠研究所能研究明白的事反而执意地要去研究明白它，所以才犯了坚石非坚、白马非马之逻辑式的错误以至于愚昧终生。像他们那样地达到了极其微妙的程度就算是真正的最高成就了吗？那么我们每一个意识心用事的人也就可以说是成道的圣人了。像他们那样地达到了极其微妙的程度不算是真正的最高成就吗？那么万物与我人也就不会成为个别的个体了。所以，只有这样地将那个大道的玄机深究到大生疑惑的境地才能不知不觉地过渡到恍然大悟的境界，这正是圣人所希望的啊！只有达到了恍然大悟的境界才能没有是非对错之意识而一切行为都隐含在道心的无为之大用中，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。\n\n>**今且有言于此，不知其与是类乎？其与是不类乎？类与不类，相与为类，则与彼无以异矣。虽然，请尝言之：有始也者，有未始有始也者，有未始有夫未始有始也者；有有也者，有无也者，有未始有无也者，有未始有夫未始有无也者。俄而有无矣，而未知有无之果孰有孰无也。今我则已有有谓矣，而未知吾所谓之其果有谓乎？其果无谓乎？**\n\n刚才已将“是非之彰也，道之所以亏也”的道理说过了，那么它与“为是不用而寓诸庸”的道理是一回事呢，还是与“为是不用而寓诸庸”的道理不是一回事呢？就以人们所认为的是一回事与不是一回事的那个认识而言，认识本身的那个思维所产生的心行就是同一回事，如此也就理解“是非之彰也，道之所以亏也”的道理与“为是不用而寓诸庸”的道理没有什么不同了。尽管如此，也需要试着将其道理说明如下。有的心行是从意识中突然产生的，有的心行是从末那识中迁流过来的，有的心行是从藏识中迁流过来的。来源于意识中的心行有的正存在着，有的已经过去了，来源于末那识的心行有的出于旧有的执着、有的出于最近才有的心得，来源于藏识中的心行乃是既没有形成执着，又没有形成心得的无为之举。心行就是这样地一会儿是从意识中产生出来，一会儿是从藏识中迁流出来，却不知道这两张心行的现象，它是不是真实的存在呢？现在用哪个会思会想的意识心反思一下自己就会发现所谓的“我”是不真实的假象了，而那个不会思不会想的道心之吾则是真实存在的了。道心之吾果真是真实的存在啊！意识心之假我果真是不真实的存在啊！\n\n>**夫天下莫大于秋毫之末，而太山为小；莫寿乎殇子，而彭祖为夭。天地与我并生，而万物与我为一。既已为一矣，且得有言乎？既已谓之一矣，且得无言乎？一与言为二，二与一为三。自此以往，巧历不能得，而况其凡乎！故自无适有，以至于三，而况自有适有乎！无适焉，因是已！**\n\n整个的天下在实相上不会比秋毫的尖头大，相形之下那有形的大山却是渺小得很；我们的寿命在实相上不会比夭折的小儿寿长，相形之下那八百寿的彭祖却是夭亡的小儿；这就证明天地与我们都是道心之大用的妙用所生，万物与我们都是一个本体而没有人我万物之别。既然天地人我万物都是一个本体的“一”而没有差别，为什么会有天地人我万物之不同的认识存在呢？既然认为它们都是一个一个的个体而有差别，又怎会没有天地人我万物之不同的认识存在呢？道之实相用言辞说出来就变成第二重的言辞之比喻象了，将道的比喻象再用言辞说出来就变成第三重的意识之妄见象了。自从道之实相变成言辞之比喻象再变成意识之妄见象以来所代代递增的妄见象，即使技术最高超的人来推算也不能计算清楚它，更何况还有以后所必然会形成的意识之妄见象呢！从道的不可言说的实相上就能变成言辞之比喻象以至于再变成意识之妄见象，更何况将意识之妄见象再变成妄见的言辞之比喻象呢！由此而知，意识之妄见再变成意识之妄见的沿流永远没有一个尽头，原因就在于妄见的沿流层出不穷。\n\n>**夫道未始有封，言未始有常，为是而有畛也。请言其畛：有左有右，有伦有义，有分有辩，有竞有争，此之谓八德。六合之外，圣人存而不论；六合之内，圣人论而不议；春秋经世先王之志，圣人议而不辩。**\n\n对于那个道心的大用而言在最初并没有“这是我的，那是你的”的私我之意识，对于言辞而言却从一开始便不存在永久不变，正是因为意识之妄见的沿流永远没有一个尽头而从道心之大用中形成了人我万物的各个个体及各种思想意识了。请让我说说这些界限：有上下、尊卑之序，有亲疏之理、贵贱之仪，有剖析万物、分别彼此，有角逐胜负、对辩是非，这就是儒、墨等派所争辩的八种界限。对于宇宙之外的不可知，圣人只是保留其说而不加以讲解；对于宇宙之内的事物，圣人只是讲解而不加以评说；对于以天道中正为喻的《春秋》所记载的经纶天下的先王的济世之道，圣人只是评说而不加以争辩。\n\n>**故分也者，有不分也；辩也者，有不辩也。曰：“何也？”“圣人怀之，众人辩之以相示也。故曰：辩也者，有不见也。”夫大道不称，大辩不言，大仁不仁，大廉不嗛，大勇不忮。道昭而不道，言辩而不及，仁常而不成，廉清而不信，勇忮而不成。五者圆而几向方矣！故知止其所不知，至矣。孰知不言之辩，不道之道？若有能知，此之谓天府。注焉而不满，酌焉而不竭，而不知其所由来，此之谓葆光。**\n\n由圣人的做法可知，既然有了是非对错的认识之分别，这本身就说明道心原本就是一而没有认识之分别；既然有了是非对错的争辩，这本身就说明道心原本就是一而没有争辩之实质。这证明了什么呢？证明了圣人是思虑于心，而众人是妄议于言为了将这个道理开示出来。所以告诉大家，“之所以存在着争辩的现象，乃是还没有达到内明的缘故。”真正的大道没有任何名相之称谓，真正的大辩没有任何说道之言辞，真正的大仁没有任何仁慈之目的，真正的大廉是不自需锋芒的，大勇是不自逞血气之勇的。如果还有有道的样子显现出来则恰恰证明没有道，言语过于辩察，就不能达到真理，仁者滞于一偏之爱就不能周遍，过分表示廉洁就不够真实，自逞血气之勇就不成器大勇。不称、不言、不仁、不嗛、不忮这五个方面，本来是圆通混成的；如果涉及昭、辩、常、清、忮等形迹，就变成四方之物了。所以道心之知的明了作用若能停留在只管去做而不去动其心的境界上，那么修心的境界也就到家了。怎能又去管它什么没有言辞才是真正的论辩，不认为有道才是真正的有道呢？如果保持住了那个能知而又不去动心的境界，也就叫作修心阶段的最高成就了。只有达到了像大海一样地诸如多少也不会满溢，舀取多少也不会枯竭，而且也不去思考为什么会这样的境界时，这才叫作包藏光亮而不露。\n\n>**故昔者尧问于舜曰：“吾欲伐宗脍、胥、敖，南面而不释然。其故何也？”舜曰：“夫三子者，犹存乎蓬艾之间。若不释然何哉！昔者十日并出，万物皆照，而况德之进乎日者乎！”**\n\n在过去的时候尧帝曾考问于大位的接班人舜帝说：“我真想消灭宗、脍、胥这三个屡犯边庭的小国，但是朕想到天子的责任又放不下对他们的牵挂，这个原因是什么呢？”舜帝回答说：“这三个小国的国君，竟然还能够在偏小卑微之地生存下来也真是不容易，你感到心情不怡悦。这说明了什么呢？过去曾有十个太阳同时普照大地，万物皆能普受恩惠，更何况您的道德境界胜过十个太阳的普照呢？”\n\n>**啮缺问乎王倪曰：“子知物之所同是乎？”曰：“吾恶乎知之！”“子知子之所不知邪？”曰：“吾恶乎知之！”“然则物无知邪？”曰：“吾恶乎知之！虽然，尝试言之：庸讵知吾所谓知之非不知邪？庸讵知吾所谓不知之非知邪？且吾尝试问乎女：民湿寝则腰疾偏死，鳅然乎哉？木处则惴栗恂惧，猨猴然乎哉？三者孰知正处？民食刍豢，麋鹿食荐，蝍蛆甘带，鸱鸦耆鼠，四者孰知正味？猨猵狙以为雌，麋与鹿交，鳅与鱼游。毛嫱丽姬，人之所美也；鱼见之深入，鸟见之高飞，麋鹿见之决骤，四者孰知天下之正色哉？自我观之，仁义之端，是非之涂，樊然淆乱，吾恶能知其辩！”啮缺曰：“子不利害，则至人固不知利害乎？”王倪曰：“至人神矣！大泽焚而不能热，河汉冱而不能寒，疾雷破山、飘风振海而不能惊。若然者，乘云气，骑日月，而游乎四海之外，死生无变于己，而况利害之端乎！”**\n\n啮缺问于王倪说：“先生知道万物所共同的那个根本吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺又问道：“先生知道您那个为什么不去知道吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺进一步问道：“那么万物是否也都是一样的什么也不去知道吗？”王倪回答道：道心之吾为什么要去知道呢！尽管如此，也需要试着将其道理说明。怎么能知道我所说的道心的大用止于“知”，也就是道心之吾的那个“知”并不是不能知道啊？道心的大用止于“知”，则正是道心之吾的那个“知”明明就在却不去知啊！现在吾且试着问于你：我们如果在潮湿的地方安歇就会腰痛乃至偏瘫，泥鳅会这样吗？我们如果在树木上安歇就会担心掉下来而心惊恐惧，猿猴会这样吗？对于人、泥鳅、猿猴这三种动物的安歇方式而言哪一种是正确的呢？我人喜欢食食草的及喂养的动物，麋鹿喜欢食草类植物，蜈蚣喜欢食蛇之类的爬行动物，鹞鹰喜欢食鼠类动物，对于人、麋鹿、蜈蚣、鹞鹰这四种动物的口味而言哪一种是正确的呢？濑猴与猴子互相吸引，狍子与鹿互相倾情，泥鳅与鱼互相交欢。毛嫱与丽姬，在我们眼里都是最具吸引力的大美女；然而鱼见了她们却恶心地躲入深水中，飞鸟见到她们却鄙视地高飞而去，麋鹿见到她们却厌恶地急速地跑走。对于猿狙、麋鹿、鳅鱼、人这四种动物的审美观点而言哪一种是正确的呢？从我们的意识心上分析，讲究仁义的开始，便是是非涂抹道心的开始，像这样互相缠绕得杂乱的意识行为，道心之吾又怎能分清仁义与是非的观念是谁对谁错呢！啮缺又问道：“看来现实您是不知道凡事对自己的利与害了，难道心身行为最完美的人也是原本就不知道凡事对自己的利与害吗？”王倪回答道：“心身行为最完美的人可就神通广大了，即使四大海都变得干涸而燃烧起来他也不会感到热，即使宇宙都冻得成冰了他也不会感到冷，即使霹雳能击破山岳、狂风能掀起海啸也不会吓着他。如果达到了这种境界的话，就能够乘云气、骑日月而逍遥地游乎环宇之内了；即使人们所认为的死生也不会改变自己的道心之大用了，更何况是人们所认为的利与害的小事呢！”\n\n>**瞿鹊子问乎长梧子曰：“吾闻诸夫子：圣人不从事于务，不就利，不违害，不喜求，不缘道，无谓有谓，有谓无谓，而游乎尘垢之外。夫子以为孟浪之言，而我以为妙道之行也。吾子以为奚若？”**\n\n瞿鹊子问于长梧子说：我听孔子说：“圣人在对待立身处世之心身行为的培养上没有必须要如何如何的想法，既没有获取利益之心，也没有躲避害处之心，既没有必得的执着之心，也没有等待外缘具备时再去做的懒散之心，只有心里真正达到了无所谓时才算是有了道心的成就了，若是心里有一点儿所谓的影子那就还没有真正达到道心的境界，如此才能使自己的心行既在世俗中生活又不受各种世俗之心对道心的污染。”先生您却认为这是好高骛远之言，而我却认为是最好的修道宗旨，作为得道的先生您认为咱俩的看法谁对呢？\n\n>**长梧子曰：“是黄帝之所听荧也，而丘也何足以知之！且女亦大早计，见卵而求时夜，见弹而求鸮炙。予尝为女妄言之，女以妄听之。奚旁日月，挟宇宙，为其脗合，置其滑涽，以隶相尊？众人役役，圣人愚芚，参万岁而一成纯。万物尽然，而以是相蕴。予恶乎知说生之非惑邪！予恶乎知恶死之非弱丧而不知归者邪！**\n\n长梧子回答说：孔子所说的境界，恰恰是轩辕皇帝毫无意识心地任由那个道心的作用慢慢地明亮后的境界，单凭听了孔丘所说的几句道理又何足以真正地知道那个境界呢！而且你也太过于听风即是雨了，似乎见到鸡蛋就得到了会即时报更的公鸡了，见到弹弓就得到了香喷喷的烤鸮了。我试着为你妄言之，你也妄听之。如何才能与日月为邻，驾驭宇宙呢，唯一的办法就是必须完全做到与孔子所说的道理相吻合，对当下的心念不管是明白地知道还是糊里糊涂都不去管它，这才能符合孔子所说的道理。不要像众人役使自己的身心为自己的欲望服劳役那样地往外求，要像圣人傻傻地待在葆光的境界里那样，如此才能参究透一万年也只不过纯属当下的一念所变现而已；万物也都是如此，也都是以这个当下一念的作用在积蓄着生命的能量。我怎么知道喜欢活着的心理并不是内心不明之迷惑呢？我怎么知道厌恶死亡的心理并不是不害怕死亡呢？我怎么知道人们害怕死亡就像弱孩迷失在他乡而不知回归故乡呢！\n\n>**丽之姬，艾封人之子也。晋国之始得之也，涕泣沾襟。及其至于王所，与王同匡床，食刍豢，而后悔其泣也。予恶乎知夫死者不悔其始之蕲生乎？梦饮酒者，旦而哭泣；梦哭泣者，旦而田猎。方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。且有大觉而后知此其大梦也，而愚者自以为觉，窃窃然知之。“君乎！牧乎！”固哉！丘也与女皆梦也，予谓女梦亦梦也。是其言也，其名为吊诡。万世之后而一遇大圣知其解者，是旦暮遇之也。**\n\n丽这个地方的美女丽姬，原是丽地一个名叫“艾”的城邑之长官的女儿；晋国的国君刚选她入宫时，她不知道这是好运气来了反而吓得哭成了泪人儿，等到她到了王宫之后，没想到竟然是与国君同吃同住，而且餐餐都是食草的及喂养的动物肉，于是就后悔当初的无知而暗自落泪。从这类事上难道我们还不明白“那些怕死的人岂不应该后悔当初怕死”的无知之心理吗！夜里梦到席间饮宴娱乐的梦，第二天往往会遇到伤心而哭泣的事；夜里梦到伤心而哭泣的梦，第二天往往会遇到驰骋田猎而心旷神怡的事。当时再梦中的时候，并不知道自己是在做梦。而且还在梦中将所梦达成了真实的事，只到醒了之后才知道那是虚幻的梦境而非真实。还有一种情况是，彻底恢复了道心之内明而后明白了夜里的梦境与白天的所作所为，它们都是非常虚幻的。然而我们未恢复道心的所有凡夫却自以为所捞到的财官名利皆是自己最聪明的结果，且暗自为自己的聪明而高兴，真不知道自己是人生的主人，还是被人生所放牧的犟牛，这可是多累劫以来所形成的根深蒂固的虚妄习气所致使的啊！孔子给你所讲的那些道理，皆都是梦话；就连我所说的“孔子给你所讲的那些道理都是梦话”的话，也同样是梦话啊！我刚才的说法，名字就叫作为了归于道用之实相而截断各种妄见的接引后学的吊诡之法。假若万世之后能够遇到一位恢复了道心的大圣人，那也是在这种接引之法的接引下，起到了早晨听了道而晚上也就明白了的作用而已。\n\n>**既使我与若辩矣，若胜我，我不若胜，若果是也？我果非也邪？我胜若，若不吾胜，我果是也？而果非也邪？其或是也？其或非也邪？其俱是也？其俱非也邪？我与若不能相知也。则人固受其黮暗，吾谁使正之？使同乎若者正之，既与若同矣，恶能正之？使同乎我者正之，既同乎我矣，恶能正之？使异乎我与若者正之，既异乎我与若矣，恶能正之？使同乎我与若者正之，既同乎我与若矣，恶能正之？然则我与若与人俱不能相知也，而待彼也邪？”**\n\n假使我与你再论辩，如果你胜了我，那么我就胜不了你，难道你就果真对了，我就果真错了吗？如果我胜了你，那么你就胜不了我，难道我就果真对了，你就果真错了吗？无论你认为是你果真对了还是我果真对了，岂不皆证明你的认为是出于意识心的了吗？如果你认为你与我的论辩都是对的，岂不证明你与我的论辩皆是出于意识的了吗？既然你与我之间不能论辩得明白，那么我人就会一直处于自己所证得的绝非道心内明的黑暗之中，那么我人的道心又怎能通过纠正自己的虚妄性而得到恢复呢？如果用与你的见地相同的人来纠正你的虚妄性，既然与你的见地相同，又怎能纠正得了呢？如果用与我的见地相同的人来纠正你的虚妄性，既然与我的见地相同，又怎能纠正得了你呢？如果用与你我的见地皆不相同的人来纠正你的虚妄性，既然与你我的见地皆不相同，又怎能纠正你的虚妄性呢？如果用与你我的见地皆相同的人来纠正你的虚妄性，既然与你我的意见皆相同，又怎能纠正你的虚妄性呢？然而反过来看我与你，也像世人一样的都是不明白自己的人，还必须有赖于吊诡之辩才能最终明白自己啊！\n\n>**化声之相待，若其不相待。和之以天倪，因之以曼衍，所以穷年也。“何谓和之以天倪？”曰：“是不是，然不然。是若果是也，则是之异乎不是也亦无辩；然若果然也，则然之异乎不然也亦无辩。忘年忘义，振于无竟，故寓诸无竟。”**\n\n怎能将极细微的起心动念控制在中和的程度呢？长梧子回答道：主观上所认定的对了，与道用上的客观事实一定是不相符的；主观上所认定的模样，与道用上的客观模样一定是相矛盾的。主观上所认定的对了，如果与道用上的客观事实是相符的，这个主观上所认定的也就达到非思维、言语所能辩的道用之实相的境界了。主观上所认定的模样，如果与道用上的客观模样是一致的，这个主观上所认定的模样也就达到非思维、言语所能辩的道用之实相的境界了。是与非纠缠在一起，如果那个审明辨知不起作用了，那就必须将起审明辨知之作用的那个极微细的起心动念时控制在中和的程度了，如果让那个极微的起心动念游衍自得，那就永远也不会恢复道心的明性而丧失审明辨知的作用了。当自己的心理上没有了时间及情义的概念时，才能像大鹏怒而飞一样地振作于不可预料的尘世生活环境中，于是也就能在各种各样的尘世生活中燕处超然了。\n\n>**罔两问景曰：“曩子行，今子止；曩子坐，今子起。何其无特操与？”景曰：“吾有待而然者邪？吾所待又有待而然者邪？吾待蛇蚹蜩翼邪？恶识所以然？恶识所以不然？”**\n\n影子的影子问影子说：“正当我刚刚跟着你走的时候，你却突然又停了下来；正当我刚刚跟着你坐下来的时候，你却突然又站了起来；你怎么就如此地没有独立的志操呢？”影子回答说：“我后面还有一个对应地管束我的东西在如此地做吗？我后面的那个对应地管束我的东西的后面还有一个对应地管束它的东西在如此地做吗？对应的我只是像蛇腹下的横鳞或蝉的翼一样地被动地随之而动而已吗？我怎么能知道我为什么会一会儿被这样？又怎么能知道为什么一会儿会不被这样呢？”\n\n>**昔者庄周梦为胡蝶，栩栩然胡蝶也。自喻适志与！不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与？胡蝶之梦为周与？周与胡蝶则必有分矣。此之谓物化。**\n\n过去庄周我曾经梦到自己变成了蝴蝶，活灵活现的一只真蝴蝶的样子，当时自己心里很明白自己就是这只蝴蝶而且非常惬意啊，已经完全不知道自己原本是庄周了；一会儿梦醒了，也就又恢复成了现实中的庄周我了。真不知道是庄周我在梦里化为了蝴蝶呢，还是蝴蝶在梦里化为了庄周我呢！对于庄周我与蝴蝶在梦中互化的现象而言，必然是在不同的心力下所产生的不同的物类及个体而已，这就是形身在心力的作用下从一个物类个体又转化为另一个物类个体的物化现象。\n","slug":"内篇（二）——齐物论","published":1,"updated":"2021-06-15T03:24:11.544Z","_id":"ckpapu7kx004nlcxu1o3b572u","layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><strong>南郭子綦隐机而坐，仰天而嘘，荅焉似丧其耦。颜成子游立侍乎前，曰：“何居乎？形固可使如槁木，而心固可使如死灰乎？今之隐机者，非昔之隐机者也？”子綦曰：“偃，不亦善乎，而问之也！今者吾丧我，汝知之乎？汝闻人籁而未闻地籁，汝闻地籁而不闻天籁夫！”</strong></p>\n</blockquote>\n<p>南郭子綦靠几静坐，仰面朝天缓缓地吐气，茫然若失，就像魂魄离开了躯体。南郭子綦的学生颜成子游见状马上前来侍候，问南郭子綦说：“您刚才是处于一种什么样的境界呢？一个人的肢体形貌在打坐时固然可以使它像枯槁之木一样毫无生气，难道一个人的心神在打坐时也可以使它像死灰一样毫无生气吗？您在今天所表现出来的安稳境界，跟以前的安稳境界绝对不一样。”南郭子綦回答说：“偃，你问此事，不是问得很好吗？今天我遗忘了形体之我，你知道这一点吗？你只听到人吹箫管发出的声音，而没听听风吹众窍所发出的声音，你只听到风吹众窍所发出的声音，而没有听到天地间万物的自鸣之声！”</p>\n<blockquote>\n<p><strong>子游曰：“敢问其方。”子綦曰：“夫大块噫气，其名为风。是唯无作，作则万窍怒呺。而独不闻之翏翏乎？山林之畏隹，大木百围之窍穴，似鼻，似口，似耳，似枅，似圈，似臼，似洼者，似污者。激者、謞者、叱者、吸者、叫者、譹者、宎者，咬者，前者唱于而随者唱喁，泠风则小和，飘风则大和，厉风济则众窍为虚。而独不见之调调之刁刁乎？”</strong></p>\n</blockquote>\n<p>子游说：“能不能问一问大地的声音与天的声音是怎么回事呢？”南郭子綦回答说：“那个地籁就是无边无际的造物之作用所发出的能量之气息啊，发出来之后就被叫作风。这种能量要么就是内在蕴含着不发出来，一旦发出来就会万窍怒号，难道你耳边就没有听到过这种‘呼呼’的风声吗！山林的险峻、大树周身的窍穴，有的形状像鼻子，有的形状像张开的嘴，有的形状像耳朵，有的形状”像扁长的发簪，有的形状像凸出来的圈筒，有的形状像凹下去的浅坑，有的浅一些，有的深一些；于是所发的声响就有的快促，有的像响箭，有的刺耳，有的发自往里吸，有的发自往外出，有的像嚎哭声，有的像狗叫，有的像悲哀声。能量流的运动原本就很舒缓动听，怪就怪哉随着各种物体所发出的众口乱叫而嘈杂了；当徐徐之风时万物就会轻微地唱和，当风大时万物就会大点儿地唱和，当劲风厉厉时反而所有能发响者皆欲发而无声了，难道你没有从风响的音调中听出来各种声响的发声原因、从风的响声上听出其后面的那个不发声的东西吗？”</p>\n<blockquote>\n<p><strong>子游曰：“地籁则众窍是已，人籁则比竹是已，敢问天籁。”子綦曰：“夫吹万不同，为而使其自己也。咸其自取，怒者其谁邪？”</strong></p>\n</blockquote>\n<p>子游又问：“大地的本意可以借助万物之窍所发出的唱和声中表达出来，人所的本意也可以从清悠、消沉、谐美的各种丝竹的或条畅或激昂的声中表达出来，那么天的本意是怎么表达出来的呢？”南郭子綦说：“所谓天籁的音响万变，而又能使其自行息止，这完全都是出于自然，有什么东西主使着它呢？”</p>\n<blockquote>\n<p><strong><font color=red>大知闲闲，小知閒閒。大言炎炎，小言詹詹。</font>其寐也魂交，其觉也形开。与接为构，日以心斗。缦者、窖者、密者。小恐惴惴，大恐缦缦。其发若机栝，其司是非之谓也；其留如诅盟，其守胜之谓也；其杀如秋冬，以言其日消也；其溺之所为之，不可使复之也；其厌也如缄，以言其老洫也；近死之心，莫使复阳也。喜怒哀乐，虑叹变慹[zhé]，姚佚启态。乐出虚，蒸成菌。日夜相代乎前而莫知其所萌。已乎，已乎！旦暮得此，其所由以生乎！</strong></p>\n</blockquote>\n<p>大智者看上去显得非常广博，小智者却十分琐细；高论者盛气凌人，争论者小辩不休。辩士睡时，精神与梦境交错在一起，醒后疲于与外物接触纠缠。每天与外物相接，其心有如经历了一场又一场的战斗一样疲惫。有的心机柔奸，有的善设陷阱，有的潜机不露。小的惧怕表现为忧惧不安，大的惧怕表现为惊恐失神。三灾八难的降临就像箭在弦上一样地随时而发，这全是由于行为人的心机所伺机行是非之行径所造成的；三灾八难的不降临也可以像发愿一样的通过履践其愿誓而消失，那就要看行为人是否践履自己的愿誓而坚持无思无为的行径来决定了。神情衰沮就像秋风冬雪肃杀万木一样无情，这就说明道心逍遥之本性的消亡是渐进的过程；如果行为人沉迷于自己之心机的经营里而不醒悟的话，也就很难再回到那个逍遥的本性去了。然而行为人对恢复道心的修行却厌恶得像自行封闭起来的蚕子一样的听不进去，这就说明行为人的执着意识的积习太严重了；像这样的几乎等于死亡的心，实在是没法使它再恢复生气。所谓的喜怒哀乐，都是认取了事物对自己所引发的感受而逐步形成多忧惧的意识，正在这个意识之执着的支配下才形成了轻狂而放任的或喜或怒或哀或乐的情绪了。喜怒哀乐发出来之后就过去了，接着而来的就是又孕育出了无明之烦恼，如此的一天到晚的不是喜乐就是烦恼的交替着出现在眼前，而从来不知道它们是怎么产生的。不可救药啊，不可救药！一天到晚地如此活着，三灾八难也就由此产生了啊！</p>\n<blockquote>\n<p><strong>非彼无我，非我无所取。是亦近矣，而不知其所为使。若有真宰，而特不得其眹。可行己信，而不见其形，有情而无形。百骸、九窍、六藏、赅而存焉，吾谁与为亲？汝皆说之乎？其有私焉？如是皆有为臣妾乎？其臣妾不足以相治乎？其递相为君臣乎？其有真君存焉！如求得其情与不得，无益损乎其真。一受其成形，不亡以待尽。<font color=red>与物相刃相靡，其行尽如驰而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？</font></strong></p>\n</blockquote>\n<p><em>如果没有了我之内外的任何对立面的观念也就没有我的观念了，如果没有了我的观念也就没有了博取之心了</em>，如此也就基本上接近于那个道心的行径了，然而却不知道是什么东西在支配着这个道心的行径。好像其中有一个迫使万物循势而动的主宰在，然而偏偏找不到那个主宰的迹象在什么地方，当你恢复了道心之后就会彻底明了那个迫使万物循势而动的主宰了，但它却又没有一个具体的形状可见，它仅仅是道心的广大无缘之悲性而没有具体形状而已。一个人身上有百骸、九窍、六脏，当这些脏器都完备了之后才能决定一个人的生存，那么你认为哪一个脏器最重要而倍加爱护呢？还不是都喜欢而都倍加爱护吗？这个问题的背后岂不牵扯到一个“私我”的观念了吗？如果有一个“私我”之观念的话，那么各脏器岂不就成了分别为“私我”提供专职服务的臣下与妻妾了吗？这种势必缺乏协调性的臣下与妻妾岂不就不足以担当全面治理整个机体的重任了吗？难道它们是逐个轮流着担当君的职责而协调各位臣妾的工作吗？这就证明里面有一个真正的主宰在后面起着决定作用吗？如果实证到了那个广大无缘之慈悲性的道心原来是没有具体形状可得的时候，那时候就会明白这个真宰的作用无论怎么做都既不会益于也不会损于那个真宰者的不生不灭、不增不减、不垢不净性了。然而自从那个人人都有的真主秉承了执着之意识以投胎成人之后，还没有到该死的寿数时就在哪里等着寿尽的一天了，这是因为内外界事物所诱发的爱、恶、欲、的心行在相争斗以至于相消耗的缘故；<font color=red>明明知道生命的寿终就像飞驰一样，但却不知道如何止住这种迈向寿终的步伐，对于自许聪明的人们来说难道不是一种悲哀吗！只知道一辈子地役使自己的心身去赴爱、恶、欲的劳役但对于恢复道心却毫无一点儿进展，整天精神不振地疲于劳役但却不知道究竟是为了什么，对于自许聪明的人们来说难道不是一种痛心吗！即使能够达到人们所说的千万岁的长生不老，对于道心的恢复又有什么益处呢？即使其形体逐渐衰败枯萎，也只是其执着心使其具有了这种变化而已，对于那个真宰的不生不死、不增不减、不垢不净性而言怎能不是最大的痛心呢！人生在世，本来就如此糊涂吗？</font></p>\n<blockquote>\n<p><strong>夫随其成心而师之，谁独且无师乎？<font color=red>奚必知代而心自取者有之？</font>愚者与有焉！未成乎心而有是非，是今日适越而昔至也。是以无有为有。无有为有，虽有神禹且不能知，吾独且奈何哉！</strong></p>\n</blockquote>\n<p>还是只有我糊涂，而别人也有不糊涂的呢？<font color=red>世人如果都以自己的偏见作为判别是非的标准，那么谁没有一个标准呢？</font>何必是懂得事物更替而心有见地的人才有是非标准呢？即使愚蠢的人也是有的。在未有成见存于心中之前已经就因自己的好恶之感受而得出对与错的心得了，这个心得之现象的得出就像今天刚到了越国而实际上原本就在越国一样地早就待在那个地方了。所以才从道心里凭空产生出心得乃至执着了。对于通过作意而产生出神奇的事物来的行为而言，即使有着禹王那样的神通，也不能有一点儿故意去知道的心在，客观世界的任何事物又怎能奈何于超然物外的那个道心之吾的神奇作用呢！</p>\n<blockquote>\n<p><strong>夫言非吹也，言者有言。其所言者特未定也。果有言邪？其未尝有言邪？其以为异于鷇音，亦有辩乎？其无辩乎？道恶乎隐而有真伪？言恶乎隐而有是非？道恶乎往而不存？言恶乎存而不可？<font color=red>道隐于小成，言隐于荣华</font>。故有儒墨之是非，<font color=red>以是其所非而非其所是。欲是其所非而非其所是，则莫若以明。</font></strong></p>\n</blockquote>\n<p>言论出于机心，与无心而吹的“天籁”是不同的。发言者知持一端，他们的话并不能作为衡量是非的标准。为了表述某事物果真就需要言辞吗？人们最初始时的思想交流并没有使用言辞啊！人们的言辞之所以能听得懂而雏鸟的叫声却听不懂，这个能听懂的背后是有一个思辨的审明作用在呢？还是没有思辨的审明作用在呢？那个大道为什么未被真正地认识到而产生了见解上的真与假呢？言辞所表述的意义为什么未被真正地认识到而产生了判断上的是与非呢？那个大道为什么必须去参悟才能实证到它而不能通过想象去找到它呢？言辞所表述的意义为什么必须通过思辨才能听懂而不能一听就能确定其真意呢？<font color=red>原因就在于那个大道被不深刻、不全面的小见解给遮蔽住了，就在于言辞所表述的意义被言辞本身的巧妙之比喻或夸张给遮蔽住了。</font>所以才产生了儒墨两家之学术思想的我对你错的争鸣，<font color=red>世人都是用自己所认定的正确去评判人家的不正确，都是用自己所认定的人家的不正确来宣扬自己的正确。与其想用自己所认为的正确去推定人家的不正确，与其想用人家的不正确来证明自己所认为的正确，那就不如静下心来认认真真地修身以达到内明为好。</font></p>\n<blockquote>\n<p><strong>物无非彼，物无非是。自彼则不见，自知则知之。故曰：彼出于是，是亦因彼。彼是方生之说也。虽然，方生方死，方死方生；方可方不可，方不可方可；因是因非，因非因是。是以圣人不由而照之于天，亦因是也。是亦彼也，彼亦是也。彼亦一是非，此亦一是非，果且有彼是乎哉？果且无彼是乎哉？彼是莫得其偶，谓之道枢。枢始得其环中，以应无穷。是亦一无穷，非亦一无穷也。故曰：莫若以明。</strong></p>\n</blockquote>\n<p>天地万物在道体上不存在你我它的分别，天地万物在道体上也不存在你对及它错的差别。如果从万物存在的现象去看就不会认识到万物是道体之妙用的那个本质，只有从内明的大智慧上去看才能认识到万物同是道体之妙用的那个本质。所以说人们之所以会有万物的个体皆有差异以及你对而它错的分别心乃是从没有分别心的物我同胞的实相中产生的，于是那个没有分别心的物我同胞之实相的提法也就对应于人们的分别心而提出来了。人们之所以会产生分别心，乃是由于当下一念的喜爱心所造成的虽然都是因为当下一念的喜爱心所造成，但当下一念的喜爱心刚刚生起便又马上消失了，前念刚刚消失便又马上生起了后念的喜爱心；于是人们的分别心刚刚形成执着又紧接着遇到新的事物而须要去分别了，于是对新事物的分别心又形成另一个新的执著心了；因为先前的执着心而产生了对新遇到之事物的不认同，对新遇到之事物的不认同经过喜爱心的分别又形成了新的另一个执着。所以每一位恢复了道心的圣人无不鉴于当下之一念的迁流不断而不由得时刻注意着当下一念的似起未起之时，也就是因为这个道理啊！在先前的那个执着的作用下产生了新的另一个执着，新的另一个执着又变成了产生新执着的旧执着。先前的执着是喜爱心所认为的对与错而形成的，新执着也是喜爱心所认为的对与错而形成的。果真存在着执着心所认为的那个正确吗，果真存在着执着心所认为的那个不正确吗？无论是执着心所认为的正确还是所认为的不正确皆是失去了道心中庸之用的结果，这就是所说的形成执着的关键之所在。正是由于形成执着的整个关键作用发生在旧执着与新执着的环环相产生的现象中，于是无始劫以来所形成的无穷的执着也就变成了遮蔽道心的“五蕴”了。道心的中庸之大用是无穷无尽的，意识心的执着之妄用也是无穷无尽的。所以说要想了知道心的全体之大用还是静下心来认认真真地修身以达到内明为好。</p>\n<blockquote>\n<p><strong>以指喻指之非指，不若以非指喻指之非指也；以马喻马之非马，不若以非马喻马之非马也。天地一指也，万物一马也。</strong></p>\n</blockquote>\n<p>用自己的手指来说明人家的手指不是手指，不如不用自己的手指来说明人家的手指不是手指为好；用马来说明白马不是马，不如不用马来说明白马不是马为好。从道通为一的观点看，天地与一指，万物与一马，都是没有区别的。</p>\n<blockquote>\n<p><strong>可乎可，不可乎不可。道行之而成，物谓之而然。恶乎然？然于然。恶乎不然？不然于不然。物固有所然，物固有所可。无物不然，无物不可。故为是举莛与楹，厉与西施，恢诡谲怪，道通为一。</strong></p>\n</blockquote>\n<p>人家认为可，我也跟着认为可；人家认为不可，我也跟着认为不可。于是那个道的生发万物的妙用也就在因缘聚合而生的条件下形成了，于是万物也就在遇到了所对应的因缘聚合的条件下而形成了各具特色的形物了。有的万物之个体能适应因缘聚合而生的各种不同的环境条件而生，有的万物之个体不能适应因缘聚合而生的各种不同的环境条件而只能待其适应的环境条件时而生；所以有的万物之个体也就顺势而形成了具有新特色的形体了，有的万物之个体则未能顺势形成新特色的形体而是保持了始祖的面目乃至被淘汰。为什么有的万物之个体能顺势而形成具有新特色的形体呢？那是因为它具有能顺势而生的适应性所以才形成了具有新特色的形体。为什么有的万物之个体不能顺势而形成具有新特色的形体呢？那是因为它不具有能顺势而生的适应性所以才不能形成具有新特色的形体。为什么有的万物之个体能具有顺势而生的适应性呢？那是因为它具有适应因缘聚合而生的各种不同环境条件的天性。为什么有的万物之个体不具有顺势而生的适应性呢？那是因为它不具有适应因缘聚合而生的各种不同环境条件的天性。万物原本就具有顺势而形成的具有新特色的适应性，万物原本就具有适应因缘聚合而生的各种不同环境的天性。没有哪一个万物之个体不是因为这种适应性而生，也没有哪一个万物之个体不是因为这种天性而生。所以才产生了诸如轻空的莚秆或坚实的楹柱之类的各种不同物类，才产生了诸如丑陋或美丽之类的各种不同形色，才产生了诸如中正、阴险、诡秘、古怪之类的各种不同性格，当你通达了那个道心的大用后就会明白它们都是无二无别的实相了。</p>\n<blockquote>\n<p><strong>其分也，成也；其成也，毁也。凡物无成与毁，复通为一。唯达者知通为一，为是不用而寓诸庸。庸也者，用也；用也者，通也；通也者，得也；适得而几矣。因是已。已而不知其然，谓之道。劳神明为一而不知其同也，谓之“朝三”。何谓“朝三”？狙公赋芧，曰：“朝三而暮四。”众狙皆怒。曰：“然则朝四而暮三。”众狙皆悦。名实未亏而喜怒为用，亦因是也。是以圣人和之以是非而休乎天钧，是之谓两行。</strong></p>\n</blockquote>\n<p>万物之生命的死亡与分解的过程，就是又形成新的生命的过程；形成新的生命的过程，就是其生命的下一次死亡与分解的过程。万物根本就没有什么生与死的截然不同，或生活死的现象也只是同时发生着的道心之大用而已；正是由于实证到了道境界的人彻底明白了或生活死的现象都是同时发生着的，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。当一切行为都隐含在恰到好处的无之用中了的时候，才能遵循道心的全体之大用；当能遵循道心的全体之大用的时候，才能通达一切现象皆是无二无别的实相；当通达了一切现象皆是无二无别之实相的时候，才能驾驭道心的全体之大用；当驾驭了道心的全体之大用的时候，也就差不多恢复了那个道心了。遵循这个过程也就恢复那个道心了。恢复了那个道心也就凡事只是无为地去做而不去问为什么了，这才叫作真正的道境界。被喜怒爱恶欲所驱使的心意之妄动与其内在的思辨觉知之作用是一个本原，然而却不知道此二者都是一个本原，这就叫作只知朝四而不知暮三的猴子意识。为什么叫作只知朝四而不知暮三的猴子意识呢？管理猴子的人给猴子喂食橡实时说：“早晨喂三个晚上喂四个。”众猴子闻之则大怒；管理猴子的人又说：“既然大家都不同意，那就还按早晨喂四个晚上喂三个的老法子。”众猴子们则闻之则大喜。名字之类的名相与名相所代表的那个实物的本性原本就没有什么不同，然而在人们的喜怒哀乐恶欲的心理作用下却变成了各种不同的理解，这就是因为那个只知朝四而不知暮三的意识在作怪啊。所以恢复了道心的圣人们既能在外行上将各种矛盾对立的意识调节控制在中和的状态，又能在内行上安闲自在于道心大用之遍行的无二无别的精神境界中，这就叫作一个道心境界而同时有着内外两种行径的圣行。</p>\n<blockquote>\n<p><strong>古之人，其知有所至矣。恶乎至？有以为未始有物者，至矣，尽矣，不可以加矣！其次以为有物矣，而未始有封也。其次以为有封焉，而未始有是非也。是非之彰也，道之所以亏也。道之所以亏，爱之所以成。果且有成与亏乎哉？果且无成与亏乎哉？有成与亏，故昭氏之鼓琴也；无成与亏，故昭氏之不鼓琴也。昭文之鼓琴也，师旷之枝策也，惠子之据梧也，三者之知几乎！皆其盛者也，故载之末年。唯其好之也，以异于彼，其好之也，欲以明之。彼非所明而明之，故以坚白之昧终。而其子又以文之纶终，终身无成。若是而可谓成乎，虽我亦成也；若是而不可谓成乎，物与我无成也。是故滑疑之耀，圣人之所图也。为是不用而寓诸庸，此之谓“以明”。</strong></p>\n</blockquote>\n<p>古时候的人，他们所具足的大智慧任何地方都能无所不至啊！都是打倒了什么样的无所不至呢？凡所做出的任何行为从根本上就没有做事之动机的存在，就是具足了无所不至的大智慧的境界了，当具足了这种无所不至的大智慧后，就再也不会被喜怒爱恶欲的习气所污染了。差一点的境界则仅仅才有了做事的动机，但却没有达到“这是我的，那是你的”的私我意识；再差一点的境界也只是有了“这是我的，那是你的”的私我意识，但却没有形成以我见而划分对错是非的唯我意识。后来我人便有了对错是非之心而且越来越严重了，于是道心也就亏失了；道心之所以亏失了，完全是心里的那个喜欢之所用所导致的。难道那个道心果真会圆满也会亏失吗，还是果真不会圆满也不会亏失呢？那个道心确实会圆满也会亏失，所以当大琴师昭氏鼓琴时便能激荡起人们心神的喜悦而造成道心之静的亏失了啊；那个道心确实不会圆满也不会亏失，所以当大琴师昭氏不鼓琴时人们的心神便恢复了道心之静的常态了。大琴师昭文的鼓琴之技艺，大乐师师旷持策以击乐器，大逻辑家惠子的诡辩之造诣，就这三个人对于各自爱好之事所达到的极其微妙的程度而言，都是各自领域里的顶尖高手，所以才能千古流传下来。由此三人在琴、诊、论上有着超乎寻常的爱好心，所以才使得在琴、诊、论的成就上大大超出了其他方面的技能；他们之所以爱好其所好的东西，其目的就是为了彻底研究明白所爱好之东西的内在机制。所爱好之东西的内在机制本来就不是靠研究所能研究明白的事反而执意地要去研究明白它，所以才犯了坚石非坚、白马非马之逻辑式的错误以至于愚昧终生。像他们那样地达到了极其微妙的程度就算是真正的最高成就了吗？那么我们每一个意识心用事的人也就可以说是成道的圣人了。像他们那样地达到了极其微妙的程度不算是真正的最高成就吗？那么万物与我人也就不会成为个别的个体了。所以，只有这样地将那个大道的玄机深究到大生疑惑的境地才能不知不觉地过渡到恍然大悟的境界，这正是圣人所希望的啊！只有达到了恍然大悟的境界才能没有是非对错之意识而一切行为都隐含在道心的无为之大用中，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。</p>\n<blockquote>\n<p><strong>今且有言于此，不知其与是类乎？其与是不类乎？类与不类，相与为类，则与彼无以异矣。虽然，请尝言之：有始也者，有未始有始也者，有未始有夫未始有始也者；有有也者，有无也者，有未始有无也者，有未始有夫未始有无也者。俄而有无矣，而未知有无之果孰有孰无也。今我则已有有谓矣，而未知吾所谓之其果有谓乎？其果无谓乎？</strong></p>\n</blockquote>\n<p>刚才已将“是非之彰也，道之所以亏也”的道理说过了，那么它与“为是不用而寓诸庸”的道理是一回事呢，还是与“为是不用而寓诸庸”的道理不是一回事呢？就以人们所认为的是一回事与不是一回事的那个认识而言，认识本身的那个思维所产生的心行就是同一回事，如此也就理解“是非之彰也，道之所以亏也”的道理与“为是不用而寓诸庸”的道理没有什么不同了。尽管如此，也需要试着将其道理说明如下。有的心行是从意识中突然产生的，有的心行是从末那识中迁流过来的，有的心行是从藏识中迁流过来的。来源于意识中的心行有的正存在着，有的已经过去了，来源于末那识的心行有的出于旧有的执着、有的出于最近才有的心得，来源于藏识中的心行乃是既没有形成执着，又没有形成心得的无为之举。心行就是这样地一会儿是从意识中产生出来，一会儿是从藏识中迁流出来，却不知道这两张心行的现象，它是不是真实的存在呢？现在用哪个会思会想的意识心反思一下自己就会发现所谓的“我”是不真实的假象了，而那个不会思不会想的道心之吾则是真实存在的了。道心之吾果真是真实的存在啊！意识心之假我果真是不真实的存在啊！</p>\n<blockquote>\n<p><strong>夫天下莫大于秋毫之末，而太山为小；莫寿乎殇子，而彭祖为夭。天地与我并生，而万物与我为一。既已为一矣，且得有言乎？既已谓之一矣，且得无言乎？一与言为二，二与一为三。自此以往，巧历不能得，而况其凡乎！故自无适有，以至于三，而况自有适有乎！无适焉，因是已！</strong></p>\n</blockquote>\n<p>整个的天下在实相上不会比秋毫的尖头大，相形之下那有形的大山却是渺小得很；我们的寿命在实相上不会比夭折的小儿寿长，相形之下那八百寿的彭祖却是夭亡的小儿；这就证明天地与我们都是道心之大用的妙用所生，万物与我们都是一个本体而没有人我万物之别。既然天地人我万物都是一个本体的“一”而没有差别，为什么会有天地人我万物之不同的认识存在呢？既然认为它们都是一个一个的个体而有差别，又怎会没有天地人我万物之不同的认识存在呢？道之实相用言辞说出来就变成第二重的言辞之比喻象了，将道的比喻象再用言辞说出来就变成第三重的意识之妄见象了。自从道之实相变成言辞之比喻象再变成意识之妄见象以来所代代递增的妄见象，即使技术最高超的人来推算也不能计算清楚它，更何况还有以后所必然会形成的意识之妄见象呢！从道的不可言说的实相上就能变成言辞之比喻象以至于再变成意识之妄见象，更何况将意识之妄见象再变成妄见的言辞之比喻象呢！由此而知，意识之妄见再变成意识之妄见的沿流永远没有一个尽头，原因就在于妄见的沿流层出不穷。</p>\n<blockquote>\n<p><strong>夫道未始有封，言未始有常，为是而有畛也。请言其畛：有左有右，有伦有义，有分有辩，有竞有争，此之谓八德。六合之外，圣人存而不论；六合之内，圣人论而不议；春秋经世先王之志，圣人议而不辩。</strong></p>\n</blockquote>\n<p>对于那个道心的大用而言在最初并没有“这是我的，那是你的”的私我之意识，对于言辞而言却从一开始便不存在永久不变，正是因为意识之妄见的沿流永远没有一个尽头而从道心之大用中形成了人我万物的各个个体及各种思想意识了。请让我说说这些界限：有上下、尊卑之序，有亲疏之理、贵贱之仪，有剖析万物、分别彼此，有角逐胜负、对辩是非，这就是儒、墨等派所争辩的八种界限。对于宇宙之外的不可知，圣人只是保留其说而不加以讲解；对于宇宙之内的事物，圣人只是讲解而不加以评说；对于以天道中正为喻的《春秋》所记载的经纶天下的先王的济世之道，圣人只是评说而不加以争辩。</p>\n<blockquote>\n<p><strong>故分也者，有不分也；辩也者，有不辩也。曰：“何也？”“圣人怀之，众人辩之以相示也。故曰：辩也者，有不见也。”夫大道不称，大辩不言，大仁不仁，大廉不嗛，大勇不忮。道昭而不道，言辩而不及，仁常而不成，廉清而不信，勇忮而不成。五者圆而几向方矣！故知止其所不知，至矣。孰知不言之辩，不道之道？若有能知，此之谓天府。注焉而不满，酌焉而不竭，而不知其所由来，此之谓葆光。</strong></p>\n</blockquote>\n<p>由圣人的做法可知，既然有了是非对错的认识之分别，这本身就说明道心原本就是一而没有认识之分别；既然有了是非对错的争辩，这本身就说明道心原本就是一而没有争辩之实质。这证明了什么呢？证明了圣人是思虑于心，而众人是妄议于言为了将这个道理开示出来。所以告诉大家，“之所以存在着争辩的现象，乃是还没有达到内明的缘故。”真正的大道没有任何名相之称谓，真正的大辩没有任何说道之言辞，真正的大仁没有任何仁慈之目的，真正的大廉是不自需锋芒的，大勇是不自逞血气之勇的。如果还有有道的样子显现出来则恰恰证明没有道，言语过于辩察，就不能达到真理，仁者滞于一偏之爱就不能周遍，过分表示廉洁就不够真实，自逞血气之勇就不成器大勇。不称、不言、不仁、不嗛、不忮这五个方面，本来是圆通混成的；如果涉及昭、辩、常、清、忮等形迹，就变成四方之物了。所以道心之知的明了作用若能停留在只管去做而不去动其心的境界上，那么修心的境界也就到家了。怎能又去管它什么没有言辞才是真正的论辩，不认为有道才是真正的有道呢？如果保持住了那个能知而又不去动心的境界，也就叫作修心阶段的最高成就了。只有达到了像大海一样地诸如多少也不会满溢，舀取多少也不会枯竭，而且也不去思考为什么会这样的境界时，这才叫作包藏光亮而不露。</p>\n<blockquote>\n<p><strong>故昔者尧问于舜曰：“吾欲伐宗脍、胥、敖，南面而不释然。其故何也？”舜曰：“夫三子者，犹存乎蓬艾之间。若不释然何哉！昔者十日并出，万物皆照，而况德之进乎日者乎！”</strong></p>\n</blockquote>\n<p>在过去的时候尧帝曾考问于大位的接班人舜帝说：“我真想消灭宗、脍、胥这三个屡犯边庭的小国，但是朕想到天子的责任又放不下对他们的牵挂，这个原因是什么呢？”舜帝回答说：“这三个小国的国君，竟然还能够在偏小卑微之地生存下来也真是不容易，你感到心情不怡悦。这说明了什么呢？过去曾有十个太阳同时普照大地，万物皆能普受恩惠，更何况您的道德境界胜过十个太阳的普照呢？”</p>\n<blockquote>\n<p><strong>啮缺问乎王倪曰：“子知物之所同是乎？”曰：“吾恶乎知之！”“子知子之所不知邪？”曰：“吾恶乎知之！”“然则物无知邪？”曰：“吾恶乎知之！虽然，尝试言之：庸讵知吾所谓知之非不知邪？庸讵知吾所谓不知之非知邪？且吾尝试问乎女：民湿寝则腰疾偏死，鳅然乎哉？木处则惴栗恂惧，猨猴然乎哉？三者孰知正处？民食刍豢，麋鹿食荐，蝍蛆甘带，鸱鸦耆鼠，四者孰知正味？猨猵狙以为雌，麋与鹿交，鳅与鱼游。毛嫱丽姬，人之所美也；鱼见之深入，鸟见之高飞，麋鹿见之决骤，四者孰知天下之正色哉？自我观之，仁义之端，是非之涂，樊然淆乱，吾恶能知其辩！”啮缺曰：“子不利害，则至人固不知利害乎？”王倪曰：“至人神矣！大泽焚而不能热，河汉冱而不能寒，疾雷破山、飘风振海而不能惊。若然者，乘云气，骑日月，而游乎四海之外，死生无变于己，而况利害之端乎！”</strong></p>\n</blockquote>\n<p>啮缺问于王倪说：“先生知道万物所共同的那个根本吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺又问道：“先生知道您那个为什么不去知道吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺进一步问道：“那么万物是否也都是一样的什么也不去知道吗？”王倪回答道：道心之吾为什么要去知道呢！尽管如此，也需要试着将其道理说明。怎么能知道我所说的道心的大用止于“知”，也就是道心之吾的那个“知”并不是不能知道啊？道心的大用止于“知”，则正是道心之吾的那个“知”明明就在却不去知啊！现在吾且试着问于你：我们如果在潮湿的地方安歇就会腰痛乃至偏瘫，泥鳅会这样吗？我们如果在树木上安歇就会担心掉下来而心惊恐惧，猿猴会这样吗？对于人、泥鳅、猿猴这三种动物的安歇方式而言哪一种是正确的呢？我人喜欢食食草的及喂养的动物，麋鹿喜欢食草类植物，蜈蚣喜欢食蛇之类的爬行动物，鹞鹰喜欢食鼠类动物，对于人、麋鹿、蜈蚣、鹞鹰这四种动物的口味而言哪一种是正确的呢？濑猴与猴子互相吸引，狍子与鹿互相倾情，泥鳅与鱼互相交欢。毛嫱与丽姬，在我们眼里都是最具吸引力的大美女；然而鱼见了她们却恶心地躲入深水中，飞鸟见到她们却鄙视地高飞而去，麋鹿见到她们却厌恶地急速地跑走。对于猿狙、麋鹿、鳅鱼、人这四种动物的审美观点而言哪一种是正确的呢？从我们的意识心上分析，讲究仁义的开始，便是是非涂抹道心的开始，像这样互相缠绕得杂乱的意识行为，道心之吾又怎能分清仁义与是非的观念是谁对谁错呢！啮缺又问道：“看来现实您是不知道凡事对自己的利与害了，难道心身行为最完美的人也是原本就不知道凡事对自己的利与害吗？”王倪回答道：“心身行为最完美的人可就神通广大了，即使四大海都变得干涸而燃烧起来他也不会感到热，即使宇宙都冻得成冰了他也不会感到冷，即使霹雳能击破山岳、狂风能掀起海啸也不会吓着他。如果达到了这种境界的话，就能够乘云气、骑日月而逍遥地游乎环宇之内了；即使人们所认为的死生也不会改变自己的道心之大用了，更何况是人们所认为的利与害的小事呢！”</p>\n<blockquote>\n<p><strong>瞿鹊子问乎长梧子曰：“吾闻诸夫子：圣人不从事于务，不就利，不违害，不喜求，不缘道，无谓有谓，有谓无谓，而游乎尘垢之外。夫子以为孟浪之言，而我以为妙道之行也。吾子以为奚若？”</strong></p>\n</blockquote>\n<p>瞿鹊子问于长梧子说：我听孔子说：“圣人在对待立身处世之心身行为的培养上没有必须要如何如何的想法，既没有获取利益之心，也没有躲避害处之心，既没有必得的执着之心，也没有等待外缘具备时再去做的懒散之心，只有心里真正达到了无所谓时才算是有了道心的成就了，若是心里有一点儿所谓的影子那就还没有真正达到道心的境界，如此才能使自己的心行既在世俗中生活又不受各种世俗之心对道心的污染。”先生您却认为这是好高骛远之言，而我却认为是最好的修道宗旨，作为得道的先生您认为咱俩的看法谁对呢？</p>\n<blockquote>\n<p><strong>长梧子曰：“是黄帝之所听荧也，而丘也何足以知之！且女亦大早计，见卵而求时夜，见弹而求鸮炙。予尝为女妄言之，女以妄听之。奚旁日月，挟宇宙，为其脗合，置其滑涽，以隶相尊？众人役役，圣人愚芚，参万岁而一成纯。万物尽然，而以是相蕴。予恶乎知说生之非惑邪！予恶乎知恶死之非弱丧而不知归者邪！</strong></p>\n</blockquote>\n<p>长梧子回答说：孔子所说的境界，恰恰是轩辕皇帝毫无意识心地任由那个道心的作用慢慢地明亮后的境界，单凭听了孔丘所说的几句道理又何足以真正地知道那个境界呢！而且你也太过于听风即是雨了，似乎见到鸡蛋就得到了会即时报更的公鸡了，见到弹弓就得到了香喷喷的烤鸮了。我试着为你妄言之，你也妄听之。如何才能与日月为邻，驾驭宇宙呢，唯一的办法就是必须完全做到与孔子所说的道理相吻合，对当下的心念不管是明白地知道还是糊里糊涂都不去管它，这才能符合孔子所说的道理。不要像众人役使自己的身心为自己的欲望服劳役那样地往外求，要像圣人傻傻地待在葆光的境界里那样，如此才能参究透一万年也只不过纯属当下的一念所变现而已；万物也都是如此，也都是以这个当下一念的作用在积蓄着生命的能量。我怎么知道喜欢活着的心理并不是内心不明之迷惑呢？我怎么知道厌恶死亡的心理并不是不害怕死亡呢？我怎么知道人们害怕死亡就像弱孩迷失在他乡而不知回归故乡呢！</p>\n<blockquote>\n<p><strong>丽之姬，艾封人之子也。晋国之始得之也，涕泣沾襟。及其至于王所，与王同匡床，食刍豢，而后悔其泣也。予恶乎知夫死者不悔其始之蕲生乎？梦饮酒者，旦而哭泣；梦哭泣者，旦而田猎。方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。且有大觉而后知此其大梦也，而愚者自以为觉，窃窃然知之。“君乎！牧乎！”固哉！丘也与女皆梦也，予谓女梦亦梦也。是其言也，其名为吊诡。万世之后而一遇大圣知其解者，是旦暮遇之也。</strong></p>\n</blockquote>\n<p>丽这个地方的美女丽姬，原是丽地一个名叫“艾”的城邑之长官的女儿；晋国的国君刚选她入宫时，她不知道这是好运气来了反而吓得哭成了泪人儿，等到她到了王宫之后，没想到竟然是与国君同吃同住，而且餐餐都是食草的及喂养的动物肉，于是就后悔当初的无知而暗自落泪。从这类事上难道我们还不明白“那些怕死的人岂不应该后悔当初怕死”的无知之心理吗！夜里梦到席间饮宴娱乐的梦，第二天往往会遇到伤心而哭泣的事；夜里梦到伤心而哭泣的梦，第二天往往会遇到驰骋田猎而心旷神怡的事。当时再梦中的时候，并不知道自己是在做梦。而且还在梦中将所梦达成了真实的事，只到醒了之后才知道那是虚幻的梦境而非真实。还有一种情况是，彻底恢复了道心之内明而后明白了夜里的梦境与白天的所作所为，它们都是非常虚幻的。然而我们未恢复道心的所有凡夫却自以为所捞到的财官名利皆是自己最聪明的结果，且暗自为自己的聪明而高兴，真不知道自己是人生的主人，还是被人生所放牧的犟牛，这可是多累劫以来所形成的根深蒂固的虚妄习气所致使的啊！孔子给你所讲的那些道理，皆都是梦话；就连我所说的“孔子给你所讲的那些道理都是梦话”的话，也同样是梦话啊！我刚才的说法，名字就叫作为了归于道用之实相而截断各种妄见的接引后学的吊诡之法。假若万世之后能够遇到一位恢复了道心的大圣人，那也是在这种接引之法的接引下，起到了早晨听了道而晚上也就明白了的作用而已。</p>\n<blockquote>\n<p><strong>既使我与若辩矣，若胜我，我不若胜，若果是也？我果非也邪？我胜若，若不吾胜，我果是也？而果非也邪？其或是也？其或非也邪？其俱是也？其俱非也邪？我与若不能相知也。则人固受其黮暗，吾谁使正之？使同乎若者正之，既与若同矣，恶能正之？使同乎我者正之，既同乎我矣，恶能正之？使异乎我与若者正之，既异乎我与若矣，恶能正之？使同乎我与若者正之，既同乎我与若矣，恶能正之？然则我与若与人俱不能相知也，而待彼也邪？”</strong></p>\n</blockquote>\n<p>假使我与你再论辩，如果你胜了我，那么我就胜不了你，难道你就果真对了，我就果真错了吗？如果我胜了你，那么你就胜不了我，难道我就果真对了，你就果真错了吗？无论你认为是你果真对了还是我果真对了，岂不皆证明你的认为是出于意识心的了吗？如果你认为你与我的论辩都是对的，岂不证明你与我的论辩皆是出于意识的了吗？既然你与我之间不能论辩得明白，那么我人就会一直处于自己所证得的绝非道心内明的黑暗之中，那么我人的道心又怎能通过纠正自己的虚妄性而得到恢复呢？如果用与你的见地相同的人来纠正你的虚妄性，既然与你的见地相同，又怎能纠正得了呢？如果用与我的见地相同的人来纠正你的虚妄性，既然与我的见地相同，又怎能纠正得了你呢？如果用与你我的见地皆不相同的人来纠正你的虚妄性，既然与你我的见地皆不相同，又怎能纠正你的虚妄性呢？如果用与你我的见地皆相同的人来纠正你的虚妄性，既然与你我的意见皆相同，又怎能纠正你的虚妄性呢？然而反过来看我与你，也像世人一样的都是不明白自己的人，还必须有赖于吊诡之辩才能最终明白自己啊！</p>\n<blockquote>\n<p><strong>化声之相待，若其不相待。和之以天倪，因之以曼衍，所以穷年也。“何谓和之以天倪？”曰：“是不是，然不然。是若果是也，则是之异乎不是也亦无辩；然若果然也，则然之异乎不然也亦无辩。忘年忘义，振于无竟，故寓诸无竟。”</strong></p>\n</blockquote>\n<p>怎能将极细微的起心动念控制在中和的程度呢？长梧子回答道：主观上所认定的对了，与道用上的客观事实一定是不相符的；主观上所认定的模样，与道用上的客观模样一定是相矛盾的。主观上所认定的对了，如果与道用上的客观事实是相符的，这个主观上所认定的也就达到非思维、言语所能辩的道用之实相的境界了。主观上所认定的模样，如果与道用上的客观模样是一致的，这个主观上所认定的模样也就达到非思维、言语所能辩的道用之实相的境界了。是与非纠缠在一起，如果那个审明辨知不起作用了，那就必须将起审明辨知之作用的那个极微细的起心动念时控制在中和的程度了，如果让那个极微的起心动念游衍自得，那就永远也不会恢复道心的明性而丧失审明辨知的作用了。当自己的心理上没有了时间及情义的概念时，才能像大鹏怒而飞一样地振作于不可预料的尘世生活环境中，于是也就能在各种各样的尘世生活中燕处超然了。</p>\n<blockquote>\n<p><strong>罔两问景曰：“曩子行，今子止；曩子坐，今子起。何其无特操与？”景曰：“吾有待而然者邪？吾所待又有待而然者邪？吾待蛇蚹蜩翼邪？恶识所以然？恶识所以不然？”</strong></p>\n</blockquote>\n<p>影子的影子问影子说：“正当我刚刚跟着你走的时候，你却突然又停了下来；正当我刚刚跟着你坐下来的时候，你却突然又站了起来；你怎么就如此地没有独立的志操呢？”影子回答说：“我后面还有一个对应地管束我的东西在如此地做吗？我后面的那个对应地管束我的东西的后面还有一个对应地管束它的东西在如此地做吗？对应的我只是像蛇腹下的横鳞或蝉的翼一样地被动地随之而动而已吗？我怎么能知道我为什么会一会儿被这样？又怎么能知道为什么一会儿会不被这样呢？”</p>\n<blockquote>\n<p><strong>昔者庄周梦为胡蝶，栩栩然胡蝶也。自喻适志与！不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与？胡蝶之梦为周与？周与胡蝶则必有分矣。此之谓物化。</strong></p>\n</blockquote>\n<p>过去庄周我曾经梦到自己变成了蝴蝶，活灵活现的一只真蝴蝶的样子，当时自己心里很明白自己就是这只蝴蝶而且非常惬意啊，已经完全不知道自己原本是庄周了；一会儿梦醒了，也就又恢复成了现实中的庄周我了。真不知道是庄周我在梦里化为了蝴蝶呢，还是蝴蝶在梦里化为了庄周我呢！对于庄周我与蝴蝶在梦中互化的现象而言，必然是在不同的心力下所产生的不同的物类及个体而已，这就是形身在心力的作用下从一个物类个体又转化为另一个物类个体的物化现象。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>南郭子綦隐机而坐，仰天而嘘，荅焉似丧其耦。颜成子游立侍乎前，曰：“何居乎？形固可使如槁木，而心固可使如死灰乎？今之隐机者，非昔之隐机者也？”子綦曰：“偃，不亦善乎，而问之也！今者吾丧我，汝知之乎？汝闻人籁而未闻地籁，汝闻地籁而不闻天籁夫！”</strong></p>\n</blockquote>\n<p>南郭子綦靠几静坐，仰面朝天缓缓地吐气，茫然若失，就像魂魄离开了躯体。南郭子綦的学生颜成子游见状马上前来侍候，问南郭子綦说：“您刚才是处于一种什么样的境界呢？一个人的肢体形貌在打坐时固然可以使它像枯槁之木一样毫无生气，难道一个人的心神在打坐时也可以使它像死灰一样毫无生气吗？您在今天所表现出来的安稳境界，跟以前的安稳境界绝对不一样。”南郭子綦回答说：“偃，你问此事，不是问得很好吗？今天我遗忘了形体之我，你知道这一点吗？你只听到人吹箫管发出的声音，而没听听风吹众窍所发出的声音，你只听到风吹众窍所发出的声音，而没有听到天地间万物的自鸣之声！”</p>\n<blockquote>\n<p><strong>子游曰：“敢问其方。”子綦曰：“夫大块噫气，其名为风。是唯无作，作则万窍怒呺。而独不闻之翏翏乎？山林之畏隹，大木百围之窍穴，似鼻，似口，似耳，似枅，似圈，似臼，似洼者，似污者。激者、謞者、叱者、吸者、叫者、譹者、宎者，咬者，前者唱于而随者唱喁，泠风则小和，飘风则大和，厉风济则众窍为虚。而独不见之调调之刁刁乎？”</strong></p>\n</blockquote>\n<p>子游说：“能不能问一问大地的声音与天的声音是怎么回事呢？”南郭子綦回答说：“那个地籁就是无边无际的造物之作用所发出的能量之气息啊，发出来之后就被叫作风。这种能量要么就是内在蕴含着不发出来，一旦发出来就会万窍怒号，难道你耳边就没有听到过这种‘呼呼’的风声吗！山林的险峻、大树周身的窍穴，有的形状像鼻子，有的形状像张开的嘴，有的形状像耳朵，有的形状”像扁长的发簪，有的形状像凸出来的圈筒，有的形状像凹下去的浅坑，有的浅一些，有的深一些；于是所发的声响就有的快促，有的像响箭，有的刺耳，有的发自往里吸，有的发自往外出，有的像嚎哭声，有的像狗叫，有的像悲哀声。能量流的运动原本就很舒缓动听，怪就怪哉随着各种物体所发出的众口乱叫而嘈杂了；当徐徐之风时万物就会轻微地唱和，当风大时万物就会大点儿地唱和，当劲风厉厉时反而所有能发响者皆欲发而无声了，难道你没有从风响的音调中听出来各种声响的发声原因、从风的响声上听出其后面的那个不发声的东西吗？”</p>\n<blockquote>\n<p><strong>子游曰：“地籁则众窍是已，人籁则比竹是已，敢问天籁。”子綦曰：“夫吹万不同，为而使其自己也。咸其自取，怒者其谁邪？”</strong></p>\n</blockquote>\n<p>子游又问：“大地的本意可以借助万物之窍所发出的唱和声中表达出来，人所的本意也可以从清悠、消沉、谐美的各种丝竹的或条畅或激昂的声中表达出来，那么天的本意是怎么表达出来的呢？”南郭子綦说：“所谓天籁的音响万变，而又能使其自行息止，这完全都是出于自然，有什么东西主使着它呢？”</p>\n<blockquote>\n<p><strong><font color=red>大知闲闲，小知閒閒。大言炎炎，小言詹詹。</font>其寐也魂交，其觉也形开。与接为构，日以心斗。缦者、窖者、密者。小恐惴惴，大恐缦缦。其发若机栝，其司是非之谓也；其留如诅盟，其守胜之谓也；其杀如秋冬，以言其日消也；其溺之所为之，不可使复之也；其厌也如缄，以言其老洫也；近死之心，莫使复阳也。喜怒哀乐，虑叹变慹[zhé]，姚佚启态。乐出虚，蒸成菌。日夜相代乎前而莫知其所萌。已乎，已乎！旦暮得此，其所由以生乎！</strong></p>\n</blockquote>\n<p>大智者看上去显得非常广博，小智者却十分琐细；高论者盛气凌人，争论者小辩不休。辩士睡时，精神与梦境交错在一起，醒后疲于与外物接触纠缠。每天与外物相接，其心有如经历了一场又一场的战斗一样疲惫。有的心机柔奸，有的善设陷阱，有的潜机不露。小的惧怕表现为忧惧不安，大的惧怕表现为惊恐失神。三灾八难的降临就像箭在弦上一样地随时而发，这全是由于行为人的心机所伺机行是非之行径所造成的；三灾八难的不降临也可以像发愿一样的通过履践其愿誓而消失，那就要看行为人是否践履自己的愿誓而坚持无思无为的行径来决定了。神情衰沮就像秋风冬雪肃杀万木一样无情，这就说明道心逍遥之本性的消亡是渐进的过程；如果行为人沉迷于自己之心机的经营里而不醒悟的话，也就很难再回到那个逍遥的本性去了。然而行为人对恢复道心的修行却厌恶得像自行封闭起来的蚕子一样的听不进去，这就说明行为人的执着意识的积习太严重了；像这样的几乎等于死亡的心，实在是没法使它再恢复生气。所谓的喜怒哀乐，都是认取了事物对自己所引发的感受而逐步形成多忧惧的意识，正在这个意识之执着的支配下才形成了轻狂而放任的或喜或怒或哀或乐的情绪了。喜怒哀乐发出来之后就过去了，接着而来的就是又孕育出了无明之烦恼，如此的一天到晚的不是喜乐就是烦恼的交替着出现在眼前，而从来不知道它们是怎么产生的。不可救药啊，不可救药！一天到晚地如此活着，三灾八难也就由此产生了啊！</p>\n<blockquote>\n<p><strong>非彼无我，非我无所取。是亦近矣，而不知其所为使。若有真宰，而特不得其眹。可行己信，而不见其形，有情而无形。百骸、九窍、六藏、赅而存焉，吾谁与为亲？汝皆说之乎？其有私焉？如是皆有为臣妾乎？其臣妾不足以相治乎？其递相为君臣乎？其有真君存焉！如求得其情与不得，无益损乎其真。一受其成形，不亡以待尽。<font color=red>与物相刃相靡，其行尽如驰而莫之能止，不亦悲乎！终身役役而不见其成功，苶然疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化，其心与之然，可不谓大哀乎？人之生也，固若是芒乎？其我独芒，而人亦有不芒者乎？</font></strong></p>\n</blockquote>\n<p><em>如果没有了我之内外的任何对立面的观念也就没有我的观念了，如果没有了我的观念也就没有了博取之心了</em>，如此也就基本上接近于那个道心的行径了，然而却不知道是什么东西在支配着这个道心的行径。好像其中有一个迫使万物循势而动的主宰在，然而偏偏找不到那个主宰的迹象在什么地方，当你恢复了道心之后就会彻底明了那个迫使万物循势而动的主宰了，但它却又没有一个具体的形状可见，它仅仅是道心的广大无缘之悲性而没有具体形状而已。一个人身上有百骸、九窍、六脏，当这些脏器都完备了之后才能决定一个人的生存，那么你认为哪一个脏器最重要而倍加爱护呢？还不是都喜欢而都倍加爱护吗？这个问题的背后岂不牵扯到一个“私我”的观念了吗？如果有一个“私我”之观念的话，那么各脏器岂不就成了分别为“私我”提供专职服务的臣下与妻妾了吗？这种势必缺乏协调性的臣下与妻妾岂不就不足以担当全面治理整个机体的重任了吗？难道它们是逐个轮流着担当君的职责而协调各位臣妾的工作吗？这就证明里面有一个真正的主宰在后面起着决定作用吗？如果实证到了那个广大无缘之慈悲性的道心原来是没有具体形状可得的时候，那时候就会明白这个真宰的作用无论怎么做都既不会益于也不会损于那个真宰者的不生不灭、不增不减、不垢不净性了。然而自从那个人人都有的真主秉承了执着之意识以投胎成人之后，还没有到该死的寿数时就在哪里等着寿尽的一天了，这是因为内外界事物所诱发的爱、恶、欲、的心行在相争斗以至于相消耗的缘故；<font color=red>明明知道生命的寿终就像飞驰一样，但却不知道如何止住这种迈向寿终的步伐，对于自许聪明的人们来说难道不是一种悲哀吗！只知道一辈子地役使自己的心身去赴爱、恶、欲的劳役但对于恢复道心却毫无一点儿进展，整天精神不振地疲于劳役但却不知道究竟是为了什么，对于自许聪明的人们来说难道不是一种痛心吗！即使能够达到人们所说的千万岁的长生不老，对于道心的恢复又有什么益处呢？即使其形体逐渐衰败枯萎，也只是其执着心使其具有了这种变化而已，对于那个真宰的不生不死、不增不减、不垢不净性而言怎能不是最大的痛心呢！人生在世，本来就如此糊涂吗？</font></p>\n<blockquote>\n<p><strong>夫随其成心而师之，谁独且无师乎？<font color=red>奚必知代而心自取者有之？</font>愚者与有焉！未成乎心而有是非，是今日适越而昔至也。是以无有为有。无有为有，虽有神禹且不能知，吾独且奈何哉！</strong></p>\n</blockquote>\n<p>还是只有我糊涂，而别人也有不糊涂的呢？<font color=red>世人如果都以自己的偏见作为判别是非的标准，那么谁没有一个标准呢？</font>何必是懂得事物更替而心有见地的人才有是非标准呢？即使愚蠢的人也是有的。在未有成见存于心中之前已经就因自己的好恶之感受而得出对与错的心得了，这个心得之现象的得出就像今天刚到了越国而实际上原本就在越国一样地早就待在那个地方了。所以才从道心里凭空产生出心得乃至执着了。对于通过作意而产生出神奇的事物来的行为而言，即使有着禹王那样的神通，也不能有一点儿故意去知道的心在，客观世界的任何事物又怎能奈何于超然物外的那个道心之吾的神奇作用呢！</p>\n<blockquote>\n<p><strong>夫言非吹也，言者有言。其所言者特未定也。果有言邪？其未尝有言邪？其以为异于鷇音，亦有辩乎？其无辩乎？道恶乎隐而有真伪？言恶乎隐而有是非？道恶乎往而不存？言恶乎存而不可？<font color=red>道隐于小成，言隐于荣华</font>。故有儒墨之是非，<font color=red>以是其所非而非其所是。欲是其所非而非其所是，则莫若以明。</font></strong></p>\n</blockquote>\n<p>言论出于机心，与无心而吹的“天籁”是不同的。发言者知持一端，他们的话并不能作为衡量是非的标准。为了表述某事物果真就需要言辞吗？人们最初始时的思想交流并没有使用言辞啊！人们的言辞之所以能听得懂而雏鸟的叫声却听不懂，这个能听懂的背后是有一个思辨的审明作用在呢？还是没有思辨的审明作用在呢？那个大道为什么未被真正地认识到而产生了见解上的真与假呢？言辞所表述的意义为什么未被真正地认识到而产生了判断上的是与非呢？那个大道为什么必须去参悟才能实证到它而不能通过想象去找到它呢？言辞所表述的意义为什么必须通过思辨才能听懂而不能一听就能确定其真意呢？<font color=red>原因就在于那个大道被不深刻、不全面的小见解给遮蔽住了，就在于言辞所表述的意义被言辞本身的巧妙之比喻或夸张给遮蔽住了。</font>所以才产生了儒墨两家之学术思想的我对你错的争鸣，<font color=red>世人都是用自己所认定的正确去评判人家的不正确，都是用自己所认定的人家的不正确来宣扬自己的正确。与其想用自己所认为的正确去推定人家的不正确，与其想用人家的不正确来证明自己所认为的正确，那就不如静下心来认认真真地修身以达到内明为好。</font></p>\n<blockquote>\n<p><strong>物无非彼，物无非是。自彼则不见，自知则知之。故曰：彼出于是，是亦因彼。彼是方生之说也。虽然，方生方死，方死方生；方可方不可，方不可方可；因是因非，因非因是。是以圣人不由而照之于天，亦因是也。是亦彼也，彼亦是也。彼亦一是非，此亦一是非，果且有彼是乎哉？果且无彼是乎哉？彼是莫得其偶，谓之道枢。枢始得其环中，以应无穷。是亦一无穷，非亦一无穷也。故曰：莫若以明。</strong></p>\n</blockquote>\n<p>天地万物在道体上不存在你我它的分别，天地万物在道体上也不存在你对及它错的差别。如果从万物存在的现象去看就不会认识到万物是道体之妙用的那个本质，只有从内明的大智慧上去看才能认识到万物同是道体之妙用的那个本质。所以说人们之所以会有万物的个体皆有差异以及你对而它错的分别心乃是从没有分别心的物我同胞的实相中产生的，于是那个没有分别心的物我同胞之实相的提法也就对应于人们的分别心而提出来了。人们之所以会产生分别心，乃是由于当下一念的喜爱心所造成的虽然都是因为当下一念的喜爱心所造成，但当下一念的喜爱心刚刚生起便又马上消失了，前念刚刚消失便又马上生起了后念的喜爱心；于是人们的分别心刚刚形成执着又紧接着遇到新的事物而须要去分别了，于是对新事物的分别心又形成另一个新的执著心了；因为先前的执着心而产生了对新遇到之事物的不认同，对新遇到之事物的不认同经过喜爱心的分别又形成了新的另一个执着。所以每一位恢复了道心的圣人无不鉴于当下之一念的迁流不断而不由得时刻注意着当下一念的似起未起之时，也就是因为这个道理啊！在先前的那个执着的作用下产生了新的另一个执着，新的另一个执着又变成了产生新执着的旧执着。先前的执着是喜爱心所认为的对与错而形成的，新执着也是喜爱心所认为的对与错而形成的。果真存在着执着心所认为的那个正确吗，果真存在着执着心所认为的那个不正确吗？无论是执着心所认为的正确还是所认为的不正确皆是失去了道心中庸之用的结果，这就是所说的形成执着的关键之所在。正是由于形成执着的整个关键作用发生在旧执着与新执着的环环相产生的现象中，于是无始劫以来所形成的无穷的执着也就变成了遮蔽道心的“五蕴”了。道心的中庸之大用是无穷无尽的，意识心的执着之妄用也是无穷无尽的。所以说要想了知道心的全体之大用还是静下心来认认真真地修身以达到内明为好。</p>\n<blockquote>\n<p><strong>以指喻指之非指，不若以非指喻指之非指也；以马喻马之非马，不若以非马喻马之非马也。天地一指也，万物一马也。</strong></p>\n</blockquote>\n<p>用自己的手指来说明人家的手指不是手指，不如不用自己的手指来说明人家的手指不是手指为好；用马来说明白马不是马，不如不用马来说明白马不是马为好。从道通为一的观点看，天地与一指，万物与一马，都是没有区别的。</p>\n<blockquote>\n<p><strong>可乎可，不可乎不可。道行之而成，物谓之而然。恶乎然？然于然。恶乎不然？不然于不然。物固有所然，物固有所可。无物不然，无物不可。故为是举莛与楹，厉与西施，恢诡谲怪，道通为一。</strong></p>\n</blockquote>\n<p>人家认为可，我也跟着认为可；人家认为不可，我也跟着认为不可。于是那个道的生发万物的妙用也就在因缘聚合而生的条件下形成了，于是万物也就在遇到了所对应的因缘聚合的条件下而形成了各具特色的形物了。有的万物之个体能适应因缘聚合而生的各种不同的环境条件而生，有的万物之个体不能适应因缘聚合而生的各种不同的环境条件而只能待其适应的环境条件时而生；所以有的万物之个体也就顺势而形成了具有新特色的形体了，有的万物之个体则未能顺势形成新特色的形体而是保持了始祖的面目乃至被淘汰。为什么有的万物之个体能顺势而形成具有新特色的形体呢？那是因为它具有能顺势而生的适应性所以才形成了具有新特色的形体。为什么有的万物之个体不能顺势而形成具有新特色的形体呢？那是因为它不具有能顺势而生的适应性所以才不能形成具有新特色的形体。为什么有的万物之个体能具有顺势而生的适应性呢？那是因为它具有适应因缘聚合而生的各种不同环境条件的天性。为什么有的万物之个体不具有顺势而生的适应性呢？那是因为它不具有适应因缘聚合而生的各种不同环境条件的天性。万物原本就具有顺势而形成的具有新特色的适应性，万物原本就具有适应因缘聚合而生的各种不同环境的天性。没有哪一个万物之个体不是因为这种适应性而生，也没有哪一个万物之个体不是因为这种天性而生。所以才产生了诸如轻空的莚秆或坚实的楹柱之类的各种不同物类，才产生了诸如丑陋或美丽之类的各种不同形色，才产生了诸如中正、阴险、诡秘、古怪之类的各种不同性格，当你通达了那个道心的大用后就会明白它们都是无二无别的实相了。</p>\n<blockquote>\n<p><strong>其分也，成也；其成也，毁也。凡物无成与毁，复通为一。唯达者知通为一，为是不用而寓诸庸。庸也者，用也；用也者，通也；通也者，得也；适得而几矣。因是已。已而不知其然，谓之道。劳神明为一而不知其同也，谓之“朝三”。何谓“朝三”？狙公赋芧，曰：“朝三而暮四。”众狙皆怒。曰：“然则朝四而暮三。”众狙皆悦。名实未亏而喜怒为用，亦因是也。是以圣人和之以是非而休乎天钧，是之谓两行。</strong></p>\n</blockquote>\n<p>万物之生命的死亡与分解的过程，就是又形成新的生命的过程；形成新的生命的过程，就是其生命的下一次死亡与分解的过程。万物根本就没有什么生与死的截然不同，或生活死的现象也只是同时发生着的道心之大用而已；正是由于实证到了道境界的人彻底明白了或生活死的现象都是同时发生着的，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。当一切行为都隐含在恰到好处的无之用中了的时候，才能遵循道心的全体之大用；当能遵循道心的全体之大用的时候，才能通达一切现象皆是无二无别的实相；当通达了一切现象皆是无二无别之实相的时候，才能驾驭道心的全体之大用；当驾驭了道心的全体之大用的时候，也就差不多恢复了那个道心了。遵循这个过程也就恢复那个道心了。恢复了那个道心也就凡事只是无为地去做而不去问为什么了，这才叫作真正的道境界。被喜怒爱恶欲所驱使的心意之妄动与其内在的思辨觉知之作用是一个本原，然而却不知道此二者都是一个本原，这就叫作只知朝四而不知暮三的猴子意识。为什么叫作只知朝四而不知暮三的猴子意识呢？管理猴子的人给猴子喂食橡实时说：“早晨喂三个晚上喂四个。”众猴子闻之则大怒；管理猴子的人又说：“既然大家都不同意，那就还按早晨喂四个晚上喂三个的老法子。”众猴子们则闻之则大喜。名字之类的名相与名相所代表的那个实物的本性原本就没有什么不同，然而在人们的喜怒哀乐恶欲的心理作用下却变成了各种不同的理解，这就是因为那个只知朝四而不知暮三的意识在作怪啊。所以恢复了道心的圣人们既能在外行上将各种矛盾对立的意识调节控制在中和的状态，又能在内行上安闲自在于道心大用之遍行的无二无别的精神境界中，这就叫作一个道心境界而同时有着内外两种行径的圣行。</p>\n<blockquote>\n<p><strong>古之人，其知有所至矣。恶乎至？有以为未始有物者，至矣，尽矣，不可以加矣！其次以为有物矣，而未始有封也。其次以为有封焉，而未始有是非也。是非之彰也，道之所以亏也。道之所以亏，爱之所以成。果且有成与亏乎哉？果且无成与亏乎哉？有成与亏，故昭氏之鼓琴也；无成与亏，故昭氏之不鼓琴也。昭文之鼓琴也，师旷之枝策也，惠子之据梧也，三者之知几乎！皆其盛者也，故载之末年。唯其好之也，以异于彼，其好之也，欲以明之。彼非所明而明之，故以坚白之昧终。而其子又以文之纶终，终身无成。若是而可谓成乎，虽我亦成也；若是而不可谓成乎，物与我无成也。是故滑疑之耀，圣人之所图也。为是不用而寓诸庸，此之谓“以明”。</strong></p>\n</blockquote>\n<p>古时候的人，他们所具足的大智慧任何地方都能无所不至啊！都是打倒了什么样的无所不至呢？凡所做出的任何行为从根本上就没有做事之动机的存在，就是具足了无所不至的大智慧的境界了，当具足了这种无所不至的大智慧后，就再也不会被喜怒爱恶欲的习气所污染了。差一点的境界则仅仅才有了做事的动机，但却没有达到“这是我的，那是你的”的私我意识；再差一点的境界也只是有了“这是我的，那是你的”的私我意识，但却没有形成以我见而划分对错是非的唯我意识。后来我人便有了对错是非之心而且越来越严重了，于是道心也就亏失了；道心之所以亏失了，完全是心里的那个喜欢之所用所导致的。难道那个道心果真会圆满也会亏失吗，还是果真不会圆满也不会亏失呢？那个道心确实会圆满也会亏失，所以当大琴师昭氏鼓琴时便能激荡起人们心神的喜悦而造成道心之静的亏失了啊；那个道心确实不会圆满也不会亏失，所以当大琴师昭氏不鼓琴时人们的心神便恢复了道心之静的常态了。大琴师昭文的鼓琴之技艺，大乐师师旷持策以击乐器，大逻辑家惠子的诡辩之造诣，就这三个人对于各自爱好之事所达到的极其微妙的程度而言，都是各自领域里的顶尖高手，所以才能千古流传下来。由此三人在琴、诊、论上有着超乎寻常的爱好心，所以才使得在琴、诊、论的成就上大大超出了其他方面的技能；他们之所以爱好其所好的东西，其目的就是为了彻底研究明白所爱好之东西的内在机制。所爱好之东西的内在机制本来就不是靠研究所能研究明白的事反而执意地要去研究明白它，所以才犯了坚石非坚、白马非马之逻辑式的错误以至于愚昧终生。像他们那样地达到了极其微妙的程度就算是真正的最高成就了吗？那么我们每一个意识心用事的人也就可以说是成道的圣人了。像他们那样地达到了极其微妙的程度不算是真正的最高成就吗？那么万物与我人也就不会成为个别的个体了。所以，只有这样地将那个大道的玄机深究到大生疑惑的境地才能不知不觉地过渡到恍然大悟的境界，这正是圣人所希望的啊！只有达到了恍然大悟的境界才能没有是非对错之意识而一切行为都隐含在道心的无为之大用中，所以也就没有了意识分别心地将一切行为都隐含在恰到好处的无之用中了。</p>\n<blockquote>\n<p><strong>今且有言于此，不知其与是类乎？其与是不类乎？类与不类，相与为类，则与彼无以异矣。虽然，请尝言之：有始也者，有未始有始也者，有未始有夫未始有始也者；有有也者，有无也者，有未始有无也者，有未始有夫未始有无也者。俄而有无矣，而未知有无之果孰有孰无也。今我则已有有谓矣，而未知吾所谓之其果有谓乎？其果无谓乎？</strong></p>\n</blockquote>\n<p>刚才已将“是非之彰也，道之所以亏也”的道理说过了，那么它与“为是不用而寓诸庸”的道理是一回事呢，还是与“为是不用而寓诸庸”的道理不是一回事呢？就以人们所认为的是一回事与不是一回事的那个认识而言，认识本身的那个思维所产生的心行就是同一回事，如此也就理解“是非之彰也，道之所以亏也”的道理与“为是不用而寓诸庸”的道理没有什么不同了。尽管如此，也需要试着将其道理说明如下。有的心行是从意识中突然产生的，有的心行是从末那识中迁流过来的，有的心行是从藏识中迁流过来的。来源于意识中的心行有的正存在着，有的已经过去了，来源于末那识的心行有的出于旧有的执着、有的出于最近才有的心得，来源于藏识中的心行乃是既没有形成执着，又没有形成心得的无为之举。心行就是这样地一会儿是从意识中产生出来，一会儿是从藏识中迁流出来，却不知道这两张心行的现象，它是不是真实的存在呢？现在用哪个会思会想的意识心反思一下自己就会发现所谓的“我”是不真实的假象了，而那个不会思不会想的道心之吾则是真实存在的了。道心之吾果真是真实的存在啊！意识心之假我果真是不真实的存在啊！</p>\n<blockquote>\n<p><strong>夫天下莫大于秋毫之末，而太山为小；莫寿乎殇子，而彭祖为夭。天地与我并生，而万物与我为一。既已为一矣，且得有言乎？既已谓之一矣，且得无言乎？一与言为二，二与一为三。自此以往，巧历不能得，而况其凡乎！故自无适有，以至于三，而况自有适有乎！无适焉，因是已！</strong></p>\n</blockquote>\n<p>整个的天下在实相上不会比秋毫的尖头大，相形之下那有形的大山却是渺小得很；我们的寿命在实相上不会比夭折的小儿寿长，相形之下那八百寿的彭祖却是夭亡的小儿；这就证明天地与我们都是道心之大用的妙用所生，万物与我们都是一个本体而没有人我万物之别。既然天地人我万物都是一个本体的“一”而没有差别，为什么会有天地人我万物之不同的认识存在呢？既然认为它们都是一个一个的个体而有差别，又怎会没有天地人我万物之不同的认识存在呢？道之实相用言辞说出来就变成第二重的言辞之比喻象了，将道的比喻象再用言辞说出来就变成第三重的意识之妄见象了。自从道之实相变成言辞之比喻象再变成意识之妄见象以来所代代递增的妄见象，即使技术最高超的人来推算也不能计算清楚它，更何况还有以后所必然会形成的意识之妄见象呢！从道的不可言说的实相上就能变成言辞之比喻象以至于再变成意识之妄见象，更何况将意识之妄见象再变成妄见的言辞之比喻象呢！由此而知，意识之妄见再变成意识之妄见的沿流永远没有一个尽头，原因就在于妄见的沿流层出不穷。</p>\n<blockquote>\n<p><strong>夫道未始有封，言未始有常，为是而有畛也。请言其畛：有左有右，有伦有义，有分有辩，有竞有争，此之谓八德。六合之外，圣人存而不论；六合之内，圣人论而不议；春秋经世先王之志，圣人议而不辩。</strong></p>\n</blockquote>\n<p>对于那个道心的大用而言在最初并没有“这是我的，那是你的”的私我之意识，对于言辞而言却从一开始便不存在永久不变，正是因为意识之妄见的沿流永远没有一个尽头而从道心之大用中形成了人我万物的各个个体及各种思想意识了。请让我说说这些界限：有上下、尊卑之序，有亲疏之理、贵贱之仪，有剖析万物、分别彼此，有角逐胜负、对辩是非，这就是儒、墨等派所争辩的八种界限。对于宇宙之外的不可知，圣人只是保留其说而不加以讲解；对于宇宙之内的事物，圣人只是讲解而不加以评说；对于以天道中正为喻的《春秋》所记载的经纶天下的先王的济世之道，圣人只是评说而不加以争辩。</p>\n<blockquote>\n<p><strong>故分也者，有不分也；辩也者，有不辩也。曰：“何也？”“圣人怀之，众人辩之以相示也。故曰：辩也者，有不见也。”夫大道不称，大辩不言，大仁不仁，大廉不嗛，大勇不忮。道昭而不道，言辩而不及，仁常而不成，廉清而不信，勇忮而不成。五者圆而几向方矣！故知止其所不知，至矣。孰知不言之辩，不道之道？若有能知，此之谓天府。注焉而不满，酌焉而不竭，而不知其所由来，此之谓葆光。</strong></p>\n</blockquote>\n<p>由圣人的做法可知，既然有了是非对错的认识之分别，这本身就说明道心原本就是一而没有认识之分别；既然有了是非对错的争辩，这本身就说明道心原本就是一而没有争辩之实质。这证明了什么呢？证明了圣人是思虑于心，而众人是妄议于言为了将这个道理开示出来。所以告诉大家，“之所以存在着争辩的现象，乃是还没有达到内明的缘故。”真正的大道没有任何名相之称谓，真正的大辩没有任何说道之言辞，真正的大仁没有任何仁慈之目的，真正的大廉是不自需锋芒的，大勇是不自逞血气之勇的。如果还有有道的样子显现出来则恰恰证明没有道，言语过于辩察，就不能达到真理，仁者滞于一偏之爱就不能周遍，过分表示廉洁就不够真实，自逞血气之勇就不成器大勇。不称、不言、不仁、不嗛、不忮这五个方面，本来是圆通混成的；如果涉及昭、辩、常、清、忮等形迹，就变成四方之物了。所以道心之知的明了作用若能停留在只管去做而不去动其心的境界上，那么修心的境界也就到家了。怎能又去管它什么没有言辞才是真正的论辩，不认为有道才是真正的有道呢？如果保持住了那个能知而又不去动心的境界，也就叫作修心阶段的最高成就了。只有达到了像大海一样地诸如多少也不会满溢，舀取多少也不会枯竭，而且也不去思考为什么会这样的境界时，这才叫作包藏光亮而不露。</p>\n<blockquote>\n<p><strong>故昔者尧问于舜曰：“吾欲伐宗脍、胥、敖，南面而不释然。其故何也？”舜曰：“夫三子者，犹存乎蓬艾之间。若不释然何哉！昔者十日并出，万物皆照，而况德之进乎日者乎！”</strong></p>\n</blockquote>\n<p>在过去的时候尧帝曾考问于大位的接班人舜帝说：“我真想消灭宗、脍、胥这三个屡犯边庭的小国，但是朕想到天子的责任又放不下对他们的牵挂，这个原因是什么呢？”舜帝回答说：“这三个小国的国君，竟然还能够在偏小卑微之地生存下来也真是不容易，你感到心情不怡悦。这说明了什么呢？过去曾有十个太阳同时普照大地，万物皆能普受恩惠，更何况您的道德境界胜过十个太阳的普照呢？”</p>\n<blockquote>\n<p><strong>啮缺问乎王倪曰：“子知物之所同是乎？”曰：“吾恶乎知之！”“子知子之所不知邪？”曰：“吾恶乎知之！”“然则物无知邪？”曰：“吾恶乎知之！虽然，尝试言之：庸讵知吾所谓知之非不知邪？庸讵知吾所谓不知之非知邪？且吾尝试问乎女：民湿寝则腰疾偏死，鳅然乎哉？木处则惴栗恂惧，猨猴然乎哉？三者孰知正处？民食刍豢，麋鹿食荐，蝍蛆甘带，鸱鸦耆鼠，四者孰知正味？猨猵狙以为雌，麋与鹿交，鳅与鱼游。毛嫱丽姬，人之所美也；鱼见之深入，鸟见之高飞，麋鹿见之决骤，四者孰知天下之正色哉？自我观之，仁义之端，是非之涂，樊然淆乱，吾恶能知其辩！”啮缺曰：“子不利害，则至人固不知利害乎？”王倪曰：“至人神矣！大泽焚而不能热，河汉冱而不能寒，疾雷破山、飘风振海而不能惊。若然者，乘云气，骑日月，而游乎四海之外，死生无变于己，而况利害之端乎！”</strong></p>\n</blockquote>\n<p>啮缺问于王倪说：“先生知道万物所共同的那个根本吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺又问道：“先生知道您那个为什么不去知道吗？”王倪回答说：“道心之吾为什么要去知道呢！”啮缺进一步问道：“那么万物是否也都是一样的什么也不去知道吗？”王倪回答道：道心之吾为什么要去知道呢！尽管如此，也需要试着将其道理说明。怎么能知道我所说的道心的大用止于“知”，也就是道心之吾的那个“知”并不是不能知道啊？道心的大用止于“知”，则正是道心之吾的那个“知”明明就在却不去知啊！现在吾且试着问于你：我们如果在潮湿的地方安歇就会腰痛乃至偏瘫，泥鳅会这样吗？我们如果在树木上安歇就会担心掉下来而心惊恐惧，猿猴会这样吗？对于人、泥鳅、猿猴这三种动物的安歇方式而言哪一种是正确的呢？我人喜欢食食草的及喂养的动物，麋鹿喜欢食草类植物，蜈蚣喜欢食蛇之类的爬行动物，鹞鹰喜欢食鼠类动物，对于人、麋鹿、蜈蚣、鹞鹰这四种动物的口味而言哪一种是正确的呢？濑猴与猴子互相吸引，狍子与鹿互相倾情，泥鳅与鱼互相交欢。毛嫱与丽姬，在我们眼里都是最具吸引力的大美女；然而鱼见了她们却恶心地躲入深水中，飞鸟见到她们却鄙视地高飞而去，麋鹿见到她们却厌恶地急速地跑走。对于猿狙、麋鹿、鳅鱼、人这四种动物的审美观点而言哪一种是正确的呢？从我们的意识心上分析，讲究仁义的开始，便是是非涂抹道心的开始，像这样互相缠绕得杂乱的意识行为，道心之吾又怎能分清仁义与是非的观念是谁对谁错呢！啮缺又问道：“看来现实您是不知道凡事对自己的利与害了，难道心身行为最完美的人也是原本就不知道凡事对自己的利与害吗？”王倪回答道：“心身行为最完美的人可就神通广大了，即使四大海都变得干涸而燃烧起来他也不会感到热，即使宇宙都冻得成冰了他也不会感到冷，即使霹雳能击破山岳、狂风能掀起海啸也不会吓着他。如果达到了这种境界的话，就能够乘云气、骑日月而逍遥地游乎环宇之内了；即使人们所认为的死生也不会改变自己的道心之大用了，更何况是人们所认为的利与害的小事呢！”</p>\n<blockquote>\n<p><strong>瞿鹊子问乎长梧子曰：“吾闻诸夫子：圣人不从事于务，不就利，不违害，不喜求，不缘道，无谓有谓，有谓无谓，而游乎尘垢之外。夫子以为孟浪之言，而我以为妙道之行也。吾子以为奚若？”</strong></p>\n</blockquote>\n<p>瞿鹊子问于长梧子说：我听孔子说：“圣人在对待立身处世之心身行为的培养上没有必须要如何如何的想法，既没有获取利益之心，也没有躲避害处之心，既没有必得的执着之心，也没有等待外缘具备时再去做的懒散之心，只有心里真正达到了无所谓时才算是有了道心的成就了，若是心里有一点儿所谓的影子那就还没有真正达到道心的境界，如此才能使自己的心行既在世俗中生活又不受各种世俗之心对道心的污染。”先生您却认为这是好高骛远之言，而我却认为是最好的修道宗旨，作为得道的先生您认为咱俩的看法谁对呢？</p>\n<blockquote>\n<p><strong>长梧子曰：“是黄帝之所听荧也，而丘也何足以知之！且女亦大早计，见卵而求时夜，见弹而求鸮炙。予尝为女妄言之，女以妄听之。奚旁日月，挟宇宙，为其脗合，置其滑涽，以隶相尊？众人役役，圣人愚芚，参万岁而一成纯。万物尽然，而以是相蕴。予恶乎知说生之非惑邪！予恶乎知恶死之非弱丧而不知归者邪！</strong></p>\n</blockquote>\n<p>长梧子回答说：孔子所说的境界，恰恰是轩辕皇帝毫无意识心地任由那个道心的作用慢慢地明亮后的境界，单凭听了孔丘所说的几句道理又何足以真正地知道那个境界呢！而且你也太过于听风即是雨了，似乎见到鸡蛋就得到了会即时报更的公鸡了，见到弹弓就得到了香喷喷的烤鸮了。我试着为你妄言之，你也妄听之。如何才能与日月为邻，驾驭宇宙呢，唯一的办法就是必须完全做到与孔子所说的道理相吻合，对当下的心念不管是明白地知道还是糊里糊涂都不去管它，这才能符合孔子所说的道理。不要像众人役使自己的身心为自己的欲望服劳役那样地往外求，要像圣人傻傻地待在葆光的境界里那样，如此才能参究透一万年也只不过纯属当下的一念所变现而已；万物也都是如此，也都是以这个当下一念的作用在积蓄着生命的能量。我怎么知道喜欢活着的心理并不是内心不明之迷惑呢？我怎么知道厌恶死亡的心理并不是不害怕死亡呢？我怎么知道人们害怕死亡就像弱孩迷失在他乡而不知回归故乡呢！</p>\n<blockquote>\n<p><strong>丽之姬，艾封人之子也。晋国之始得之也，涕泣沾襟。及其至于王所，与王同匡床，食刍豢，而后悔其泣也。予恶乎知夫死者不悔其始之蕲生乎？梦饮酒者，旦而哭泣；梦哭泣者，旦而田猎。方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。且有大觉而后知此其大梦也，而愚者自以为觉，窃窃然知之。“君乎！牧乎！”固哉！丘也与女皆梦也，予谓女梦亦梦也。是其言也，其名为吊诡。万世之后而一遇大圣知其解者，是旦暮遇之也。</strong></p>\n</blockquote>\n<p>丽这个地方的美女丽姬，原是丽地一个名叫“艾”的城邑之长官的女儿；晋国的国君刚选她入宫时，她不知道这是好运气来了反而吓得哭成了泪人儿，等到她到了王宫之后，没想到竟然是与国君同吃同住，而且餐餐都是食草的及喂养的动物肉，于是就后悔当初的无知而暗自落泪。从这类事上难道我们还不明白“那些怕死的人岂不应该后悔当初怕死”的无知之心理吗！夜里梦到席间饮宴娱乐的梦，第二天往往会遇到伤心而哭泣的事；夜里梦到伤心而哭泣的梦，第二天往往会遇到驰骋田猎而心旷神怡的事。当时再梦中的时候，并不知道自己是在做梦。而且还在梦中将所梦达成了真实的事，只到醒了之后才知道那是虚幻的梦境而非真实。还有一种情况是，彻底恢复了道心之内明而后明白了夜里的梦境与白天的所作所为，它们都是非常虚幻的。然而我们未恢复道心的所有凡夫却自以为所捞到的财官名利皆是自己最聪明的结果，且暗自为自己的聪明而高兴，真不知道自己是人生的主人，还是被人生所放牧的犟牛，这可是多累劫以来所形成的根深蒂固的虚妄习气所致使的啊！孔子给你所讲的那些道理，皆都是梦话；就连我所说的“孔子给你所讲的那些道理都是梦话”的话，也同样是梦话啊！我刚才的说法，名字就叫作为了归于道用之实相而截断各种妄见的接引后学的吊诡之法。假若万世之后能够遇到一位恢复了道心的大圣人，那也是在这种接引之法的接引下，起到了早晨听了道而晚上也就明白了的作用而已。</p>\n<blockquote>\n<p><strong>既使我与若辩矣，若胜我，我不若胜，若果是也？我果非也邪？我胜若，若不吾胜，我果是也？而果非也邪？其或是也？其或非也邪？其俱是也？其俱非也邪？我与若不能相知也。则人固受其黮暗，吾谁使正之？使同乎若者正之，既与若同矣，恶能正之？使同乎我者正之，既同乎我矣，恶能正之？使异乎我与若者正之，既异乎我与若矣，恶能正之？使同乎我与若者正之，既同乎我与若矣，恶能正之？然则我与若与人俱不能相知也，而待彼也邪？”</strong></p>\n</blockquote>\n<p>假使我与你再论辩，如果你胜了我，那么我就胜不了你，难道你就果真对了，我就果真错了吗？如果我胜了你，那么你就胜不了我，难道我就果真对了，你就果真错了吗？无论你认为是你果真对了还是我果真对了，岂不皆证明你的认为是出于意识心的了吗？如果你认为你与我的论辩都是对的，岂不证明你与我的论辩皆是出于意识的了吗？既然你与我之间不能论辩得明白，那么我人就会一直处于自己所证得的绝非道心内明的黑暗之中，那么我人的道心又怎能通过纠正自己的虚妄性而得到恢复呢？如果用与你的见地相同的人来纠正你的虚妄性，既然与你的见地相同，又怎能纠正得了呢？如果用与我的见地相同的人来纠正你的虚妄性，既然与我的见地相同，又怎能纠正得了你呢？如果用与你我的见地皆不相同的人来纠正你的虚妄性，既然与你我的见地皆不相同，又怎能纠正你的虚妄性呢？如果用与你我的见地皆相同的人来纠正你的虚妄性，既然与你我的意见皆相同，又怎能纠正你的虚妄性呢？然而反过来看我与你，也像世人一样的都是不明白自己的人，还必须有赖于吊诡之辩才能最终明白自己啊！</p>\n<blockquote>\n<p><strong>化声之相待，若其不相待。和之以天倪，因之以曼衍，所以穷年也。“何谓和之以天倪？”曰：“是不是，然不然。是若果是也，则是之异乎不是也亦无辩；然若果然也，则然之异乎不然也亦无辩。忘年忘义，振于无竟，故寓诸无竟。”</strong></p>\n</blockquote>\n<p>怎能将极细微的起心动念控制在中和的程度呢？长梧子回答道：主观上所认定的对了，与道用上的客观事实一定是不相符的；主观上所认定的模样，与道用上的客观模样一定是相矛盾的。主观上所认定的对了，如果与道用上的客观事实是相符的，这个主观上所认定的也就达到非思维、言语所能辩的道用之实相的境界了。主观上所认定的模样，如果与道用上的客观模样是一致的，这个主观上所认定的模样也就达到非思维、言语所能辩的道用之实相的境界了。是与非纠缠在一起，如果那个审明辨知不起作用了，那就必须将起审明辨知之作用的那个极微细的起心动念时控制在中和的程度了，如果让那个极微的起心动念游衍自得，那就永远也不会恢复道心的明性而丧失审明辨知的作用了。当自己的心理上没有了时间及情义的概念时，才能像大鹏怒而飞一样地振作于不可预料的尘世生活环境中，于是也就能在各种各样的尘世生活中燕处超然了。</p>\n<blockquote>\n<p><strong>罔两问景曰：“曩子行，今子止；曩子坐，今子起。何其无特操与？”景曰：“吾有待而然者邪？吾所待又有待而然者邪？吾待蛇蚹蜩翼邪？恶识所以然？恶识所以不然？”</strong></p>\n</blockquote>\n<p>影子的影子问影子说：“正当我刚刚跟着你走的时候，你却突然又停了下来；正当我刚刚跟着你坐下来的时候，你却突然又站了起来；你怎么就如此地没有独立的志操呢？”影子回答说：“我后面还有一个对应地管束我的东西在如此地做吗？我后面的那个对应地管束我的东西的后面还有一个对应地管束它的东西在如此地做吗？对应的我只是像蛇腹下的横鳞或蝉的翼一样地被动地随之而动而已吗？我怎么能知道我为什么会一会儿被这样？又怎么能知道为什么一会儿会不被这样呢？”</p>\n<blockquote>\n<p><strong>昔者庄周梦为胡蝶，栩栩然胡蝶也。自喻适志与！不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与？胡蝶之梦为周与？周与胡蝶则必有分矣。此之谓物化。</strong></p>\n</blockquote>\n<p>过去庄周我曾经梦到自己变成了蝴蝶，活灵活现的一只真蝴蝶的样子，当时自己心里很明白自己就是这只蝴蝶而且非常惬意啊，已经完全不知道自己原本是庄周了；一会儿梦醒了，也就又恢复成了现实中的庄周我了。真不知道是庄周我在梦里化为了蝴蝶呢，还是蝴蝶在梦里化为了庄周我呢！对于庄周我与蝴蝶在梦中互化的现象而言，必然是在不同的心力下所产生的不同的物类及个体而已，这就是形身在心力的作用下从一个物类个体又转化为另一个物类个体的物化现象。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_4.webp","slug":"Screenshot_4.webp","post":"ckpapu7gj0001lcxuh91xh30t","modified":0,"renderable":0},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7gj0001lcxuh91xh30t","modified":0,"renderable":0},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7gj0001lcxuh91xh30t","modified":0,"renderable":0},{"_id":"source/_posts/Ajax爬取案例实战/Screenshot_3.webp","slug":"Screenshot_3.webp","post":"ckpapu7gj0001lcxuh91xh30t","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_5.webp","slug":"Screenshot_5.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_3.webp","slug":"Screenshot_3.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_4.webp","slug":"Screenshot_4.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_6.webp","slug":"Screenshot_6.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_8.webp","slug":"Screenshot_8.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Ajax的原理和解析/Screenshot_7.webp","slug":"Screenshot_7.webp","post":"ckpapu7gx0002lcxu1mpp7axh","modified":0,"renderable":0},{"_id":"source/_posts/Nginx配置详解/1.jpg","slug":"1.jpg","post":"ckpapu7ho000alcxu8syz94h2","modified":0,"renderable":0},{"_id":"source/_posts/Nginx配置详解/2.jpg","slug":"2.jpg","post":"ckpapu7ho000alcxu8syz94h2","modified":0,"renderable":0},{"_id":"source/_posts/Nginx配置详解/3.jpg","slug":"3.jpg","post":"ckpapu7ho000alcxu8syz94h2","modified":0,"renderable":0},{"_id":"source/_posts/go语言的下载和安装/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7i3000nlcxuh7paf5fa","modified":0,"renderable":0},{"_id":"source/_posts/go语言的下载和安装/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7i3000nlcxuh7paf5fa","modified":0,"renderable":0},{"_id":"source/_posts/scrapy框架介绍/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7id000vlcxudaqy38uj","modified":0,"renderable":0},{"_id":"source/_posts/python的内置类型/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7ib000tlcxu6xpk0zpe","modified":0,"renderable":0},{"_id":"source/_posts/scrapy的基本使用/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7ig0010lcxucxt0bf3m","modified":0,"renderable":0},{"_id":"source/_posts/scrapy的基本使用/Screenshot_3.webp","slug":"Screenshot_3.webp","post":"ckpapu7ig0010lcxucxt0bf3m","modified":0,"renderable":0},{"_id":"source/_posts/scrapy的基本使用/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7ig0010lcxucxt0bf3m","modified":0,"renderable":0},{"_id":"source/_posts/web网页基础/Screenshot_1.png","slug":"Screenshot_1.png","post":"ckpapu7ij0012lcxuavhaejfe","modified":0,"renderable":0},{"_id":"source/_posts/基于docker部署code-server/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7it001hlcxuf2fma75d","modified":0,"renderable":0},{"_id":"source/_posts/正则表达式/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7iv001jlcxuc8825odl","modified":0,"renderable":0},{"_id":"source/_posts/腾讯云主机CPU占用百分百/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7k8003alcxuhcaj5rb5","modified":0,"renderable":0},{"_id":"source/_posts/HTTP基本原理/webp_0.webp","slug":"webp_0.webp","post":"ckpapu7kb003dlcxu0ku34b0v","modified":0,"renderable":0},{"_id":"source/_posts/HTTP基本原理/1.png","slug":"1.png","post":"ckpapu7kb003dlcxu0ku34b0v","modified":0,"renderable":0},{"_id":"source/_posts/HTTP基本原理/Screenshot_2.png","slug":"Screenshot_2.png","post":"ckpapu7kb003dlcxu0ku34b0v","modified":0,"renderable":0},{"_id":"source/_posts/HTTP基本原理/Screenshot_3.png","slug":"Screenshot_3.png","post":"ckpapu7kb003dlcxu0ku34b0v","modified":0,"renderable":0},{"_id":"source/_posts/HTTP基本原理/Screenshot_1.png","slug":"Screenshot_1.png","post":"ckpapu7kb003dlcxu0ku34b0v","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_4.webp","slug":"Screenshot_4.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_3.webp","slug":"Screenshot_3.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_5.webp","slug":"Screenshot_5.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_6.webp","slug":"Screenshot_6.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_8.webp","slug":"Screenshot_8.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/Selenium的基本使用/Screenshot_7.webp","slug":"Screenshot_7.webp","post":"ckpapu7kg003jlcxuc53k84x2","modified":0,"renderable":0},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_4.webp","slug":"Screenshot_4.webp","post":"ckpapu7ko003tlcxu496acsnf","modified":0,"renderable":0},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7ko003tlcxu496acsnf","modified":0,"renderable":0},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7ko003tlcxu496acsnf","modified":0,"renderable":0},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_3.webp","slug":"Screenshot_3.webp","post":"ckpapu7ko003tlcxu496acsnf","modified":0,"renderable":0},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_5.webp","slug":"Screenshot_5.webp","post":"ckpapu7ko003tlcxu496acsnf","modified":0,"renderable":0},{"_id":"source/_posts/request、pyquest和pymongodb案例实战/Screenshot_6.webp","slug":"Screenshot_6.webp","post":"ckpapu7ko003tlcxu496acsnf","modified":0,"renderable":0},{"_id":"source/_posts/requests库的基本使用/Screenshot_2.webp","slug":"Screenshot_2.webp","post":"ckpapu7km003qlcxu77jh71ge","modified":0,"renderable":0},{"_id":"source/_posts/requests库的基本使用/Screenshot_1.webp","slug":"Screenshot_1.webp","post":"ckpapu7km003qlcxu77jh71ge","modified":0,"renderable":0},{"_id":"source/_posts/requests库的基本使用/Screenshot_3.webp","slug":"Screenshot_3.webp","post":"ckpapu7km003qlcxu77jh71ge","modified":0,"renderable":0},{"_id":"source/_posts/requests库的基本使用/Screenshot_4.webp","slug":"Screenshot_4.webp","post":"ckpapu7km003qlcxu77jh71ge","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckpapu7gj0001lcxuh91xh30t","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7hv000dlcxu6hwwg4kz"},{"post_id":"ckpapu7hd0007lcxubbf9023a","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7hy000glcxu4fds5orl"},{"post_id":"ckpapu7gx0002lcxu1mpp7axh","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7i1000jlcxu9d5pfd1u"},{"post_id":"ckpapu7hq000blcxu198iganf","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7i6000olcxu02pb1uuv"},{"post_id":"ckpapu7h90005lcxu7jc95deq","category_id":"ckpapu7hu000clcxu0h1j5vnp","_id":"ckpapu7ia000rlcxu4ryrfyoz"},{"post_id":"ckpapu7hb0006lcxu73sr3sdl","category_id":"ckpapu7hu000clcxu0h1j5vnp","_id":"ckpapu7if000wlcxu0idy6rxt"},{"post_id":"ckpapu7ho000alcxu8syz94h2","category_id":"ckpapu7ia000qlcxuafed7h4f","_id":"ckpapu7ik0014lcxu225y7896"},{"post_id":"ckpapu7id000vlcxudaqy38uj","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7io0018lcxugyie5mty"},{"post_id":"ckpapu7ig0010lcxucxt0bf3m","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7iq001blcxufun560z1"},{"post_id":"ckpapu7hw000flcxug2m161kh","category_id":"ckpapu7if000ylcxu3qzcfuin","_id":"ckpapu7it001glcxu0zf41qey"},{"post_id":"ckpapu7ij0012lcxuavhaejfe","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7iv001ilcxu12n12li3"},{"post_id":"ckpapu7il0017lcxu196gcfxk","category_id":"ckpapu7hu000clcxu0h1j5vnp","_id":"ckpapu7iy001mlcxu4934bqjp"},{"post_id":"ckpapu7hz000ilcxu66p23in4","category_id":"ckpapu7il0015lcxu9ube7hpw","_id":"ckpapu7iz001olcxu98zzhcs1"},{"post_id":"ckpapu7ir001elcxu7jljfive","category_id":"ckpapu7hu000clcxu0h1j5vnp","_id":"ckpapu7j0001slcxu94fi5wtz"},{"post_id":"ckpapu7i3000nlcxuh7paf5fa","category_id":"ckpapu7is001flcxu20v54hoo","_id":"ckpapu7j1001tlcxu8tc3fcrc"},{"post_id":"ckpapu7iv001jlcxuc8825odl","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7j2001vlcxu2muee55c"},{"post_id":"ckpapu7i7000plcxuftjv4i42","category_id":"ckpapu7ix001llcxu1mfk73vv","_id":"ckpapu7j3001xlcxua7k7bx62"},{"post_id":"ckpapu7ib000tlcxu6xpk0zpe","category_id":"ckpapu7ix001llcxu1mfk73vv","_id":"ckpapu7j3001ylcxuamb14h5x"},{"post_id":"ckpapu7io001alcxu7jkz66xe","category_id":"ckpapu7j1001ulcxu2azp5db3","_id":"ckpapu7ja0023lcxu3h7i2fp8"},{"post_id":"ckpapu7it001hlcxuf2fma75d","category_id":"ckpapu7j3001zlcxu1cxx0cf2","_id":"ckpapu7jb0026lcxuemqa8ltd"},{"post_id":"ckpapu7k70039lcxue1lnfjc9","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7kc003elcxug1vy2c85"},{"post_id":"ckpapu7k8003alcxuhcaj5rb5","category_id":"ckpapu7if000ylcxu3qzcfuin","_id":"ckpapu7ke003glcxubtzq4n83"},{"post_id":"ckpapu7ka003clcxu4iqa0eh7","category_id":"ckpapu7hu000clcxu0h1j5vnp","_id":"ckpapu7ki003klcxuho5shbl2"},{"post_id":"ckpapu7kb003dlcxu0ku34b0v","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7kl003nlcxuaqev8o7r"},{"post_id":"ckpapu7kc003flcxuapss6zux","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7ko003rlcxu1upnhu5m"},{"post_id":"ckpapu7kg003jlcxuc53k84x2","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7kp003ulcxu0qno9tpi"},{"post_id":"ckpapu7kj003mlcxugvgy7fr7","category_id":"ckpapu7ix001llcxu1mfk73vv","_id":"ckpapu7kq003wlcxugssvatkx"},{"post_id":"ckpapu7km003qlcxu77jh71ge","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7kq003ylcxuessf4zqu"},{"post_id":"ckpapu7ko003tlcxu496acsnf","category_id":"ckpapu7h40003lcxu5fjnchf2","_id":"ckpapu7kr0041lcxu9b1i6hob"},{"post_id":"ckpapu7kx004nlcxu1o3b572u","category_id":"ckpapu7j1001ulcxu2azp5db3","_id":"ckpapu7ky004plcxuaiwvhyyg"}],"PostTag":[{"post_id":"ckpapu7gj0001lcxuh91xh30t","tag_id":"ckpapu7h70004lcxuheevbo8w","_id":"ckpapu7hy000hlcxudjk81dzn"},{"post_id":"ckpapu7gj0001lcxuh91xh30t","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7i1000klcxu0l8ygvgu"},{"post_id":"ckpapu7gx0002lcxu1mpp7axh","tag_id":"ckpapu7h70004lcxuheevbo8w","_id":"ckpapu7id000ulcxu2psuabuq"},{"post_id":"ckpapu7gx0002lcxu1mpp7axh","tag_id":"ckpapu7i1000mlcxueeci8p4t","_id":"ckpapu7if000xlcxudgj0apty"},{"post_id":"ckpapu7ib000tlcxu6xpk0zpe","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7ii0011lcxuhmm68kwu"},{"post_id":"ckpapu7h90005lcxu7jc95deq","tag_id":"ckpapu7ib000slcxuazzthigq","_id":"ckpapu7ik0013lcxufw00d9oo"},{"post_id":"ckpapu7hb0006lcxu73sr3sdl","tag_id":"ckpapu7ib000slcxuazzthigq","_id":"ckpapu7io0019lcxubba0diii"},{"post_id":"ckpapu7il0017lcxu196gcfxk","tag_id":"ckpapu7ib000slcxuazzthigq","_id":"ckpapu7iq001clcxuaqdn0vne"},{"post_id":"ckpapu7hd0007lcxubbf9023a","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7iy001nlcxuhp2ne2jp"},{"post_id":"ckpapu7hd0007lcxubbf9023a","tag_id":"ckpapu7iq001dlcxua8osftaq","_id":"ckpapu7iz001plcxugg1j9q0l"},{"post_id":"ckpapu7ho000alcxu8syz94h2","tag_id":"ckpapu7ix001klcxugx6ddro2","_id":"ckpapu7ja0021lcxu6zeab6n1"},{"post_id":"ckpapu7ho000alcxu8syz94h2","tag_id":"ckpapu7iz001qlcxuhyytg3py","_id":"ckpapu7ja0022lcxu23563j66"},{"post_id":"ckpapu7ho000alcxu8syz94h2","tag_id":"ckpapu7j2001wlcxu0xdv3vsz","_id":"ckpapu7jb0025lcxu6wxp0fbs"},{"post_id":"ckpapu7hq000blcxu198iganf","tag_id":"ckpapu7j2001wlcxu0xdv3vsz","_id":"ckpapu7jc0028lcxu7zv12zcn"},{"post_id":"ckpapu7hq000blcxu198iganf","tag_id":"ckpapu7ja0024lcxu4xlrgo9h","_id":"ckpapu7jc0029lcxu230odb8q"},{"post_id":"ckpapu7hw000flcxug2m161kh","tag_id":"ckpapu7jc0027lcxu4i0jcc22","_id":"ckpapu7jd002clcxu119phsv2"},{"post_id":"ckpapu7hw000flcxug2m161kh","tag_id":"ckpapu7jd002alcxuafbg9gxj","_id":"ckpapu7je002dlcxu54b40v3b"},{"post_id":"ckpapu7hz000ilcxu66p23in4","tag_id":"ckpapu7jd002blcxuhohn7zyc","_id":"ckpapu7jf002flcxu5bp2ghso"},{"post_id":"ckpapu7i3000nlcxuh7paf5fa","tag_id":"ckpapu7je002elcxu8mv1gtez","_id":"ckpapu7jg002hlcxua599diik"},{"post_id":"ckpapu7i7000plcxuftjv4i42","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7ji002klcxu5fde7p5c"},{"post_id":"ckpapu7i7000plcxuftjv4i42","tag_id":"ckpapu7jf002glcxu0tnx6vpe","_id":"ckpapu7jj002llcxu9rp045hw"},{"post_id":"ckpapu7i7000plcxuftjv4i42","tag_id":"ckpapu7jg002ilcxubo1n5sqm","_id":"ckpapu7jl002nlcxu1qidhhf0"},{"post_id":"ckpapu7id000vlcxudaqy38uj","tag_id":"ckpapu7jh002jlcxu6xwo6u7y","_id":"ckpapu7jl002olcxub4925f9a"},{"post_id":"ckpapu7id000vlcxudaqy38uj","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7jm002qlcxu3a1u2ilf"},{"post_id":"ckpapu7ig0010lcxucxt0bf3m","tag_id":"ckpapu7jh002jlcxu6xwo6u7y","_id":"ckpapu7jm002rlcxu43937irs"},{"post_id":"ckpapu7ij0012lcxuavhaejfe","tag_id":"ckpapu7jm002plcxu34rq1r7a","_id":"ckpapu7jo002ulcxuhynjcbhe"},{"post_id":"ckpapu7ij0012lcxuavhaejfe","tag_id":"ckpapu7jn002slcxueax96l40","_id":"ckpapu7jp002vlcxufu23dew2"},{"post_id":"ckpapu7ij0012lcxuavhaejfe","tag_id":"ckpapu7i1000mlcxueeci8p4t","_id":"ckpapu7jp002xlcxu41lzgg9i"},{"post_id":"ckpapu7io001alcxu7jkz66xe","tag_id":"ckpapu7jn002tlcxuepbd4iio","_id":"ckpapu7jq002ylcxu3vgk47af"},{"post_id":"ckpapu7ir001elcxu7jljfive","tag_id":"ckpapu7jp002wlcxugm62fgl1","_id":"ckpapu7js0031lcxu6g85azs4"},{"post_id":"ckpapu7ir001elcxu7jljfive","tag_id":"ckpapu7jd002alcxuafbg9gxj","_id":"ckpapu7js0032lcxud50a14lk"},{"post_id":"ckpapu7it001hlcxuf2fma75d","tag_id":"ckpapu7jd002alcxuafbg9gxj","_id":"ckpapu7jt0035lcxudd2e3xmz"},{"post_id":"ckpapu7it001hlcxuf2fma75d","tag_id":"ckpapu7js0033lcxub7e62xmh","_id":"ckpapu7ju0036lcxu6e7a9f9l"},{"post_id":"ckpapu7iv001jlcxuc8825odl","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7ju0037lcxucaq7965p"},{"post_id":"ckpapu7iv001jlcxuc8825odl","tag_id":"ckpapu7jt0034lcxucm2yb8zg","_id":"ckpapu7ju0038lcxu5dnsfqgo"},{"post_id":"ckpapu7kb003dlcxu0ku34b0v","tag_id":"ckpapu7j2001wlcxu0xdv3vsz","_id":"ckpapu7kg003ilcxu2tuna0oj"},{"post_id":"ckpapu7k70039lcxue1lnfjc9","tag_id":"ckpapu7j2001wlcxu0xdv3vsz","_id":"ckpapu7ki003llcxu9o3z1j55"},{"post_id":"ckpapu7k70039lcxue1lnfjc9","tag_id":"ckpapu7k9003blcxu52c86aeu","_id":"ckpapu7km003plcxu5zrf6c3y"},{"post_id":"ckpapu7k70039lcxue1lnfjc9","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7ko003slcxugbpybzm9"},{"post_id":"ckpapu7k8003alcxuhcaj5rb5","tag_id":"ckpapu7ke003hlcxuagx8dyvi","_id":"ckpapu7kq003xlcxu96vva5kz"},{"post_id":"ckpapu7k8003alcxuhcaj5rb5","tag_id":"ckpapu7jc0027lcxu4i0jcc22","_id":"ckpapu7kq003zlcxucng12rtb"},{"post_id":"ckpapu7k8003alcxuhcaj5rb5","tag_id":"ckpapu7kl003olcxuf1iz3fct","_id":"ckpapu7kr0042lcxu9iyk15s8"},{"post_id":"ckpapu7ka003clcxu4iqa0eh7","tag_id":"ckpapu7kp003vlcxu8v1ubeea","_id":"ckpapu7kr0044lcxu9us4eapo"},{"post_id":"ckpapu7ka003clcxu4iqa0eh7","tag_id":"ckpapu7kq0040lcxue0r8ez2d","_id":"ckpapu7kr0045lcxu7f6gdevy"},{"post_id":"ckpapu7kc003flcxuapss6zux","tag_id":"ckpapu7kr0043lcxu37935g6e","_id":"ckpapu7ks0047lcxu2qpk5ey0"},{"post_id":"ckpapu7kc003flcxuapss6zux","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7ks0048lcxu3bu7b4yu"},{"post_id":"ckpapu7kg003jlcxuc53k84x2","tag_id":"ckpapu7kr0046lcxu8q0afbgz","_id":"ckpapu7ks004alcxu81w53430"},{"post_id":"ckpapu7kj003mlcxugvgy7fr7","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7kt004clcxug6uh4lxm"},{"post_id":"ckpapu7kj003mlcxugvgy7fr7","tag_id":"ckpapu7ks0049lcxu25o00ik0","_id":"ckpapu7kt004dlcxu7mxacume"},{"post_id":"ckpapu7km003qlcxu77jh71ge","tag_id":"ckpapu7hf0009lcxuedzz2z5d","_id":"ckpapu7kt004flcxu2jub9jxx"},{"post_id":"ckpapu7km003qlcxu77jh71ge","tag_id":"ckpapu7ks004blcxugrz7g6e5","_id":"ckpapu7kt004glcxu97uedror"},{"post_id":"ckpapu7km003qlcxu77jh71ge","tag_id":"ckpapu7k9003blcxu52c86aeu","_id":"ckpapu7ku004ilcxu2w91cv78"},{"post_id":"ckpapu7ko003tlcxu496acsnf","tag_id":"ckpapu7kt004elcxueye770xu","_id":"ckpapu7ku004klcxu11fubdr5"},{"post_id":"ckpapu7ko003tlcxu496acsnf","tag_id":"ckpapu7kt004hlcxu60yg5rxc","_id":"ckpapu7ku004llcxu3egu8r79"},{"post_id":"ckpapu7ko003tlcxu496acsnf","tag_id":"ckpapu7ku004jlcxugex9hv4d","_id":"ckpapu7ku004mlcxu7y6ddiwl"},{"post_id":"ckpapu7kx004nlcxu1o3b572u","tag_id":"ckpapu7jn002tlcxuepbd4iio","_id":"ckpapu7ky004olcxudgo813fx"}],"Tag":[{"name":"ajax","_id":"ckpapu7h70004lcxuheevbo8w"},{"name":"python","_id":"ckpapu7hf0009lcxuedzz2z5d"},{"name":"javascript","_id":"ckpapu7i1000mlcxueeci8p4t"},{"name":"Hexo","_id":"ckpapu7ib000slcxuazzthigq"},{"name":"mongodb","_id":"ckpapu7iq001dlcxua8osftaq"},{"name":"Nginx","_id":"ckpapu7ix001klcxugx6ddro2"},{"name":"负载均衡","_id":"ckpapu7iz001qlcxuhyytg3py"},{"name":"http","_id":"ckpapu7j2001wlcxu0xdv3vsz"},{"name":"web","_id":"ckpapu7ja0024lcxu4xlrgo9h"},{"name":"linux","_id":"ckpapu7jc0027lcxu4i0jcc22"},{"name":"docker","_id":"ckpapu7jd002alcxuafbg9gxj"},{"name":"Git","_id":"ckpapu7jd002blcxuhohn7zyc"},{"name":"go","_id":"ckpapu7je002elcxu8mv1gtez"},{"name":"多线程","_id":"ckpapu7jf002glcxu0tnx6vpe"},{"name":"threading","_id":"ckpapu7jg002ilcxubo1n5sqm"},{"name":"scrapy","_id":"ckpapu7jh002jlcxu6xwo6u7y"},{"name":"html","_id":"ckpapu7jm002plcxu34rq1r7a"},{"name":"css","_id":"ckpapu7jn002slcxueax96l40"},{"name":"读书","_id":"ckpapu7jn002tlcxuepbd4iio"},{"name":"nextCloud","_id":"ckpapu7jp002wlcxugm62fgl1"},{"name":"vscode","_id":"ckpapu7js0033lcxub7e62xmh"},{"name":"re","_id":"ckpapu7jt0034lcxucm2yb8zg"},{"name":"爬虫","_id":"ckpapu7k9003blcxu52c86aeu"},{"name":"git","_id":"ckpapu7ke003hlcxuagx8dyvi"},{"name":"病毒","_id":"ckpapu7kl003olcxuf1iz3fct"},{"name":"nginx","_id":"ckpapu7kp003vlcxu8v1ubeea"},{"name":"https","_id":"ckpapu7kq0040lcxue0r8ez2d"},{"name":"pyquery","_id":"ckpapu7kr0043lcxu37935g6e"},{"name":"selenium","_id":"ckpapu7kr0046lcxu8q0afbgz"},{"name":"multiprocessing","_id":"ckpapu7ks0049lcxu25o00ik0"},{"name":"requests","_id":"ckpapu7ks004blcxugrz7g6e5"},{"name":"request","_id":"ckpapu7kt004elcxueye770xu"},{"name":"pyquest","_id":"ckpapu7kt004hlcxu60yg5rxc"},{"name":"pymongodb","_id":"ckpapu7ku004jlcxugex9hv4d"}]}}