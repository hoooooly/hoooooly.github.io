---
title: 正则表达式
tags:
  - python
  - re
comments: true
toc: true
only:
  - home
  - category
  - tag
date: 2021-05-21 21:08:59
categories: 爬虫
pic:
---

# 正则表达式

正则表达式是处理字符串的强大工具，它有自己特定的语法结构。能实现字符串的检索、替换、匹配验证，对于爬虫来说，从 HTML里提取想要的信息就非常方便。

## 实例引入

下面用几个实例来看一下正则表达式的用法。

打开开源中国提供的正则表达式测试工具[http://tool.oschina.net/regex/](http://tool.oschina.net/regex/)，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。

例如，输入下面这段待匹配的文本：

```python
Hello, my phone number is 010-86432100 and email is espholychan@outlook.com, and my website is https://holychan.ltd.
```

这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。

![](Screenshot_1.webp)

在网页右侧选择**“匹配 Email地址”**，就可以看到下方出现了文本中的`E-mail`。如果选择**“匹配网址URL”**，就可以看到下方出现了文本中的`URL`。

这里使用了正则表达式的匹配功能，也就是用一定规则将特定的文本提取出来。

比方说，电子邮件是有其特定的组成格式的：`一段字符串` `+` `@` `符号` `+` `某个域名`。而`URL`的组成格式则是`协议类型``+``冒号``+``双斜线``+``域名和路径`。

可以用下面的正则表达式匹配`URL`：

```re
[a-zA-z]+://[^\s]*
```

用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似`URL`的文本，那就会被提取出来。

下表中列出了常用的匹配规则：

| 模式 | 描述 |
| :--: | :---: |
| \w | 匹配字母、数字及下划线 |
| \W | 匹配不是字母、数字及下划线的字符 |
| \s | 匹配任意空白字符，等价于 [\t\n\r\f] |
| \S | 匹配任意非空字符 |
| \d | 匹配任意数字，等价于 [0~9] |
| \D | 匹配任意非数字的字符 |
| \A | 匹配字符串开头 |
| \Z | 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 |
| \z | 匹配字符串结尾，如果存在换行，同时还会匹配换行符 |
| \G | 匹配最后匹配完成的位置 |
| \n | 匹配一个换行符 |
| \t | 匹配一个制表符 |
| ^ | 匹配一行字符串的开头 |
| $ | 匹配一行字符串的结尾 |
| . | 匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符 |
| [...] | 用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k |
| [^...] | 不在 [] 中的字符，比如 匹配除了 a、b、c 之外的字符 |
| * | 匹配 0 个或多个表达式 |
| + | 匹配 1 个或多个表达式 |
| ? | 匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式 |
| {n} | 精确匹配 n 个前面的表达式 |
| {n, m} | 匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式 |
| a\|b | 匹配 a 或 b |
| () | 匹配括号内的表达式，也表示一个组 |

[//]:#(设置表格整体居中显示)
<style>
    table
    {
        margin: auto;
        font-size: 80%;
    }
</style>

`Python`的`re库`提供了整个正则表达式的实现，利用这个库，可以在`Python`中使用正则表达式。

## match

首先介绍一个常用的匹配方法——`match`，向它传入要匹配的字符串，以及正则表达式，就可以检测这个正则表达式是否匹配字符串。`match`方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回`None`。

```python
import re

content = 'Hello 123 4567 World_This is a Regex Demo'
print(len(content))
result = re.match('^Hello\s\d\d\d\s\d{4}\s\w{10}', content)
print(result)
print(result.group())
print(result.span())
```

运行结果如下：

```python
41
<re.Match object; span=(0, 25), match='Hello 123 4567 World_This'>
Hello 123 4567 World_This
(0, 25)
```

这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：

```python
^Hello\s\d\d\d\s\d{4}\s\w{10}
```

用它来匹配这个长字符串。开头的`^`·匹配字符串的开头，也就是以`Hello`开头；`\s`匹配空白字符，用来匹配目标字符串的空格；`\d`匹配数字，3个`\d`匹配`123`；再写1个`\s`匹配空格；后面的`4567`，依然能用4个`\d`来匹配，但是这么写比较烦琐，所以后面可以跟`{4}`代表匹配前面的规则4次，也就是匹配4个数字；后面再紧接1个空白字符，最后`\w{10}`匹配10个字母及下划线。

在`match`方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。打印输出结果，可以看到结果是`SRE_Match`对象，这证明成功匹配。该对象有两个方法：`group`方法可以输出匹配的内容，结果是`Hello 123 4567 World_This`，这恰好是正则表达式规则所匹配的内容；`span`方法可以输出匹配的范围，结果是`(0, 25)`，这就是匹配到的结果字符串在原字符串中的位置范围。
