---
title: 大型应用的结构
tags:
  - flask
  - python
comments: true
typora-root-url: 大型应用的结构
date: 2021-08-05 14:19:01
categories: Flask
index_img:
banner_img:
---

# 项目结构

多文件`Flask`应用的基本结构：

```python
├─app/
   ├─__init__.py
   ├─email.py
   ├─models.py
   ├─main/
      ├─__init__.py
      ├─errors.py
      ├─forms.py
   	  ├─views.py
   ├─static/
   └─templates/
├─migrations/
├─tests/
   ├─__init__.py
   ├─test.py
├─venv/
├─requirements.txt
├─config.py
├─flasky.py
```

这种结构有4个顶级文件夹：

-  Flask应用一般保存在名为`app`的包中；
- 和之前一样，数据库迁移脚本在`migrations`文件夹中；
- 单元测试在`tests`包中编写；•
- 和之前一样，Python虚拟环境在`venv`文件夹中。

此外，这种结构还多了一些新文件：

- `requirements.txt`列出了所有依赖包，便于在其他计算机中重新生成相同的虚拟环境；
- `config.py`存储配置；•
- `flasky.py`定义`Flask`应用实例，同时还有一些辅助管理应用的任务。

## 配置选项

应用经常需要设定多个配置。这方面最好的例子就是开发、测试和生产环境要使用不同的数据库，这样才不会彼此影响。

`config.py`应用的配置：

```python
import os

basedir = os.path.abspath(os.path.dirname(__file__))


class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess'
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.googlemail.com')
    MAIL_PORT = os.environ.get('MAIL_PORT', '587')
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() in ['true', 'on', '1']
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    # 数据库
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    @staticmethod
    def init_app(app):
        pass


class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URI') or 'sqlite:///' + os.path.join(basedir,
                                                                                                'data-dev.sqlite')


class TestConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URI') or 'sqlite:///'


class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URI') or 'sqlite:///' + os.path.join(basedir,

                                                                                            'data.sqlite')


config = {
    'development': DevelopmentConfig,
    'testing': TestConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig,
}
```

基类`Config`中包含通用配置，各个子类分别定义专用的配置。如果需要，你还可添加其他配置类。

为了让配置方式更灵活且更安全，多数配置都可以从环境变量中导入。例如，`SECRET_KEY`的值，这是个敏感信息，可以在环境中设定，但系统也提供了一个默认值，以防环境中没有定义。通常，在开发过程中可以使用这些设置的默认值，但是在生产服务器中应该通过环境变量设定各个值。

> 千万不要把密码或其他机密信息写在纳入版本控制的配置文件中。

在3个子类中，`SQLALCHEMY_DATABASE_URI`变量都被指定了不同的值。这样应用就可以在不同的环境中使用不同的数据库。把不同环境的数据库区分开是十分必要的，因为你肯定不想让单元测试修改日常开发中使用的数据库。

开发环境和生产环境都配置了邮件服务器。为了再给应用提供一种定制配置的方式，`Config`类及其子类可以定义`init_app()`类方法，其参数为应用实例。现在，基类`Config`中的`init_app()`方法为空。

在这个配置脚本末尾，`config`字典中注册了不同的配置环境，而且还注册了一个默认配置（这里注册为开发环境）

## 应用包

应用包用于存放应用的所有代码、模板和静态文件。我们可以把这个包直接称为`app`（应用），如果有需求，也可使用一个应用专属的名称。`templates`和`static`目录现在是应用包的一部分，因此要把二者移到`app`包中。数据库模型和电子邮件支持函数也要移到这个包中，分别保存为`app/models.py`和`app/email.py`。

### 使用应用工厂函数

在单个文件中开发应用是很方便，但却有个很大的缺点：应用在全局作用域中创建，无法动态修改配置。运行脚本时，应用实例已经创建，再修改配置为时已晚。这一点对单元测试尤其重要，因为有时为了提高测试覆盖度，必须在不同的配置下运行应用。

这个问题的解决方法是延迟创建应用实例，把创建过程移到可显式调用的`工厂函数`中。这种方法不仅可以给脚本留出配置应用的时间，还能够创建多个应用实例，为测试提供便利。

`app/__init__.py`应用包构造文件：

```python
from flask import Flask, render_template
from flask_bootstrap import Bootstrap
from flask_moment import Moment
from flask_sqlalchemy import SQLAlchemy
from ..config import config

bootstrap = Bootstrap()
moment = Moment()
db = SQLAlchemy()


def create_app(config_name):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    bootstrap.init_app(app)
    moment.init_app(app)
    db.init_app(app)

    # 添加路由和自定义错误页面

    return app
```

构造文件导入了大多数正在使用的Flask扩展。由于尚未初始化所需的应用实例，所以创建扩展类时没有向构造函数传入参数，因此扩展并未真正初始化。`createapp()`函数是应用的工厂函数，接受一个参数，是应用使用的配置名。配置类在`config.py`文件中定义，其中保存的配置可以使用`Flask app.config`配置对象提供的`from_object()`方法直接导入应用。至于配置对象，则可以通过名称从`config`字典中选择。应用创建并配置好后，就能初始化扩展了。在之前创建的扩展对象上调用`init_app()`便可以完成初始化。

现在，应用在这个工厂函数中初始化，使用Flask配置对象的`from_object()`方法，其参数为`config.py`中定义的某个配置类。此外，这里还调用了所选配置的`init_app()`方法，以便执行更复杂的初始化过程。工厂函数返回创建的应用示例，不过要注意，现在工厂函数创建的应用还不完整，因为没有路由和自定义的错误页面处理程序。

### 在蓝本中实现应用功能

转换成应用工厂函数的操作让定义路由变复杂了。在单脚本应用中，应用实例存在于全局作用域中，路由可以直接使用`app.route`装饰器定义。但现在应用在运行时创建，只有调用`create_app()`之后才能使用`app.route`装饰器，这时定义路由就太晚了。自定义的错误页面处理程序也面临相同的问题，因为错误页面处理程序使用`app.errorhandler`装饰器定义。幸好，Flask使用**蓝本（blueprint）**提供了更好的解决方法。蓝本和应用类似，也可以定义路由和错误处理程序。不同的是，在蓝本中定义的路由和错误处理程序处于休眠状态，直到蓝本注册到应用上之后，它们才真正成为应用的一部分。使用位于全局作用域中的蓝本时，定义路由和错误处理程序的方法几乎与单脚本应用一样。

与应用一样，蓝本可以在单个文件中定义，也可使用更结构化的方式在包中的多个模块中创建。为了获得最大的灵活性，我们将在应用包中创建一个子包，用于保存应用的第一个蓝本。

`app/main/__init__.py`：创建主蓝本

```python
from flask import Blueprint

main = Blueprint('main', __name__)

from . import views, errors
```

蓝本通过实例化一个`Blueprint`类对象创建。这个构造函数有两个必须指定的参数：蓝本的名称和蓝本所在的包或模块。与应用一样，多数情况下第二个参数使用Python的`__name__`变量即可。

应用的路由保存在包里的`app/main/views.py`模块中，而错误处理程序保存在`app/main/errors.py`模块中。导入这两个模块就能把路由和错误处理程序与蓝本关联起来。注意，这些模块在`app/main/ init .py`脚本的末尾导入，这是为了避免循环导入依赖，因为在`app/main/views.py`和`app/main/errors.py`中还要导入`main`蓝本，所以除非循环引用出现在定义`main`之后，否则会致使导入出错。

蓝本在工厂函数`create_app()`中注册到应用上。

```python
def create_app(config_name):
    # ...

    # 注册主蓝本
    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)
```

在`app/main/errors.py`：主蓝本中定义的错误处理程序：

```python
from flask import render_template
from . import main


@main.app_errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404


@main.app_errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500
```

在蓝本中编写错误处理程序稍有不同，如果使用`errorhandler`装饰器，那么只有蓝本中的错误才能触发处理程序。要想注册应用全局的错误处理程序，必须使用`app_errorhandler`装饰器。

在`app/main/views.py`：主蓝本中定义的应用路由。

```python
from datetime import datetime
from flask import render_template, session, redirect, url_for
from . import main
from .forms import NameForm
from .. import db
from ..models import User


@main.route('/', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        # ...
        return redirect(url_for('index'))
    return render_template('index.html', name=session.get('name'), known=session.get('known', False),
                           current_time=datetime.utcnow())
```

在蓝本中编写视图函数主要有两点不同：第一，与前面的错误处理程序一样，路由装饰器由蓝本提供，因此使用的是`main.route`，而非`app.route`；第二，`url_for()`函数的用法不同。你可能还记得，`url_for()`函数的第一个参数是路由的端点名，在应用的路由中，默认为视图函数的名称。例如，在单脚本应用中，`index()`视图函数的URL可使用`url_for('index')`获取。

在蓝本中就不一样了，Flask会为蓝本中的全部端点加上一个命名空间，这样就可以在不同的蓝本中使用相同的端点名定义视图函数，而不产生冲突。命名空间是蓝本的名称（**Blueprint构造函数的第一个参数**），而且它与端点名之间以一个点号分隔。因此，视图函数`index()`注册的端点名是`main.index`，其URL使用`urlfor('main.index')`获取。

`url_for()`函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如`url_for('.index')`。在这种写法中，使用当前请求的蓝本名补足端点名。这意味着，同一蓝本中的重定向可以使用简写形式，但跨蓝本的重定向必须使用带有蓝本名的完全限定端点名。为了完成对应用包的修改，还要把表单对象移到蓝本中，保存在`app/main/forms.py`模块里。

## 应用脚本

应用实例在顶级目录中的`flasky.py`模块里定义。

```python
import os
from app import create_app, db
from app.models import User, Role
from flask_migrate import Migrate

app = create_app(os.getenv('FLASK_CONFIG') or 'default')
migrate = Migrate(app, db)


@app.shell_context_processor
def make_shell_context():
    return dict(db=db, User=User, Role=Role)
```

这个脚本先创建一个应用实例。如果已经定义了环境变量`FLASK_CONFIG`，则从中读取配置名；否则使用默认配置。然后初始化`Flask-Migrate`和为`Python shell`定义的上下文。

相应地修改`FLASK_APP`环境变量，以便flask命令找到应用实例。此外，还可以设置`FLASK_DEBUG=1`，启用Flask的调试模式。`Linux`和`macOS`用户这样做：

```python
(venv) $ export FLASK_APP=flasky.py
(venv) $ export FLASK_DEBUG=1
```

`windows`用户：

```python
(venv) $ set FLASK_APP=flasky.py
(venv) $ set FLASK_DEBUG=1
```

## 需求文件

应用中最好有个`requirements.txt`文件，用于记录所有依赖包及其精确的版本号。如果要在另一台计算机上重新生成虚拟环境，这个文件的重要性就体现出来了，例如部署应用时使用的设备。这个文件可由`pip`自动生成，使用的命令如下：

```python
(venv) $ pip freeze >requirements.txt
```

如果你想创建这个虚拟环境的完整副本，先创建一个新的虚拟环境，然后在其中运行下述命令：

```python
(venv) $ pip install -r requirements.txt
```

## 单元测试

```python
import unittest
from flask import current_app
from app import create_app, db


class BasicsTestCase(unittest.TestCase):
    def setUp(self):
        self.app = create_app('testing')
        self.app_context = self.app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()
    
    def test_app_exists(self):
        self.assertFalse(current_app is None)
    
    def test_app_is_testing(self):
        self.assertTrue(current_app.config['TESTING'])
```

这些测试使用Python标准库中的`unittest`包编写。测试用例类的`setUp()`和`tearDown()`方法分别在各测试之前和之后运行。名称以test开头的方法都作为测试运行。

`setUp()`方法尝试创建一个测试环境，尽量与正常运行应用所需的环境一致。首先，使用测试配置创建应用，然后激活上下文。这一步的作用是确保能在测试中使用`current_app`，就像普通请求一样。然后，使用`Flask-SQLAlchemy`的`createall()`方法创建一个全新的数据库，供测试使用。数据库和应用上下文在`tearDown()`方法中删除。

第一个测试确保应用实例存在。第二个测试确保应用在测试配置中运行。若想把`tests`目录作为包来使用，要添加`tests/init.py`模块，不过这个文件可以为空，因为`unittest`包会扫描所有模块，找出测试。

为了运行单元测试，可以在`flasky.py`脚本中添加一个自定义命令。

`flasky.py`：启动单元测试的命令

```python
@app.cli.command()
def test():
    """运行单元测试"""
    import unittest
    tests = unittest.TestLoader().discover('tests')
    unittest.TextTestRunner(verbosity=2).run(tests)
```

`app.cli.command`装饰器把自定义命令变得很简单。被装饰的函数名就是命令名，函数的文档字符串会显示在帮助消息中。`test()`函数的定义体中调用了`unittest`包提供的测试运行程序。单元测试可使用下面的命令运行：

```python
(venv) $ flask test
<class 'config.DevelopmentConfig'>
test_app_exists (test_basics.BasicsTestCase) ... <class 'config.TestConfig'>
ok
test_app_is_testing (test_basics.BasicsTestCase) ... <class 'config.TestConfig'>
ok

----------------------------------------------------------------------
Ran 2 tests in 0.043s

OK
```

## 创建数据库

选从环境变量中读取数据库的URL，同时还提供了一个默认的`SQLite`数据库作为备用。3种配置环境中的环境变量名和`SQLite`数据库文件名都不一样。例如，在开发环境中，数据库URL从环境变量`DEV_DATABASE_URI`中读取，如果没有定义这个环境变量，则使用名为`data-dev.sqlite`的`SQLite`数据库。不管从哪里获取数据库URL，都要在新数据库中创建数据表。如果使用`Flask-Migrate`跟踪迁移，可使用下述命令创建数据表或者升级到最新修订版本。

```python
(venv) $ flask db init
<class 'config.DevelopmentConfig'>
Creating directory D:\PycharmProjects\Flask_Projects\flasky\migrations\versions ...  done
Generating D:\PycharmProjects\Flask_Projects\flasky\migrations\alembic.ini ...  done
Generating D:\PycharmProjects\Flask_Projects\flasky\migrations\env.py ...  done
Generating D:\PycharmProjects\Flask_Projects\flasky\migrations\README ...  done
Generating D:\PycharmProjects\Flask_Projects\flasky\migrations\script.py.mako ...  done
Please edit configuration/connection/logging settings in 'D:\\PycharmProjects\\Flask_Projects\\flasky\\migrations\\alembic.ini' before proceeding.
```

迁移：

```python
(venv) $ flask db migrate
<class 'config.DevelopmentConfig'>
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'roles'
INFO  [alembic.autogenerate.compare] Detected added table 'users'
INFO  [alembic.autogenerate.compare] Detected added index 'ix_users_username' on '['username']'
Generating D:\PycharmProjects\Flask_Projects\flasky\migrations\versions\94427408a3d4_.py ...  done
```

更新：

```python
(venv) $ flask db upgrade
```

## 运行应用

```python
(venv) $ flask run
```

每次启动一个新的命令提示符会话，都要设定`FLASK_APP`和`FLASK_DEBUG`环境变量，这有点麻烦。你可以做些配置，让系统自动设定这些变量。如果你使用`bash`，可以把环境变量添加到`~/.bashrc`文件中。





[//]:#(设置表格整体居中显示)
<style>
    table
    {
        margin: auto;
        font-size: 80%;
    }
</style>


